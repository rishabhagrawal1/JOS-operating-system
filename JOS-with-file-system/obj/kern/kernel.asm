
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
.text
.globl _head64
_head64:

# Save multiboot_info addr passed by bootloader
    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

	movw $0x1234,0x472			# warm boot
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
    movl $CR4_PAE,%eax
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
  100115:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011c:	00 00 00 
  10011f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100126:	00 00 00 
  100129:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100130:	00 00 00 
  100133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10013a:	00 00 00 
  10013d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100144:	00 00 00 
  100147:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014e:	00 00 00 
  100151:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100158:	00 00 00 
  10015b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100162:	00 00 00 
  100165:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016c:	00 00 00 
  10016f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100176:	00 00 00 
  100179:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100180:	00 00 00 
  100183:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10018a:	00 00 00 
  10018d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100194:	00 00 00 
  100197:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019e:	00 00 00 
  1001a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a8:	00 00 00 
  1001ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b2:	00 00 00 
  1001b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bc:	00 00 00 
  1001bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c6:	00 00 00 
  1001c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d0:	00 00 00 
  1001d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001da:	00 00 00 
  1001dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e4:	00 00 00 
  1001e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ee:	00 00 00 
  1001f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f8:	00 00 00 
  1001fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100202:	00 00 00 
  100205:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020c:	00 00 00 
  10020f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100216:	00 00 00 
  100219:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100220:	00 00 00 
  100223:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10022a:	00 00 00 
  10022d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100234:	00 00 00 
  100237:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023e:	00 00 00 
  100241:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100248:	00 00 00 
  10024b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100252:	00 00 00 
  100255:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025c:	00 00 00 
  10025f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100266:	00 00 00 
  100269:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100270:	00 00 00 
  100273:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10027a:	00 00 00 
  10027d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100284:	00 00 00 
  100287:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028e:	00 00 00 
  100291:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100298:	00 00 00 
  10029b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a2:	00 00 00 
  1002a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ac:	00 00 00 
  1002af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b6:	00 00 00 
  1002b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c0:	00 00 00 
  1002c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ca:	00 00 00 
  1002cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d4:	00 00 00 
  1002d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002de:	00 00 00 
  1002e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e8:	00 00 00 
  1002eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f2:	00 00 00 
  1002f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fc:	00 00 00 
  1002ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100306:	00 00 00 
  100309:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100310:	00 00 00 
  100313:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10031a:	00 00 00 
  10031d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100324:	00 00 00 
  100327:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032e:	00 00 00 
  100331:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100338:	00 00 00 
  10033b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100342:	00 00 00 
  100345:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034c:	00 00 00 
  10034f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100356:	00 00 00 
  100359:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100360:	00 00 00 
  100363:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10036a:	00 00 00 
  10036d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100374:	00 00 00 
  100377:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037e:	00 00 00 
  100381:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100388:	00 00 00 
  10038b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100392:	00 00 00 
  100395:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039c:	00 00 00 
  10039f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a6:	00 00 00 
  1003a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b0:	00 00 00 
  1003b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ba:	00 00 00 
  1003bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c4:	00 00 00 
  1003c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ce:	00 00 00 
  1003d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d8:	00 00 00 
  1003db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e2:	00 00 00 
  1003e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ec:	00 00 00 
  1003ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f6:	00 00 00 
  1003f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100400:	00 00 00 
  100403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10040a:	00 00 00 
  10040d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100414:	00 00 00 
  100417:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041e:	00 00 00 
  100421:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100428:	00 00 00 
  10042b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100432:	00 00 00 
  100435:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043c:	00 00 00 
  10043f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100446:	00 00 00 
  100449:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100450:	00 00 00 
  100453:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10045a:	00 00 00 
  10045d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100464:	00 00 00 
  100467:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046e:	00 00 00 
  100471:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100478:	00 00 00 
  10047b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100482:	00 00 00 
  100485:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048c:	00 00 00 
  10048f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100496:	00 00 00 
  100499:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a0:	00 00 00 
  1004a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004aa:	00 00 00 
  1004ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b4:	00 00 00 
  1004b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004be:	00 00 00 
  1004c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c8:	00 00 00 
  1004cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d2:	00 00 00 
  1004d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004dc:	00 00 00 
  1004df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e6:	00 00 00 
  1004e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f0:	00 00 00 
  1004f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004fa:	00 00 00 
  1004fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100504:	00 00 00 
  100507:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050e:	00 00 00 
  100511:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100518:	00 00 00 
  10051b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100522:	00 00 00 
  100525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052c:	00 00 00 
  10052f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100536:	00 00 00 
  100539:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100540:	00 00 00 
  100543:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10054a:	00 00 00 
  10054d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100554:	00 00 00 
  100557:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055e:	00 00 00 
  100561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100568:	00 00 00 
  10056b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100572:	00 00 00 
  100575:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057c:	00 00 00 
  10057f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100586:	00 00 00 
  100589:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100590:	00 00 00 
  100593:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10059a:	00 00 00 
  10059d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a4:	00 00 00 
  1005a7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ae:	00 00 00 
  1005b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b8:	00 00 00 
  1005bb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c2:	00 00 00 
  1005c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cc:	00 00 00 
  1005cf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d6:	00 00 00 
  1005d9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e0:	00 00 00 
  1005e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ea:	00 00 00 
  1005ed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f4:	00 00 00 
  1005f7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fe:	00 00 00 
  100601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100608:	00 00 00 
  10060b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100612:	00 00 00 
  100615:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061c:	00 00 00 
  10061f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100626:	00 00 00 
  100629:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100630:	00 00 00 
  100633:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10063a:	00 00 00 
  10063d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100644:	00 00 00 
  100647:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064e:	00 00 00 
  100651:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100658:	00 00 00 
  10065b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100662:	00 00 00 
  100665:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066c:	00 00 00 
  10066f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100676:	00 00 00 
  100679:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100680:	00 00 00 
  100683:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10068a:	00 00 00 
  10068d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100694:	00 00 00 
  100697:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069e:	00 00 00 
  1006a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a8:	00 00 00 
  1006ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b2:	00 00 00 
  1006b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bc:	00 00 00 
  1006bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c6:	00 00 00 
  1006c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d0:	00 00 00 
  1006d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006da:	00 00 00 
  1006dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e4:	00 00 00 
  1006e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ee:	00 00 00 
  1006f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f8:	00 00 00 
  1006fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100702:	00 00 00 
  100705:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070c:	00 00 00 
  10070f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100716:	00 00 00 
  100719:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100720:	00 00 00 
  100723:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10072a:	00 00 00 
  10072d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100734:	00 00 00 
  100737:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073e:	00 00 00 
  100741:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100748:	00 00 00 
  10074b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100752:	00 00 00 
  100755:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075c:	00 00 00 
  10075f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100766:	00 00 00 
  100769:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100770:	00 00 00 
  100773:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10077a:	00 00 00 
  10077d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100784:	00 00 00 
  100787:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078e:	00 00 00 
  100791:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100798:	00 00 00 
  10079b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a2:	00 00 00 
  1007a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ac:	00 00 00 
  1007af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b6:	00 00 00 
  1007b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c0:	00 00 00 
  1007c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ca:	00 00 00 
  1007cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d4:	00 00 00 
  1007d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007de:	00 00 00 
  1007e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e8:	00 00 00 
  1007eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f2:	00 00 00 
  1007f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fc:	00 00 00 
  1007ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100806:	00 00 00 
  100809:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100810:	00 00 00 
  100813:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10081a:	00 00 00 
  10081d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100824:	00 00 00 
  100827:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082e:	00 00 00 
  100831:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100838:	00 00 00 
  10083b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100842:	00 00 00 
  100845:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084c:	00 00 00 
  10084f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100856:	00 00 00 
  100859:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100860:	00 00 00 
  100863:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10086a:	00 00 00 
  10086d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100874:	00 00 00 
  100877:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087e:	00 00 00 
  100881:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100888:	00 00 00 
  10088b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100892:	00 00 00 
  100895:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089c:	00 00 00 
  10089f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a6:	00 00 00 
  1008a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b0:	00 00 00 
  1008b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ba:	00 00 00 
  1008bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c4:	00 00 00 
  1008c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ce:	00 00 00 
  1008d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d8:	00 00 00 
  1008db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e2:	00 00 00 
  1008e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ec:	00 00 00 
  1008ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f6:	00 00 00 
  1008f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100900:	00 00 00 
  100903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10090a:	00 00 00 
  10090d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100914:	00 00 00 
  100917:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091e:	00 00 00 
  100921:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100928:	00 00 00 
  10092b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100932:	00 00 00 
  100935:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093c:	00 00 00 
  10093f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100946:	00 00 00 
  100949:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100950:	00 00 00 
  100953:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10095a:	00 00 00 
  10095d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100964:	00 00 00 
  100967:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096e:	00 00 00 
  100971:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100978:	00 00 00 
  10097b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100982:	00 00 00 
  100985:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098c:	00 00 00 
  10098f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100996:	00 00 00 
  100999:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a0:	00 00 00 
  1009a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009aa:	00 00 00 
  1009ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b4:	00 00 00 
  1009b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009be:	00 00 00 
  1009c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c8:	00 00 00 
  1009cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d2:	00 00 00 
  1009d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009dc:	00 00 00 
  1009df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e6:	00 00 00 
  1009e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f0:	00 00 00 
  1009f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009fa:	00 00 00 
  1009fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a04:	00 00 00 
  100a07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0e:	00 00 00 
  100a11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a18:	00 00 00 
  100a1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a22:	00 00 00 
  100a25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2c:	00 00 00 
  100a2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a36:	00 00 00 
  100a39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a40:	00 00 00 
  100a43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a4a:	00 00 00 
  100a4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a54:	00 00 00 
  100a57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5e:	00 00 00 
  100a61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a68:	00 00 00 
  100a6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a72:	00 00 00 
  100a75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7c:	00 00 00 
  100a7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a86:	00 00 00 
  100a89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a90:	00 00 00 
  100a93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a9a:	00 00 00 
  100a9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa4:	00 00 00 
  100aa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aae:	00 00 00 
  100ab1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab8:	00 00 00 
  100abb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac2:	00 00 00 
  100ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acc:	00 00 00 
  100acf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad6:	00 00 00 
  100ad9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae0:	00 00 00 
  100ae3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aea:	00 00 00 
  100aed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af4:	00 00 00 
  100af7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afe:	00 00 00 
  100b01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b08:	00 00 00 
  100b0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b12:	00 00 00 
  100b15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1c:	00 00 00 
  100b1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b26:	00 00 00 
  100b29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b30:	00 00 00 
  100b33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b3a:	00 00 00 
  100b3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b44:	00 00 00 
  100b47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4e:	00 00 00 
  100b51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b58:	00 00 00 
  100b5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b62:	00 00 00 
  100b65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6c:	00 00 00 
  100b6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b76:	00 00 00 
  100b79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b80:	00 00 00 
  100b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b8a:	00 00 00 
  100b8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b94:	00 00 00 
  100b97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9e:	00 00 00 
  100ba1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba8:	00 00 00 
  100bab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb2:	00 00 00 
  100bb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbc:	00 00 00 
  100bbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc6:	00 00 00 
  100bc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd0:	00 00 00 
  100bd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bda:	00 00 00 
  100bdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be4:	00 00 00 
  100be7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bee:	00 00 00 
  100bf1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf8:	00 00 00 
  100bfb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c02:	00 00 00 
  100c05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0c:	00 00 00 
  100c0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c16:	00 00 00 
  100c19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c20:	00 00 00 
  100c23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c2a:	00 00 00 
  100c2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c34:	00 00 00 
  100c37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3e:	00 00 00 
  100c41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c48:	00 00 00 
  100c4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c52:	00 00 00 
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5c:	00 00 00 
  100c5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c66:	00 00 00 
  100c69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c70:	00 00 00 
  100c73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c7a:	00 00 00 
  100c7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c84:	00 00 00 
  100c87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8e:	00 00 00 
  100c91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c98:	00 00 00 
  100c9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca2:	00 00 00 
  100ca5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cac:	00 00 00 
  100caf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb6:	00 00 00 
  100cb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc0:	00 00 00 
  100cc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cca:	00 00 00 
  100ccd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd4:	00 00 00 
  100cd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cde:	00 00 00 
  100ce1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce8:	00 00 00 
  100ceb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf2:	00 00 00 
  100cf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfc:	00 00 00 
  100cff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d06:	00 00 00 
  100d09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d10:	00 00 00 
  100d13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d1a:	00 00 00 
  100d1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d24:	00 00 00 
  100d27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2e:	00 00 00 
  100d31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d38:	00 00 00 
  100d3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d42:	00 00 00 
  100d45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4c:	00 00 00 
  100d4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d56:	00 00 00 
  100d59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d60:	00 00 00 
  100d63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d6a:	00 00 00 
  100d6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d74:	00 00 00 
  100d77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7e:	00 00 00 
  100d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d88:	00 00 00 
  100d8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d92:	00 00 00 
  100d95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9c:	00 00 00 
  100d9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da6:	00 00 00 
  100da9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db0:	00 00 00 
  100db3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dba:	00 00 00 
  100dbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc4:	00 00 00 
  100dc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dce:	00 00 00 
  100dd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd8:	00 00 00 
  100ddb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de2:	00 00 00 
  100de5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dec:	00 00 00 
  100def:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df6:	00 00 00 
  100df9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e00:	00 00 00 
  100e03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e0a:	00 00 00 
  100e0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e14:	00 00 00 
  100e17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1e:	00 00 00 
  100e21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e28:	00 00 00 
  100e2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e32:	00 00 00 
  100e35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3c:	00 00 00 
  100e3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e46:	00 00 00 
  100e49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e50:	00 00 00 
  100e53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e5a:	00 00 00 
  100e5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e64:	00 00 00 
  100e67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6e:	00 00 00 
  100e71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e78:	00 00 00 
  100e7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e82:	00 00 00 
  100e85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8c:	00 00 00 
  100e8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e96:	00 00 00 
  100e99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea0:	00 00 00 
  100ea3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eaa:	00 00 00 
  100ead:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb4:	00 00 00 
  100eb7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebe:	00 00 00 
  100ec1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec8:	00 00 00 
  100ecb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed2:	00 00 00 
  100ed5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edc:	00 00 00 
  100edf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee6:	00 00 00 
  100ee9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef0:	00 00 00 
  100ef3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100efa:	00 00 00 
  100efd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f04:	00 00 00 
  100f07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0e:	00 00 00 
  100f11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f18:	00 00 00 
  100f1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f22:	00 00 00 
  100f25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2c:	00 00 00 
  100f2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f36:	00 00 00 
  100f39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f40:	00 00 00 
  100f43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f4a:	00 00 00 
  100f4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f54:	00 00 00 
  100f57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5e:	00 00 00 
  100f61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f68:	00 00 00 
  100f6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f72:	00 00 00 
  100f75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7c:	00 00 00 
  100f7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f86:	00 00 00 
  100f89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f90:	00 00 00 
  100f93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f9a:	00 00 00 
  100f9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa4:	00 00 00 
  100fa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fae:	00 00 00 
  100fb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb8:	00 00 00 
  100fbb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc2:	00 00 00 
  100fc5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcc:	00 00 00 
  100fcf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd6:	00 00 00 
  100fd9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe0:	00 00 00 
  100fe3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fea:	00 00 00 
  100fed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff4:	00 00 00 
  100ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  100ffe:	00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 c0 22 04 80 	movabs $0x800422c038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 c0 22 04 80 	movabs $0x800422c000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 1d 01 20 04 80 	movabs $0x800420011d,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004200060:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004200064:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200067:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420006b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420006e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004200072:	f0 87 02             	lock xchg %eax,(%rdx)
  8004200075:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004200078:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420007b:	c9                   	leaveq 
  800420007c:	c3                   	retq   

000000800420007d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420007d:	55                   	push   %rbp
  800420007e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004200081:	48 bf 80 c7 22 04 80 	movabs $0x800422c780,%rdi
  8004200088:	00 00 00 
  800420008b:	48 b8 e0 6a 21 04 80 	movabs $0x8004216ae0,%rax
  8004200092:	00 00 00 
  8004200095:	ff d0                	callq  *%rax
}
  8004200097:	5d                   	pop    %rbp
  8004200098:	c3                   	retq   

0000008004200099 <test_backtrace>:


// Test the stack backtrace function (lab 1 only)
void
test_backtrace(int x)
{
  8004200099:	55                   	push   %rbp
  800420009a:	48 89 e5             	mov    %rsp,%rbp
  800420009d:	48 83 ec 10          	sub    $0x10,%rsp
  80042000a1:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cprintf("entering test_backtrace %d\n", x);
  80042000a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000a7:	89 c6                	mov    %eax,%esi
  80042000a9:	48 bf 20 6e 21 04 80 	movabs $0x8004216e20,%rdi
  80042000b0:	00 00 00 
  80042000b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000b8:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042000bf:	00 00 00 
  80042000c2:	ff d2                	callq  *%rdx
	if (x > 0)
  80042000c4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042000c8:	7e 16                	jle    80042000e0 <test_backtrace+0x47>
		test_backtrace(x-1);
  80042000ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000cd:	83 e8 01             	sub    $0x1,%eax
  80042000d0:	89 c7                	mov    %eax,%edi
  80042000d2:	48 b8 99 00 20 04 80 	movabs $0x8004200099,%rax
  80042000d9:	00 00 00 
  80042000dc:	ff d0                	callq  *%rax
  80042000de:	eb 1b                	jmp    80042000fb <test_backtrace+0x62>
	else
		mon_backtrace(0, 0, 0);
  80042000e0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042000e5:	be 00 00 00 00       	mov    $0x0,%esi
  80042000ea:	bf 00 00 00 00       	mov    $0x0,%edi
  80042000ef:	48 b8 53 16 20 04 80 	movabs $0x8004201653,%rax
  80042000f6:	00 00 00 
  80042000f9:	ff d0                	callq  *%rax
	cprintf("leaving test_backtrace %d\n", x);
  80042000fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000fe:	89 c6                	mov    %eax,%esi
  8004200100:	48 bf 3c 6e 21 04 80 	movabs $0x8004216e3c,%rdi
  8004200107:	00 00 00 
  800420010a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420010f:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004200116:	00 00 00 
  8004200119:	ff d2                	callq  *%rdx
}
  800420011b:	c9                   	leaveq 
  800420011c:	c3                   	retq   

000000800420011d <i386_init>:


void
i386_init(void)
{
  800420011d:	55                   	push   %rbp
  800420011e:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  8004200121:	48 ba 10 40 52 04 80 	movabs $0x8004524010,%rdx
  8004200128:	00 00 00 
  800420012b:	48 b8 2c f0 49 04 80 	movabs $0x800449f02c,%rax
  8004200132:	00 00 00 
  8004200135:	48 29 c2             	sub    %rax,%rdx
  8004200138:	48 89 d0             	mov    %rdx,%rax
  800420013b:	48 89 c2             	mov    %rax,%rdx
  800420013e:	be 00 00 00 00       	mov    $0x0,%esi
  8004200143:	48 bf 2c f0 49 04 80 	movabs $0x800449f02c,%rdi
  800420014a:	00 00 00 
  800420014d:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004200154:	00 00 00 
  8004200157:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  8004200159:	48 b8 f7 11 20 04 80 	movabs $0x80042011f7,%rax
  8004200160:	00 00 00 
  8004200163:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  8004200165:	be ac 1a 00 00       	mov    $0x1aac,%esi
  800420016a:	48 bf 57 6e 21 04 80 	movabs $0x8004216e57,%rdi
  8004200171:	00 00 00 
  8004200174:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200179:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004200180:	00 00 00 
  8004200183:	ff d2                	callq  *%rdx

	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end); 
  8004200185:	48 b8 10 40 52 04 80 	movabs $0x8004524010,%rax
  800420018c:	00 00 00 
  800420018f:	48 89 c6             	mov    %rax,%rsi
  8004200192:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200199:	00 00 00 
  800420019c:	48 b8 96 52 21 04 80 	movabs $0x8004215296,%rax
  80042001a3:	00 00 00 
  80042001a6:	ff d0                	callq  *%rax
  80042001a8:	48 ba 88 17 4a 04 80 	movabs $0x80044a1788,%rdx
  80042001af:	00 00 00 
  80042001b2:	48 89 02             	mov    %rax,(%rdx)

	// Lab 2 memory management initialization functions
	x64_vm_init();
  80042001b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042001ba:	48 ba 0e 27 20 04 80 	movabs $0x800420270e,%rdx
  80042001c1:	00 00 00 
  80042001c4:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  80042001c6:	48 b8 d1 79 20 04 80 	movabs $0x80042079d1,%rax
  80042001cd:	00 00 00 
  80042001d0:	ff d0                	callq  *%rax
	trap_init();
  80042001d2:	48 b8 11 8f 20 04 80 	movabs $0x8004208f11,%rax
  80042001d9:	00 00 00 
  80042001dc:	ff d0                	callq  *%rax

	// Lab 4 multiprocessor initialization functions
	mp_init();
  80042001de:	48 b8 1d 62 21 04 80 	movabs $0x800421621d,%rax
  80042001e5:	00 00 00 
  80042001e8:	ff d0                	callq  *%rax
	lapic_init();
  80042001ea:	48 b8 5e 65 21 04 80 	movabs $0x800421655e,%rax
  80042001f1:	00 00 00 
  80042001f4:	ff d0                	callq  *%rax

	// Lab 4 multitasking initialization functions
	pic_init();
  80042001f6:	48 b8 c9 8a 20 04 80 	movabs $0x8004208ac9,%rax
  80042001fd:	00 00 00 
  8004200200:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:

	//Starting non-boot CPUs
	lock_kernel();
  8004200202:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200209:	00 00 00 
  800420020c:	ff d0                	callq  *%rax
	boot_aps();
  800420020e:	48 b8 5c 02 20 04 80 	movabs $0x800420025c,%rax
  8004200215:	00 00 00 
  8004200218:	ff d0                	callq  *%rax

	// Start fs.
	ENV_CREATE(fs_fs, ENV_TYPE_FS);
  800420021a:	be 01 00 00 00       	mov    $0x1,%esi
  800420021f:	48 bf c3 8b 3d 04 80 	movabs $0x80043d8bc3,%rdi
  8004200226:	00 00 00 
  8004200229:	48 b8 95 80 20 04 80 	movabs $0x8004208095,%rax
  8004200230:	00 00 00 
  8004200233:	ff d0                	callq  *%rax

#if defined(TEST)
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
  8004200235:	be 00 00 00 00       	mov    $0x0,%esi
  800420023a:	48 bf a7 86 48 04 80 	movabs $0x80044886a7,%rdi
  8004200241:	00 00 00 
  8004200244:	48 b8 95 80 20 04 80 	movabs $0x8004208095,%rax
  800420024b:	00 00 00 
  800420024e:	ff d0                	callq  *%rax
	//ENV_CREATE(user_testkbd, ENV_TYPE_USER);


#endif // TEST*
	// Schedule and run the first user environment!
	sched_yield();
  8004200250:	48 b8 93 ce 20 04 80 	movabs $0x800420ce93,%rax
  8004200257:	00 00 00 
  800420025a:	ff d0                	callq  *%rax

000000800420025c <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  800420025c:	55                   	push   %rbp
  800420025d:	48 89 e5             	mov    %rsp,%rbp
  8004200260:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  8004200264:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  800420026b:	00 
  800420026c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200270:	48 c1 e8 0c          	shr    $0xc,%rax
  8004200274:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200277:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420027a:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004200281:	00 00 00 
  8004200284:	48 8b 00             	mov    (%rax),%rax
  8004200287:	48 39 c2             	cmp    %rax,%rdx
  800420028a:	72 32                	jb     80042002be <boot_aps+0x62>
  800420028c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200290:	48 89 c1             	mov    %rax,%rcx
  8004200293:	48 ba 78 6e 21 04 80 	movabs $0x8004216e78,%rdx
  800420029a:	00 00 00 
  800420029d:	be 82 00 00 00       	mov    $0x82,%esi
  80042002a2:	48 bf 9b 6e 21 04 80 	movabs $0x8004216e9b,%rdi
  80042002a9:	00 00 00 
  80042002ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042002b1:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042002b8:	00 00 00 
  80042002bb:	41 ff d0             	callq  *%r8
  80042002be:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042002c5:	00 00 00 
  80042002c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042002cc:	48 01 d0             	add    %rdx,%rax
  80042002cf:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  80042002d3:	48 ba 46 5d 21 04 80 	movabs $0x8004215d46,%rdx
  80042002da:	00 00 00 
  80042002dd:	48 b8 60 5c 21 04 80 	movabs $0x8004215c60,%rax
  80042002e4:	00 00 00 
  80042002e7:	48 29 c2             	sub    %rax,%rdx
  80042002ea:	48 89 d0             	mov    %rdx,%rax
  80042002ed:	48 89 c2             	mov    %rax,%rdx
  80042002f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042002f4:	48 be 60 5c 21 04 80 	movabs $0x8004215c60,%rsi
  80042002fb:	00 00 00 
  80042002fe:	48 89 c7             	mov    %rax,%rdi
  8004200301:	48 b8 31 f9 20 04 80 	movabs $0x800420f931,%rax
  8004200308:	00 00 00 
  800420030b:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  800420030d:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  8004200314:	00 00 00 
  8004200317:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420031b:	e9 0b 01 00 00       	jmpq   800420042b <boot_aps+0x1cf>
		if (c == cpus + cpunum())  // We've started already.
  8004200320:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004200327:	00 00 00 
  800420032a:	ff d0                	callq  *%rax
  800420032c:	48 98                	cltq   
  800420032e:	48 c1 e0 03          	shl    $0x3,%rax
  8004200332:	48 89 c2             	mov    %rax,%rdx
  8004200335:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200339:	48 29 c2             	sub    %rax,%rdx
  800420033c:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  8004200343:	00 00 00 
  8004200346:	48 01 d0             	add    %rdx,%rax
  8004200349:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420034d:	75 05                	jne    8004200354 <boot_aps+0xf8>
			continue;
  800420034f:	e9 d2 00 00 00       	jmpq   8004200426 <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  8004200354:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200358:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  800420035f:	00 00 00 
  8004200362:	48 29 c2             	sub    %rax,%rdx
  8004200365:	48 89 d0             	mov    %rdx,%rax
  8004200368:	48 c1 f8 03          	sar    $0x3,%rax
  800420036c:	48 89 c2             	mov    %rax,%rdx
  800420036f:	48 b8 ef ee ee ee ee 	movabs $0xeeeeeeeeeeeeeeef,%rax
  8004200376:	ee ee ee 
  8004200379:	48 0f af c2          	imul   %rdx,%rax
  800420037d:	48 83 c0 01          	add    $0x1,%rax
  8004200381:	48 c1 e0 10          	shl    $0x10,%rax
  8004200385:	48 89 c2             	mov    %rax,%rdx
  8004200388:	48 b8 00 40 4a 04 80 	movabs $0x80044a4000,%rax
  800420038f:	00 00 00 
  8004200392:	48 01 c2             	add    %rax,%rdx
  8004200395:	48 b8 98 17 4a 04 80 	movabs $0x80044a1798,%rax
  800420039c:	00 00 00 
  800420039f:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  80042003a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042003a6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042003aa:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042003b1:	00 00 00 
  80042003b4:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80042003b8:	77 32                	ja     80042003ec <boot_aps+0x190>
  80042003ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042003be:	48 89 c1             	mov    %rax,%rcx
  80042003c1:	48 ba a8 6e 21 04 80 	movabs $0x8004216ea8,%rdx
  80042003c8:	00 00 00 
  80042003cb:	be 8c 00 00 00       	mov    $0x8c,%esi
  80042003d0:	48 bf 9b 6e 21 04 80 	movabs $0x8004216e9b,%rdi
  80042003d7:	00 00 00 
  80042003da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042003df:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042003e6:	00 00 00 
  80042003e9:	41 ff d0             	callq  *%r8
  80042003ec:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042003f3:	ff ff ff 
  80042003f6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042003fa:	48 01 d0             	add    %rdx,%rax
  80042003fd:	89 c2                	mov    %eax,%edx
  80042003ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200403:	0f b6 00             	movzbl (%rax),%eax
  8004200406:	0f b6 c0             	movzbl %al,%eax
  8004200409:	89 d6                	mov    %edx,%esi
  800420040b:	89 c7                	mov    %eax,%edi
  800420040d:	48 b8 c5 67 21 04 80 	movabs $0x80042167c5,%rax
  8004200414:	00 00 00 
  8004200417:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  8004200419:	90                   	nop
  800420041a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420041e:	8b 40 04             	mov    0x4(%rax),%eax
  8004200421:	83 f8 01             	cmp    $0x1,%eax
  8004200424:	75 f4                	jne    800420041a <boot_aps+0x1be>

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  8004200426:	48 83 45 f8 78       	addq   $0x78,-0x8(%rbp)
  800420042b:	48 b8 e8 33 4a 04 80 	movabs $0x80044a33e8,%rax
  8004200432:	00 00 00 
  8004200435:	8b 00                	mov    (%rax),%eax
  8004200437:	48 98                	cltq   
  8004200439:	48 c1 e0 03          	shl    $0x3,%rax
  800420043d:	48 89 c2             	mov    %rax,%rdx
  8004200440:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200444:	48 29 c2             	sub    %rax,%rdx
  8004200447:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  800420044e:	00 00 00 
  8004200451:	48 01 d0             	add    %rdx,%rax
  8004200454:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200458:	0f 87 c2 fe ff ff    	ja     8004200320 <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  800420045e:	c9                   	leaveq 
  800420045f:	c3                   	retq   

0000008004200460 <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  8004200460:	55                   	push   %rbp
  8004200461:	48 89 e5             	mov    %rsp,%rbp
  8004200464:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  8004200468:	48 b8 a0 17 4a 04 80 	movabs $0x80044a17a0,%rax
  800420046f:	00 00 00 
  8004200472:	48 8b 00             	mov    (%rax),%rax
  8004200475:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004200479:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420047d:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  8004200480:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004200487:	00 00 00 
  800420048a:	ff d0                	callq  *%rax
  800420048c:	89 c6                	mov    %eax,%esi
  800420048e:	48 bf cc 6e 21 04 80 	movabs $0x8004216ecc,%rdi
  8004200495:	00 00 00 
  8004200498:	b8 00 00 00 00       	mov    $0x0,%eax
  800420049d:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042004a4:	00 00 00 
  80042004a7:	ff d2                	callq  *%rdx

	lapic_init();
  80042004a9:	48 b8 5e 65 21 04 80 	movabs $0x800421655e,%rax
  80042004b0:	00 00 00 
  80042004b3:	ff d0                	callq  *%rax
	env_init_percpu();
  80042004b5:	48 b8 c2 7a 20 04 80 	movabs $0x8004207ac2,%rax
  80042004bc:	00 00 00 
  80042004bf:	ff d0                	callq  *%rax
	trap_init_percpu();
  80042004c1:	48 b8 c1 b6 20 04 80 	movabs $0x800420b6c1,%rax
  80042004c8:	00 00 00 
  80042004cb:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  80042004cd:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  80042004d4:	00 00 00 
  80042004d7:	ff d0                	callq  *%rax
  80042004d9:	48 98                	cltq   
  80042004db:	48 c1 e0 03          	shl    $0x3,%rax
  80042004df:	48 89 c2             	mov    %rax,%rdx
  80042004e2:	48 c1 e2 04          	shl    $0x4,%rdx
  80042004e6:	48 29 c2             	sub    %rax,%rdx
  80042004e9:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  80042004f0:	00 00 00 
  80042004f3:	48 01 d0             	add    %rdx,%rax
  80042004f6:	48 83 c0 04          	add    $0x4,%rax
  80042004fa:	be 01 00 00 00       	mov    $0x1,%esi
  80042004ff:	48 89 c7             	mov    %rax,%rdi
  8004200502:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  8004200509:	00 00 00 
  800420050c:	ff d0                	callq  *%rax
	// Now that we have finished some basic setup, call sched_yield()
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:
	lock_kernel();
  800420050e:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200515:	00 00 00 
  8004200518:	ff d0                	callq  *%rax
	sched_yield();
  800420051a:	48 b8 93 ce 20 04 80 	movabs $0x800420ce93,%rax
  8004200521:	00 00 00 
  8004200524:	ff d0                	callq  *%rax

0000008004200526 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  8004200526:	55                   	push   %rbp
  8004200527:	48 89 e5             	mov    %rsp,%rbp
  800420052a:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200531:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200538:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  800420053e:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200545:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420054c:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200553:	84 c0                	test   %al,%al
  8004200555:	74 20                	je     8004200577 <_panic+0x51>
  8004200557:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420055b:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420055f:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200563:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200567:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420056b:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420056f:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200573:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200577:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  800420057e:	48 b8 90 17 4a 04 80 	movabs $0x80044a1790,%rax
  8004200585:	00 00 00 
  8004200588:	48 8b 00             	mov    (%rax),%rax
  800420058b:	48 85 c0             	test   %rax,%rax
  800420058e:	74 05                	je     8004200595 <_panic+0x6f>
		goto dead;
  8004200590:	e9 b5 00 00 00       	jmpq   800420064a <_panic+0x124>
	panicstr = fmt;
  8004200595:	48 b8 90 17 4a 04 80 	movabs $0x80044a1790,%rax
  800420059c:	00 00 00 
  800420059f:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  80042005a6:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  80042005a9:	fa                   	cli    
  80042005aa:	fc                   	cld    

	va_start(ap, fmt);
  80042005ab:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042005b2:	00 00 00 
  80042005b5:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042005bc:	00 00 00 
  80042005bf:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042005c3:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042005ca:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042005d1:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  80042005d8:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  80042005df:	00 00 00 
  80042005e2:	ff d0                	callq  *%rax
  80042005e4:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  80042005ea:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80042005f1:	89 c6                	mov    %eax,%esi
  80042005f3:	48 bf e8 6e 21 04 80 	movabs $0x8004216ee8,%rdi
  80042005fa:	00 00 00 
  80042005fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200602:	49 b8 99 8d 20 04 80 	movabs $0x8004208d99,%r8
  8004200609:	00 00 00 
  800420060c:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  800420060f:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200616:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800420061d:	48 89 d6             	mov    %rdx,%rsi
  8004200620:	48 89 c7             	mov    %rax,%rdi
  8004200623:	48 b8 3a 8d 20 04 80 	movabs $0x8004208d3a,%rax
  800420062a:	00 00 00 
  800420062d:	ff d0                	callq  *%rax
	cprintf("\n");
  800420062f:	48 bf 0a 6f 21 04 80 	movabs $0x8004216f0a,%rdi
  8004200636:	00 00 00 
  8004200639:	b8 00 00 00 00       	mov    $0x0,%eax
  800420063e:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004200645:	00 00 00 
  8004200648:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  800420064a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420064f:	48 b8 31 1b 20 04 80 	movabs $0x8004201b31,%rax
  8004200656:	00 00 00 
  8004200659:	ff d0                	callq  *%rax
  800420065b:	eb ed                	jmp    800420064a <_panic+0x124>

000000800420065d <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  800420065d:	55                   	push   %rbp
  800420065e:	48 89 e5             	mov    %rsp,%rbp
  8004200661:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200668:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420066f:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200675:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420067c:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200683:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420068a:	84 c0                	test   %al,%al
  800420068c:	74 20                	je     80042006ae <_warn+0x51>
  800420068e:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200692:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200696:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420069a:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420069e:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042006a2:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042006a6:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042006aa:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042006ae:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  80042006b5:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042006bc:	00 00 00 
  80042006bf:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042006c6:	00 00 00 
  80042006c9:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042006cd:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042006d4:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042006db:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  80042006e2:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  80042006e8:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042006ef:	48 89 c6             	mov    %rax,%rsi
  80042006f2:	48 bf 0c 6f 21 04 80 	movabs $0x8004216f0c,%rdi
  80042006f9:	00 00 00 
  80042006fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200701:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  8004200708:	00 00 00 
  800420070b:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  800420070d:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200714:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800420071b:	48 89 d6             	mov    %rdx,%rsi
  800420071e:	48 89 c7             	mov    %rax,%rdi
  8004200721:	48 b8 3a 8d 20 04 80 	movabs $0x8004208d3a,%rax
  8004200728:	00 00 00 
  800420072b:	ff d0                	callq  *%rax
	cprintf("\n");
  800420072d:	48 bf 0a 6f 21 04 80 	movabs $0x8004216f0a,%rdi
  8004200734:	00 00 00 
  8004200737:	b8 00 00 00 00       	mov    $0x0,%eax
  800420073c:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004200743:	00 00 00 
  8004200746:	ff d2                	callq  *%rdx
	va_end(ap);
}
  8004200748:	c9                   	leaveq 
  8004200749:	c3                   	retq   

000000800420074a <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  800420074a:	55                   	push   %rbp
  800420074b:	48 89 e5             	mov    %rsp,%rbp
  800420074e:	48 83 ec 20          	sub    $0x20,%rsp
  8004200752:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200759:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420075c:	89 c2                	mov    %eax,%edx
  800420075e:	ec                   	in     (%dx),%al
  800420075f:	88 45 fb             	mov    %al,-0x5(%rbp)
  8004200762:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  8004200769:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420076c:	89 c2                	mov    %eax,%edx
  800420076e:	ec                   	in     (%dx),%al
  800420076f:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004200772:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  8004200779:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420077c:	89 c2                	mov    %eax,%edx
  800420077e:	ec                   	in     (%dx),%al
  800420077f:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004200782:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  8004200789:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420078c:	89 c2                	mov    %eax,%edx
  800420078e:	ec                   	in     (%dx),%al
  800420078f:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  8004200792:	c9                   	leaveq 
  8004200793:	c3                   	retq   

0000008004200794 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  8004200794:	55                   	push   %rbp
  8004200795:	48 89 e5             	mov    %rsp,%rbp
  8004200798:	48 83 ec 10          	sub    $0x10,%rsp
  800420079c:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  80042007a3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042007a6:	89 c2                	mov    %eax,%edx
  80042007a8:	ec                   	in     (%dx),%al
  80042007a9:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  80042007ac:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  80042007b0:	0f b6 c0             	movzbl %al,%eax
  80042007b3:	83 e0 01             	and    $0x1,%eax
  80042007b6:	85 c0                	test   %eax,%eax
  80042007b8:	75 07                	jne    80042007c1 <serial_proc_data+0x2d>
		return -1;
  80042007ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042007bf:	eb 17                	jmp    80042007d8 <serial_proc_data+0x44>
  80042007c1:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042007c8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042007cb:	89 c2                	mov    %eax,%edx
  80042007cd:	ec                   	in     (%dx),%al
  80042007ce:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  80042007d1:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  80042007d5:	0f b6 c0             	movzbl %al,%eax
}
  80042007d8:	c9                   	leaveq 
  80042007d9:	c3                   	retq   

00000080042007da <serial_intr>:

void
serial_intr(void)
{
  80042007da:	55                   	push   %rbp
  80042007db:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  80042007de:	48 b8 00 00 4a 04 80 	movabs $0x80044a0000,%rax
  80042007e5:	00 00 00 
  80042007e8:	0f b6 00             	movzbl (%rax),%eax
  80042007eb:	84 c0                	test   %al,%al
  80042007ed:	74 16                	je     8004200805 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  80042007ef:	48 bf 94 07 20 04 80 	movabs $0x8004200794,%rdi
  80042007f6:	00 00 00 
  80042007f9:	48 b8 7a 10 20 04 80 	movabs $0x800420107a,%rax
  8004200800:	00 00 00 
  8004200803:	ff d0                	callq  *%rax
}
  8004200805:	5d                   	pop    %rbp
  8004200806:	c3                   	retq   

0000008004200807 <serial_putc>:

static void
serial_putc(int c)
{
  8004200807:	55                   	push   %rbp
  8004200808:	48 89 e5             	mov    %rsp,%rbp
  800420080b:	48 83 ec 28          	sub    $0x28,%rsp
  800420080f:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  8004200812:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200819:	eb 10                	jmp    800420082b <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  800420081b:	48 b8 4a 07 20 04 80 	movabs $0x800420074a,%rax
  8004200822:	00 00 00 
  8004200825:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  8004200827:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420082b:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200832:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200835:	89 c2                	mov    %eax,%edx
  8004200837:	ec                   	in     (%dx),%al
  8004200838:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  800420083b:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  800420083f:	0f b6 c0             	movzbl %al,%eax
  8004200842:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  8004200845:	85 c0                	test   %eax,%eax
  8004200847:	75 09                	jne    8004200852 <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200849:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200850:	7e c9                	jle    800420081b <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  8004200852:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200855:	0f b6 c0             	movzbl %al,%eax
  8004200858:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  800420085f:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200862:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200866:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200869:	ee                   	out    %al,(%dx)
}
  800420086a:	c9                   	leaveq 
  800420086b:	c3                   	retq   

000000800420086c <serial_init>:

static void
serial_init(void)
{
  800420086c:	55                   	push   %rbp
  800420086d:	48 89 e5             	mov    %rsp,%rbp
  8004200870:	48 83 ec 50          	sub    $0x50,%rsp
  8004200874:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  800420087b:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  800420087f:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200883:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200886:	ee                   	out    %al,(%dx)
  8004200887:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  800420088e:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  8004200892:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004200896:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200899:	ee                   	out    %al,(%dx)
  800420089a:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  80042008a1:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  80042008a5:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  80042008a9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042008ac:	ee                   	out    %al,(%dx)
  80042008ad:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  80042008b4:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  80042008b8:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042008bc:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042008bf:	ee                   	out    %al,(%dx)
  80042008c0:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  80042008c7:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  80042008cb:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042008cf:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042008d2:	ee                   	out    %al,(%dx)
  80042008d3:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  80042008da:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  80042008de:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042008e2:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042008e5:	ee                   	out    %al,(%dx)
  80042008e6:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  80042008ed:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  80042008f1:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042008f5:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042008f8:	ee                   	out    %al,(%dx)
  80042008f9:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200900:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004200903:	89 c2                	mov    %eax,%edx
  8004200905:	ec                   	in     (%dx),%al
  8004200906:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004200909:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  800420090d:	3c ff                	cmp    $0xff,%al
  800420090f:	0f 95 c2             	setne  %dl
  8004200912:	48 b8 00 00 4a 04 80 	movabs $0x80044a0000,%rax
  8004200919:	00 00 00 
  800420091c:	88 10                	mov    %dl,(%rax)
  800420091e:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200925:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004200928:	89 c2                	mov    %eax,%edx
  800420092a:	ec                   	in     (%dx),%al
  800420092b:	88 45 bb             	mov    %al,-0x45(%rbp)
  800420092e:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  8004200935:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004200938:	89 c2                	mov    %eax,%edx
  800420093a:	ec                   	in     (%dx),%al
  800420093b:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	// Enable serial interrupts
	if (serial_exists)
  800420093e:	48 b8 00 00 4a 04 80 	movabs $0x80044a0000,%rax
  8004200945:	00 00 00 
  8004200948:	0f b6 00             	movzbl (%rax),%eax
  800420094b:	84 c0                	test   %al,%al
  800420094d:	74 23                	je     8004200972 <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  800420094f:	48 b8 92 c6 22 04 80 	movabs $0x800422c692,%rax
  8004200956:	00 00 00 
  8004200959:	0f b7 00             	movzwl (%rax),%eax
  800420095c:	0f b7 c0             	movzwl %ax,%eax
  800420095f:	25 ef ff 00 00       	and    $0xffef,%eax
  8004200964:	89 c7                	mov    %eax,%edi
  8004200966:	48 b8 1b 8c 20 04 80 	movabs $0x8004208c1b,%rax
  800420096d:	00 00 00 
  8004200970:	ff d0                	callq  *%rax
}
  8004200972:	c9                   	leaveq 
  8004200973:	c3                   	retq   

0000008004200974 <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  8004200974:	55                   	push   %rbp
  8004200975:	48 89 e5             	mov    %rsp,%rbp
  8004200978:	48 83 ec 38          	sub    $0x38,%rsp
  800420097c:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  800420097f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200986:	eb 10                	jmp    8004200998 <lpt_putc+0x24>
		delay();
  8004200988:	48 b8 4a 07 20 04 80 	movabs $0x800420074a,%rax
  800420098f:	00 00 00 
  8004200992:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200994:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200998:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  800420099f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042009a2:	89 c2                	mov    %eax,%edx
  80042009a4:	ec                   	in     (%dx),%al
  80042009a5:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  80042009a8:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  80042009ac:	84 c0                	test   %al,%al
  80042009ae:	78 09                	js     80042009b9 <lpt_putc+0x45>
  80042009b0:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  80042009b7:	7e cf                	jle    8004200988 <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  80042009b9:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042009bc:	0f b6 c0             	movzbl %al,%eax
  80042009bf:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  80042009c6:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042009c9:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042009cd:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042009d0:	ee                   	out    %al,(%dx)
  80042009d1:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  80042009d8:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  80042009dc:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042009e0:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042009e3:	ee                   	out    %al,(%dx)
  80042009e4:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  80042009eb:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  80042009ef:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042009f3:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80042009f6:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  80042009f7:	c9                   	leaveq 
  80042009f8:	c3                   	retq   

00000080042009f9 <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  80042009f9:	55                   	push   %rbp
  80042009fa:	48 89 e5             	mov    %rsp,%rbp
  80042009fd:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  8004200a01:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200a08:	00 00 00 
  8004200a0b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  8004200a0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a13:	0f b7 00             	movzwl (%rax),%eax
  8004200a16:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200a1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a1e:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  8004200a23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a27:	0f b7 00             	movzwl (%rax),%eax
  8004200a2a:	66 3d 5a a5          	cmp    $0xa55a,%ax
  8004200a2e:	74 20                	je     8004200a50 <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  8004200a30:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  8004200a37:	00 00 00 
  8004200a3a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  8004200a3e:	48 b8 04 00 4a 04 80 	movabs $0x80044a0004,%rax
  8004200a45:	00 00 00 
  8004200a48:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200a4e:	eb 1b                	jmp    8004200a6b <cga_init+0x72>
	} else {
		*cp = was;
  8004200a50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a54:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200a58:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200a5b:	48 b8 04 00 4a 04 80 	movabs $0x80044a0004,%rax
  8004200a62:	00 00 00 
  8004200a65:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200a6b:	48 b8 04 00 4a 04 80 	movabs $0x80044a0004,%rax
  8004200a72:	00 00 00 
  8004200a75:	8b 00                	mov    (%rax),%eax
  8004200a77:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200a7a:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200a7e:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200a82:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200a85:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200a86:	48 b8 04 00 4a 04 80 	movabs $0x80044a0004,%rax
  8004200a8d:	00 00 00 
  8004200a90:	8b 00                	mov    (%rax),%eax
  8004200a92:	83 c0 01             	add    $0x1,%eax
  8004200a95:	89 45 e4             	mov    %eax,-0x1c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a98:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200a9b:	89 c2                	mov    %eax,%edx
  8004200a9d:	ec                   	in     (%dx),%al
  8004200a9e:	88 45 e3             	mov    %al,-0x1d(%rbp)
	return data;
  8004200aa1:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200aa5:	0f b6 c0             	movzbl %al,%eax
  8004200aa8:	c1 e0 08             	shl    $0x8,%eax
  8004200aab:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200aae:	48 b8 04 00 4a 04 80 	movabs $0x80044a0004,%rax
  8004200ab5:	00 00 00 
  8004200ab8:	8b 00                	mov    (%rax),%eax
  8004200aba:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004200abd:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200ac1:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200ac5:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200ac8:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200ac9:	48 b8 04 00 4a 04 80 	movabs $0x80044a0004,%rax
  8004200ad0:	00 00 00 
  8004200ad3:	8b 00                	mov    (%rax),%eax
  8004200ad5:	83 c0 01             	add    $0x1,%eax
  8004200ad8:	89 45 d4             	mov    %eax,-0x2c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200adb:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200ade:	89 c2                	mov    %eax,%edx
  8004200ae0:	ec                   	in     (%dx),%al
  8004200ae1:	88 45 d3             	mov    %al,-0x2d(%rbp)
	return data;
  8004200ae4:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200ae8:	0f b6 c0             	movzbl %al,%eax
  8004200aeb:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200aee:	48 b8 08 00 4a 04 80 	movabs $0x80044a0008,%rax
  8004200af5:	00 00 00 
  8004200af8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200afc:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200aff:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200b02:	89 c2                	mov    %eax,%edx
  8004200b04:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200b0b:	00 00 00 
  8004200b0e:	66 89 10             	mov    %dx,(%rax)
}
  8004200b11:	c9                   	leaveq 
  8004200b12:	c3                   	retq   

0000008004200b13 <cga_putc>:



static void
cga_putc(int c)
{
  8004200b13:	55                   	push   %rbp
  8004200b14:	48 89 e5             	mov    %rsp,%rbp
  8004200b17:	48 83 ec 40          	sub    $0x40,%rsp
  8004200b1b:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200b1e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b21:	b0 00                	mov    $0x0,%al
  8004200b23:	85 c0                	test   %eax,%eax
  8004200b25:	75 07                	jne    8004200b2e <cga_putc+0x1b>
		c |= 0x0700;
  8004200b27:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200b2e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b31:	0f b6 c0             	movzbl %al,%eax
  8004200b34:	83 f8 09             	cmp    $0x9,%eax
  8004200b37:	0f 84 f6 00 00 00    	je     8004200c33 <cga_putc+0x120>
  8004200b3d:	83 f8 09             	cmp    $0x9,%eax
  8004200b40:	7f 0a                	jg     8004200b4c <cga_putc+0x39>
  8004200b42:	83 f8 08             	cmp    $0x8,%eax
  8004200b45:	74 18                	je     8004200b5f <cga_putc+0x4c>
  8004200b47:	e9 3e 01 00 00       	jmpq   8004200c8a <cga_putc+0x177>
  8004200b4c:	83 f8 0a             	cmp    $0xa,%eax
  8004200b4f:	74 75                	je     8004200bc6 <cga_putc+0xb3>
  8004200b51:	83 f8 0d             	cmp    $0xd,%eax
  8004200b54:	0f 84 89 00 00 00    	je     8004200be3 <cga_putc+0xd0>
  8004200b5a:	e9 2b 01 00 00       	jmpq   8004200c8a <cga_putc+0x177>
	case '\b':
		if (crt_pos > 0) {
  8004200b5f:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200b66:	00 00 00 
  8004200b69:	0f b7 00             	movzwl (%rax),%eax
  8004200b6c:	66 85 c0             	test   %ax,%ax
  8004200b6f:	74 50                	je     8004200bc1 <cga_putc+0xae>
			crt_pos--;
  8004200b71:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200b78:	00 00 00 
  8004200b7b:	0f b7 00             	movzwl (%rax),%eax
  8004200b7e:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200b81:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200b88:	00 00 00 
  8004200b8b:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200b8e:	48 b8 08 00 4a 04 80 	movabs $0x80044a0008,%rax
  8004200b95:	00 00 00 
  8004200b98:	48 8b 10             	mov    (%rax),%rdx
  8004200b9b:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200ba2:	00 00 00 
  8004200ba5:	0f b7 00             	movzwl (%rax),%eax
  8004200ba8:	0f b7 c0             	movzwl %ax,%eax
  8004200bab:	48 01 c0             	add    %rax,%rax
  8004200bae:	48 01 c2             	add    %rax,%rdx
  8004200bb1:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200bb4:	b0 00                	mov    $0x0,%al
  8004200bb6:	83 c8 20             	or     $0x20,%eax
  8004200bb9:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200bbc:	e9 04 01 00 00       	jmpq   8004200cc5 <cga_putc+0x1b2>
  8004200bc1:	e9 ff 00 00 00       	jmpq   8004200cc5 <cga_putc+0x1b2>
	case '\n':
		crt_pos += CRT_COLS;
  8004200bc6:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200bcd:	00 00 00 
  8004200bd0:	0f b7 00             	movzwl (%rax),%eax
  8004200bd3:	8d 50 50             	lea    0x50(%rax),%edx
  8004200bd6:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200bdd:	00 00 00 
  8004200be0:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200be3:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200bea:	00 00 00 
  8004200bed:	0f b7 30             	movzwl (%rax),%esi
  8004200bf0:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200bf7:	00 00 00 
  8004200bfa:	0f b7 08             	movzwl (%rax),%ecx
  8004200bfd:	0f b7 c1             	movzwl %cx,%eax
  8004200c00:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200c06:	c1 e8 10             	shr    $0x10,%eax
  8004200c09:	89 c2                	mov    %eax,%edx
  8004200c0b:	66 c1 ea 06          	shr    $0x6,%dx
  8004200c0f:	89 d0                	mov    %edx,%eax
  8004200c11:	c1 e0 02             	shl    $0x2,%eax
  8004200c14:	01 d0                	add    %edx,%eax
  8004200c16:	c1 e0 04             	shl    $0x4,%eax
  8004200c19:	29 c1                	sub    %eax,%ecx
  8004200c1b:	89 ca                	mov    %ecx,%edx
  8004200c1d:	29 d6                	sub    %edx,%esi
  8004200c1f:	89 f2                	mov    %esi,%edx
  8004200c21:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200c28:	00 00 00 
  8004200c2b:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200c2e:	e9 92 00 00 00       	jmpq   8004200cc5 <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200c33:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c38:	48 b8 b7 11 20 04 80 	movabs $0x80042011b7,%rax
  8004200c3f:	00 00 00 
  8004200c42:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c44:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c49:	48 b8 b7 11 20 04 80 	movabs $0x80042011b7,%rax
  8004200c50:	00 00 00 
  8004200c53:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c55:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c5a:	48 b8 b7 11 20 04 80 	movabs $0x80042011b7,%rax
  8004200c61:	00 00 00 
  8004200c64:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c66:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c6b:	48 b8 b7 11 20 04 80 	movabs $0x80042011b7,%rax
  8004200c72:	00 00 00 
  8004200c75:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c77:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c7c:	48 b8 b7 11 20 04 80 	movabs $0x80042011b7,%rax
  8004200c83:	00 00 00 
  8004200c86:	ff d0                	callq  *%rax
		break;
  8004200c88:	eb 3b                	jmp    8004200cc5 <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200c8a:	48 b8 08 00 4a 04 80 	movabs $0x80044a0008,%rax
  8004200c91:	00 00 00 
  8004200c94:	48 8b 30             	mov    (%rax),%rsi
  8004200c97:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200c9e:	00 00 00 
  8004200ca1:	0f b7 00             	movzwl (%rax),%eax
  8004200ca4:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200ca7:	48 ba 10 00 4a 04 80 	movabs $0x80044a0010,%rdx
  8004200cae:	00 00 00 
  8004200cb1:	66 89 0a             	mov    %cx,(%rdx)
  8004200cb4:	0f b7 c0             	movzwl %ax,%eax
  8004200cb7:	48 01 c0             	add    %rax,%rax
  8004200cba:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  8004200cbe:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200cc1:	66 89 02             	mov    %ax,(%rdx)
		break;
  8004200cc4:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200cc5:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200ccc:	00 00 00 
  8004200ccf:	0f b7 00             	movzwl (%rax),%eax
  8004200cd2:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200cd6:	0f 86 89 00 00 00    	jbe    8004200d65 <cga_putc+0x252>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200cdc:	48 b8 08 00 4a 04 80 	movabs $0x80044a0008,%rax
  8004200ce3:	00 00 00 
  8004200ce6:	48 8b 00             	mov    (%rax),%rax
  8004200ce9:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200cf0:	48 b8 08 00 4a 04 80 	movabs $0x80044a0008,%rax
  8004200cf7:	00 00 00 
  8004200cfa:	48 8b 00             	mov    (%rax),%rax
  8004200cfd:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200d02:	48 89 ce             	mov    %rcx,%rsi
  8004200d05:	48 89 c7             	mov    %rax,%rdi
  8004200d08:	48 b8 31 f9 20 04 80 	movabs $0x800420f931,%rax
  8004200d0f:	00 00 00 
  8004200d12:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d14:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200d1b:	eb 22                	jmp    8004200d3f <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200d1d:	48 b8 08 00 4a 04 80 	movabs $0x80044a0008,%rax
  8004200d24:	00 00 00 
  8004200d27:	48 8b 00             	mov    (%rax),%rax
  8004200d2a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200d2d:	48 63 d2             	movslq %edx,%rdx
  8004200d30:	48 01 d2             	add    %rdx,%rdx
  8004200d33:	48 01 d0             	add    %rdx,%rax
  8004200d36:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d3b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200d3f:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200d46:	7e d5                	jle    8004200d1d <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200d48:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200d4f:	00 00 00 
  8004200d52:	0f b7 00             	movzwl (%rax),%eax
  8004200d55:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200d58:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200d5f:	00 00 00 
  8004200d62:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200d65:	48 b8 04 00 4a 04 80 	movabs $0x80044a0004,%rax
  8004200d6c:	00 00 00 
  8004200d6f:	8b 00                	mov    (%rax),%eax
  8004200d71:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200d74:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200d78:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200d7c:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200d7f:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200d80:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200d87:	00 00 00 
  8004200d8a:	0f b7 00             	movzwl (%rax),%eax
  8004200d8d:	66 c1 e8 08          	shr    $0x8,%ax
  8004200d91:	0f b6 c0             	movzbl %al,%eax
  8004200d94:	48 ba 04 00 4a 04 80 	movabs $0x80044a0004,%rdx
  8004200d9b:	00 00 00 
  8004200d9e:	8b 12                	mov    (%rdx),%edx
  8004200da0:	83 c2 01             	add    $0x1,%edx
  8004200da3:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200da6:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200da9:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200dad:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200db0:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200db1:	48 b8 04 00 4a 04 80 	movabs $0x80044a0004,%rax
  8004200db8:	00 00 00 
  8004200dbb:	8b 00                	mov    (%rax),%eax
  8004200dbd:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200dc0:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200dc4:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200dc8:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200dcb:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200dcc:	48 b8 10 00 4a 04 80 	movabs $0x80044a0010,%rax
  8004200dd3:	00 00 00 
  8004200dd6:	0f b7 00             	movzwl (%rax),%eax
  8004200dd9:	0f b6 c0             	movzbl %al,%eax
  8004200ddc:	48 ba 04 00 4a 04 80 	movabs $0x80044a0004,%rdx
  8004200de3:	00 00 00 
  8004200de6:	8b 12                	mov    (%rdx),%edx
  8004200de8:	83 c2 01             	add    $0x1,%edx
  8004200deb:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200dee:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200df1:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200df5:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200df8:	ee                   	out    %al,(%dx)
}
  8004200df9:	c9                   	leaveq 
  8004200dfa:	c3                   	retq   

0000008004200dfb <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200dfb:	55                   	push   %rbp
  8004200dfc:	48 89 e5             	mov    %rsp,%rbp
  8004200dff:	48 83 ec 20          	sub    $0x20,%rsp
  8004200e03:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e0a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200e0d:	89 c2                	mov    %eax,%edx
  8004200e0f:	ec                   	in     (%dx),%al
  8004200e10:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200e13:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200e17:	0f b6 c0             	movzbl %al,%eax
  8004200e1a:	83 e0 01             	and    $0x1,%eax
  8004200e1d:	85 c0                	test   %eax,%eax
  8004200e1f:	75 0a                	jne    8004200e2b <kbd_proc_data+0x30>
		return -1;
  8004200e21:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200e26:	e9 fc 01 00 00       	jmpq   8004201027 <kbd_proc_data+0x22c>
  8004200e2b:	c7 45 ec 60 00 00 00 	movl   $0x60,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e32:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200e35:	89 c2                	mov    %eax,%edx
  8004200e37:	ec                   	in     (%dx),%al
  8004200e38:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  8004200e3b:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax

	data = inb(KBDATAP);
  8004200e3f:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200e42:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200e46:	75 27                	jne    8004200e6f <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200e48:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200e4f:	00 00 00 
  8004200e52:	8b 00                	mov    (%rax),%eax
  8004200e54:	83 c8 40             	or     $0x40,%eax
  8004200e57:	89 c2                	mov    %eax,%edx
  8004200e59:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200e60:	00 00 00 
  8004200e63:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e6a:	e9 b8 01 00 00       	jmpq   8004201027 <kbd_proc_data+0x22c>
	} else if (data & 0x80) {
  8004200e6f:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e73:	84 c0                	test   %al,%al
  8004200e75:	79 65                	jns    8004200edc <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200e77:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200e7e:	00 00 00 
  8004200e81:	8b 00                	mov    (%rax),%eax
  8004200e83:	83 e0 40             	and    $0x40,%eax
  8004200e86:	85 c0                	test   %eax,%eax
  8004200e88:	75 09                	jne    8004200e93 <kbd_proc_data+0x98>
  8004200e8a:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e8e:	83 e0 7f             	and    $0x7f,%eax
  8004200e91:	eb 04                	jmp    8004200e97 <kbd_proc_data+0x9c>
  8004200e93:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e97:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200e9a:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e9e:	48 ba 60 c0 22 04 80 	movabs $0x800422c060,%rdx
  8004200ea5:	00 00 00 
  8004200ea8:	48 98                	cltq   
  8004200eaa:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200eae:	83 c8 40             	or     $0x40,%eax
  8004200eb1:	0f b6 c0             	movzbl %al,%eax
  8004200eb4:	f7 d0                	not    %eax
  8004200eb6:	89 c2                	mov    %eax,%edx
  8004200eb8:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200ebf:	00 00 00 
  8004200ec2:	8b 00                	mov    (%rax),%eax
  8004200ec4:	21 c2                	and    %eax,%edx
  8004200ec6:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200ecd:	00 00 00 
  8004200ed0:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200ed2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200ed7:	e9 4b 01 00 00       	jmpq   8004201027 <kbd_proc_data+0x22c>
	} else if (shift & E0ESC) {
  8004200edc:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200ee3:	00 00 00 
  8004200ee6:	8b 00                	mov    (%rax),%eax
  8004200ee8:	83 e0 40             	and    $0x40,%eax
  8004200eeb:	85 c0                	test   %eax,%eax
  8004200eed:	74 21                	je     8004200f10 <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200eef:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200ef3:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200efa:	00 00 00 
  8004200efd:	8b 00                	mov    (%rax),%eax
  8004200eff:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200f02:	89 c2                	mov    %eax,%edx
  8004200f04:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200f0b:	00 00 00 
  8004200f0e:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200f10:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f14:	48 ba 60 c0 22 04 80 	movabs $0x800422c060,%rdx
  8004200f1b:	00 00 00 
  8004200f1e:	48 98                	cltq   
  8004200f20:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f24:	0f b6 d0             	movzbl %al,%edx
  8004200f27:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200f2e:	00 00 00 
  8004200f31:	8b 00                	mov    (%rax),%eax
  8004200f33:	09 c2                	or     %eax,%edx
  8004200f35:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200f3c:	00 00 00 
  8004200f3f:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200f41:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f45:	48 ba 60 c1 22 04 80 	movabs $0x800422c160,%rdx
  8004200f4c:	00 00 00 
  8004200f4f:	48 98                	cltq   
  8004200f51:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f55:	0f b6 d0             	movzbl %al,%edx
  8004200f58:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200f5f:	00 00 00 
  8004200f62:	8b 00                	mov    (%rax),%eax
  8004200f64:	31 c2                	xor    %eax,%edx
  8004200f66:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200f6d:	00 00 00 
  8004200f70:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200f72:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200f79:	00 00 00 
  8004200f7c:	8b 00                	mov    (%rax),%eax
  8004200f7e:	83 e0 03             	and    $0x3,%eax
  8004200f81:	89 c2                	mov    %eax,%edx
  8004200f83:	48 b8 60 c5 22 04 80 	movabs $0x800422c560,%rax
  8004200f8a:	00 00 00 
  8004200f8d:	89 d2                	mov    %edx,%edx
  8004200f8f:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200f93:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f97:	48 01 d0             	add    %rdx,%rax
  8004200f9a:	0f b6 00             	movzbl (%rax),%eax
  8004200f9d:	0f b6 c0             	movzbl %al,%eax
  8004200fa0:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200fa3:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200faa:	00 00 00 
  8004200fad:	8b 00                	mov    (%rax),%eax
  8004200faf:	83 e0 08             	and    $0x8,%eax
  8004200fb2:	85 c0                	test   %eax,%eax
  8004200fb4:	74 22                	je     8004200fd8 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200fb6:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200fba:	7e 0c                	jle    8004200fc8 <kbd_proc_data+0x1cd>
  8004200fbc:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200fc0:	7f 06                	jg     8004200fc8 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200fc2:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200fc6:	eb 10                	jmp    8004200fd8 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200fc8:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200fcc:	7e 0a                	jle    8004200fd8 <kbd_proc_data+0x1dd>
  8004200fce:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200fd2:	7f 04                	jg     8004200fd8 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200fd4:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200fd8:	48 b8 28 02 4a 04 80 	movabs $0x80044a0228,%rax
  8004200fdf:	00 00 00 
  8004200fe2:	8b 00                	mov    (%rax),%eax
  8004200fe4:	f7 d0                	not    %eax
  8004200fe6:	83 e0 06             	and    $0x6,%eax
  8004200fe9:	85 c0                	test   %eax,%eax
  8004200feb:	75 37                	jne    8004201024 <kbd_proc_data+0x229>
  8004200fed:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004200ff4:	75 2e                	jne    8004201024 <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004200ff6:	48 bf 26 6f 21 04 80 	movabs $0x8004216f26,%rdi
  8004200ffd:	00 00 00 
  8004201000:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201005:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420100c:	00 00 00 
  800420100f:	ff d2                	callq  *%rdx
  8004201011:	c7 45 e4 92 00 00 00 	movl   $0x92,-0x1c(%rbp)
  8004201018:	c6 45 e3 03          	movb   $0x3,-0x1d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420101c:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004201020:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201023:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
  8004201024:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004201027:	c9                   	leaveq 
  8004201028:	c3                   	retq   

0000008004201029 <kbd_intr>:

void
kbd_intr(void)
{
  8004201029:	55                   	push   %rbp
  800420102a:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  800420102d:	48 bf fb 0d 20 04 80 	movabs $0x8004200dfb,%rdi
  8004201034:	00 00 00 
  8004201037:	48 b8 7a 10 20 04 80 	movabs $0x800420107a,%rax
  800420103e:	00 00 00 
  8004201041:	ff d0                	callq  *%rax
}
  8004201043:	5d                   	pop    %rbp
  8004201044:	c3                   	retq   

0000008004201045 <kbd_init>:

static void
kbd_init(void)
{
  8004201045:	55                   	push   %rbp
  8004201046:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004201049:	48 b8 29 10 20 04 80 	movabs $0x8004201029,%rax
  8004201050:	00 00 00 
  8004201053:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  8004201055:	48 b8 92 c6 22 04 80 	movabs $0x800422c692,%rax
  800420105c:	00 00 00 
  800420105f:	0f b7 00             	movzwl (%rax),%eax
  8004201062:	0f b7 c0             	movzwl %ax,%eax
  8004201065:	25 fd ff 00 00       	and    $0xfffd,%eax
  800420106a:	89 c7                	mov    %eax,%edi
  800420106c:	48 b8 1b 8c 20 04 80 	movabs $0x8004208c1b,%rax
  8004201073:	00 00 00 
  8004201076:	ff d0                	callq  *%rax
}
  8004201078:	5d                   	pop    %rbp
  8004201079:	c3                   	retq   

000000800420107a <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  800420107a:	55                   	push   %rbp
  800420107b:	48 89 e5             	mov    %rsp,%rbp
  800420107e:	48 83 ec 20          	sub    $0x20,%rsp
  8004201082:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  8004201086:	eb 6a                	jmp    80042010f2 <cons_intr+0x78>
		if (c == 0)
  8004201088:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420108c:	75 02                	jne    8004201090 <cons_intr+0x16>
			continue;
  800420108e:	eb 62                	jmp    80042010f2 <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  8004201090:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  8004201097:	00 00 00 
  800420109a:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010a0:	8d 48 01             	lea    0x1(%rax),%ecx
  80042010a3:	48 ba 20 00 4a 04 80 	movabs $0x80044a0020,%rdx
  80042010aa:	00 00 00 
  80042010ad:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  80042010b3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042010b6:	89 d1                	mov    %edx,%ecx
  80042010b8:	48 ba 20 00 4a 04 80 	movabs $0x80044a0020,%rdx
  80042010bf:	00 00 00 
  80042010c2:	89 c0                	mov    %eax,%eax
  80042010c4:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  80042010c7:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  80042010ce:	00 00 00 
  80042010d1:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010d7:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042010dc:	75 14                	jne    80042010f2 <cons_intr+0x78>
			cons.wpos = 0;
  80042010de:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  80042010e5:	00 00 00 
  80042010e8:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  80042010ef:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  80042010f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042010f6:	ff d0                	callq  *%rax
  80042010f8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042010fb:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80042010ff:	75 87                	jne    8004201088 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  8004201101:	c9                   	leaveq 
  8004201102:	c3                   	retq   

0000008004201103 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  8004201103:	55                   	push   %rbp
  8004201104:	48 89 e5             	mov    %rsp,%rbp
  8004201107:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  800420110b:	48 b8 da 07 20 04 80 	movabs $0x80042007da,%rax
  8004201112:	00 00 00 
  8004201115:	ff d0                	callq  *%rax
	kbd_intr();
  8004201117:	48 b8 29 10 20 04 80 	movabs $0x8004201029,%rax
  800420111e:	00 00 00 
  8004201121:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  8004201123:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  800420112a:	00 00 00 
  800420112d:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  8004201133:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  800420113a:	00 00 00 
  800420113d:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201143:	39 c2                	cmp    %eax,%edx
  8004201145:	74 69                	je     80042011b0 <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  8004201147:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  800420114e:	00 00 00 
  8004201151:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201157:	8d 48 01             	lea    0x1(%rax),%ecx
  800420115a:	48 ba 20 00 4a 04 80 	movabs $0x80044a0020,%rdx
  8004201161:	00 00 00 
  8004201164:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  800420116a:	48 ba 20 00 4a 04 80 	movabs $0x80044a0020,%rdx
  8004201171:	00 00 00 
  8004201174:	89 c0                	mov    %eax,%eax
  8004201176:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420117a:	0f b6 c0             	movzbl %al,%eax
  800420117d:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  8004201180:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  8004201187:	00 00 00 
  800420118a:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201190:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004201195:	75 14                	jne    80042011ab <cons_getc+0xa8>
			cons.rpos = 0;
  8004201197:	48 b8 20 00 4a 04 80 	movabs $0x80044a0020,%rax
  800420119e:	00 00 00 
  80042011a1:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  80042011a8:	00 00 00 
		return c;
  80042011ab:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011ae:	eb 05                	jmp    80042011b5 <cons_getc+0xb2>
	}
	return 0;
  80042011b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042011b5:	c9                   	leaveq 
  80042011b6:	c3                   	retq   

00000080042011b7 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  80042011b7:	55                   	push   %rbp
  80042011b8:	48 89 e5             	mov    %rsp,%rbp
  80042011bb:	48 83 ec 10          	sub    $0x10,%rsp
  80042011bf:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  80042011c2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011c5:	89 c7                	mov    %eax,%edi
  80042011c7:	48 b8 07 08 20 04 80 	movabs $0x8004200807,%rax
  80042011ce:	00 00 00 
  80042011d1:	ff d0                	callq  *%rax
	lpt_putc(c);
  80042011d3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011d6:	89 c7                	mov    %eax,%edi
  80042011d8:	48 b8 74 09 20 04 80 	movabs $0x8004200974,%rax
  80042011df:	00 00 00 
  80042011e2:	ff d0                	callq  *%rax
	cga_putc(c);
  80042011e4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011e7:	89 c7                	mov    %eax,%edi
  80042011e9:	48 b8 13 0b 20 04 80 	movabs $0x8004200b13,%rax
  80042011f0:	00 00 00 
  80042011f3:	ff d0                	callq  *%rax
}
  80042011f5:	c9                   	leaveq 
  80042011f6:	c3                   	retq   

00000080042011f7 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  80042011f7:	55                   	push   %rbp
  80042011f8:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  80042011fb:	48 b8 f9 09 20 04 80 	movabs $0x80042009f9,%rax
  8004201202:	00 00 00 
  8004201205:	ff d0                	callq  *%rax
	kbd_init();
  8004201207:	48 b8 45 10 20 04 80 	movabs $0x8004201045,%rax
  800420120e:	00 00 00 
  8004201211:	ff d0                	callq  *%rax
	serial_init();
  8004201213:	48 b8 6c 08 20 04 80 	movabs $0x800420086c,%rax
  800420121a:	00 00 00 
  800420121d:	ff d0                	callq  *%rax

	if (!serial_exists)
  800420121f:	48 b8 00 00 4a 04 80 	movabs $0x80044a0000,%rax
  8004201226:	00 00 00 
  8004201229:	0f b6 00             	movzbl (%rax),%eax
  800420122c:	83 f0 01             	xor    $0x1,%eax
  800420122f:	84 c0                	test   %al,%al
  8004201231:	74 1b                	je     800420124e <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  8004201233:	48 bf 32 6f 21 04 80 	movabs $0x8004216f32,%rdi
  800420123a:	00 00 00 
  800420123d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201242:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004201249:	00 00 00 
  800420124c:	ff d2                	callq  *%rdx
}
  800420124e:	5d                   	pop    %rbp
  800420124f:	c3                   	retq   

0000008004201250 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  8004201250:	55                   	push   %rbp
  8004201251:	48 89 e5             	mov    %rsp,%rbp
  8004201254:	48 83 ec 10          	sub    $0x10,%rsp
  8004201258:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  800420125b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420125e:	89 c7                	mov    %eax,%edi
  8004201260:	48 b8 b7 11 20 04 80 	movabs $0x80042011b7,%rax
  8004201267:	00 00 00 
  800420126a:	ff d0                	callq  *%rax
}
  800420126c:	c9                   	leaveq 
  800420126d:	c3                   	retq   

000000800420126e <getchar>:

int
getchar(void)
{
  800420126e:	55                   	push   %rbp
  800420126f:	48 89 e5             	mov    %rsp,%rbp
  8004201272:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  8004201276:	48 b8 03 11 20 04 80 	movabs $0x8004201103,%rax
  800420127d:	00 00 00 
  8004201280:	ff d0                	callq  *%rax
  8004201282:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201285:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201289:	74 eb                	je     8004201276 <getchar+0x8>
		/* do nothing */;
	return c;
  800420128b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420128e:	c9                   	leaveq 
  800420128f:	c3                   	retq   

0000008004201290 <iscons>:

int
iscons(int fdnum)
{
  8004201290:	55                   	push   %rbp
  8004201291:	48 89 e5             	mov    %rsp,%rbp
  8004201294:	48 83 ec 04          	sub    $0x4,%rsp
  8004201298:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  800420129b:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042012a0:	c9                   	leaveq 
  80042012a1:	c3                   	retq   

00000080042012a2 <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  80042012a2:	55                   	push   %rbp
  80042012a3:	48 89 e5             	mov    %rsp,%rbp
  80042012a6:	48 83 ec 30          	sub    $0x30,%rsp
  80042012aa:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042012ad:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042012b1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042012b5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042012bc:	eb 6c                	jmp    800420132a <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  80042012be:	48 b9 80 c5 22 04 80 	movabs $0x800422c580,%rcx
  80042012c5:	00 00 00 
  80042012c8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012cb:	48 63 d0             	movslq %eax,%rdx
  80042012ce:	48 89 d0             	mov    %rdx,%rax
  80042012d1:	48 01 c0             	add    %rax,%rax
  80042012d4:	48 01 d0             	add    %rdx,%rax
  80042012d7:	48 c1 e0 03          	shl    $0x3,%rax
  80042012db:	48 01 c8             	add    %rcx,%rax
  80042012de:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042012e2:	48 be 80 c5 22 04 80 	movabs $0x800422c580,%rsi
  80042012e9:	00 00 00 
  80042012ec:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012ef:	48 63 d0             	movslq %eax,%rdx
  80042012f2:	48 89 d0             	mov    %rdx,%rax
  80042012f5:	48 01 c0             	add    %rax,%rax
  80042012f8:	48 01 d0             	add    %rdx,%rax
  80042012fb:	48 c1 e0 03          	shl    $0x3,%rax
  80042012ff:	48 01 f0             	add    %rsi,%rax
  8004201302:	48 8b 00             	mov    (%rax),%rax
  8004201305:	48 89 ca             	mov    %rcx,%rdx
  8004201308:	48 89 c6             	mov    %rax,%rsi
  800420130b:	48 bf ca 6f 21 04 80 	movabs $0x8004216fca,%rdi
  8004201312:	00 00 00 
  8004201315:	b8 00 00 00 00       	mov    $0x0,%eax
  800420131a:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  8004201321:	00 00 00 
  8004201324:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201326:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420132a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420132d:	83 f8 02             	cmp    $0x2,%eax
  8004201330:	76 8c                	jbe    80042012be <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	cprintf("%d",sizeof(int));	
  8004201332:	be 04 00 00 00       	mov    $0x4,%esi
  8004201337:	48 bf d3 6f 21 04 80 	movabs $0x8004216fd3,%rdi
  800420133e:	00 00 00 
  8004201341:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201346:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420134d:	00 00 00 
  8004201350:	ff d2                	callq  *%rdx
	return 0;
  8004201352:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201357:	c9                   	leaveq 
  8004201358:	c3                   	retq   

0000008004201359 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  8004201359:	55                   	push   %rbp
  800420135a:	48 89 e5             	mov    %rsp,%rbp
  800420135d:	48 83 ec 30          	sub    $0x30,%rsp
  8004201361:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004201364:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201368:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  800420136c:	48 bf d6 6f 21 04 80 	movabs $0x8004216fd6,%rdi
  8004201373:	00 00 00 
  8004201376:	b8 00 00 00 00       	mov    $0x0,%eax
  800420137b:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004201382:	00 00 00 
  8004201385:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  8004201387:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  800420138e:	00 00 00 
  8004201391:	48 bf f0 6f 21 04 80 	movabs $0x8004216ff0,%rdi
  8004201398:	00 00 00 
  800420139b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013a0:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042013a7:	00 00 00 
  80042013aa:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  80042013ac:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  80042013b3:	00 00 00 
  80042013b6:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  80042013bd:	00 00 00 
  80042013c0:	48 bf 18 70 21 04 80 	movabs $0x8004217018,%rdi
  80042013c7:	00 00 00 
  80042013ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013cf:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  80042013d6:	00 00 00 
  80042013d9:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  80042013db:	48 ba 01 6e 21 00 00 	movabs $0x216e01,%rdx
  80042013e2:	00 00 00 
  80042013e5:	48 be 01 6e 21 04 80 	movabs $0x8004216e01,%rsi
  80042013ec:	00 00 00 
  80042013ef:	48 bf 40 70 21 04 80 	movabs $0x8004217040,%rdi
  80042013f6:	00 00 00 
  80042013f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013fe:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  8004201405:	00 00 00 
  8004201408:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  800420140a:	48 ba 2c f0 49 00 00 	movabs $0x49f02c,%rdx
  8004201411:	00 00 00 
  8004201414:	48 be 2c f0 49 04 80 	movabs $0x800449f02c,%rsi
  800420141b:	00 00 00 
  800420141e:	48 bf 68 70 21 04 80 	movabs $0x8004217068,%rdi
  8004201425:	00 00 00 
  8004201428:	b8 00 00 00 00       	mov    $0x0,%eax
  800420142d:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  8004201434:	00 00 00 
  8004201437:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004201439:	48 ba 10 40 52 00 00 	movabs $0x524010,%rdx
  8004201440:	00 00 00 
  8004201443:	48 be 10 40 52 04 80 	movabs $0x8004524010,%rsi
  800420144a:	00 00 00 
  800420144d:	48 bf 90 70 21 04 80 	movabs $0x8004217090,%rdi
  8004201454:	00 00 00 
  8004201457:	b8 00 00 00 00       	mov    $0x0,%eax
  800420145c:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  8004201463:	00 00 00 
  8004201466:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  8004201468:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800420146f:	00 
  8004201470:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201477:	00 00 00 
  800420147a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420147e:	48 29 c2             	sub    %rax,%rdx
  8004201481:	48 b8 10 40 52 04 80 	movabs $0x8004524010,%rax
  8004201488:	00 00 00 
  800420148b:	48 83 e8 01          	sub    $0x1,%rax
  800420148f:	48 01 d0             	add    %rdx,%rax
  8004201492:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201496:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420149a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420149f:	48 f7 75 f8          	divq   -0x8(%rbp)
  80042014a3:	48 89 d0             	mov    %rdx,%rax
  80042014a6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042014aa:	48 29 c2             	sub    %rax,%rdx
  80042014ad:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  80042014b0:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  80042014b7:	48 85 c0             	test   %rax,%rax
  80042014ba:	48 0f 48 c2          	cmovs  %rdx,%rax
  80042014be:	48 c1 f8 0a          	sar    $0xa,%rax
  80042014c2:	48 89 c6             	mov    %rax,%rsi
  80042014c5:	48 bf b8 70 21 04 80 	movabs $0x80042170b8,%rdi
  80042014cc:	00 00 00 
  80042014cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014d4:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042014db:	00 00 00 
  80042014de:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  80042014e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042014e5:	c9                   	leaveq 
  80042014e6:	c3                   	retq   

00000080042014e7 <printArgList>:

void printArgList(uint64_t* prbp, struct Ripdebuginfo *info)
{
  80042014e7:	55                   	push   %rbp
  80042014e8:	48 89 e5             	mov    %rsp,%rbp
  80042014eb:	48 83 ec 30          	sub    $0x30,%rsp
  80042014ef:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042014f3:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t* tprbp = (uint64_t*)(prbp - 4);
  80042014f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042014fb:	48 83 e8 20          	sub    $0x20,%rax
  80042014ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	int numberArg = info->rip_fn_narg;
  8004201503:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201507:	8b 40 28             	mov    0x28(%rax),%eax
  800420150a:	89 45 f4             	mov    %eax,-0xc(%rbp)
	int i = 0;
  800420150d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	uint64_t size = 0;
  8004201514:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420151b:	00 
	if(numberArg <= 0)
  800420151c:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004201520:	7f 20                	jg     8004201542 <printArgList+0x5b>
	{
		cprintf("\n");
  8004201522:	48 bf e2 70 21 04 80 	movabs $0x80042170e2,%rdi
  8004201529:	00 00 00 
  800420152c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201531:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004201538:	00 00 00 
  800420153b:	ff d2                	callq  *%rdx
		return;
  800420153d:	e9 0f 01 00 00       	jmpq   8004201651 <printArgList+0x16a>
	}
	
	while(numberArg > 0)
  8004201542:	e9 e5 00 00 00       	jmpq   800420162c <printArgList+0x145>
	{
		//cprintf("size of argument %d is %d %x",i, info->size_fn_arg[i],*prbp);
		size = info->size_fn_arg[i];
  8004201547:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420154b:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800420154e:	48 63 d2             	movslq %edx,%rdx
  8004201551:	48 83 c2 08          	add    $0x8,%rdx
  8004201555:	8b 44 90 0c          	mov    0xc(%rax,%rdx,4),%eax
  8004201559:	48 98                	cltq   
  800420155b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		cprintf(" ");
  800420155f:	48 bf e4 70 21 04 80 	movabs $0x80042170e4,%rdi
  8004201566:	00 00 00 
  8004201569:	b8 00 00 00 00       	mov    $0x0,%eax
  800420156e:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004201575:	00 00 00 
  8004201578:	ff d2                	callq  *%rdx
		switch(size)
  800420157a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420157e:	48 83 f8 04          	cmp    $0x4,%rax
  8004201582:	74 43                	je     80042015c7 <printArgList+0xe0>
  8004201584:	48 83 f8 08          	cmp    $0x8,%rax
  8004201588:	74 6b                	je     80042015f5 <printArgList+0x10e>
  800420158a:	48 83 f8 01          	cmp    $0x1,%rax
  800420158e:	74 05                	je     8004201595 <printArgList+0xae>
			case 8:
				cprintf("%016x",*(tprbp -1));
				tprbp = tprbp - 1;
				break;
			default:
				break;
  8004201590:	e9 8f 00 00 00       	jmpq   8004201624 <printArgList+0x13d>
		size = info->size_fn_arg[i];
		cprintf(" ");
		switch(size)
		{
			case 1:
				cprintf("%016x",*((char*)tprbp -1));
  8004201595:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201599:	48 83 e8 01          	sub    $0x1,%rax
  800420159d:	0f b6 00             	movzbl (%rax),%eax
  80042015a0:	0f be c0             	movsbl %al,%eax
  80042015a3:	89 c6                	mov    %eax,%esi
  80042015a5:	48 bf e6 70 21 04 80 	movabs $0x80042170e6,%rdi
  80042015ac:	00 00 00 
  80042015af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015b4:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042015bb:	00 00 00 
  80042015be:	ff d2                	callq  *%rdx
				tprbp = (uint64_t*)((char*)tprbp - 1);
  80042015c0:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
				break;
  80042015c5:	eb 5d                	jmp    8004201624 <printArgList+0x13d>
			case 4:
				cprintf("%016x",*((int*)tprbp -1));
  80042015c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042015cb:	48 83 e8 04          	sub    $0x4,%rax
  80042015cf:	8b 00                	mov    (%rax),%eax
  80042015d1:	89 c6                	mov    %eax,%esi
  80042015d3:	48 bf e6 70 21 04 80 	movabs $0x80042170e6,%rdi
  80042015da:	00 00 00 
  80042015dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015e2:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042015e9:	00 00 00 
  80042015ec:	ff d2                	callq  *%rdx
				tprbp = (uint64_t*)((int*)tprbp - 1);
  80042015ee:	48 83 6d f8 04       	subq   $0x4,-0x8(%rbp)
				break;
  80042015f3:	eb 2f                	jmp    8004201624 <printArgList+0x13d>
			case 8:
				cprintf("%016x",*(tprbp -1));
  80042015f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042015f9:	48 83 e8 08          	sub    $0x8,%rax
  80042015fd:	48 8b 00             	mov    (%rax),%rax
  8004201600:	48 89 c6             	mov    %rax,%rsi
  8004201603:	48 bf e6 70 21 04 80 	movabs $0x80042170e6,%rdi
  800420160a:	00 00 00 
  800420160d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201612:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004201619:	00 00 00 
  800420161c:	ff d2                	callq  *%rdx
				tprbp = tprbp - 1;
  800420161e:	48 83 6d f8 08       	subq   $0x8,-0x8(%rbp)
				break;
  8004201623:	90                   	nop
			default:
				break;
		}
		i++;
  8004201624:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
		numberArg--;
  8004201628:	83 6d f4 01          	subl   $0x1,-0xc(%rbp)
	{
		cprintf("\n");
		return;
	}
	
	while(numberArg > 0)
  800420162c:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004201630:	0f 8f 11 ff ff ff    	jg     8004201547 <printArgList+0x60>
				break;
		}
		i++;
		numberArg--;
	}
	cprintf("\n");
  8004201636:	48 bf e2 70 21 04 80 	movabs $0x80042170e2,%rdi
  800420163d:	00 00 00 
  8004201640:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201645:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420164c:	00 00 00 
  800420164f:	ff d2                	callq  *%rdx
}
  8004201651:	c9                   	leaveq 
  8004201652:	c3                   	retq   

0000008004201653 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  8004201653:	55                   	push   %rbp
  8004201654:	48 89 e5             	mov    %rsp,%rbp
  8004201657:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  800420165e:	89 bd fc fa ff ff    	mov    %edi,-0x504(%rbp)
  8004201664:	48 89 b5 f0 fa ff ff 	mov    %rsi,-0x510(%rbp)
  800420166b:	48 89 95 e8 fa ff ff 	mov    %rdx,-0x518(%rbp)
	// Your code here.
	uint64_t rbp = 0x0;
  8004201672:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004201679:	00 
	uint64_t rip = 0x0;
  800420167a:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004201681:	00 
	uint64_t* prbp = NULL;
  8004201682:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004201689:	00 

	struct Ripdebuginfo info;

	cprintf("Stack backtrace:\n");
  800420168a:	48 bf ec 70 21 04 80 	movabs $0x80042170ec,%rdi
  8004201691:	00 00 00 
  8004201694:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201699:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042016a0:	00 00 00 
  80042016a3:	ff d2                	callq  *%rdx

static __inline uint64_t
read_rbp(void)
{
        uint64_t rbp;
        __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042016a5:	48 89 e8             	mov    %rbp,%rax
  80042016a8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        return rbp;
  80042016ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	rbp = read_rbp();
  80042016b0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	read_rip(rip);
  80042016b4:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 80042016bb <mon_backtrace+0x68>
  80042016bb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(rbp == 0x0 || rip == 0x0)
  80042016bf:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042016c4:	74 07                	je     80042016cd <mon_backtrace+0x7a>
  80042016c6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042016cb:	75 25                	jne    80042016f2 <mon_backtrace+0x9f>
	{
		cprintf("Not able to show backtrace");
  80042016cd:	48 bf fe 70 21 04 80 	movabs $0x80042170fe,%rdi
  80042016d4:	00 00 00 
  80042016d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016dc:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042016e3:	00 00 00 
  80042016e6:	ff d2                	callq  *%rdx
		return -1;
  80042016e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042016ed:	e9 2c 02 00 00       	jmpq   800420191e <mon_backtrace+0x2cb>
	}
	prbp = (uint64_t*)(rbp);
  80042016f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042016f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("    rbp %016x  rip %016x\n", prbp, rip);
  80042016fa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042016fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201702:	48 89 c6             	mov    %rax,%rsi
  8004201705:	48 bf 19 71 21 04 80 	movabs $0x8004217119,%rdi
  800420170c:	00 00 00 
  800420170f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201714:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  800420171b:	00 00 00 
  800420171e:	ff d1                	callq  *%rcx
	debuginfo_rip(rip ,&info);
  8004201720:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  8004201727:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420172b:	48 89 d6             	mov    %rdx,%rsi
  800420172e:	48 89 c7             	mov    %rax,%rdi
  8004201731:	48 b8 0e e5 20 04 80 	movabs $0x800420e50e,%rax
  8004201738:	00 00 00 
  800420173b:	ff d0                	callq  *%rax
	
	cprintf("        %s:%d: ",info.rip_file, info.rip_line);
  800420173d:	8b 95 08 fb ff ff    	mov    -0x4f8(%rbp),%edx
  8004201743:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
  800420174a:	48 89 c6             	mov    %rax,%rsi
  800420174d:	48 bf 33 71 21 04 80 	movabs $0x8004217133,%rdi
  8004201754:	00 00 00 
  8004201757:	b8 00 00 00 00       	mov    $0x0,%eax
  800420175c:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  8004201763:	00 00 00 
  8004201766:	ff d1                	callq  *%rcx
	cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
  8004201768:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
  800420176f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201773:	48 89 d1             	mov    %rdx,%rcx
  8004201776:	48 29 c1             	sub    %rax,%rcx
  8004201779:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8004201780:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  8004201786:	89 c6                	mov    %eax,%esi
  8004201788:	48 bf 43 71 21 04 80 	movabs $0x8004217143,%rdi
  800420178f:	00 00 00 
  8004201792:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201797:	49 b8 99 8d 20 04 80 	movabs $0x8004208d99,%r8
  800420179e:	00 00 00 
  80042017a1:	41 ff d0             	callq  *%r8
	cprintf(" args:%d", info.rip_fn_narg);
  80042017a4:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  80042017aa:	89 c6                	mov    %eax,%esi
  80042017ac:	48 bf 4e 71 21 04 80 	movabs $0x800421714e,%rdi
  80042017b3:	00 00 00 
  80042017b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017bb:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042017c2:	00 00 00 
  80042017c5:	ff d2                	callq  *%rdx
	printArgList(prbp, &info);
  80042017c7:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  80042017ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017d2:	48 89 d6             	mov    %rdx,%rsi
  80042017d5:	48 89 c7             	mov    %rax,%rdi
  80042017d8:	48 b8 e7 14 20 04 80 	movabs $0x80042014e7,%rax
  80042017df:	00 00 00 
  80042017e2:	ff d0                	callq  *%rax

	while(prbp && *(prbp) != 0x0 && *(prbp+1) != 0x0)
  80042017e4:	e9 09 01 00 00       	jmpq   80042018f2 <mon_backtrace+0x29f>
	{
		cprintf("    rbp %016x  rip %016x\n",*(prbp),*((prbp) +1));
  80042017e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017ed:	48 83 c0 08          	add    $0x8,%rax
  80042017f1:	48 8b 10             	mov    (%rax),%rdx
  80042017f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017f8:	48 8b 00             	mov    (%rax),%rax
  80042017fb:	48 89 c6             	mov    %rax,%rsi
  80042017fe:	48 bf 19 71 21 04 80 	movabs $0x8004217119,%rdi
  8004201805:	00 00 00 
  8004201808:	b8 00 00 00 00       	mov    $0x0,%eax
  800420180d:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  8004201814:	00 00 00 
  8004201817:	ff d1                	callq  *%rcx
		debuginfo_rip(*(prbp+1) ,&info);
  8004201819:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420181d:	48 83 c0 08          	add    $0x8,%rax
  8004201821:	48 8b 00             	mov    (%rax),%rax
  8004201824:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  800420182b:	48 89 d6             	mov    %rdx,%rsi
  800420182e:	48 89 c7             	mov    %rax,%rdi
  8004201831:	48 b8 0e e5 20 04 80 	movabs $0x800420e50e,%rax
  8004201838:	00 00 00 
  800420183b:	ff d0                	callq  *%rax

		cprintf("        %s:%d: ",info.rip_file, info.rip_line);
  800420183d:	8b 95 08 fb ff ff    	mov    -0x4f8(%rbp),%edx
  8004201843:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
  800420184a:	48 89 c6             	mov    %rax,%rsi
  800420184d:	48 bf 33 71 21 04 80 	movabs $0x8004217133,%rdi
  8004201854:	00 00 00 
  8004201857:	b8 00 00 00 00       	mov    $0x0,%eax
  800420185c:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  8004201863:	00 00 00 
  8004201866:	ff d1                	callq  *%rcx
		cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
  8004201868:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
  800420186f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201873:	48 89 d1             	mov    %rdx,%rcx
  8004201876:	48 29 c1             	sub    %rax,%rcx
  8004201879:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8004201880:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  8004201886:	89 c6                	mov    %eax,%esi
  8004201888:	48 bf 43 71 21 04 80 	movabs $0x8004217143,%rdi
  800420188f:	00 00 00 
  8004201892:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201897:	49 b8 99 8d 20 04 80 	movabs $0x8004208d99,%r8
  800420189e:	00 00 00 
  80042018a1:	41 ff d0             	callq  *%r8
		cprintf(" args:%d", info.rip_fn_narg);
  80042018a4:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  80042018aa:	89 c6                	mov    %eax,%esi
  80042018ac:	48 bf 4e 71 21 04 80 	movabs $0x800421714e,%rdi
  80042018b3:	00 00 00 
  80042018b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018bb:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042018c2:	00 00 00 
  80042018c5:	ff d2                	callq  *%rdx
		printArgList((uint64_t*)(*(prbp)), &info);
  80042018c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042018cb:	48 8b 00             	mov    (%rax),%rax
  80042018ce:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  80042018d5:	48 89 d6             	mov    %rdx,%rsi
  80042018d8:	48 89 c7             	mov    %rax,%rdi
  80042018db:	48 b8 e7 14 20 04 80 	movabs $0x80042014e7,%rax
  80042018e2:	00 00 00 
  80042018e5:	ff d0                	callq  *%rax
		
		prbp = (uint64_t*)(*(prbp)); 
  80042018e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042018eb:	48 8b 00             	mov    (%rax),%rax
  80042018ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	cprintf("        %s:%d: ",info.rip_file, info.rip_line);
	cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
	cprintf(" args:%d", info.rip_fn_narg);
	printArgList(prbp, &info);

	while(prbp && *(prbp) != 0x0 && *(prbp+1) != 0x0)
  80042018f2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042018f7:	74 20                	je     8004201919 <mon_backtrace+0x2c6>
  80042018f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042018fd:	48 8b 00             	mov    (%rax),%rax
  8004201900:	48 85 c0             	test   %rax,%rax
  8004201903:	74 14                	je     8004201919 <mon_backtrace+0x2c6>
  8004201905:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201909:	48 83 c0 08          	add    $0x8,%rax
  800420190d:	48 8b 00             	mov    (%rax),%rax
  8004201910:	48 85 c0             	test   %rax,%rax
  8004201913:	0f 85 d0 fe ff ff    	jne    80042017e9 <mon_backtrace+0x196>
		cprintf(" args:%d", info.rip_fn_narg);
		printArgList((uint64_t*)(*(prbp)), &info);
		
		prbp = (uint64_t*)(*(prbp)); 
	}
	return 0;
  8004201919:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420191e:	c9                   	leaveq 
  800420191f:	c3                   	retq   

0000008004201920 <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  8004201920:	55                   	push   %rbp
  8004201921:	48 89 e5             	mov    %rsp,%rbp
  8004201924:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  800420192b:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004201932:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  8004201939:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  8004201940:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201943:	48 98                	cltq   
  8004201945:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  800420194c:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201951:	eb 15                	jmp    8004201968 <runcmd+0x48>
			*buf++ = 0;
  8004201953:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420195a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420195e:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  8004201965:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201968:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420196f:	0f b6 00             	movzbl (%rax),%eax
  8004201972:	84 c0                	test   %al,%al
  8004201974:	74 2a                	je     80042019a0 <runcmd+0x80>
  8004201976:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420197d:	0f b6 00             	movzbl (%rax),%eax
  8004201980:	0f be c0             	movsbl %al,%eax
  8004201983:	89 c6                	mov    %eax,%esi
  8004201985:	48 bf 57 71 21 04 80 	movabs $0x8004217157,%rdi
  800420198c:	00 00 00 
  800420198f:	48 b8 33 f8 20 04 80 	movabs $0x800420f833,%rax
  8004201996:	00 00 00 
  8004201999:	ff d0                	callq  *%rax
  800420199b:	48 85 c0             	test   %rax,%rax
  800420199e:	75 b3                	jne    8004201953 <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  80042019a0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042019a7:	0f b6 00             	movzbl (%rax),%eax
  80042019aa:	84 c0                	test   %al,%al
  80042019ac:	75 21                	jne    80042019cf <runcmd+0xaf>
			break;
  80042019ae:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  80042019af:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042019b2:	48 98                	cltq   
  80042019b4:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042019bb:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  80042019c0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042019c4:	0f 85 a1 00 00 00    	jne    8004201a6b <runcmd+0x14b>
  80042019ca:	e9 92 00 00 00       	jmpq   8004201a61 <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  80042019cf:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042019d3:	75 2a                	jne    80042019ff <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  80042019d5:	be 10 00 00 00       	mov    $0x10,%esi
  80042019da:	48 bf 5c 71 21 04 80 	movabs $0x800421715c,%rdi
  80042019e1:	00 00 00 
  80042019e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019e9:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042019f0:	00 00 00 
  80042019f3:	ff d2                	callq  *%rdx
			return 0;
  80042019f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019fa:	e9 30 01 00 00       	jmpq   8004201b2f <runcmd+0x20f>
		}
		argv[argc++] = buf;
  80042019ff:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201a02:	8d 50 01             	lea    0x1(%rax),%edx
  8004201a05:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004201a08:	48 98                	cltq   
  8004201a0a:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004201a11:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  8004201a18:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201a19:	eb 08                	jmp    8004201a23 <runcmd+0x103>
			buf++;
  8004201a1b:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  8004201a22:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201a23:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201a2a:	0f b6 00             	movzbl (%rax),%eax
  8004201a2d:	84 c0                	test   %al,%al
  8004201a2f:	74 2a                	je     8004201a5b <runcmd+0x13b>
  8004201a31:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201a38:	0f b6 00             	movzbl (%rax),%eax
  8004201a3b:	0f be c0             	movsbl %al,%eax
  8004201a3e:	89 c6                	mov    %eax,%esi
  8004201a40:	48 bf 57 71 21 04 80 	movabs $0x8004217157,%rdi
  8004201a47:	00 00 00 
  8004201a4a:	48 b8 33 f8 20 04 80 	movabs $0x800420f833,%rax
  8004201a51:	00 00 00 
  8004201a54:	ff d0                	callq  *%rax
  8004201a56:	48 85 c0             	test   %rax,%rax
  8004201a59:	74 c0                	je     8004201a1b <runcmd+0xfb>
			buf++;
	}
  8004201a5b:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201a5c:	e9 07 ff ff ff       	jmpq   8004201968 <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  8004201a61:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a66:	e9 c4 00 00 00       	jmpq   8004201b2f <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  8004201a6b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004201a72:	e9 82 00 00 00       	jmpq   8004201af9 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004201a77:	48 b9 80 c5 22 04 80 	movabs $0x800422c580,%rcx
  8004201a7e:	00 00 00 
  8004201a81:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201a84:	48 63 d0             	movslq %eax,%rdx
  8004201a87:	48 89 d0             	mov    %rdx,%rax
  8004201a8a:	48 01 c0             	add    %rax,%rax
  8004201a8d:	48 01 d0             	add    %rdx,%rax
  8004201a90:	48 c1 e0 03          	shl    $0x3,%rax
  8004201a94:	48 01 c8             	add    %rcx,%rax
  8004201a97:	48 8b 10             	mov    (%rax),%rdx
  8004201a9a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201aa1:	48 89 d6             	mov    %rdx,%rsi
  8004201aa4:	48 89 c7             	mov    %rax,%rdi
  8004201aa7:	48 b8 6f f7 20 04 80 	movabs $0x800420f76f,%rax
  8004201aae:	00 00 00 
  8004201ab1:	ff d0                	callq  *%rax
  8004201ab3:	85 c0                	test   %eax,%eax
  8004201ab5:	75 3e                	jne    8004201af5 <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  8004201ab7:	48 b9 80 c5 22 04 80 	movabs $0x800422c580,%rcx
  8004201abe:	00 00 00 
  8004201ac1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201ac4:	48 63 d0             	movslq %eax,%rdx
  8004201ac7:	48 89 d0             	mov    %rdx,%rax
  8004201aca:	48 01 c0             	add    %rax,%rax
  8004201acd:	48 01 d0             	add    %rdx,%rax
  8004201ad0:	48 c1 e0 03          	shl    $0x3,%rax
  8004201ad4:	48 01 c8             	add    %rcx,%rax
  8004201ad7:	48 83 c0 10          	add    $0x10,%rax
  8004201adb:	48 8b 00             	mov    (%rax),%rax
  8004201ade:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004201ae5:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201aec:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004201aef:	89 cf                	mov    %ecx,%edi
  8004201af1:	ff d0                	callq  *%rax
  8004201af3:	eb 3a                	jmp    8004201b2f <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  8004201af5:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201af9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201afc:	83 f8 02             	cmp    $0x2,%eax
  8004201aff:	0f 86 72 ff ff ff    	jbe    8004201a77 <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004201b05:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201b0c:	48 89 c6             	mov    %rax,%rsi
  8004201b0f:	48 bf 79 71 21 04 80 	movabs $0x8004217179,%rdi
  8004201b16:	00 00 00 
  8004201b19:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b1e:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004201b25:	00 00 00 
  8004201b28:	ff d2                	callq  *%rdx
	return 0;
  8004201b2a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201b2f:	c9                   	leaveq 
  8004201b30:	c3                   	retq   

0000008004201b31 <monitor>:

void
monitor(struct Trapframe *tf)
{
  8004201b31:	55                   	push   %rbp
  8004201b32:	48 89 e5             	mov    %rsp,%rbp
  8004201b35:	48 83 ec 20          	sub    $0x20,%rsp
  8004201b39:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  8004201b3d:	48 bf 90 71 21 04 80 	movabs $0x8004217190,%rdi
  8004201b44:	00 00 00 
  8004201b47:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b4c:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004201b53:	00 00 00 
  8004201b56:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004201b58:	48 bf b8 71 21 04 80 	movabs $0x80042171b8,%rdi
  8004201b5f:	00 00 00 
  8004201b62:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b67:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004201b6e:	00 00 00 
  8004201b71:	ff d2                	callq  *%rdx

	if (tf != NULL)
  8004201b73:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201b78:	74 13                	je     8004201b8d <monitor+0x5c>
		print_trapframe(tf);
  8004201b7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201b7e:	48 89 c7             	mov    %rax,%rdi
  8004201b81:	48 b8 a2 bd 20 04 80 	movabs $0x800420bda2,%rax
  8004201b88:	00 00 00 
  8004201b8b:	ff d0                	callq  *%rax

	while (1) {
		buf = readline("K> ");
  8004201b8d:	48 bf dd 71 21 04 80 	movabs $0x80042171dd,%rdi
  8004201b94:	00 00 00 
  8004201b97:	48 b8 4c f4 20 04 80 	movabs $0x800420f44c,%rax
  8004201b9e:	00 00 00 
  8004201ba1:	ff d0                	callq  *%rax
  8004201ba3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201ba7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201bac:	74 20                	je     8004201bce <monitor+0x9d>
			if (runcmd(buf, tf) < 0)
  8004201bae:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201bb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201bb6:	48 89 d6             	mov    %rdx,%rsi
  8004201bb9:	48 89 c7             	mov    %rax,%rdi
  8004201bbc:	48 b8 20 19 20 04 80 	movabs $0x8004201920,%rax
  8004201bc3:	00 00 00 
  8004201bc6:	ff d0                	callq  *%rax
  8004201bc8:	85 c0                	test   %eax,%eax
  8004201bca:	79 02                	jns    8004201bce <monitor+0x9d>
				break;
  8004201bcc:	eb 02                	jmp    8004201bd0 <monitor+0x9f>
	}
  8004201bce:	eb bd                	jmp    8004201b8d <monitor+0x5c>
}
  8004201bd0:	c9                   	leaveq 
  8004201bd1:	c3                   	retq   

0000008004201bd2 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004201bd2:	55                   	push   %rbp
  8004201bd3:	48 89 e5             	mov    %rsp,%rbp
  8004201bd6:	48 83 ec 08          	sub    $0x8,%rsp
  8004201bda:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004201bde:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201be2:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004201be9:	00 00 00 
  8004201bec:	48 8b 00             	mov    (%rax),%rax
  8004201bef:	48 29 c2             	sub    %rax,%rdx
  8004201bf2:	48 89 d0             	mov    %rdx,%rax
  8004201bf5:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201bf9:	c9                   	leaveq 
  8004201bfa:	c3                   	retq   

0000008004201bfb <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201bfb:	55                   	push   %rbp
  8004201bfc:	48 89 e5             	mov    %rsp,%rbp
  8004201bff:	48 83 ec 08          	sub    $0x8,%rsp
  8004201c03:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201c07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c0b:	48 89 c7             	mov    %rax,%rdi
  8004201c0e:	48 b8 d2 1b 20 04 80 	movabs $0x8004201bd2,%rax
  8004201c15:	00 00 00 
  8004201c18:	ff d0                	callq  *%rax
  8004201c1a:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004201c1e:	c9                   	leaveq 
  8004201c1f:	c3                   	retq   

0000008004201c20 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004201c20:	55                   	push   %rbp
  8004201c21:	48 89 e5             	mov    %rsp,%rbp
  8004201c24:	48 83 ec 10          	sub    $0x10,%rsp
  8004201c28:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004201c2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c30:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201c34:	48 89 c2             	mov    %rax,%rdx
  8004201c37:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004201c3e:	00 00 00 
  8004201c41:	48 8b 00             	mov    (%rax),%rax
  8004201c44:	48 39 c2             	cmp    %rax,%rdx
  8004201c47:	72 2a                	jb     8004201c73 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004201c49:	48 ba e8 71 21 04 80 	movabs $0x80042171e8,%rdx
  8004201c50:	00 00 00 
  8004201c53:	be 54 00 00 00       	mov    $0x54,%esi
  8004201c58:	48 bf 07 72 21 04 80 	movabs $0x8004217207,%rdi
  8004201c5f:	00 00 00 
  8004201c62:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c67:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  8004201c6e:	00 00 00 
  8004201c71:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201c73:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004201c7a:	00 00 00 
  8004201c7d:	48 8b 00             	mov    (%rax),%rax
  8004201c80:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201c84:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201c88:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201c8c:	48 01 d0             	add    %rdx,%rax
}
  8004201c8f:	c9                   	leaveq 
  8004201c90:	c3                   	retq   

0000008004201c91 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004201c91:	55                   	push   %rbp
  8004201c92:	48 89 e5             	mov    %rsp,%rbp
  8004201c95:	48 83 ec 20          	sub    $0x20,%rsp
  8004201c99:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004201c9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201ca1:	48 89 c7             	mov    %rax,%rdi
  8004201ca4:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004201cab:	00 00 00 
  8004201cae:	ff d0                	callq  *%rax
  8004201cb0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201cb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201cb8:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201cbc:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004201cbf:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004201cc2:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004201cc9:	00 00 00 
  8004201ccc:	48 8b 00             	mov    (%rax),%rax
  8004201ccf:	48 39 c2             	cmp    %rax,%rdx
  8004201cd2:	72 32                	jb     8004201d06 <page2kva+0x75>
  8004201cd4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201cd8:	48 89 c1             	mov    %rax,%rcx
  8004201cdb:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004201ce2:	00 00 00 
  8004201ce5:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004201cea:	48 bf 07 72 21 04 80 	movabs $0x8004217207,%rdi
  8004201cf1:	00 00 00 
  8004201cf4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201cf9:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004201d00:	00 00 00 
  8004201d03:	41 ff d0             	callq  *%r8
  8004201d06:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201d0d:	00 00 00 
  8004201d10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d14:	48 01 d0             	add    %rdx,%rax
}
  8004201d17:	c9                   	leaveq 
  8004201d18:	c3                   	retq   

0000008004201d19 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201d19:	55                   	push   %rbp
  8004201d1a:	48 89 e5             	mov    %rsp,%rbp
  8004201d1d:	48 83 ec 08          	sub    $0x8,%rsp
  8004201d21:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201d24:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201d27:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201d2b:	74 06                	je     8004201d33 <restrictive_type+0x1a>
  8004201d2d:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  8004201d31:	75 07                	jne    8004201d3a <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201d33:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201d38:	eb 3e                	jmp    8004201d78 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201d3a:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201d3e:	74 06                	je     8004201d46 <restrictive_type+0x2d>
  8004201d40:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201d44:	75 07                	jne    8004201d4d <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201d46:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201d4b:	eb 2b                	jmp    8004201d78 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201d4d:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  8004201d51:	74 06                	je     8004201d59 <restrictive_type+0x40>
  8004201d53:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201d57:	75 07                	jne    8004201d60 <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201d59:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201d5e:	eb 18                	jmp    8004201d78 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004201d60:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201d64:	74 06                	je     8004201d6c <restrictive_type+0x53>
  8004201d66:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201d6a:	75 07                	jne    8004201d73 <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004201d6c:	b8 03 00 00 00       	mov    $0x3,%eax
  8004201d71:	eb 05                	jmp    8004201d78 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201d73:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201d78:	c9                   	leaveq 
  8004201d79:	c3                   	retq   

0000008004201d7a <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201d7a:	55                   	push   %rbp
  8004201d7b:	48 89 e5             	mov    %rsp,%rbp
  8004201d7e:	53                   	push   %rbx
  8004201d7f:	48 83 ec 18          	sub    $0x18,%rsp
  8004201d83:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201d86:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d89:	89 c7                	mov    %eax,%edi
  8004201d8b:	48 b8 4d 8a 20 04 80 	movabs $0x8004208a4d,%rax
  8004201d92:	00 00 00 
  8004201d95:	ff d0                	callq  *%rax
  8004201d97:	89 c3                	mov    %eax,%ebx
  8004201d99:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d9c:	83 c0 01             	add    $0x1,%eax
  8004201d9f:	89 c7                	mov    %eax,%edi
  8004201da1:	48 b8 4d 8a 20 04 80 	movabs $0x8004208a4d,%rax
  8004201da8:	00 00 00 
  8004201dab:	ff d0                	callq  *%rax
  8004201dad:	c1 e0 08             	shl    $0x8,%eax
  8004201db0:	09 d8                	or     %ebx,%eax
}
  8004201db2:	48 83 c4 18          	add    $0x18,%rsp
  8004201db6:	5b                   	pop    %rbx
  8004201db7:	5d                   	pop    %rbp
  8004201db8:	c3                   	retq   

0000008004201db9 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201db9:	55                   	push   %rbp
  8004201dba:	48 89 e5             	mov    %rsp,%rbp
  8004201dbd:	41 54                	push   %r12
  8004201dbf:	53                   	push   %rbx
  8004201dc0:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004201dc7:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201dce:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201dd5:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201ddc:	48 89 e0             	mov    %rsp,%rax
  8004201ddf:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  8004201de2:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201de9:	8b 40 30             	mov    0x30(%rax),%eax
  8004201dec:	89 c0                	mov    %eax,%eax
  8004201dee:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  8004201df2:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201df9:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201dfc:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201e01:	f7 e2                	mul    %edx
  8004201e03:	89 d0                	mov    %edx,%eax
  8004201e05:	c1 e8 04             	shr    $0x4,%eax
  8004201e08:	89 c0                	mov    %eax,%eax
  8004201e0a:	48 89 c2             	mov    %rax,%rdx
  8004201e0d:	48 83 ea 01          	sub    $0x1,%rdx
  8004201e11:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201e15:	49 89 c0             	mov    %rax,%r8
  8004201e18:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004201e1e:	48 89 c1             	mov    %rax,%rcx
  8004201e21:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004201e26:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e2a:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004201e2e:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201e33:	48 83 e8 01          	sub    $0x1,%rax
  8004201e37:	48 01 d0             	add    %rdx,%rax
  8004201e3a:	bb 10 00 00 00       	mov    $0x10,%ebx
  8004201e3f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201e44:	48 f7 f3             	div    %rbx
  8004201e47:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201e4b:	48 29 c4             	sub    %rax,%rsp
  8004201e4e:	48 89 e0             	mov    %rsp,%rax
  8004201e51:	48 83 c0 07          	add    $0x7,%rax
  8004201e55:	48 c1 e8 03          	shr    $0x3,%rax
  8004201e59:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e5d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004201e61:	48 bf 3b 72 21 04 80 	movabs $0x800421723b,%rdi
  8004201e68:	00 00 00 
  8004201e6b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201e70:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004201e77:	00 00 00 
  8004201e7a:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201e7c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201e83:	e9 6c 01 00 00       	jmpq   8004201ff4 <multiboot_read+0x23b>
		memory_map_t* mmap = &mmap_base[i];
  8004201e88:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201e8b:	48 63 d0             	movslq %eax,%rdx
  8004201e8e:	48 89 d0             	mov    %rdx,%rax
  8004201e91:	48 01 c0             	add    %rax,%rax
  8004201e94:	48 01 d0             	add    %rdx,%rax
  8004201e97:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e9b:	48 89 c2             	mov    %rax,%rdx
  8004201e9e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201ea2:	48 01 d0             	add    %rdx,%rax
  8004201ea5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201ea9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ead:	8b 40 08             	mov    0x8(%rax),%eax
  8004201eb0:	89 c0                	mov    %eax,%eax
  8004201eb2:	48 c1 e0 20          	shl    $0x20,%rax
  8004201eb6:	48 89 c2             	mov    %rax,%rdx
  8004201eb9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ebd:	8b 40 04             	mov    0x4(%rax),%eax
  8004201ec0:	89 c0                	mov    %eax,%eax
  8004201ec2:	48 01 d0             	add    %rdx,%rax
  8004201ec5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201ec9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ecd:	8b 40 10             	mov    0x10(%rax),%eax
  8004201ed0:	89 c0                	mov    %eax,%eax
  8004201ed2:	48 c1 e0 20          	shl    $0x20,%rax
  8004201ed6:	48 89 c2             	mov    %rax,%rdx
  8004201ed9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201edd:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201ee0:	89 c0                	mov    %eax,%eax
  8004201ee2:	48 01 d0             	add    %rdx,%rax
  8004201ee5:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  8004201ee9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201eed:	8b 70 14             	mov    0x14(%rax),%esi
  8004201ef0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ef4:	8b 00                	mov    (%rax),%eax
  8004201ef6:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201efa:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201efe:	41 89 f0             	mov    %esi,%r8d
  8004201f01:	89 c6                	mov    %eax,%esi
  8004201f03:	48 bf 50 72 21 04 80 	movabs $0x8004217250,%rdi
  8004201f0a:	00 00 00 
  8004201f0d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f12:	49 b9 99 8d 20 04 80 	movabs $0x8004208d99,%r9
  8004201f19:	00 00 00 
  8004201f1c:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  8004201f1f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f23:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f26:	83 f8 05             	cmp    $0x5,%eax
  8004201f29:	77 0b                	ja     8004201f36 <multiboot_read+0x17d>
  8004201f2b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f2f:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f32:	85 c0                	test   %eax,%eax
  8004201f34:	75 0b                	jne    8004201f41 <multiboot_read+0x188>
			mmap->type = MB_TYPE_RESERVED;
  8004201f36:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f3a:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
		//Insert into the sorted list
		int j = 0;
  8004201f41:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004201f48:	e9 85 00 00 00       	jmpq   8004201fd2 <multiboot_read+0x219>
			memory_map_t* this = mmap_list[j];
  8004201f4d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f51:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201f54:	48 63 d2             	movslq %edx,%rdx
  8004201f57:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201f5b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201f5f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201f63:	8b 40 08             	mov    0x8(%rax),%eax
  8004201f66:	89 c0                	mov    %eax,%eax
  8004201f68:	48 c1 e0 20          	shl    $0x20,%rax
  8004201f6c:	48 89 c2             	mov    %rax,%rdx
  8004201f6f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201f73:	8b 40 04             	mov    0x4(%rax),%eax
  8004201f76:	89 c0                	mov    %eax,%eax
  8004201f78:	48 01 d0             	add    %rdx,%rax
  8004201f7b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004201f7f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201f83:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201f87:	76 45                	jbe    8004201fce <multiboot_read+0x215>
				int last = i+1;
  8004201f89:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201f8c:	83 c0 01             	add    $0x1,%eax
  8004201f8f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004201f92:	eb 30                	jmp    8004201fc4 <multiboot_read+0x20b>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201f94:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f98:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201f9b:	48 63 d2             	movslq %edx,%rdx
  8004201f9e:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201fa2:	48 01 c2             	add    %rax,%rdx
  8004201fa5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fa9:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201fac:	48 63 c9             	movslq %ecx,%rcx
  8004201faf:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201fb3:	48 83 e9 08          	sub    $0x8,%rcx
  8004201fb7:	48 01 c8             	add    %rcx,%rax
  8004201fba:	48 8b 00             	mov    (%rax),%rax
  8004201fbd:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004201fc0:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004201fc4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201fc7:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201fca:	75 c8                	jne    8004201f94 <multiboot_read+0x1db>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break; 
  8004201fcc:	eb 10                	jmp    8004201fde <multiboot_read+0x225>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;
       
		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  8004201fce:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004201fd2:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201fd5:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201fd8:	0f 8c 6f ff ff ff    	jl     8004201f4d <multiboot_read+0x194>
					last--;
				}
				break; 
			}
		}
		mmap_list[j] = mmap;  
  8004201fde:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fe2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201fe5:	48 63 d2             	movslq %edx,%rdx
  8004201fe8:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004201fec:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201ff0:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201ff4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ff7:	48 63 c8             	movslq %eax,%rcx
  8004201ffa:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202001:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202004:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202009:	f7 e2                	mul    %edx
  800420200b:	89 d0                	mov    %edx,%eax
  800420200d:	c1 e8 04             	shr    $0x4,%eax
  8004202010:	89 c0                	mov    %eax,%eax
  8004202012:	48 39 c1             	cmp    %rax,%rcx
  8004202015:	0f 82 6d fe ff ff    	jb     8004201e88 <multiboot_read+0xcf>
				break; 
			}
		}
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
  800420201b:	48 bf 87 72 21 04 80 	movabs $0x8004217287,%rdi
  8004202022:	00 00 00 
  8004202025:	b8 00 00 00 00       	mov    $0x0,%eax
  800420202a:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004202031:	00 00 00 
  8004202034:	ff d2                	callq  *%rdx
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202036:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  800420203d:	e9 93 01 00 00       	jmpq   80042021d5 <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  8004202042:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202045:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202048:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420204c:	48 63 d2             	movslq %edx,%rdx
  800420204f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202053:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004202057:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420205b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420205e:	48 63 d2             	movslq %edx,%rdx
  8004202061:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202065:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004202069:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420206d:	8b 40 08             	mov    0x8(%rax),%eax
  8004202070:	89 c0                	mov    %eax,%eax
  8004202072:	48 c1 e0 20          	shl    $0x20,%rax
  8004202076:	48 89 c2             	mov    %rax,%rdx
  8004202079:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420207d:	8b 40 04             	mov    0x4(%rax),%eax
  8004202080:	89 c0                	mov    %eax,%eax
  8004202082:	48 01 d0             	add    %rdx,%rax
  8004202085:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004202089:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420208d:	8b 40 08             	mov    0x8(%rax),%eax
  8004202090:	89 c0                	mov    %eax,%eax
  8004202092:	48 c1 e0 20          	shl    $0x20,%rax
  8004202096:	48 89 c2             	mov    %rax,%rdx
  8004202099:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420209d:	8b 40 04             	mov    0x4(%rax),%eax
  80042020a0:	89 c0                	mov    %eax,%eax
  80042020a2:	48 01 d0             	add    %rdx,%rax
  80042020a5:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  80042020a9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020ad:	8b 40 10             	mov    0x10(%rax),%eax
  80042020b0:	89 c0                	mov    %eax,%eax
  80042020b2:	48 c1 e0 20          	shl    $0x20,%rax
  80042020b6:	48 89 c2             	mov    %rax,%rdx
  80042020b9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020bd:	8b 40 0c             	mov    0xc(%rax),%eax
  80042020c0:	89 c0                	mov    %eax,%eax
  80042020c2:	48 01 d0             	add    %rdx,%rax
  80042020c5:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  80042020cc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020d0:	8b 40 10             	mov    0x10(%rax),%eax
  80042020d3:	89 c0                	mov    %eax,%eax
  80042020d5:	48 c1 e0 20          	shl    $0x20,%rax
  80042020d9:	48 89 c2             	mov    %rax,%rdx
  80042020dc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020e0:	8b 40 0c             	mov    0xc(%rax),%eax
  80042020e3:	89 c0                	mov    %eax,%eax
  80042020e5:	48 01 d0             	add    %rdx,%rax
  80042020e8:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  80042020ef:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042020f6:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042020fa:	48 01 d0             	add    %rdx,%rax
  80042020fd:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004202101:	75 7c                	jne    800420217f <multiboot_read+0x3c6>
  8004202103:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202107:	8b 50 14             	mov    0x14(%rax),%edx
  800420210a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420210e:	8b 40 14             	mov    0x14(%rax),%eax
  8004202111:	39 c2                	cmp    %eax,%edx
  8004202113:	75 6a                	jne    800420217f <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  8004202115:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420211c:	89 c2                	mov    %eax,%edx
  800420211e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202125:	01 c2                	add    %eax,%edx
  8004202127:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420212b:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  800420212e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202135:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800420213c:	48 01 d0             	add    %rdx,%rax
  800420213f:	48 c1 e8 20          	shr    $0x20,%rax
  8004202143:	89 c2                	mov    %eax,%edx
  8004202145:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202149:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  800420214c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202150:	8b 50 04             	mov    0x4(%rax),%edx
  8004202153:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202157:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  800420215a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420215e:	8b 50 08             	mov    0x8(%rax),%edx
  8004202161:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202165:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004202168:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420216b:	8d 50 ff             	lea    -0x1(%rax),%edx
  800420216e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202172:	48 63 d2             	movslq %edx,%rdx
  8004202175:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  800420217c:	00 
  800420217d:	eb 52                	jmp    80042021d1 <multiboot_read+0x418>
		} else if(prev_addr + prev_length > this_addr) {
  800420217f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202186:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800420218a:	48 01 d0             	add    %rdx,%rax
  800420218d:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004202191:	76 3e                	jbe    80042021d1 <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  8004202193:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202197:	8b 50 14             	mov    0x14(%rax),%edx
  800420219a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420219e:	8b 40 14             	mov    0x14(%rax),%eax
  80042021a1:	89 d6                	mov    %edx,%esi
  80042021a3:	89 c7                	mov    %eax,%edi
  80042021a5:	48 b8 19 1d 20 04 80 	movabs $0x8004201d19,%rax
  80042021ac:	00 00 00 
  80042021af:	ff d0                	callq  *%rax
  80042021b1:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  80042021b7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042021bb:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042021c1:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  80042021c4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021c8:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042021ce:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042021d1:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042021d5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042021d8:	48 63 c8             	movslq %eax,%rcx
  80042021db:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042021e2:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042021e5:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  80042021ea:	f7 e2                	mul    %edx
  80042021ec:	89 d0                	mov    %edx,%eax
  80042021ee:	c1 e8 04             	shr    $0x4,%eax
  80042021f1:	89 c0                	mov    %eax,%eax
  80042021f3:	48 39 c1             	cmp    %rax,%rcx
  80042021f6:	0f 82 46 fe ff ff    	jb     8004202042 <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042021fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004202203:	e9 dc 00 00 00       	jmpq   80042022e4 <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004202208:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420220c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420220f:	48 63 d2             	movslq %edx,%rdx
  8004202212:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202216:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  800420221d:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004202224:	00 
  8004202225:	0f 84 b5 00 00 00    	je     80042022e0 <multiboot_read+0x527>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  800420222b:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202232:	8b 40 14             	mov    0x14(%rax),%eax
  8004202235:	83 f8 01             	cmp    $0x1,%eax
  8004202238:	74 13                	je     800420224d <multiboot_read+0x494>
  800420223a:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202241:	8b 40 14             	mov    0x14(%rax),%eax
  8004202244:	83 f8 03             	cmp    $0x3,%eax
  8004202247:	0f 85 93 00 00 00    	jne    80042022e0 <multiboot_read+0x527>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  800420224d:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202254:	8b 40 04             	mov    0x4(%rax),%eax
  8004202257:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  800420225c:	77 49                	ja     80042022a7 <multiboot_read+0x4ee>
  800420225e:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202265:	8b 40 08             	mov    0x8(%rax),%eax
  8004202268:	85 c0                	test   %eax,%eax
  800420226a:	75 3b                	jne    80042022a7 <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  800420226c:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004202273:	48 8b 10             	mov    (%rax),%rdx
  8004202276:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420227d:	8b 40 10             	mov    0x10(%rax),%eax
  8004202280:	89 c0                	mov    %eax,%eax
  8004202282:	48 c1 e0 20          	shl    $0x20,%rax
  8004202286:	48 89 c1             	mov    %rax,%rcx
  8004202289:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202290:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202293:	89 c0                	mov    %eax,%eax
  8004202295:	48 01 c8             	add    %rcx,%rax
  8004202298:	48 01 c2             	add    %rax,%rdx
  800420229b:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042022a2:	48 89 10             	mov    %rdx,(%rax)
  80042022a5:	eb 39                	jmp    80042022e0 <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042022a7:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042022ae:	48 8b 10             	mov    (%rax),%rdx
  80042022b1:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022b8:	8b 40 10             	mov    0x10(%rax),%eax
  80042022bb:	89 c0                	mov    %eax,%eax
  80042022bd:	48 c1 e0 20          	shl    $0x20,%rax
  80042022c1:	48 89 c1             	mov    %rax,%rcx
  80042022c4:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022cb:	8b 40 0c             	mov    0xc(%rax),%eax
  80042022ce:	89 c0                	mov    %eax,%eax
  80042022d0:	48 01 c8             	add    %rcx,%rax
  80042022d3:	48 01 c2             	add    %rax,%rdx
  80042022d6:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042022dd:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042022e0:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042022e4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042022e7:	48 63 c8             	movslq %eax,%rcx
  80042022ea:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042022f1:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042022f4:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  80042022f9:	f7 e2                	mul    %edx
  80042022fb:	89 d0                	mov    %edx,%eax
  80042022fd:	c1 e8 04             	shr    $0x4,%eax
  8004202300:	89 c0                	mov    %eax,%eax
  8004202302:	48 39 c1             	cmp    %rax,%rcx
  8004202305:	0f 82 fd fe ff ff    	jb     8004202208 <multiboot_read+0x44f>
  800420230b:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  800420230e:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  8004202312:	5b                   	pop    %rbx
  8004202313:	41 5c                	pop    %r12
  8004202315:	5d                   	pop    %rbp
  8004202316:	c3                   	retq   

0000008004202317 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004202317:	55                   	push   %rbp
  8004202318:	48 89 e5             	mov    %rsp,%rbp
  800420231b:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  800420231f:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004202326:	00 
	size_t extmem = 0;
  8004202327:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  800420232e:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  800420232f:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004202336:	00 00 00 
  8004202339:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  800420233d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202341:	48 8b 00             	mov    (%rax),%rax
  8004202344:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004202348:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420234d:	74 2d                	je     800420237c <i386_detect_memory+0x65>
  800420234f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202353:	8b 00                	mov    (%rax),%eax
  8004202355:	83 e0 40             	and    $0x40,%eax
  8004202358:	85 c0                	test   %eax,%eax
  800420235a:	74 20                	je     800420237c <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  800420235c:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  8004202360:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8004202364:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202368:	48 89 ce             	mov    %rcx,%rsi
  800420236b:	48 89 c7             	mov    %rax,%rdi
  800420236e:	48 b8 b9 1d 20 04 80 	movabs $0x8004201db9,%rax
  8004202375:	00 00 00 
  8004202378:	ff d0                	callq  *%rax
  800420237a:	eb 34                	jmp    80042023b0 <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  800420237c:	bf 15 00 00 00       	mov    $0x15,%edi
  8004202381:	48 b8 7a 1d 20 04 80 	movabs $0x8004201d7a,%rax
  8004202388:	00 00 00 
  800420238b:	ff d0                	callq  *%rax
  800420238d:	c1 e0 0a             	shl    $0xa,%eax
  8004202390:	48 98                	cltq   
  8004202392:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  8004202396:	bf 17 00 00 00       	mov    $0x17,%edi
  800420239b:	48 b8 7a 1d 20 04 80 	movabs $0x8004201d7a,%rax
  80042023a2:	00 00 00 
  80042023a5:	ff d0                	callq  *%rax
  80042023a7:	c1 e0 0a             	shl    $0xa,%eax
  80042023aa:	48 98                	cltq   
  80042023ac:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}
    
	assert(basemem);
  80042023b0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042023b4:	48 85 c0             	test   %rax,%rax
  80042023b7:	75 35                	jne    80042023ee <i386_detect_memory+0xd7>
  80042023b9:	48 b9 89 72 21 04 80 	movabs $0x8004217289,%rcx
  80042023c0:	00 00 00 
  80042023c3:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042023ca:	00 00 00 
  80042023cd:	be 89 00 00 00       	mov    $0x89,%esi
  80042023d2:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042023d9:	00 00 00 
  80042023dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042023e1:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042023e8:	00 00 00 
  80042023eb:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  80042023ee:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042023f2:	48 c1 e8 0c          	shr    $0xc,%rax
  80042023f6:	48 89 c2             	mov    %rax,%rdx
  80042023f9:	48 b8 30 02 4a 04 80 	movabs $0x80044a0230,%rax
  8004202400:	00 00 00 
  8004202403:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004202406:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420240a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420240e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  8004202412:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202417:	48 b8 7a 1d 20 04 80 	movabs $0x8004201d7a,%rax
  800420241e:	00 00 00 
  8004202421:	ff d0                	callq  *%rax
  8004202423:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202428:	75 2c                	jne    8004202456 <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  800420242a:	bf 34 00 00 00       	mov    $0x34,%edi
  800420242f:	48 b8 7a 1d 20 04 80 	movabs $0x8004201d7a,%rax
  8004202436:	00 00 00 
  8004202439:	ff d0                	callq  *%rax
  800420243b:	c1 e0 10             	shl    $0x10,%eax
  800420243e:	48 98                	cltq   
  8004202440:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  8004202444:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202448:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  800420244e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202452:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004202456:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420245b:	74 1a                	je     8004202477 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  800420245d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202461:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004202468:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  800420246f:	00 00 00 
  8004202472:	48 89 10             	mov    %rdx,(%rax)
  8004202475:	eb 1a                	jmp    8004202491 <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  8004202477:	48 b8 30 02 4a 04 80 	movabs $0x80044a0230,%rax
  800420247e:	00 00 00 
  8004202481:	48 8b 10             	mov    (%rax),%rdx
  8004202484:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  800420248b:	00 00 00 
  800420248e:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202491:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004202498:	00 00 00 
  800420249b:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  800420249e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042024a2:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024a6:	48 c1 e8 0a          	shr    $0xa,%rax
  80042024aa:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  80042024ad:	48 b8 30 02 4a 04 80 	movabs $0x80044a0230,%rax
  80042024b4:	00 00 00 
  80042024b7:	48 8b 00             	mov    (%rax),%rax
  80042024ba:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024be:	48 c1 e8 0a          	shr    $0xa,%rax
  80042024c2:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  80042024c5:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  80042024cc:	00 00 00 
  80042024cf:	48 8b 00             	mov    (%rax),%rax
  80042024d2:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024d6:	48 c1 e8 14          	shr    $0x14,%rax
  80042024da:	49 89 f0             	mov    %rsi,%r8
  80042024dd:	48 89 c6             	mov    %rax,%rsi
  80042024e0:	48 bf b8 72 21 04 80 	movabs $0x80042172b8,%rdi
  80042024e7:	00 00 00 
  80042024ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042024ef:	49 b9 99 8d 20 04 80 	movabs $0x8004208d99,%r9
  80042024f6:	00 00 00 
  80042024f9:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  80042024fc:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  8004202503:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  8004202504:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  800420250b:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  800420250c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202510:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  8004202514:	48 c1 e8 14          	shr    $0x14,%rax
  8004202518:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  800420251b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420251f:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  8004202523:	48 c1 e8 14          	shr    $0x14,%rax
  8004202527:	48 89 c6             	mov    %rax,%rsi
  800420252a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420252e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202532:	49 89 c8             	mov    %rcx,%r8
  8004202535:	48 89 d1             	mov    %rdx,%rcx
  8004202538:	48 89 f2             	mov    %rsi,%rdx
  800420253b:	48 89 c6             	mov    %rax,%rsi
  800420253e:	48 bf 08 73 21 04 80 	movabs $0x8004217308,%rdi
  8004202545:	00 00 00 
  8004202548:	b8 00 00 00 00       	mov    $0x0,%eax
  800420254d:	49 b9 99 8d 20 04 80 	movabs $0x8004208d99,%r9
  8004202554:	00 00 00 
  8004202557:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  800420255a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420255e:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004202562:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  8004202567:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  800420256b:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004202572:	00 00 00 
  8004202575:	48 8b 00             	mov    (%rax),%rax
  8004202578:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800420257c:	76 3a                	jbe    80042025b8 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  800420257e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202582:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  8004202589:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004202590:	00 00 00 
  8004202593:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  8004202596:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420259a:	48 89 c6             	mov    %rax,%rsi
  800420259d:	48 bf 70 73 21 04 80 	movabs $0x8004217370,%rdi
  80042025a4:	00 00 00 
  80042025a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042025ac:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042025b3:	00 00 00 
  80042025b6:	ff d2                	callq  *%rdx
	}
}
  80042025b8:	c9                   	leaveq 
  80042025b9:	c3                   	retq   

00000080042025ba <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  80042025ba:	55                   	push   %rbp
  80042025bb:	48 89 e5             	mov    %rsp,%rbp
  80042025be:	48 83 ec 40          	sub    $0x40,%rsp
  80042025c2:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  80042025c5:	48 b8 48 02 4a 04 80 	movabs $0x80044a0248,%rax
  80042025cc:	00 00 00 
  80042025cf:	48 8b 00             	mov    (%rax),%rax
  80042025d2:	48 85 c0             	test   %rax,%rax
  80042025d5:	75 4e                	jne    8004202625 <boot_alloc+0x6b>
		extern uintptr_t end_debug;
		nextfree = ROUNDUP((char *) end_debug, PGSIZE);
  80042025d7:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  80042025de:	00 
  80042025df:	48 b8 88 17 4a 04 80 	movabs $0x80044a1788,%rax
  80042025e6:	00 00 00 
  80042025e9:	48 8b 10             	mov    (%rax),%rdx
  80042025ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042025f0:	48 01 d0             	add    %rdx,%rax
  80042025f3:	48 83 e8 01          	sub    $0x1,%rax
  80042025f7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042025fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042025ff:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202604:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004202608:	48 89 d0             	mov    %rdx,%rax
  800420260b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420260f:	48 29 c2             	sub    %rax,%rdx
  8004202612:	48 89 d0             	mov    %rdx,%rax
  8004202615:	48 89 c2             	mov    %rax,%rdx
  8004202618:	48 b8 48 02 4a 04 80 	movabs $0x80044a0248,%rax
  800420261f:	00 00 00 
  8004202622:	48 89 10             	mov    %rdx,(%rax)
	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	if (n == 0) 
  8004202625:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004202629:	75 12                	jne    800420263d <boot_alloc+0x83>
		return nextfree;
  800420262b:	48 b8 48 02 4a 04 80 	movabs $0x80044a0248,%rax
  8004202632:	00 00 00 
  8004202635:	48 8b 00             	mov    (%rax),%rax
  8004202638:	e9 cf 00 00 00       	jmpq   800420270c <boot_alloc+0x152>
	result = nextfree;
  800420263d:	48 b8 48 02 4a 04 80 	movabs $0x80044a0248,%rax
  8004202644:	00 00 00 
  8004202647:	48 8b 00             	mov    (%rax),%rax
  800420264a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nextfree = nextfree + n;
  800420264e:	48 b8 48 02 4a 04 80 	movabs $0x80044a0248,%rax
  8004202655:	00 00 00 
  8004202658:	48 8b 10             	mov    (%rax),%rdx
  800420265b:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420265e:	48 01 c2             	add    %rax,%rdx
  8004202661:	48 b8 48 02 4a 04 80 	movabs $0x80044a0248,%rax
  8004202668:	00 00 00 
  800420266b:	48 89 10             	mov    %rdx,(%rax)
	nextfree = ROUNDUP(nextfree, PGSIZE);
  800420266e:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004202675:	00 
  8004202676:	48 b8 48 02 4a 04 80 	movabs $0x80044a0248,%rax
  800420267d:	00 00 00 
  8004202680:	48 8b 00             	mov    (%rax),%rax
  8004202683:	48 89 c2             	mov    %rax,%rdx
  8004202686:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420268a:	48 01 d0             	add    %rdx,%rax
  800420268d:	48 83 e8 01          	sub    $0x1,%rax
  8004202691:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202695:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202699:	ba 00 00 00 00       	mov    $0x0,%edx
  800420269e:	48 f7 75 e0          	divq   -0x20(%rbp)
  80042026a2:	48 89 d0             	mov    %rdx,%rax
  80042026a5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042026a9:	48 29 c2             	sub    %rax,%rdx
  80042026ac:	48 89 d0             	mov    %rdx,%rax
  80042026af:	48 89 c2             	mov    %rax,%rdx
  80042026b2:	48 b8 48 02 4a 04 80 	movabs $0x80044a0248,%rax
  80042026b9:	00 00 00 
  80042026bc:	48 89 10             	mov    %rdx,(%rax)
	//process memory wrap arounds on memory full
	if((uint64_t)nextfree < (uint64_t)end)
  80042026bf:	48 b8 48 02 4a 04 80 	movabs $0x80044a0248,%rax
  80042026c6:	00 00 00 
  80042026c9:	48 8b 00             	mov    (%rax),%rax
  80042026cc:	48 89 c2             	mov    %rax,%rdx
  80042026cf:	48 b8 10 40 52 04 80 	movabs $0x8004524010,%rax
  80042026d6:	00 00 00 
  80042026d9:	48 39 c2             	cmp    %rax,%rdx
  80042026dc:	73 2a                	jae    8004202708 <boot_alloc+0x14e>
	{
		panic("we're out of memory");
  80042026de:	48 ba 99 73 21 04 80 	movabs $0x8004217399,%rdx
  80042026e5:	00 00 00 
  80042026e8:	be e9 00 00 00       	mov    $0xe9,%esi
  80042026ed:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042026f4:	00 00 00 
  80042026f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042026fc:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  8004202703:	00 00 00 
  8004202706:	ff d1                	callq  *%rcx
	}
	return result;
  8004202708:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420270c:	c9                   	leaveq 
  800420270d:	c3                   	retq   

000000800420270e <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  800420270e:	55                   	push   %rbp
  800420270f:	48 89 e5             	mov    %rsp,%rbp
  8004202712:	48 83 ec 60          	sub    $0x60,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  8004202716:	48 b8 17 23 20 04 80 	movabs $0x8004202317,%rax
  800420271d:	00 00 00 
  8004202720:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	//panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  8004202722:	bf 00 10 00 00       	mov    $0x1000,%edi
  8004202727:	48 b8 ba 25 20 04 80 	movabs $0x80042025ba,%rax
  800420272e:	00 00 00 
  8004202731:	ff d0                	callq  *%rax
  8004202733:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  8004202737:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420273b:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202740:	be 00 00 00 00       	mov    $0x0,%esi
  8004202745:	48 89 c7             	mov    %rax,%rdi
  8004202748:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  800420274f:	00 00 00 
  8004202752:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  8004202754:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  800420275b:	00 00 00 
  800420275e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202762:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  8004202765:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202769:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420276d:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202774:	00 00 00 
  8004202777:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420277b:	77 32                	ja     80042027af <x64_vm_init+0xa1>
  800420277d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202781:	48 89 c1             	mov    %rax,%rcx
  8004202784:	48 ba b0 73 21 04 80 	movabs $0x80042173b0,%rdx
  800420278b:	00 00 00 
  800420278e:	be 07 01 00 00       	mov    $0x107,%esi
  8004202793:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420279a:	00 00 00 
  800420279d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042027a2:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042027a9:	00 00 00 
  80042027ac:	41 ff d0             	callq  *%r8
  80042027af:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042027b6:	ff ff ff 
  80042027b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042027bd:	48 01 c2             	add    %rax,%rdx
  80042027c0:	48 b8 a0 17 4a 04 80 	movabs $0x80044a17a0,%rax
  80042027c7:	00 00 00 
  80042027ca:	48 89 10             	mov    %rdx,(%rax)
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:
	pages = (struct PageInfo*)boot_alloc(npages * sizeof(struct PageInfo));
  80042027cd:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  80042027d4:	00 00 00 
  80042027d7:	48 8b 00             	mov    (%rax),%rax
  80042027da:	c1 e0 04             	shl    $0x4,%eax
  80042027dd:	89 c7                	mov    %eax,%edi
  80042027df:	48 b8 ba 25 20 04 80 	movabs $0x80042025ba,%rax
  80042027e6:	00 00 00 
  80042027e9:	ff d0                	callq  *%rax
  80042027eb:	48 ba b8 17 4a 04 80 	movabs $0x80044a17b8,%rdx
  80042027f2:	00 00 00 
  80042027f5:	48 89 02             	mov    %rax,(%rdx)

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	
	envs = (struct Env*)boot_alloc(NENV * sizeof(struct Env));
  80042027f8:	bf 00 80 04 00       	mov    $0x48000,%edi
  80042027fd:	48 b8 ba 25 20 04 80 	movabs $0x80042025ba,%rax
  8004202804:	00 00 00 
  8004202807:	ff d0                	callq  *%rax
  8004202809:	48 ba 50 02 4a 04 80 	movabs $0x80044a0250,%rdx
  8004202810:	00 00 00 
  8004202813:	48 89 02             	mov    %rax,(%rdx)
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  8004202816:	48 b8 82 2b 20 04 80 	movabs $0x8004202b82,%rax
  800420281d:	00 00 00 
  8004202820:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
    boot_map_region(pml4e, UPAGES, npages * sizeof(struct PageInfo), PADDR(pages), PTE_U|PTE_P);
  8004202822:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004202829:	00 00 00 
  800420282c:	48 8b 00             	mov    (%rax),%rax
  800420282f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202833:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420283a:	00 00 00 
  800420283d:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202841:	77 32                	ja     8004202875 <x64_vm_init+0x167>
  8004202843:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202847:	48 89 c1             	mov    %rax,%rcx
  800420284a:	48 ba b0 73 21 04 80 	movabs $0x80042173b0,%rdx
  8004202851:	00 00 00 
  8004202854:	be 26 01 00 00       	mov    $0x126,%esi
  8004202859:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004202860:	00 00 00 
  8004202863:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202868:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420286f:	00 00 00 
  8004202872:	41 ff d0             	callq  *%r8
  8004202875:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420287c:	ff ff ff 
  800420287f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202883:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004202887:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  800420288e:	00 00 00 
  8004202891:	48 8b 00             	mov    (%rax),%rax
  8004202894:	48 c1 e0 04          	shl    $0x4,%rax
  8004202898:	48 89 c2             	mov    %rax,%rdx
  800420289b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420289f:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  80042028a5:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  80042028ac:	00 00 00 
  80042028af:	48 89 c7             	mov    %rax,%rdi
  80042028b2:	48 b8 02 37 20 04 80 	movabs $0x8004203702,%rax
  80042028b9:	00 00 00 
  80042028bc:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	boot_map_region(pml4e, UENVS, NENV * sizeof(struct Env), PADDR(envs), PTE_U|PTE_P);
  80042028be:	48 b8 50 02 4a 04 80 	movabs $0x80044a0250,%rax
  80042028c5:	00 00 00 
  80042028c8:	48 8b 00             	mov    (%rax),%rax
  80042028cb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042028cf:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042028d6:	00 00 00 
  80042028d9:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042028dd:	77 32                	ja     8004202911 <x64_vm_init+0x203>
  80042028df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042028e3:	48 89 c1             	mov    %rax,%rcx
  80042028e6:	48 ba b0 73 21 04 80 	movabs $0x80042173b0,%rdx
  80042028ed:	00 00 00 
  80042028f0:	be 2f 01 00 00       	mov    $0x12f,%esi
  80042028f5:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042028fc:	00 00 00 
  80042028ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202904:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420290b:	00 00 00 
  800420290e:	41 ff d0             	callq  *%r8
  8004202911:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202918:	ff ff ff 
  800420291b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420291f:	48 01 c2             	add    %rax,%rdx
  8004202922:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202926:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  800420292c:	48 89 d1             	mov    %rdx,%rcx
  800420292f:	ba 00 80 04 00       	mov    $0x48000,%edx
  8004202934:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  800420293b:	00 00 00 
  800420293e:	48 89 c7             	mov    %rax,%rdi
  8004202941:	48 b8 02 37 20 04 80 	movabs $0x8004203702,%rax
  8004202948:	00 00 00 
  800420294b:	ff d0                	callq  *%rax
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here: 
	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  800420294d:	48 b8 a3 2a 20 04 80 	movabs $0x8004202aa3,%rax
  8004202954:	00 00 00 
  8004202957:	ff d0                	callq  *%rax
	boot_map_region(pml4e, KERNBASE, npages*PGSIZE, 0, PTE_P|PTE_W);
  8004202959:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004202960:	00 00 00 
  8004202963:	48 8b 00             	mov    (%rax),%rax
  8004202966:	48 c1 e0 0c          	shl    $0xc,%rax
  800420296a:	48 89 c2             	mov    %rax,%rdx
  800420296d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202971:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202977:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420297c:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  8004202983:	00 00 00 
  8004202986:	48 89 c7             	mov    %rax,%rdi
  8004202989:	48 b8 02 37 20 04 80 	movabs $0x8004203702,%rax
  8004202990:	00 00 00 
  8004202993:	ff d0                	callq  *%rax
	//check_boot_pml4e(boot_pml4e);

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE

	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  8004202995:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202999:	48 83 c0 08          	add    $0x8,%rax
  800420299d:	48 8b 00             	mov    (%rax),%rax
  80042029a0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042029a6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042029aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042029ae:	48 c1 e8 0c          	shr    $0xc,%rax
  80042029b2:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  80042029b5:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042029b8:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  80042029bf:	00 00 00 
  80042029c2:	48 8b 00             	mov    (%rax),%rax
  80042029c5:	48 39 c2             	cmp    %rax,%rdx
  80042029c8:	72 32                	jb     80042029fc <x64_vm_init+0x2ee>
  80042029ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042029ce:	48 89 c1             	mov    %rax,%rcx
  80042029d1:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  80042029d8:	00 00 00 
  80042029db:	be 4f 01 00 00       	mov    $0x14f,%esi
  80042029e0:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042029e7:	00 00 00 
  80042029ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042029ef:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042029f6:	00 00 00 
  80042029f9:	41 ff d0             	callq  *%r8
  80042029fc:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202a03:	00 00 00 
  8004202a06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202a0a:	48 01 d0             	add    %rdx,%rax
  8004202a0d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004202a11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202a15:	48 8b 00             	mov    (%rax),%rax
  8004202a18:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202a1e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202a22:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a26:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202a2a:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004202a2d:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202a30:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004202a37:	00 00 00 
  8004202a3a:	48 8b 00             	mov    (%rax),%rax
  8004202a3d:	48 39 c2             	cmp    %rax,%rdx
  8004202a40:	72 32                	jb     8004202a74 <x64_vm_init+0x366>
  8004202a42:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a46:	48 89 c1             	mov    %rax,%rcx
  8004202a49:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004202a50:	00 00 00 
  8004202a53:	be 50 01 00 00       	mov    $0x150,%esi
  8004202a58:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004202a5f:	00 00 00 
  8004202a62:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a67:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004202a6e:	00 00 00 
  8004202a71:	41 ff d0             	callq  *%r8
  8004202a74:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202a7b:	00 00 00 
  8004202a7e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a82:	48 01 d0             	add    %rdx,%rax
  8004202a85:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	lcr3(boot_cr3);
  8004202a89:	48 b8 a0 17 4a 04 80 	movabs $0x80044a17a0,%rax
  8004202a90:	00 00 00 
  8004202a93:	48 8b 00             	mov    (%rax),%rax
  8004202a96:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202a9a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202a9e:	0f 22 d8             	mov    %rax,%cr3

    //check_page_free_list(1);
	//check_page_alloc();
	//page_check();
	//check_page_free_list(0);
}
  8004202aa1:	c9                   	leaveq 
  8004202aa2:	c3                   	retq   

0000008004202aa3 <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  8004202aa3:	55                   	push   %rbp
  8004202aa4:	48 89 e5             	mov    %rsp,%rbp
  8004202aa7:	48 83 ec 20          	sub    $0x20,%rsp
	//             it will fault rather than overwrite another CPU's stack.
	//             Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int i = 0;
  8004202aab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	uint64_t la = KSTACKTOP;
  8004202ab2:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004202ab9:	00 00 00 
  8004202abc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for(; i < NCPU; i++)
  8004202ac0:	e9 b1 00 00 00       	jmpq   8004202b76 <mem_init_mp+0xd3>
	{
		//cprintf("\npercpu_kstacks %x", PADDR(percpu_kstacks[i]));
		boot_map_region(boot_pml4e, la - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
  8004202ac5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202ac8:	48 98                	cltq   
  8004202aca:	48 c1 e0 10          	shl    $0x10,%rax
  8004202ace:	48 89 c2             	mov    %rax,%rdx
  8004202ad1:	48 b8 00 40 4a 04 80 	movabs $0x80044a4000,%rax
  8004202ad8:	00 00 00 
  8004202adb:	48 01 d0             	add    %rdx,%rax
  8004202ade:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202ae2:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202ae9:	00 00 00 
  8004202aec:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202af0:	77 32                	ja     8004202b24 <mem_init_mp+0x81>
  8004202af2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202af6:	48 89 c1             	mov    %rax,%rcx
  8004202af9:	48 ba b0 73 21 04 80 	movabs $0x80042173b0,%rdx
  8004202b00:	00 00 00 
  8004202b03:	be 75 01 00 00       	mov    $0x175,%esi
  8004202b08:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004202b0f:	00 00 00 
  8004202b12:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b17:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004202b1e:	00 00 00 
  8004202b21:	41 ff d0             	callq  *%r8
  8004202b24:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202b2b:	ff ff ff 
  8004202b2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202b32:	48 01 c2             	add    %rax,%rdx
  8004202b35:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202b39:	48 8d b0 00 00 ff ff 	lea    -0x10000(%rax),%rsi
  8004202b40:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004202b47:	00 00 00 
  8004202b4a:	48 8b 00             	mov    (%rax),%rax
  8004202b4d:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202b53:	48 89 d1             	mov    %rdx,%rcx
  8004202b56:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202b5b:	48 89 c7             	mov    %rax,%rdi
  8004202b5e:	48 b8 02 37 20 04 80 	movabs $0x8004203702,%rax
  8004202b65:	00 00 00 
  8004202b68:	ff d0                	callq  *%rax
		la -= (KSTKSIZE + KSTKGAP);
  8004202b6a:	48 81 6d f0 00 80 01 	subq   $0x18000,-0x10(%rbp)
  8004202b71:	00 
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int i = 0;
	uint64_t la = KSTACKTOP;
	for(; i < NCPU; i++)
  8004202b72:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004202b76:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
  8004202b7a:	0f 8e 45 ff ff ff    	jle    8004202ac5 <mem_init_mp+0x22>
	{
		//cprintf("\npercpu_kstacks %x", PADDR(percpu_kstacks[i]));
		boot_map_region(boot_pml4e, la - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
		la -= (KSTKSIZE + KSTKGAP);
	}
}
  8004202b80:	c9                   	leaveq 
  8004202b81:	c3                   	retq   

0000008004202b82 <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004202b82:	55                   	push   %rbp
  8004202b83:	48 89 e5             	mov    %rsp,%rbp
  8004202b86:	48 83 ec 70          	sub    $0x70,%rsp
	// NB: Make sure you preserve the direction in which your page_free_list 
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

	size_t i, holeS, kernE, bootPTS, bootPTE;
	struct PageInfo* last = NULL;
  8004202b8a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004202b91:	00 
	for (i = 0; i < npages; i++) {
  8004202b92:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202b99:	00 
  8004202b9a:	e9 ab 00 00 00       	jmpq   8004202c4a <page_init+0xc8>
		pages[i].pp_ref = 0;
  8004202b9f:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004202ba6:	00 00 00 
  8004202ba9:	48 8b 00             	mov    (%rax),%rax
  8004202bac:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202bb0:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202bb4:	48 01 d0             	add    %rdx,%rax
  8004202bb7:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
		pages[i].pp_link = NULL;
  8004202bbd:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004202bc4:	00 00 00 
  8004202bc7:	48 8b 00             	mov    (%rax),%rax
  8004202bca:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202bce:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202bd2:	48 01 d0             	add    %rdx,%rax
  8004202bd5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if(last)
  8004202bdc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004202be1:	74 21                	je     8004202c04 <page_init+0x82>
			last->pp_link = &pages[i];
  8004202be3:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004202bea:	00 00 00 
  8004202bed:	48 8b 00             	mov    (%rax),%rax
  8004202bf0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202bf4:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202bf8:	48 01 c2             	add    %rax,%rdx
  8004202bfb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202bff:	48 89 10             	mov    %rdx,(%rax)
  8004202c02:	eb 25                	jmp    8004202c29 <page_init+0xa7>
		else
			page_free_list = &pages[i];
  8004202c04:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004202c0b:	00 00 00 
  8004202c0e:	48 8b 00             	mov    (%rax),%rax
  8004202c11:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c15:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c19:	48 01 c2             	add    %rax,%rdx
  8004202c1c:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004202c23:	00 00 00 
  8004202c26:	48 89 10             	mov    %rdx,(%rax)
		last = &pages[i];
  8004202c29:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004202c30:	00 00 00 
  8004202c33:	48 8b 00             	mov    (%rax),%rax
  8004202c36:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c3a:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c3e:	48 01 d0             	add    %rdx,%rax
  8004202c41:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

	size_t i, holeS, kernE, bootPTS, bootPTE;
	struct PageInfo* last = NULL;
	for (i = 0; i < npages; i++) {
  8004202c45:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202c4a:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004202c51:	00 00 00 
  8004202c54:	48 8b 00             	mov    (%rax),%rax
  8004202c57:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202c5b:	0f 82 3e ff ff ff    	jb     8004202b9f <page_init+0x1d>
		else
			page_free_list = &pages[i];
		last = &pages[i];
	}
	//remove page 0 from page list
	page_free_list = page_free_list->pp_link;
  8004202c61:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004202c68:	00 00 00 
  8004202c6b:	48 8b 00             	mov    (%rax),%rax
  8004202c6e:	48 8b 10             	mov    (%rax),%rdx
  8004202c71:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004202c78:	00 00 00 
  8004202c7b:	48 89 10             	mov    %rdx,(%rax)

	//remove entries of holes till current kernel available memory pointer
	holeS = IOPHYSMEM/PGSIZE;
  8004202c7e:	48 c7 45 e8 a0 00 00 	movq   $0xa0,-0x18(%rbp)
  8004202c85:	00 
	kernE = PADDR(boot_alloc(0))/PGSIZE;
  8004202c86:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202c8b:	48 b8 ba 25 20 04 80 	movabs $0x80042025ba,%rax
  8004202c92:	00 00 00 
  8004202c95:	ff d0                	callq  *%rax
  8004202c97:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202c9b:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202ca2:	00 00 00 
  8004202ca5:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202ca9:	77 32                	ja     8004202cdd <page_init+0x15b>
  8004202cab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202caf:	48 89 c1             	mov    %rax,%rcx
  8004202cb2:	48 ba b0 73 21 04 80 	movabs $0x80042173b0,%rdx
  8004202cb9:	00 00 00 
  8004202cbc:	be b2 01 00 00       	mov    $0x1b2,%esi
  8004202cc1:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004202cc8:	00 00 00 
  8004202ccb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202cd0:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004202cd7:	00 00 00 
  8004202cda:	41 ff d0             	callq  *%r8
  8004202cdd:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202ce4:	ff ff ff 
  8004202ce7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202ceb:	48 01 d0             	add    %rdx,%rax
  8004202cee:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202cf2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	pages[holeS - 1].pp_link = &pages[kernE];
  8004202cf6:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004202cfd:	00 00 00 
  8004202d00:	48 8b 00             	mov    (%rax),%rax
  8004202d03:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202d07:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202d0b:	48 83 ea 10          	sub    $0x10,%rdx
  8004202d0f:	48 01 c2             	add    %rax,%rdx
  8004202d12:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004202d19:	00 00 00 
  8004202d1c:	48 8b 00             	mov    (%rax),%rax
  8004202d1f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004202d23:	48 c1 e1 04          	shl    $0x4,%rcx
  8004202d27:	48 01 c8             	add    %rcx,%rax
  8004202d2a:	48 89 02             	mov    %rax,(%rdx)

	bootPTS = PADDR(BOOT_PAGE_TABLE_START)/PGSIZE;	
  8004202d2d:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202d34:	00 00 00 
  8004202d37:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202d3b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202d3f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202d43:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004202d46:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004202d49:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004202d50:	00 00 00 
  8004202d53:	48 8b 00             	mov    (%rax),%rax
  8004202d56:	48 39 c2             	cmp    %rax,%rdx
  8004202d59:	72 32                	jb     8004202d8d <page_init+0x20b>
  8004202d5b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202d5f:	48 89 c1             	mov    %rax,%rcx
  8004202d62:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004202d69:	00 00 00 
  8004202d6c:	be b5 01 00 00       	mov    $0x1b5,%esi
  8004202d71:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004202d78:	00 00 00 
  8004202d7b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202d80:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004202d87:	00 00 00 
  8004202d8a:	41 ff d0             	callq  *%r8
  8004202d8d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202d94:	00 00 00 
  8004202d97:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202d9b:	48 01 d0             	add    %rdx,%rax
  8004202d9e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202da2:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202da9:	00 00 00 
  8004202dac:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004202db0:	77 32                	ja     8004202de4 <page_init+0x262>
  8004202db2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202db6:	48 89 c1             	mov    %rax,%rcx
  8004202db9:	48 ba b0 73 21 04 80 	movabs $0x80042173b0,%rdx
  8004202dc0:	00 00 00 
  8004202dc3:	be b5 01 00 00       	mov    $0x1b5,%esi
  8004202dc8:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004202dcf:	00 00 00 
  8004202dd2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202dd7:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004202dde:	00 00 00 
  8004202de1:	41 ff d0             	callq  *%r8
  8004202de4:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202deb:	ff ff ff 
  8004202dee:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202df2:	48 01 d0             	add    %rdx,%rax
  8004202df5:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202df9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	bootPTE = PADDR(BOOT_PAGE_TABLE_END - 1)/PGSIZE;
  8004202dfd:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202e04:	00 00 00 
  8004202e07:	48 05 00 50 00 00    	add    $0x5000,%rax
  8004202e0d:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004202e11:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202e15:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202e19:	89 45 ac             	mov    %eax,-0x54(%rbp)
  8004202e1c:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004202e1f:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004202e26:	00 00 00 
  8004202e29:	48 8b 00             	mov    (%rax),%rax
  8004202e2c:	48 39 c2             	cmp    %rax,%rdx
  8004202e2f:	72 32                	jb     8004202e63 <page_init+0x2e1>
  8004202e31:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202e35:	48 89 c1             	mov    %rax,%rcx
  8004202e38:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004202e3f:	00 00 00 
  8004202e42:	be b6 01 00 00       	mov    $0x1b6,%esi
  8004202e47:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004202e4e:	00 00 00 
  8004202e51:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e56:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004202e5d:	00 00 00 
  8004202e60:	41 ff d0             	callq  *%r8
  8004202e63:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202e6a:	00 00 00 
  8004202e6d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202e71:	48 01 d0             	add    %rdx,%rax
  8004202e74:	48 83 e8 01          	sub    $0x1,%rax
  8004202e78:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004202e7c:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202e83:	00 00 00 
  8004202e86:	48 39 45 a0          	cmp    %rax,-0x60(%rbp)
  8004202e8a:	77 32                	ja     8004202ebe <page_init+0x33c>
  8004202e8c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202e90:	48 89 c1             	mov    %rax,%rcx
  8004202e93:	48 ba b0 73 21 04 80 	movabs $0x80042173b0,%rdx
  8004202e9a:	00 00 00 
  8004202e9d:	be b6 01 00 00       	mov    $0x1b6,%esi
  8004202ea2:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004202ea9:	00 00 00 
  8004202eac:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202eb1:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004202eb8:	00 00 00 
  8004202ebb:	41 ff d0             	callq  *%r8
  8004202ebe:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202ec5:	ff ff ff 
  8004202ec8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202ecc:	48 01 d0             	add    %rdx,%rax
  8004202ecf:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202ed3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pages[bootPTS - 1].pp_link = &pages[bootPTE + 1];
  8004202ed7:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004202ede:	00 00 00 
  8004202ee1:	48 8b 00             	mov    (%rax),%rax
  8004202ee4:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004202ee8:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202eec:	48 83 ea 10          	sub    $0x10,%rdx
  8004202ef0:	48 01 c2             	add    %rax,%rdx
  8004202ef3:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004202efa:	00 00 00 
  8004202efd:	48 8b 00             	mov    (%rax),%rax
  8004202f00:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  8004202f04:	48 83 c1 01          	add    $0x1,%rcx
  8004202f08:	48 c1 e1 04          	shl    $0x4,%rcx
  8004202f0c:	48 01 c8             	add    %rcx,%rax
  8004202f0f:	48 89 02             	mov    %rax,(%rdx)

	//marking page at MPENTRY_PADDR as being used 
	pages[MPENTRY_PADDR / PGSIZE - 1].pp_link = &pages[MPENTRY_PADDR / PGSIZE + 1];
  8004202f12:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004202f19:	00 00 00 
  8004202f1c:	48 8b 00             	mov    (%rax),%rax
  8004202f1f:	48 8d 50 60          	lea    0x60(%rax),%rdx
  8004202f23:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004202f2a:	00 00 00 
  8004202f2d:	48 8b 00             	mov    (%rax),%rax
  8004202f30:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  8004202f34:	48 89 02             	mov    %rax,(%rdx)
}
  8004202f37:	c9                   	leaveq 
  8004202f38:	c3                   	retq   

0000008004202f39 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202f39:	55                   	push   %rbp
  8004202f3a:	48 89 e5             	mov    %rsp,%rbp
  8004202f3d:	48 83 ec 20          	sub    $0x20,%rsp
  8004202f41:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in
	struct PageInfo * page = NULL;
  8004202f44:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202f4b:	00 
	if(page_free_list)
  8004202f4c:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004202f53:	00 00 00 
  8004202f56:	48 8b 00             	mov    (%rax),%rax
  8004202f59:	48 85 c0             	test   %rax,%rax
  8004202f5c:	74 6f                	je     8004202fcd <page_alloc+0x94>
	{
		page = page_free_list;
  8004202f5e:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004202f65:	00 00 00 
  8004202f68:	48 8b 00             	mov    (%rax),%rax
  8004202f6b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		page_free_list = page_free_list->pp_link;
  8004202f6f:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004202f76:	00 00 00 
  8004202f79:	48 8b 00             	mov    (%rax),%rax
  8004202f7c:	48 8b 10             	mov    (%rax),%rdx
  8004202f7f:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004202f86:	00 00 00 
  8004202f89:	48 89 10             	mov    %rdx,(%rax)
		page->pp_link = NULL;
  8004202f8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f90:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
//		cprintf("Umesh: physical addresses =[%x]\n",page);
		if(alloc_flags & ALLOC_ZERO)
  8004202f97:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202f9a:	83 e0 01             	and    $0x1,%eax
  8004202f9d:	85 c0                	test   %eax,%eax
  8004202f9f:	74 2c                	je     8004202fcd <page_alloc+0x94>
		{
			memset(page2kva(page), '\0', PGSIZE);
  8004202fa1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fa5:	48 89 c7             	mov    %rax,%rdi
  8004202fa8:	48 b8 91 1c 20 04 80 	movabs $0x8004201c91,%rax
  8004202faf:	00 00 00 
  8004202fb2:	ff d0                	callq  *%rax
  8004202fb4:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202fb9:	be 00 00 00 00       	mov    $0x0,%esi
  8004202fbe:	48 89 c7             	mov    %rax,%rdi
  8004202fc1:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004202fc8:	00 00 00 
  8004202fcb:	ff d0                	callq  *%rax
		}
	}
	else{
		//cprintf("page alloc failed\n");
	}
	return page;
  8004202fcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004202fd1:	c9                   	leaveq 
  8004202fd2:	c3                   	retq   

0000008004202fd3 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004202fd3:	55                   	push   %rbp
  8004202fd4:	48 89 e5             	mov    %rsp,%rbp
  8004202fd7:	48 83 ec 10          	sub    $0x10,%rsp
  8004202fdb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004202fdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fe3:	ba 10 00 00 00       	mov    $0x10,%edx
  8004202fe8:	be 00 00 00 00       	mov    $0x0,%esi
  8004202fed:	48 89 c7             	mov    %rax,%rdi
  8004202ff0:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004202ff7:	00 00 00 
  8004202ffa:	ff d0                	callq  *%rax
}
  8004202ffc:	c9                   	leaveq 
  8004202ffd:	c3                   	retq   

0000008004202ffe <insertAtBegining>:

void insertAtBegining(struct PageInfo ** list, struct PageInfo * node)
{
  8004202ffe:	55                   	push   %rbp
  8004202fff:	48 89 e5             	mov    %rsp,%rbp
  8004203002:	48 83 ec 10          	sub    $0x10,%rsp
  8004203006:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420300a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	if(*list == NULL)
  800420300e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203012:	48 8b 00             	mov    (%rax),%rax
  8004203015:	48 85 c0             	test   %rax,%rax
  8004203018:	75 0d                	jne    8004203027 <insertAtBegining+0x29>
	{
		*list = node;
  800420301a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420301e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203022:	48 89 10             	mov    %rdx,(%rax)
  8004203025:	eb 2c                	jmp    8004203053 <insertAtBegining+0x55>
	}
	else if(*list != NULL && node != NULL)
  8004203027:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420302b:	48 8b 00             	mov    (%rax),%rax
  800420302e:	48 85 c0             	test   %rax,%rax
  8004203031:	74 20                	je     8004203053 <insertAtBegining+0x55>
  8004203033:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203038:	74 19                	je     8004203053 <insertAtBegining+0x55>
	{
		node->pp_link = *list;
  800420303a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420303e:	48 8b 10             	mov    (%rax),%rdx
  8004203041:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203045:	48 89 10             	mov    %rdx,(%rax)
		*list = node;
  8004203048:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420304c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203050:	48 89 10             	mov    %rdx,(%rax)
	}
}
  8004203053:	c9                   	leaveq 
  8004203054:	c3                   	retq   

0000008004203055 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004203055:	55                   	push   %rbp
  8004203056:	48 89 e5             	mov    %rsp,%rbp
  8004203059:	48 83 ec 10          	sub    $0x10,%rsp
  800420305d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if(pp->pp_ref != 0)
  8004203061:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203065:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203069:	66 85 c0             	test   %ax,%ax
  800420306c:	74 2a                	je     8004203098 <page_free+0x43>
	{	
		panic("pp->pp_ref is nonzero");
  800420306e:	48 ba d4 73 21 04 80 	movabs $0x80042173d4,%rdx
  8004203075:	00 00 00 
  8004203078:	be 03 02 00 00       	mov    $0x203,%esi
  800420307d:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004203084:	00 00 00 
  8004203087:	b8 00 00 00 00       	mov    $0x0,%eax
  800420308c:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  8004203093:	00 00 00 
  8004203096:	ff d1                	callq  *%rcx
	}
	else if(pp->pp_link)
  8004203098:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420309c:	48 8b 00             	mov    (%rax),%rax
  800420309f:	48 85 c0             	test   %rax,%rax
  80042030a2:	74 2a                	je     80042030ce <page_free+0x79>
	{
		panic("pp->pp_link is not NULL");
  80042030a4:	48 ba ea 73 21 04 80 	movabs $0x80042173ea,%rdx
  80042030ab:	00 00 00 
  80042030ae:	be 07 02 00 00       	mov    $0x207,%esi
  80042030b3:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042030ba:	00 00 00 
  80042030bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042030c2:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  80042030c9:	00 00 00 
  80042030cc:	ff d1                	callq  *%rcx
	}
	else
	{
		//insert node to be freed at the begining of free node list
		insertAtBegining(&page_free_list, pp);
  80042030ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030d2:	48 89 c6             	mov    %rax,%rsi
  80042030d5:	48 bf 38 02 4a 04 80 	movabs $0x80044a0238,%rdi
  80042030dc:	00 00 00 
  80042030df:	48 b8 fe 2f 20 04 80 	movabs $0x8004202ffe,%rax
  80042030e6:	00 00 00 
  80042030e9:	ff d0                	callq  *%rax
	}
}
  80042030eb:	c9                   	leaveq 
  80042030ec:	c3                   	retq   

00000080042030ed <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  80042030ed:	55                   	push   %rbp
  80042030ee:	48 89 e5             	mov    %rsp,%rbp
  80042030f1:	48 83 ec 10          	sub    $0x10,%rsp
  80042030f5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  80042030f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030fd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203101:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004203104:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203108:	66 89 50 08          	mov    %dx,0x8(%rax)
  800420310c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203110:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203114:	66 85 c0             	test   %ax,%ax
  8004203117:	75 13                	jne    800420312c <page_decref+0x3f>
		page_free(pp);
  8004203119:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420311d:	48 89 c7             	mov    %rax,%rdi
  8004203120:	48 b8 55 30 20 04 80 	movabs $0x8004203055,%rax
  8004203127:	00 00 00 
  800420312a:	ff d0                	callq  *%rax
}
  800420312c:	c9                   	leaveq 
  800420312d:	c3                   	retq   

000000800420312e <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  800420312e:	55                   	push   %rbp
  800420312f:	48 89 e5             	mov    %rsp,%rbp
  8004203132:	53                   	push   %rbx
  8004203133:	48 83 ec 58          	sub    $0x58,%rsp
  8004203137:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800420313b:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420313f:	89 55 ac             	mov    %edx,-0x54(%rbp)
	//Need to return
	pte_t * pml4eIndexPtr = NULL;
  8004203142:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004203149:	00 
	int pml4eIndex;
	int pdpeIndex;
	uint64_t temp;
	struct PageInfo * page = NULL;
  800420314a:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203151:	00 
	if(pml4e == NULL)
  8004203152:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004203157:	75 0a                	jne    8004203163 <pml4e_walk+0x35>
	{
		return NULL;
  8004203159:	b8 00 00 00 00       	mov    $0x0,%eax
  800420315e:	e9 c5 01 00 00       	jmpq   8004203328 <pml4e_walk+0x1fa>
	}
	pml4eIndex = PML4(va);
  8004203163:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203167:	48 c1 e8 27          	shr    $0x27,%rax
  800420316b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203170:	89 45 dc             	mov    %eax,-0x24(%rbp)

	if((uint64_t*)pml4e[pml4eIndex] == NULL && create == false)
  8004203173:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203176:	48 98                	cltq   
  8004203178:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420317f:	00 
  8004203180:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203184:	48 01 d0             	add    %rdx,%rax
  8004203187:	48 8b 00             	mov    (%rax),%rax
  800420318a:	48 85 c0             	test   %rax,%rax
  800420318d:	75 10                	jne    800420319f <pml4e_walk+0x71>
  800420318f:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004203193:	75 0a                	jne    800420319f <pml4e_walk+0x71>
	{
		return NULL;
  8004203195:	b8 00 00 00 00       	mov    $0x0,%eax
  800420319a:	e9 89 01 00 00       	jmpq   8004203328 <pml4e_walk+0x1fa>
	}
	else if((uint64_t*)pml4e[pml4eIndex] == NULL && create == true)
  800420319f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042031a2:	48 98                	cltq   
  80042031a4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042031ab:	00 
  80042031ac:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042031b0:	48 01 d0             	add    %rdx,%rax
  80042031b3:	48 8b 00             	mov    (%rax),%rax
  80042031b6:	48 85 c0             	test   %rax,%rax
  80042031b9:	75 7a                	jne    8004203235 <pml4e_walk+0x107>
  80042031bb:	83 7d ac 01          	cmpl   $0x1,-0x54(%rbp)
  80042031bf:	75 74                	jne    8004203235 <pml4e_walk+0x107>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  80042031c1:	c7 45 d8 07 00 00 00 	movl   $0x7,-0x28(%rbp)
		page = page_alloc(ALLOC_ZERO);
  80042031c8:	bf 01 00 00 00       	mov    $0x1,%edi
  80042031cd:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  80042031d4:	00 00 00 
  80042031d7:	ff d0                	callq  *%rax
  80042031d9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(!page)
  80042031dd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042031e2:	75 0a                	jne    80042031ee <pml4e_walk+0xc0>
			return NULL;
  80042031e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031e9:	e9 3a 01 00 00       	jmpq   8004203328 <pml4e_walk+0x1fa>
		page->pp_ref++;
  80042031ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042031f2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042031f6:	8d 50 01             	lea    0x1(%rax),%edx
  80042031f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042031fd:	66 89 50 08          	mov    %dx,0x8(%rax)
		//cprintf("pml4eIndex = [%d], pml4e[pml4eIndex] = %d", pml4eIndex, pml4e[pml4eIndex]);
		pml4e[pml4eIndex] = page2pa(page) | perm;
  8004203201:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203204:	48 98                	cltq   
  8004203206:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420320d:	00 
  800420320e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203212:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203216:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420321a:	48 89 c7             	mov    %rax,%rdi
  800420321d:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004203224:	00 00 00 
  8004203227:	ff d0                	callq  *%rax
  8004203229:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420322c:	48 63 d2             	movslq %edx,%rdx
  800420322f:	48 09 d0             	or     %rdx,%rax
  8004203232:	48 89 03             	mov    %rax,(%rbx)
		//cprintf("pml4eIndex = [%d], pml4e[pml4eIndex] = %d", pml4eIndex, pml4e[pml4eIndex]);
	}
	//pml4e entry with last 12 bits permissions
	temp = pml4e[pml4eIndex];
  8004203235:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203238:	48 98                	cltq   
  800420323a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203241:	00 
  8004203242:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203246:	48 01 d0             	add    %rdx,%rax
  8004203249:	48 8b 00             	mov    (%rax),%rax
  800420324c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  8004203250:	48 81 65 d0 00 f0 ff 	andq   $0xfffffffffffff000,-0x30(%rbp)
  8004203257:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  8004203258:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420325c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004203260:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203264:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203268:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  800420326b:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420326e:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004203275:	00 00 00 
  8004203278:	48 8b 00             	mov    (%rax),%rax
  800420327b:	48 39 c2             	cmp    %rax,%rdx
  800420327e:	72 32                	jb     80042032b2 <pml4e_walk+0x184>
  8004203280:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203284:	48 89 c1             	mov    %rax,%rcx
  8004203287:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  800420328e:	00 00 00 
  8004203291:	be 57 02 00 00       	mov    $0x257,%esi
  8004203296:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420329d:	00 00 00 
  80042032a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032a5:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042032ac:	00 00 00 
  80042032af:	41 ff d0             	callq  *%r8
  80042032b2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042032b9:	00 00 00 
  80042032bc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042032c0:	48 01 d0             	add    %rdx,%rax
  80042032c3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//increase pgtable index to get index pointer in page table
	pml4eIndexPtr = (pte_t *)pdpe_walk((pte_t *)temp, va, create); 
  80042032c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042032cb:	8b 55 ac             	mov    -0x54(%rbp),%edx
  80042032ce:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042032d2:	48 89 ce             	mov    %rcx,%rsi
  80042032d5:	48 89 c7             	mov    %rax,%rdi
  80042032d8:	48 b8 2f 33 20 04 80 	movabs $0x800420332f,%rax
  80042032df:	00 00 00 
  80042032e2:	ff d0                	callq  *%rax
  80042032e4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	//Null check
	if(pml4eIndexPtr == NULL && page != NULL)
  80042032e8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042032ed:	75 35                	jne    8004203324 <pml4e_walk+0x1f6>
  80042032ef:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042032f4:	74 2e                	je     8004203324 <pml4e_walk+0x1f6>
	{
		page_decref(page);
  80042032f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042032fa:	48 89 c7             	mov    %rax,%rdi
  80042032fd:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  8004203304:	00 00 00 
  8004203307:	ff d0                	callq  *%rax
        pml4e[pml4eIndex] = 0;
  8004203309:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420330c:	48 98                	cltq   
  800420330e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203315:	00 
  8004203316:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420331a:	48 01 d0             	add    %rdx,%rax
  800420331d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
	return pml4eIndexPtr;
  8004203324:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004203328:	48 83 c4 58          	add    $0x58,%rsp
  800420332c:	5b                   	pop    %rbx
  800420332d:	5d                   	pop    %rbp
  800420332e:	c3                   	retq   

000000800420332f <pdpe_walk>:
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create)
{
  800420332f:	55                   	push   %rbp
  8004203330:	48 89 e5             	mov    %rsp,%rbp
  8004203333:	53                   	push   %rbx
  8004203334:	48 83 ec 68          	sub    $0x68,%rsp
  8004203338:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420333c:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004203340:	89 55 9c             	mov    %edx,-0x64(%rbp)
	//Need to return
	pte_t * pdpeIndexPtr = NULL;
  8004203343:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420334a:	00 
	int pdpeIndex = 0;
  800420334b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
	int pgdirIndex = 0;
  8004203352:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
	uint64_t temp;
	struct PageInfo * page = NULL;
  8004203359:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004203360:	00 
	if(pdpe == NULL)
  8004203361:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004203366:	75 0a                	jne    8004203372 <pdpe_walk+0x43>
	{
		return NULL;
  8004203368:	b8 00 00 00 00       	mov    $0x0,%eax
  800420336d:	e9 c5 01 00 00       	jmpq   8004203537 <pdpe_walk+0x208>
	}
	pdpeIndex = PDPE(va);
  8004203372:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203376:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420337a:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420337f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if(!(uint64_t*)pdpe[pdpeIndex] && create == false)
  8004203382:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203385:	48 98                	cltq   
  8004203387:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420338e:	00 
  800420338f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203393:	48 01 d0             	add    %rdx,%rax
  8004203396:	48 8b 00             	mov    (%rax),%rax
  8004203399:	48 85 c0             	test   %rax,%rax
  800420339c:	75 10                	jne    80042033ae <pdpe_walk+0x7f>
  800420339e:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042033a2:	75 0a                	jne    80042033ae <pdpe_walk+0x7f>
	{
		return NULL;
  80042033a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042033a9:	e9 89 01 00 00       	jmpq   8004203537 <pdpe_walk+0x208>
	}
	else if((uint64_t*)pdpe[pdpeIndex] == NULL && create == true)
  80042033ae:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042033b1:	48 98                	cltq   
  80042033b3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042033ba:	00 
  80042033bb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042033bf:	48 01 d0             	add    %rdx,%rax
  80042033c2:	48 8b 00             	mov    (%rax),%rax
  80042033c5:	48 85 c0             	test   %rax,%rax
  80042033c8:	75 7a                	jne    8004203444 <pdpe_walk+0x115>
  80042033ca:	83 7d 9c 01          	cmpl   $0x1,-0x64(%rbp)
  80042033ce:	75 74                	jne    8004203444 <pdpe_walk+0x115>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  80042033d0:	c7 45 d4 07 00 00 00 	movl   $0x7,-0x2c(%rbp)
		struct PageInfo * page = page_alloc(ALLOC_ZERO);
  80042033d7:	bf 01 00 00 00       	mov    $0x1,%edi
  80042033dc:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  80042033e3:	00 00 00 
  80042033e6:	ff d0                	callq  *%rax
  80042033e8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		if(!page)
  80042033ec:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042033f1:	75 0a                	jne    80042033fd <pdpe_walk+0xce>
			return NULL;
  80042033f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042033f8:	e9 3a 01 00 00       	jmpq   8004203537 <pdpe_walk+0x208>
		page->pp_ref++;
  80042033fd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203401:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203405:	8d 50 01             	lea    0x1(%rax),%edx
  8004203408:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420340c:	66 89 50 08          	mov    %dx,0x8(%rax)
		pdpe[pdpeIndex] = page2pa(page) | perm;
  8004203410:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203413:	48 98                	cltq   
  8004203415:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420341c:	00 
  800420341d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203421:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203425:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203429:	48 89 c7             	mov    %rax,%rdi
  800420342c:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004203433:	00 00 00 
  8004203436:	ff d0                	callq  *%rax
  8004203438:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420343b:	48 63 d2             	movslq %edx,%rdx
  800420343e:	48 09 d0             	or     %rdx,%rax
  8004203441:	48 89 03             	mov    %rax,(%rbx)
	}
	//pdpe entry with last 12 bits permissions
	temp = pdpe[pdpeIndex];
  8004203444:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203447:	48 98                	cltq   
  8004203449:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203450:	00 
  8004203451:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203455:	48 01 d0             	add    %rdx,%rax
  8004203458:	48 8b 00             	mov    (%rax),%rax
  800420345b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  800420345f:	48 81 65 c0 00 f0 ff 	andq   $0xfffffffffffff000,-0x40(%rbp)
  8004203466:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  8004203467:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420346b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  800420346f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203473:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203477:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  800420347a:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  800420347d:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004203484:	00 00 00 
  8004203487:	48 8b 00             	mov    (%rax),%rax
  800420348a:	48 39 c2             	cmp    %rax,%rdx
  800420348d:	72 32                	jb     80042034c1 <pdpe_walk+0x192>
  800420348f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203493:	48 89 c1             	mov    %rax,%rcx
  8004203496:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  800420349d:	00 00 00 
  80042034a0:	be 88 02 00 00       	mov    $0x288,%esi
  80042034a5:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042034ac:	00 00 00 
  80042034af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034b4:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042034bb:	00 00 00 
  80042034be:	41 ff d0             	callq  *%r8
  80042034c1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042034c8:	00 00 00 
  80042034cb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042034cf:	48 01 d0             	add    %rdx,%rax
  80042034d2:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	//increase pgtable index to get index pointer in page table
	pdpeIndexPtr = (pte_t *)pgdir_walk((pte_t *)temp, va, create);
  80042034d6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042034da:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042034dd:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042034e1:	48 89 ce             	mov    %rcx,%rsi
  80042034e4:	48 89 c7             	mov    %rax,%rdi
  80042034e7:	48 b8 3e 35 20 04 80 	movabs $0x800420353e,%rax
  80042034ee:	00 00 00 
  80042034f1:	ff d0                	callq  *%rax
  80042034f3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//Null check
	if(pdpeIndexPtr == NULL && page != NULL)
  80042034f7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042034fc:	75 35                	jne    8004203533 <pdpe_walk+0x204>
  80042034fe:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203503:	74 2e                	je     8004203533 <pdpe_walk+0x204>
	{
        page_decref(page);
  8004203505:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203509:	48 89 c7             	mov    %rax,%rdi
  800420350c:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  8004203513:	00 00 00 
  8004203516:	ff d0                	callq  *%rax
        pdpe[pdpeIndex] = 0;
  8004203518:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420351b:	48 98                	cltq   
  800420351d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203524:	00 
  8004203525:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203529:	48 01 d0             	add    %rdx,%rax
  800420352c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
	
	//cprintf("Address is %x  value is %x \n", (uint64_t)KADDR(pdpe[pdpeIndex]), (uint64_t)KADDR(PTE_ADDR(pgdir[dirIndex])));
	return pdpeIndexPtr;
  8004203533:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004203537:	48 83 c4 68          	add    $0x68,%rsp
  800420353b:	5b                   	pop    %rbx
  800420353c:	5d                   	pop    %rbp
  800420353d:	c3                   	retq   

000000800420353e <pgdir_walk>:
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  800420353e:	55                   	push   %rbp
  800420353f:	48 89 e5             	mov    %rsp,%rbp
  8004203542:	53                   	push   %rbx
  8004203543:	48 83 ec 68          	sub    $0x68,%rsp
  8004203547:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420354b:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420354f:	89 55 9c             	mov    %edx,-0x64(%rbp)
	// Fill this function in
	//Need to return
	pte_t * pgTblIndexPtr = NULL;
  8004203552:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203559:	00 
	int dirIndex;
	int pgTblIndex;
	uint64_t temp;
	if(pgdir == NULL)
  800420355a:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420355f:	75 0a                	jne    800420356b <pgdir_walk+0x2d>
	{
		return NULL;
  8004203561:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203566:	e9 90 01 00 00       	jmpq   80042036fb <pgdir_walk+0x1bd>
	}
	dirIndex = PDX(va);
  800420356b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420356f:	48 c1 e8 15          	shr    $0x15,%rax
  8004203573:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203578:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	pgTblIndex = PTX(va);
  800420357b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420357f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203583:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203588:	89 45 e0             	mov    %eax,-0x20(%rbp)
	if((uint64_t*)pgdir[dirIndex] == NULL && create == false)
  800420358b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420358e:	48 98                	cltq   
  8004203590:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203597:	00 
  8004203598:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420359c:	48 01 d0             	add    %rdx,%rax
  800420359f:	48 8b 00             	mov    (%rax),%rax
  80042035a2:	48 85 c0             	test   %rax,%rax
  80042035a5:	75 10                	jne    80042035b7 <pgdir_walk+0x79>
  80042035a7:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042035ab:	75 0a                	jne    80042035b7 <pgdir_walk+0x79>
	{
		return NULL;
  80042035ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042035b2:	e9 44 01 00 00       	jmpq   80042036fb <pgdir_walk+0x1bd>
	}
	else if((uint64_t*)pgdir[dirIndex] == NULL && create == true)
  80042035b7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042035ba:	48 98                	cltq   
  80042035bc:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042035c3:	00 
  80042035c4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042035c8:	48 01 d0             	add    %rdx,%rax
  80042035cb:	48 8b 00             	mov    (%rax),%rax
  80042035ce:	48 85 c0             	test   %rax,%rax
  80042035d1:	75 7a                	jne    800420364d <pgdir_walk+0x10f>
  80042035d3:	83 7d 9c 01          	cmpl   $0x1,-0x64(%rbp)
  80042035d7:	75 74                	jne    800420364d <pgdir_walk+0x10f>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  80042035d9:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%rbp)
		struct PageInfo * page = page_alloc(ALLOC_ZERO);
  80042035e0:	bf 01 00 00 00       	mov    $0x1,%edi
  80042035e5:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  80042035ec:	00 00 00 
  80042035ef:	ff d0                	callq  *%rax
  80042035f1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!page)
  80042035f5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042035fa:	75 0a                	jne    8004203606 <pgdir_walk+0xc8>
			return NULL;
  80042035fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203601:	e9 f5 00 00 00       	jmpq   80042036fb <pgdir_walk+0x1bd>
		page->pp_ref++;
  8004203606:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420360a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420360e:	8d 50 01             	lea    0x1(%rax),%edx
  8004203611:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203615:	66 89 50 08          	mov    %dx,0x8(%rax)
		pgdir[dirIndex] = page2pa(page) | perm;
  8004203619:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420361c:	48 98                	cltq   
  800420361e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203625:	00 
  8004203626:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420362a:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420362e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203632:	48 89 c7             	mov    %rax,%rdi
  8004203635:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  800420363c:	00 00 00 
  800420363f:	ff d0                	callq  *%rax
  8004203641:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004203644:	48 63 d2             	movslq %edx,%rdx
  8004203647:	48 09 d0             	or     %rdx,%rax
  800420364a:	48 89 03             	mov    %rax,(%rbx)
	}
	//pgdir entry with last 12 bits permissions
	temp = pgdir[dirIndex];
  800420364d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203650:	48 98                	cltq   
  8004203652:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203659:	00 
  800420365a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420365e:	48 01 d0             	add    %rdx,%rax
  8004203661:	48 8b 00             	mov    (%rax),%rax
  8004203664:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  8004203668:	48 81 65 c8 00 f0 ff 	andq   $0xfffffffffffff000,-0x38(%rbp)
  800420366f:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  8004203670:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203674:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004203678:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420367c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203680:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004203683:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004203686:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  800420368d:	00 00 00 
  8004203690:	48 8b 00             	mov    (%rax),%rax
  8004203693:	48 39 c2             	cmp    %rax,%rdx
  8004203696:	72 32                	jb     80042036ca <pgdir_walk+0x18c>
  8004203698:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420369c:	48 89 c1             	mov    %rax,%rcx
  800420369f:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  80042036a6:	00 00 00 
  80042036a9:	be bb 02 00 00       	mov    $0x2bb,%esi
  80042036ae:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042036b5:	00 00 00 
  80042036b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036bd:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042036c4:	00 00 00 
  80042036c7:	41 ff d0             	callq  *%r8
  80042036ca:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042036d1:	00 00 00 
  80042036d4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042036d8:	48 01 d0             	add    %rdx,%rax
  80042036db:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//increase pgtable index to get index pointer in page table
	pgTblIndexPtr = (pte_t *)temp + pgTblIndex;
  80042036df:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042036e2:	48 98                	cltq   
  80042036e4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042036eb:	00 
  80042036ec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042036f0:	48 01 d0             	add    %rdx,%rax
  80042036f3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//cprintf("Address is %x  value is %x \n", (uint64_t)KADDR((uint64_t)(pgdir + dirIndex)), (uint64_t)KADDR(PTE_ADDR(pgdir[dirIndex])));
	return pgTblIndexPtr;
  80042036f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80042036fb:	48 83 c4 68          	add    $0x68,%rsp
  80042036ff:	5b                   	pop    %rbx
  8004203700:	5d                   	pop    %rbp
  8004203701:	c3                   	retq   

0000008004203702 <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004203702:	55                   	push   %rbp
  8004203703:	48 89 e5             	mov    %rsp,%rbp
  8004203706:	48 83 ec 50          	sub    $0x50,%rsp
  800420370a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420370e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004203712:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004203716:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  800420371a:	44 89 45 bc          	mov    %r8d,-0x44(%rbp)
        // Fill this function in
        pte_t *pte_store = NULL;
  800420371e:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203725:	00 
        pte_t * pgTblIndexPtr = NULL;
  8004203726:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420372d:	00 

        int i = 0;
  800420372e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
        if(pml4e == NULL)
  8004203735:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420373a:	75 05                	jne    8004203741 <boot_map_region+0x3f>
        {
                return;
  800420373c:	e9 82 00 00 00       	jmpq   80042037c3 <boot_map_region+0xc1>
        }

        for(; i < size / PGSIZE; i++)
  8004203741:	eb 6e                	jmp    80042037b1 <boot_map_region+0xaf>
        {
        	pgTblIndexPtr = pml4e_walk(pml4e, (void *)la , 1);
  8004203743:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004203747:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420374b:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203750:	48 89 ce             	mov    %rcx,%rsi
  8004203753:	48 89 c7             	mov    %rax,%rdi
  8004203756:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  800420375d:	00 00 00 
  8004203760:	ff d0                	callq  *%rax
  8004203762:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        	if(pgTblIndexPtr == NULL)
  8004203766:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420376b:	75 1d                	jne    800420378a <boot_map_region+0x88>
        	{
        		cprintf("Error: could not bootmap");
  800420376d:	48 bf 02 74 21 04 80 	movabs $0x8004217402,%rdi
  8004203774:	00 00 00 
  8004203777:	b8 00 00 00 00       	mov    $0x0,%eax
  800420377c:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004203783:	00 00 00 
  8004203786:	ff d2                	callq  *%rdx
        	    continue;
  8004203788:	eb 23                	jmp    80042037ad <boot_map_region+0xab>
        	}
            *pgTblIndexPtr = pa | perm;
  800420378a:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420378d:	48 98                	cltq   
  800420378f:	48 0b 45 c0          	or     -0x40(%rbp),%rax
  8004203793:	48 89 c2             	mov    %rax,%rdx
  8004203796:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420379a:	48 89 10             	mov    %rdx,(%rax)
            pa += PGSIZE;
  800420379d:	48 81 45 c0 00 10 00 	addq   $0x1000,-0x40(%rbp)
  80042037a4:	00 
            la += PGSIZE;
  80042037a5:	48 81 45 d0 00 10 00 	addq   $0x1000,-0x30(%rbp)
  80042037ac:	00 
        if(pml4e == NULL)
        {
                return;
        }

        for(; i < size / PGSIZE; i++)
  80042037ad:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042037b1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042037b4:	48 98                	cltq   
  80042037b6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042037ba:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042037be:	48 39 d0             	cmp    %rdx,%rax
  80042037c1:	72 80                	jb     8004203743 <boot_map_region+0x41>
        	}
            *pgTblIndexPtr = pa | perm;
            pa += PGSIZE;
            la += PGSIZE;
        }
}
  80042037c3:	c9                   	leaveq 
  80042037c4:	c3                   	retq   

00000080042037c5 <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  80042037c5:	55                   	push   %rbp
  80042037c6:	48 89 e5             	mov    %rsp,%rbp
  80042037c9:	48 83 ec 30          	sub    $0x30,%rsp
  80042037cd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042037d1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042037d5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042037d9:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
	// Fill this function in
	pte_t * pgTblIndexPtr;
	if(pml4e == NULL || pp == NULL)
  80042037dc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042037e1:	74 07                	je     80042037ea <page_insert+0x25>
  80042037e3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042037e8:	75 0a                	jne    80042037f4 <page_insert+0x2f>
	{
		return 0;
  80042037ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042037ef:	e9 2c 01 00 00       	jmpq   8004203920 <page_insert+0x15b>
	}
	
	pgTblIndexPtr =  pml4e_walk(pml4e, va, 1);
  80042037f4:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042037f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042037fc:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203801:	48 89 ce             	mov    %rcx,%rsi
  8004203804:	48 89 c7             	mov    %rax,%rdi
  8004203807:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  800420380e:	00 00 00 
  8004203811:	ff d0                	callq  *%rax
  8004203813:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//cprintf("pgTblIndexPtr %p %x\n", pgTblIndexPtr, pgTblIndexPtr);
	if(!pgTblIndexPtr)
  8004203817:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420381c:	75 0a                	jne    8004203828 <page_insert+0x63>
	{
		return 	-E_NO_MEM;
  800420381e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004203823:	e9 f8 00 00 00       	jmpq   8004203920 <page_insert+0x15b>
	}
	//set present bit
	perm = perm|PTE_P;
  8004203828:	83 4d d4 01          	orl    $0x1,-0x2c(%rbp)
	bool present = *pgTblIndexPtr & PTE_P;
  800420382c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203830:	48 8b 00             	mov    (%rax),%rax
  8004203833:	83 e0 01             	and    $0x1,%eax
  8004203836:	48 85 c0             	test   %rax,%rax
  8004203839:	0f 95 c0             	setne  %al
  800420383c:	88 45 f7             	mov    %al,-0x9(%rbp)
	if(present &&pa2page(PTE_ADDR(*pgTblIndexPtr)) == pp)
  800420383f:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8004203843:	74 66                	je     80042038ab <page_insert+0xe6>
  8004203845:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203849:	48 8b 00             	mov    (%rax),%rax
  800420384c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203852:	48 89 c7             	mov    %rax,%rdi
  8004203855:	48 b8 20 1c 20 04 80 	movabs $0x8004201c20,%rax
  800420385c:	00 00 00 
  800420385f:	ff d0                	callq  *%rax
  8004203861:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004203865:	75 44                	jne    80042038ab <page_insert+0xe6>
	{		
		*pgTblIndexPtr = (page2pa(pp) | perm);
  8004203867:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420386b:	48 89 c7             	mov    %rax,%rdi
  800420386e:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004203875:	00 00 00 
  8004203878:	ff d0                	callq  *%rax
  800420387a:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420387d:	48 63 d2             	movslq %edx,%rdx
  8004203880:	48 09 c2             	or     %rax,%rdx
  8004203883:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203887:	48 89 10             	mov    %rdx,(%rax)
		tlb_invalidate(pml4e, va);
  800420388a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420388e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203892:	48 89 d6             	mov    %rdx,%rsi
  8004203895:	48 89 c7             	mov    %rax,%rdi
  8004203898:	48 b8 4a 3a 20 04 80 	movabs $0x8004203a4a,%rax
  800420389f:	00 00 00 
  80042038a2:	ff d0                	callq  *%rax
		return 0;
  80042038a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038a9:	eb 75                	jmp    8004203920 <page_insert+0x15b>
	}
	//check and remove previous existing page
	else if(present)
  80042038ab:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80042038af:	74 34                	je     80042038e5 <page_insert+0x120>
	{
		page_remove(pml4e, va);
  80042038b1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042038b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038b9:	48 89 d6             	mov    %rdx,%rsi
  80042038bc:	48 89 c7             	mov    %rax,%rdi
  80042038bf:	48 b8 bc 39 20 04 80 	movabs $0x80042039bc,%rax
  80042038c6:	00 00 00 
  80042038c9:	ff d0                	callq  *%rax
		//invalidate tlb
		tlb_invalidate(pml4e, va);
  80042038cb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042038cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038d3:	48 89 d6             	mov    %rdx,%rsi
  80042038d6:	48 89 c7             	mov    %rax,%rdi
  80042038d9:	48 b8 4a 3a 20 04 80 	movabs $0x8004203a4a,%rax
  80042038e0:	00 00 00 
  80042038e3:	ff d0                	callq  *%rax
	}

	//add new page
	*pgTblIndexPtr = (page2pa(pp) | perm);
  80042038e5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042038e9:	48 89 c7             	mov    %rax,%rdi
  80042038ec:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  80042038f3:	00 00 00 
  80042038f6:	ff d0                	callq  *%rax
  80042038f8:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042038fb:	48 63 d2             	movslq %edx,%rdx
  80042038fe:	48 09 c2             	or     %rax,%rdx
  8004203901:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203905:	48 89 10             	mov    %rdx,(%rax)

	//increment reference
	pp->pp_ref += 1;
  8004203908:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420390c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203910:	8d 50 01             	lea    0x1(%rax),%edx
  8004203913:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203917:	66 89 50 08          	mov    %dx,0x8(%rax)

	return 0;
  800420391b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203920:	c9                   	leaveq 
  8004203921:	c3                   	retq   

0000008004203922 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  8004203922:	55                   	push   %rbp
  8004203923:	48 89 e5             	mov    %rsp,%rbp
  8004203926:	48 83 ec 30          	sub    $0x30,%rsp
  800420392a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420392e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203932:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in
	pte_t * pgTblIndexPtr;
	struct PageInfo * page = NULL;
  8004203936:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420393d:	00 
	bool present;

	if(pml4e == NULL)
  800420393e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203943:	75 06                	jne    800420394b <page_lookup+0x29>
	{
		return page;
  8004203945:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203949:	eb 6f                	jmp    80042039ba <page_lookup+0x98>
	}
	
	pgTblIndexPtr =  pml4e_walk(pml4e, va, 1);
  800420394b:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420394f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203953:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203958:	48 89 ce             	mov    %rcx,%rsi
  800420395b:	48 89 c7             	mov    %rax,%rdi
  800420395e:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  8004203965:	00 00 00 
  8004203968:	ff d0                	callq  *%rax
  800420396a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(pgTblIndexPtr == NULL)
  800420396e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203973:	75 06                	jne    800420397b <page_lookup+0x59>
		return page;
  8004203975:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203979:	eb 3f                	jmp    80042039ba <page_lookup+0x98>
	
	if(*pgTblIndexPtr & PTE_P)
  800420397b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420397f:	48 8b 00             	mov    (%rax),%rax
  8004203982:	83 e0 01             	and    $0x1,%eax
  8004203985:	48 85 c0             	test   %rax,%rax
  8004203988:	74 2c                	je     80042039b6 <page_lookup+0x94>
	{
		page = pa2page(*pgTblIndexPtr);				
  800420398a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420398e:	48 8b 00             	mov    (%rax),%rax
  8004203991:	48 89 c7             	mov    %rax,%rdi
  8004203994:	48 b8 20 1c 20 04 80 	movabs $0x8004201c20,%rax
  800420399b:	00 00 00 
  800420399e:	ff d0                	callq  *%rax
  80042039a0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if(pte_store)
  80042039a4:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042039a9:	74 0b                	je     80042039b6 <page_lookup+0x94>
		{
			*pte_store = pgTblIndexPtr;
  80042039ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042039af:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042039b3:	48 89 10             	mov    %rdx,(%rax)
		}
	}
	return page;
  80042039b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042039ba:	c9                   	leaveq 
  80042039bb:	c3                   	retq   

00000080042039bc <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  80042039bc:	55                   	push   %rbp
  80042039bd:	48 89 e5             	mov    %rsp,%rbp
  80042039c0:	48 83 ec 20          	sub    $0x20,%rsp
  80042039c4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042039c8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in
	
	pte_t *pte_store = NULL;
  80042039cc:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042039d3:	00 
	struct PageInfo* page_add = NULL;
  80042039d4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042039db:	00 
	if(pml4e == NULL)
  80042039dc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042039e1:	75 02                	jne    80042039e5 <page_remove+0x29>
	{
		return;
  80042039e3:	eb 63                	jmp    8004203a48 <page_remove+0x8c>
	}
	
	page_add =  page_lookup(pml4e, va, &pte_store);
  80042039e5:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80042039e9:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80042039ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042039f1:	48 89 ce             	mov    %rcx,%rsi
  80042039f4:	48 89 c7             	mov    %rax,%rdi
  80042039f7:	48 b8 22 39 20 04 80 	movabs $0x8004203922,%rax
  80042039fe:	00 00 00 
  8004203a01:	ff d0                	callq  *%rax
  8004203a03:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(page_add == NULL)
  8004203a07:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203a0c:	75 02                	jne    8004203a10 <page_remove+0x54>
		return;
  8004203a0e:	eb 38                	jmp    8004203a48 <page_remove+0x8c>
	
	tlb_invalidate(pml4e, va);
  8004203a10:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203a14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203a18:	48 89 d6             	mov    %rdx,%rsi
  8004203a1b:	48 89 c7             	mov    %rax,%rdi
  8004203a1e:	48 b8 4a 3a 20 04 80 	movabs $0x8004203a4a,%rax
  8004203a25:	00 00 00 
  8004203a28:	ff d0                	callq  *%rax
	page_decref(page_add);
  8004203a2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a2e:	48 89 c7             	mov    %rax,%rdi
  8004203a31:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  8004203a38:	00 00 00 
  8004203a3b:	ff d0                	callq  *%rax
	//The pg table entry corresponding to 'va' should be set to 0.
	*pte_store = 0;
  8004203a3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203a41:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
}
  8004203a48:	c9                   	leaveq 
  8004203a49:	c3                   	retq   

0000008004203a4a <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203a4a:	55                   	push   %rbp
  8004203a4b:	48 89 e5             	mov    %rsp,%rbp
  8004203a4e:	48 83 ec 20          	sub    $0x20,%rsp
  8004203a52:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203a56:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  8004203a5a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203a5f:	75 35                	jne    8004203a96 <tlb_invalidate+0x4c>
  8004203a61:	48 b9 1b 74 21 04 80 	movabs $0x800421741b,%rcx
  8004203a68:	00 00 00 
  8004203a6b:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004203a72:	00 00 00 
  8004203a75:	be 80 03 00 00       	mov    $0x380,%esi
  8004203a7a:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004203a81:	00 00 00 
  8004203a84:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a89:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004203a90:	00 00 00 
  8004203a93:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  8004203a96:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004203a9d:	00 00 00 
  8004203aa0:	ff d0                	callq  *%rax
  8004203aa2:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  8004203aa9:	00 00 00 
  8004203aac:	48 98                	cltq   
  8004203aae:	48 c1 e0 03          	shl    $0x3,%rax
  8004203ab2:	48 89 c2             	mov    %rax,%rdx
  8004203ab5:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203ab9:	48 29 c2             	sub    %rax,%rdx
  8004203abc:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203ac0:	48 83 c0 08          	add    $0x8,%rax
  8004203ac4:	48 8b 00             	mov    (%rax),%rax
  8004203ac7:	48 85 c0             	test   %rax,%rax
  8004203aca:	74 3e                	je     8004203b0a <tlb_invalidate+0xc0>
  8004203acc:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004203ad3:	00 00 00 
  8004203ad6:	ff d0                	callq  *%rax
  8004203ad8:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  8004203adf:	00 00 00 
  8004203ae2:	48 98                	cltq   
  8004203ae4:	48 c1 e0 03          	shl    $0x3,%rax
  8004203ae8:	48 89 c2             	mov    %rax,%rdx
  8004203aeb:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203aef:	48 29 c2             	sub    %rax,%rdx
  8004203af2:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203af6:	48 83 c0 08          	add    $0x8,%rax
  8004203afa:	48 8b 00             	mov    (%rax),%rax
  8004203afd:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203b04:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004203b08:	75 0f                	jne    8004203b19 <tlb_invalidate+0xcf>
  8004203b0a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203b0e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{ 
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004203b12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b16:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  8004203b19:	c9                   	leaveq 
  8004203b1a:	c3                   	retq   

0000008004203b1b <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004203b1b:	55                   	push   %rbp
  8004203b1c:	48 89 e5             	mov    %rsp,%rbp
  8004203b1f:	48 83 ec 30          	sub    $0x30,%rsp
  8004203b23:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203b27:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// beginning of the MMIO region.  Because this is static, its
	// value will be preserved between calls to mmio_map_region
	// (just like nextfree in boot_alloc).
	static uintptr_t base = MMIOBASE;
	uintptr_t base_prev;
	base_prev = base;
  8004203b2b:	48 b8 c8 c5 22 04 80 	movabs $0x800422c5c8,%rax
  8004203b32:	00 00 00 
  8004203b35:	48 8b 00             	mov    (%rax),%rax
  8004203b38:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	/* check if base+size < MMIOLIM,roundpu size, do we need to round down/round up pa???? move base to new size,*/
	if((base+size) >= MMIOLIM){
  8004203b3c:	48 b8 c8 c5 22 04 80 	movabs $0x800422c5c8,%rax
  8004203b43:	00 00 00 
  8004203b46:	48 8b 10             	mov    (%rax),%rdx
  8004203b49:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203b4d:	48 01 c2             	add    %rax,%rdx
  8004203b50:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004203b57:	00 00 00 
  8004203b5a:	48 39 c2             	cmp    %rax,%rdx
  8004203b5d:	76 2a                	jbe    8004203b89 <mmio_map_region+0x6e>
			panic("Out of bound memory");
  8004203b5f:	48 ba 27 74 21 04 80 	movabs $0x8004217427,%rdx
  8004203b66:	00 00 00 
  8004203b69:	be a9 03 00 00       	mov    $0x3a9,%esi
  8004203b6e:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004203b75:	00 00 00 
  8004203b78:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b7d:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  8004203b84:	00 00 00 
  8004203b87:	ff d1                	callq  *%rcx
	}
	size = ROUNDUP(size, PGSIZE);
  8004203b89:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  8004203b90:	00 
  8004203b91:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203b95:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203b99:	48 01 d0             	add    %rdx,%rax
  8004203b9c:	48 83 e8 01          	sub    $0x1,%rax
  8004203ba0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203ba4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203ba8:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203bad:	48 f7 75 f0          	divq   -0x10(%rbp)
  8004203bb1:	48 89 d0             	mov    %rdx,%rax
  8004203bb4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203bb8:	48 29 c2             	sub    %rax,%rdx
  8004203bbb:	48 89 d0             	mov    %rdx,%rax
  8004203bbe:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	boot_map_region(boot_pml4e, base, size,  pa,  PTE_PCD|PTE_PWT|PTE_W|PTE_P);
  8004203bc2:	48 b8 c8 c5 22 04 80 	movabs $0x800422c5c8,%rax
  8004203bc9:	00 00 00 
  8004203bcc:	48 8b 30             	mov    (%rax),%rsi
  8004203bcf:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004203bd6:	00 00 00 
  8004203bd9:	48 8b 00             	mov    (%rax),%rax
  8004203bdc:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203be0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203be4:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  8004203bea:	48 89 c7             	mov    %rax,%rdi
  8004203bed:	48 b8 02 37 20 04 80 	movabs $0x8004203702,%rax
  8004203bf4:	00 00 00 
  8004203bf7:	ff d0                	callq  *%rax
	base+= size;
  8004203bf9:	48 b8 c8 c5 22 04 80 	movabs $0x800422c5c8,%rax
  8004203c00:	00 00 00 
  8004203c03:	48 8b 10             	mov    (%rax),%rdx
  8004203c06:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203c0a:	48 01 c2             	add    %rax,%rdx
  8004203c0d:	48 b8 c8 c5 22 04 80 	movabs $0x800422c5c8,%rax
  8004203c14:	00 00 00 
  8004203c17:	48 89 10             	mov    %rdx,(%rax)
	return (void*)base_prev;
  8004203c1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	//panic("mmio_map_region not implemented");

}
  8004203c1e:	c9                   	leaveq 
  8004203c1f:	c3                   	retq   

0000008004203c20 <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004203c20:	55                   	push   %rbp
  8004203c21:	48 89 e5             	mov    %rsp,%rbp
  8004203c24:	48 83 ec 50          	sub    $0x50,%rsp
  8004203c28:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004203c2c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004203c30:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004203c34:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
	// LAB 3: Your code here.
	struct PageInfo * page;
	pte_t *pte_store;
	void * vaT = (void*)va;
  8004203c37:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203c3b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	void *vaE;
	vaT = ROUNDDOWN(vaT,PGSIZE);
  8004203c3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c43:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203c47:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203c4b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203c51:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	vaE = ROUNDUP(vaT + len, PGSIZE);
  8004203c55:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004203c5c:	00 
  8004203c5d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203c61:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203c65:	48 01 d0             	add    %rdx,%rax
  8004203c68:	48 89 c2             	mov    %rax,%rdx
  8004203c6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203c6f:	48 01 d0             	add    %rdx,%rax
  8004203c72:	48 83 e8 01          	sub    $0x1,%rax
  8004203c76:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203c7a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203c7e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203c83:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004203c87:	48 89 d0             	mov    %rdx,%rax
  8004203c8a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203c8e:	48 29 c2             	sub    %rax,%rdx
  8004203c91:	48 89 d0             	mov    %rdx,%rax
  8004203c94:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;vaT < vaE; vaT = vaT + PGSIZE)
  8004203c98:	e9 8c 00 00 00       	jmpq   8004203d29 <user_mem_check+0x109>
	{
		if((uintptr_t)vaT >= ULIM || !page_lookup(env->env_pml4e, vaT, &pte_store) || !pte_store || !(*pte_store & perm))
  8004203c9d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203ca1:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004203ca8:	00 00 00 
  8004203cab:	48 39 c2             	cmp    %rax,%rdx
  8004203cae:	77 47                	ja     8004203cf7 <user_mem_check+0xd7>
  8004203cb0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203cb4:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203cbb:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004203cbf:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004203cc3:	48 89 ce             	mov    %rcx,%rsi
  8004203cc6:	48 89 c7             	mov    %rax,%rdi
  8004203cc9:	48 b8 22 39 20 04 80 	movabs $0x8004203922,%rax
  8004203cd0:	00 00 00 
  8004203cd3:	ff d0                	callq  *%rax
  8004203cd5:	48 85 c0             	test   %rax,%rax
  8004203cd8:	74 1d                	je     8004203cf7 <user_mem_check+0xd7>
  8004203cda:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203cde:	48 85 c0             	test   %rax,%rax
  8004203ce1:	74 14                	je     8004203cf7 <user_mem_check+0xd7>
  8004203ce3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203ce7:	48 8b 10             	mov    (%rax),%rdx
  8004203cea:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004203ced:	48 98                	cltq   
  8004203cef:	48 21 d0             	and    %rdx,%rax
  8004203cf2:	48 85 c0             	test   %rax,%rax
  8004203cf5:	75 2a                	jne    8004203d21 <user_mem_check+0x101>
		{
			if(vaT < va){
  8004203cf7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203cfb:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004203cff:	73 08                	jae    8004203d09 <user_mem_check+0xe9>
				vaT = (void*)va;
  8004203d01:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203d05:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			}
			user_mem_check_addr = (uintptr_t)vaT;
  8004203d09:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203d0d:	48 b8 40 02 4a 04 80 	movabs $0x80044a0240,%rax
  8004203d14:	00 00 00 
  8004203d17:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;		
  8004203d1a:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004203d1f:	eb 1b                	jmp    8004203d3c <user_mem_check+0x11c>
	pte_t *pte_store;
	void * vaT = (void*)va;
	void *vaE;
	vaT = ROUNDDOWN(vaT,PGSIZE);
	vaE = ROUNDUP(vaT + len, PGSIZE);
	for(;vaT < vaE; vaT = vaT + PGSIZE)
  8004203d21:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203d28:	00 
  8004203d29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d2d:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203d31:	0f 82 66 ff ff ff    	jb     8004203c9d <user_mem_check+0x7d>
			}
			user_mem_check_addr = (uintptr_t)vaT;
			return -E_FAULT;		
		}
	}
	return 0;
  8004203d37:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203d3c:	c9                   	leaveq 
  8004203d3d:	c3                   	retq   

0000008004203d3e <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  8004203d3e:	55                   	push   %rbp
  8004203d3f:	48 89 e5             	mov    %rsp,%rbp
  8004203d42:	48 83 ec 20          	sub    $0x20,%rsp
  8004203d46:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004203d4a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004203d4e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004203d52:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004203d55:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203d58:	83 c8 04             	or     $0x4,%eax
  8004203d5b:	89 c1                	mov    %eax,%ecx
  8004203d5d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203d61:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004203d65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d69:	48 89 c7             	mov    %rax,%rdi
  8004203d6c:	48 b8 20 3c 20 04 80 	movabs $0x8004203c20,%rax
  8004203d73:	00 00 00 
  8004203d76:	ff d0                	callq  *%rax
  8004203d78:	85 c0                	test   %eax,%eax
  8004203d7a:	79 47                	jns    8004203dc3 <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  8004203d7c:	48 b8 40 02 4a 04 80 	movabs $0x80044a0240,%rax
  8004203d83:	00 00 00 
  8004203d86:	48 8b 10             	mov    (%rax),%rdx
  8004203d89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d8d:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004203d93:	89 c6                	mov    %eax,%esi
  8004203d95:	48 bf 40 74 21 04 80 	movabs $0x8004217440,%rdi
  8004203d9c:	00 00 00 
  8004203d9f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203da4:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  8004203dab:	00 00 00 
  8004203dae:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  8004203db0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203db4:	48 89 c7             	mov    %rax,%rdi
  8004203db7:	48 b8 bf 85 20 04 80 	movabs $0x80042085bf,%rax
  8004203dbe:	00 00 00 
  8004203dc1:	ff d0                	callq  *%rax
	}
}
  8004203dc3:	c9                   	leaveq 
  8004203dc4:	c3                   	retq   

0000008004203dc5 <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004203dc5:	55                   	push   %rbp
  8004203dc6:	48 89 e5             	mov    %rsp,%rbp
  8004203dc9:	48 83 ec 60          	sub    $0x60,%rsp
  8004203dcd:	89 f8                	mov    %edi,%eax
  8004203dcf:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004203dd2:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203dd6:	74 07                	je     8004203ddf <check_page_free_list+0x1a>
  8004203dd8:	b8 01 00 00 00       	mov    $0x1,%eax
  8004203ddd:	eb 05                	jmp    8004203de4 <check_page_free_list+0x1f>
  8004203ddf:	b8 00 02 00 00       	mov    $0x200,%eax
  8004203de4:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004203de7:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203dee:	00 
  8004203def:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203df6:	00 
	char *first_free_page;

	if (!page_free_list)
  8004203df7:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004203dfe:	00 00 00 
  8004203e01:	48 8b 00             	mov    (%rax),%rax
  8004203e04:	48 85 c0             	test   %rax,%rax
  8004203e07:	75 2a                	jne    8004203e33 <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004203e09:	48 ba 78 74 21 04 80 	movabs $0x8004217478,%rdx
  8004203e10:	00 00 00 
  8004203e13:	be 02 04 00 00       	mov    $0x402,%esi
  8004203e18:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004203e1f:	00 00 00 
  8004203e22:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e27:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  8004203e2e:	00 00 00 
  8004203e31:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004203e33:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203e37:	0f 84 a9 00 00 00    	je     8004203ee6 <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  8004203e3d:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004203e41:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004203e45:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004203e49:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203e4d:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004203e54:	00 00 00 
  8004203e57:	48 8b 00             	mov    (%rax),%rax
  8004203e5a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203e5e:	eb 58                	jmp    8004203eb8 <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  8004203e60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e64:	48 89 c7             	mov    %rax,%rdi
  8004203e67:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004203e6e:	00 00 00 
  8004203e71:	ff d0                	callq  *%rax
  8004203e73:	48 c1 e8 15          	shr    $0x15,%rax
  8004203e77:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203e7c:	48 89 c2             	mov    %rax,%rdx
  8004203e7f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203e82:	48 39 c2             	cmp    %rax,%rdx
  8004203e85:	0f 93 c0             	setae  %al
  8004203e88:	0f b6 c0             	movzbl %al,%eax
  8004203e8b:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  8004203e8e:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203e91:	48 98                	cltq   
  8004203e93:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  8004203e98:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203e9c:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  8004203e9f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203ea3:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203ea6:	48 98                	cltq   
  8004203ea8:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203ead:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203eb1:	48 8b 00             	mov    (%rax),%rax
  8004203eb4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203eb8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203ebd:	75 a1                	jne    8004203e60 <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004203ebf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203ec3:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004203eca:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203ece:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203ed2:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004203ed5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203ed9:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004203ee0:	00 00 00 
  8004203ee3:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203ee6:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004203eed:	00 00 00 
  8004203ef0:	48 8b 00             	mov    (%rax),%rax
  8004203ef3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203ef7:	eb 5e                	jmp    8004203f57 <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004203ef9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203efd:	48 89 c7             	mov    %rax,%rdi
  8004203f00:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004203f07:	00 00 00 
  8004203f0a:	ff d0                	callq  *%rax
  8004203f0c:	48 c1 e8 15          	shr    $0x15,%rax
  8004203f10:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203f15:	48 89 c2             	mov    %rax,%rdx
  8004203f18:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203f1b:	48 39 c2             	cmp    %rax,%rdx
  8004203f1e:	73 2c                	jae    8004203f4c <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  8004203f20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f24:	48 89 c7             	mov    %rax,%rdi
  8004203f27:	48 b8 91 1c 20 04 80 	movabs $0x8004201c91,%rax
  8004203f2e:	00 00 00 
  8004203f31:	ff d0                	callq  *%rax
  8004203f33:	ba 80 00 00 00       	mov    $0x80,%edx
  8004203f38:	be 97 00 00 00       	mov    $0x97,%esi
  8004203f3d:	48 89 c7             	mov    %rax,%rdi
  8004203f40:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004203f47:	00 00 00 
  8004203f4a:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203f4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f50:	48 8b 00             	mov    (%rax),%rax
  8004203f53:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f57:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203f5c:	75 9b                	jne    8004203ef9 <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  8004203f5e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203f63:	48 b8 ba 25 20 04 80 	movabs $0x80042025ba,%rax
  8004203f6a:	00 00 00 
  8004203f6d:	ff d0                	callq  *%rax
  8004203f6f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203f73:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004203f7a:	00 00 00 
  8004203f7d:	48 8b 00             	mov    (%rax),%rax
  8004203f80:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f84:	e9 20 03 00 00       	jmpq   80042042a9 <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  8004203f89:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004203f90:	00 00 00 
  8004203f93:	48 8b 00             	mov    (%rax),%rax
  8004203f96:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203f9a:	73 35                	jae    8004203fd1 <check_page_free_list+0x20c>
  8004203f9c:	48 b9 9c 74 21 04 80 	movabs $0x800421749c,%rcx
  8004203fa3:	00 00 00 
  8004203fa6:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004203fad:	00 00 00 
  8004203fb0:	be 1c 04 00 00       	mov    $0x41c,%esi
  8004203fb5:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004203fbc:	00 00 00 
  8004203fbf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fc4:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004203fcb:	00 00 00 
  8004203fce:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004203fd1:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004203fd8:	00 00 00 
  8004203fdb:	48 8b 10             	mov    (%rax),%rdx
  8004203fde:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004203fe5:	00 00 00 
  8004203fe8:	48 8b 00             	mov    (%rax),%rax
  8004203feb:	48 c1 e0 04          	shl    $0x4,%rax
  8004203fef:	48 01 d0             	add    %rdx,%rax
  8004203ff2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203ff6:	77 35                	ja     800420402d <check_page_free_list+0x268>
  8004203ff8:	48 b9 a8 74 21 04 80 	movabs $0x80042174a8,%rcx
  8004203fff:	00 00 00 
  8004204002:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204009:	00 00 00 
  800420400c:	be 1d 04 00 00       	mov    $0x41d,%esi
  8004204011:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204018:	00 00 00 
  800420401b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204020:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204027:	00 00 00 
  800420402a:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  800420402d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204031:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004204038:	00 00 00 
  800420403b:	48 8b 00             	mov    (%rax),%rax
  800420403e:	48 29 c2             	sub    %rax,%rdx
  8004204041:	48 89 d0             	mov    %rdx,%rax
  8004204044:	83 e0 0f             	and    $0xf,%eax
  8004204047:	48 85 c0             	test   %rax,%rax
  800420404a:	74 35                	je     8004204081 <check_page_free_list+0x2bc>
  800420404c:	48 b9 c0 74 21 04 80 	movabs $0x80042174c0,%rcx
  8004204053:	00 00 00 
  8004204056:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420405d:	00 00 00 
  8004204060:	be 1e 04 00 00       	mov    $0x41e,%esi
  8004204065:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420406c:	00 00 00 
  800420406f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204074:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420407b:	00 00 00 
  800420407e:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  8004204081:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204085:	48 89 c7             	mov    %rax,%rdi
  8004204088:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  800420408f:	00 00 00 
  8004204092:	ff d0                	callq  *%rax
  8004204094:	48 85 c0             	test   %rax,%rax
  8004204097:	75 35                	jne    80042040ce <check_page_free_list+0x309>
  8004204099:	48 b9 f2 74 21 04 80 	movabs $0x80042174f2,%rcx
  80042040a0:	00 00 00 
  80042040a3:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042040aa:	00 00 00 
  80042040ad:	be 21 04 00 00       	mov    $0x421,%esi
  80042040b2:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042040b9:	00 00 00 
  80042040bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040c1:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042040c8:	00 00 00 
  80042040cb:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  80042040ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042040d2:	48 89 c7             	mov    %rax,%rdi
  80042040d5:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  80042040dc:	00 00 00 
  80042040df:	ff d0                	callq  *%rax
  80042040e1:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  80042040e7:	75 35                	jne    800420411e <check_page_free_list+0x359>
  80042040e9:	48 b9 03 75 21 04 80 	movabs $0x8004217503,%rcx
  80042040f0:	00 00 00 
  80042040f3:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042040fa:	00 00 00 
  80042040fd:	be 22 04 00 00       	mov    $0x422,%esi
  8004204102:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204109:	00 00 00 
  800420410c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204111:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204118:	00 00 00 
  800420411b:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  800420411e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204122:	48 89 c7             	mov    %rax,%rdi
  8004204125:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  800420412c:	00 00 00 
  800420412f:	ff d0                	callq  *%rax
  8004204131:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204137:	75 35                	jne    800420416e <check_page_free_list+0x3a9>
  8004204139:	48 b9 20 75 21 04 80 	movabs $0x8004217520,%rcx
  8004204140:	00 00 00 
  8004204143:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420414a:	00 00 00 
  800420414d:	be 23 04 00 00       	mov    $0x423,%esi
  8004204152:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204159:	00 00 00 
  800420415c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204161:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204168:	00 00 00 
  800420416b:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  800420416e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204172:	48 89 c7             	mov    %rax,%rdi
  8004204175:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  800420417c:	00 00 00 
  800420417f:	ff d0                	callq  *%rax
  8004204181:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204187:	75 35                	jne    80042041be <check_page_free_list+0x3f9>
  8004204189:	48 b9 43 75 21 04 80 	movabs $0x8004217543,%rcx
  8004204190:	00 00 00 
  8004204193:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420419a:	00 00 00 
  800420419d:	be 24 04 00 00       	mov    $0x424,%esi
  80042041a2:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042041a9:	00 00 00 
  80042041ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041b1:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042041b8:	00 00 00 
  80042041bb:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  80042041be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041c2:	48 89 c7             	mov    %rax,%rdi
  80042041c5:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  80042041cc:	00 00 00 
  80042041cf:	ff d0                	callq  *%rax
  80042041d1:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042041d7:	76 4e                	jbe    8004204227 <check_page_free_list+0x462>
  80042041d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041dd:	48 89 c7             	mov    %rax,%rdi
  80042041e0:	48 b8 91 1c 20 04 80 	movabs $0x8004201c91,%rax
  80042041e7:	00 00 00 
  80042041ea:	ff d0                	callq  *%rax
  80042041ec:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042041f0:	73 35                	jae    8004204227 <check_page_free_list+0x462>
  80042041f2:	48 b9 60 75 21 04 80 	movabs $0x8004217560,%rcx
  80042041f9:	00 00 00 
  80042041fc:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204203:	00 00 00 
  8004204206:	be 25 04 00 00       	mov    $0x425,%esi
  800420420b:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204212:	00 00 00 
  8004204215:	b8 00 00 00 00       	mov    $0x0,%eax
  800420421a:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204221:	00 00 00 
  8004204224:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004204227:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420422b:	48 89 c7             	mov    %rax,%rdi
  800420422e:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004204235:	00 00 00 
  8004204238:	ff d0                	callq  *%rax
  800420423a:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  8004204240:	75 35                	jne    8004204277 <check_page_free_list+0x4b2>
  8004204242:	48 b9 a5 75 21 04 80 	movabs $0x80042175a5,%rcx
  8004204249:	00 00 00 
  800420424c:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204253:	00 00 00 
  8004204256:	be 27 04 00 00       	mov    $0x427,%esi
  800420425b:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204262:	00 00 00 
  8004204265:	b8 00 00 00 00       	mov    $0x0,%eax
  800420426a:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204271:	00 00 00 
  8004204274:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  8004204277:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420427b:	48 89 c7             	mov    %rax,%rdi
  800420427e:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004204285:	00 00 00 
  8004204288:	ff d0                	callq  *%rax
  800420428a:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004204290:	77 07                	ja     8004204299 <check_page_free_list+0x4d4>
			++nfree_basemem;
  8004204292:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004204297:	eb 05                	jmp    800420429e <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  8004204299:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  800420429e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042a2:	48 8b 00             	mov    (%rax),%rax
  80042042a5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042042a9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042042ae:	0f 85 d5 fc ff ff    	jne    8004203f89 <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  80042042b4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042042b9:	75 35                	jne    80042042f0 <check_page_free_list+0x52b>
  80042042bb:	48 b9 c2 75 21 04 80 	movabs $0x80042175c2,%rcx
  80042042c2:	00 00 00 
  80042042c5:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042042cc:	00 00 00 
  80042042cf:	be 2f 04 00 00       	mov    $0x42f,%esi
  80042042d4:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042042db:	00 00 00 
  80042042de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042e3:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042042ea:	00 00 00 
  80042042ed:	41 ff d0             	callq  *%r8
}
  80042042f0:	c9                   	leaveq 
  80042042f1:	c3                   	retq   

00000080042042f2 <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  80042042f2:	55                   	push   %rbp
  80042042f3:	48 89 e5             	mov    %rsp,%rbp
  80042042f6:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042042fa:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004204301:	00 00 00 
  8004204304:	48 8b 00             	mov    (%rax),%rax
  8004204307:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420430b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004204312:	eb 37                	jmp    800420434b <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  8004204314:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204318:	48 89 c7             	mov    %rax,%rdi
  800420431b:	48 b8 91 1c 20 04 80 	movabs $0x8004201c91,%rax
  8004204322:	00 00 00 
  8004204325:	ff d0                	callq  *%rax
  8004204327:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420432c:	be 97 00 00 00       	mov    $0x97,%esi
  8004204331:	48 89 c7             	mov    %rax,%rdi
  8004204334:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  800420433b:	00 00 00 
  800420433e:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204340:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204344:	48 8b 00             	mov    (%rax),%rax
  8004204347:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420434b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204350:	75 c2                	jne    8004204314 <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204352:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004204359:	00 00 00 
  800420435c:	48 8b 00             	mov    (%rax),%rax
  800420435f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204363:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  800420436a:	e9 ec 01 00 00       	jmpq   800420455b <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  800420436f:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004204376:	00 00 00 
  8004204379:	48 8b 00             	mov    (%rax),%rax
  800420437c:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004204380:	73 35                	jae    80042043b7 <check_page_alloc+0xc5>
  8004204382:	48 b9 d3 75 21 04 80 	movabs $0x80042175d3,%rcx
  8004204389:	00 00 00 
  800420438c:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204393:	00 00 00 
  8004204396:	be 48 04 00 00       	mov    $0x448,%esi
  800420439b:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042043a2:	00 00 00 
  80042043a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043aa:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042043b1:	00 00 00 
  80042043b4:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  80042043b7:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  80042043be:	00 00 00 
  80042043c1:	48 8b 10             	mov    (%rax),%rdx
  80042043c4:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  80042043cb:	00 00 00 
  80042043ce:	48 8b 00             	mov    (%rax),%rax
  80042043d1:	48 c1 e0 04          	shl    $0x4,%rax
  80042043d5:	48 01 d0             	add    %rdx,%rax
  80042043d8:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042043dc:	77 35                	ja     8004204413 <check_page_alloc+0x121>
  80042043de:	48 b9 e0 75 21 04 80 	movabs $0x80042175e0,%rcx
  80042043e5:	00 00 00 
  80042043e8:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042043ef:	00 00 00 
  80042043f2:	be 49 04 00 00       	mov    $0x449,%esi
  80042043f7:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042043fe:	00 00 00 
  8004204401:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204406:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420440d:	00 00 00 
  8004204410:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  8004204413:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204417:	48 89 c7             	mov    %rax,%rdi
  800420441a:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004204421:	00 00 00 
  8004204424:	ff d0                	callq  *%rax
  8004204426:	48 85 c0             	test   %rax,%rax
  8004204429:	75 35                	jne    8004204460 <check_page_alloc+0x16e>
  800420442b:	48 b9 f5 75 21 04 80 	movabs $0x80042175f5,%rcx
  8004204432:	00 00 00 
  8004204435:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420443c:	00 00 00 
  800420443f:	be 4c 04 00 00       	mov    $0x44c,%esi
  8004204444:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420444b:	00 00 00 
  800420444e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204453:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420445a:	00 00 00 
  800420445d:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  8004204460:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204464:	48 89 c7             	mov    %rax,%rdi
  8004204467:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  800420446e:	00 00 00 
  8004204471:	ff d0                	callq  *%rax
  8004204473:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204479:	75 35                	jne    80042044b0 <check_page_alloc+0x1be>
  800420447b:	48 b9 07 76 21 04 80 	movabs $0x8004217607,%rcx
  8004204482:	00 00 00 
  8004204485:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420448c:	00 00 00 
  800420448f:	be 4d 04 00 00       	mov    $0x44d,%esi
  8004204494:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420449b:	00 00 00 
  800420449e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044a3:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042044aa:	00 00 00 
  80042044ad:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  80042044b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042044b4:	48 89 c7             	mov    %rax,%rdi
  80042044b7:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  80042044be:	00 00 00 
  80042044c1:	ff d0                	callq  *%rax
  80042044c3:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  80042044c9:	75 35                	jne    8004204500 <check_page_alloc+0x20e>
  80042044cb:	48 b9 28 76 21 04 80 	movabs $0x8004217628,%rcx
  80042044d2:	00 00 00 
  80042044d5:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042044dc:	00 00 00 
  80042044df:	be 4e 04 00 00       	mov    $0x44e,%esi
  80042044e4:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042044eb:	00 00 00 
  80042044ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044f3:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042044fa:	00 00 00 
  80042044fd:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  8004204500:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204504:	48 89 c7             	mov    %rax,%rdi
  8004204507:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  800420450e:	00 00 00 
  8004204511:	ff d0                	callq  *%rax
  8004204513:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204519:	75 35                	jne    8004204550 <check_page_alloc+0x25e>
  800420451b:	48 b9 4c 76 21 04 80 	movabs $0x800421764c,%rcx
  8004204522:	00 00 00 
  8004204525:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420452c:	00 00 00 
  800420452f:	be 4f 04 00 00       	mov    $0x44f,%esi
  8004204534:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420453b:	00 00 00 
  800420453e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204543:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420454a:	00 00 00 
  800420454d:	41 ff d0             	callq  *%r8
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204550:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204554:	48 8b 00             	mov    (%rax),%rax
  8004204557:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420455b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204560:	0f 85 09 fe ff ff    	jne    800420436f <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  8004204566:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420456d:	00 
  800420456e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204572:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204576:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420457a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  800420457e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204583:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  800420458a:	00 00 00 
  800420458d:	ff d0                	callq  *%rax
  800420458f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204593:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204598:	75 35                	jne    80042045cf <check_page_alloc+0x2dd>
  800420459a:	48 b9 67 76 21 04 80 	movabs $0x8004217667,%rcx
  80042045a1:	00 00 00 
  80042045a4:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042045ab:	00 00 00 
  80042045ae:	be 53 04 00 00       	mov    $0x453,%esi
  80042045b3:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042045ba:	00 00 00 
  80042045bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045c2:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042045c9:	00 00 00 
  80042045cc:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  80042045cf:	bf 00 00 00 00       	mov    $0x0,%edi
  80042045d4:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  80042045db:	00 00 00 
  80042045de:	ff d0                	callq  *%rax
  80042045e0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042045e4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042045e9:	75 35                	jne    8004204620 <check_page_alloc+0x32e>
  80042045eb:	48 b9 7d 76 21 04 80 	movabs $0x800421767d,%rcx
  80042045f2:	00 00 00 
  80042045f5:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042045fc:	00 00 00 
  80042045ff:	be 54 04 00 00       	mov    $0x454,%esi
  8004204604:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420460b:	00 00 00 
  800420460e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204613:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420461a:	00 00 00 
  800420461d:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204620:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204625:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  800420462c:	00 00 00 
  800420462f:	ff d0                	callq  *%rax
  8004204631:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204635:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420463a:	75 35                	jne    8004204671 <check_page_alloc+0x37f>
  800420463c:	48 b9 93 76 21 04 80 	movabs $0x8004217693,%rcx
  8004204643:	00 00 00 
  8004204646:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420464d:	00 00 00 
  8004204650:	be 55 04 00 00       	mov    $0x455,%esi
  8004204655:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420465c:	00 00 00 
  800420465f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204664:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420466b:	00 00 00 
  800420466e:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204671:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204676:	75 35                	jne    80042046ad <check_page_alloc+0x3bb>
  8004204678:	48 b9 a9 76 21 04 80 	movabs $0x80042176a9,%rcx
  800420467f:	00 00 00 
  8004204682:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204689:	00 00 00 
  800420468c:	be 56 04 00 00       	mov    $0x456,%esi
  8004204691:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204698:	00 00 00 
  800420469b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046a0:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042046a7:	00 00 00 
  80042046aa:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  80042046ad:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042046b2:	74 0a                	je     80042046be <check_page_alloc+0x3cc>
  80042046b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042046b8:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042046bc:	75 35                	jne    80042046f3 <check_page_alloc+0x401>
  80042046be:	48 b9 ad 76 21 04 80 	movabs $0x80042176ad,%rcx
  80042046c5:	00 00 00 
  80042046c8:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042046cf:	00 00 00 
  80042046d2:	be 57 04 00 00       	mov    $0x457,%esi
  80042046d7:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042046de:	00 00 00 
  80042046e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046e6:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042046ed:	00 00 00 
  80042046f0:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  80042046f3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042046f8:	74 14                	je     800420470e <check_page_alloc+0x41c>
  80042046fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042046fe:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204702:	74 0a                	je     800420470e <check_page_alloc+0x41c>
  8004204704:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204708:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420470c:	75 35                	jne    8004204743 <check_page_alloc+0x451>
  800420470e:	48 b9 c0 76 21 04 80 	movabs $0x80042176c0,%rcx
  8004204715:	00 00 00 
  8004204718:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420471f:	00 00 00 
  8004204722:	be 58 04 00 00       	mov    $0x458,%esi
  8004204727:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420472e:	00 00 00 
  8004204731:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204736:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420473d:	00 00 00 
  8004204740:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004204743:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204747:	48 89 c7             	mov    %rax,%rdi
  800420474a:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004204751:	00 00 00 
  8004204754:	ff d0                	callq  *%rax
  8004204756:	48 ba b0 17 4a 04 80 	movabs $0x80044a17b0,%rdx
  800420475d:	00 00 00 
  8004204760:	48 8b 12             	mov    (%rdx),%rdx
  8004204763:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204767:	48 39 d0             	cmp    %rdx,%rax
  800420476a:	72 35                	jb     80042047a1 <check_page_alloc+0x4af>
  800420476c:	48 b9 e0 76 21 04 80 	movabs $0x80042176e0,%rcx
  8004204773:	00 00 00 
  8004204776:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420477d:	00 00 00 
  8004204780:	be 59 04 00 00       	mov    $0x459,%esi
  8004204785:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420478c:	00 00 00 
  800420478f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204794:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420479b:	00 00 00 
  800420479e:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  80042047a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042047a5:	48 89 c7             	mov    %rax,%rdi
  80042047a8:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  80042047af:	00 00 00 
  80042047b2:	ff d0                	callq  *%rax
  80042047b4:	48 ba b0 17 4a 04 80 	movabs $0x80044a17b0,%rdx
  80042047bb:	00 00 00 
  80042047be:	48 8b 12             	mov    (%rdx),%rdx
  80042047c1:	48 c1 e2 0c          	shl    $0xc,%rdx
  80042047c5:	48 39 d0             	cmp    %rdx,%rax
  80042047c8:	72 35                	jb     80042047ff <check_page_alloc+0x50d>
  80042047ca:	48 b9 fd 76 21 04 80 	movabs $0x80042176fd,%rcx
  80042047d1:	00 00 00 
  80042047d4:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042047db:	00 00 00 
  80042047de:	be 5a 04 00 00       	mov    $0x45a,%esi
  80042047e3:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042047ea:	00 00 00 
  80042047ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047f2:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042047f9:	00 00 00 
  80042047fc:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  80042047ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204803:	48 89 c7             	mov    %rax,%rdi
  8004204806:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  800420480d:	00 00 00 
  8004204810:	ff d0                	callq  *%rax
  8004204812:	48 ba b0 17 4a 04 80 	movabs $0x80044a17b0,%rdx
  8004204819:	00 00 00 
  800420481c:	48 8b 12             	mov    (%rdx),%rdx
  800420481f:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204823:	48 39 d0             	cmp    %rdx,%rax
  8004204826:	72 35                	jb     800420485d <check_page_alloc+0x56b>
  8004204828:	48 b9 1a 77 21 04 80 	movabs $0x800421771a,%rcx
  800420482f:	00 00 00 
  8004204832:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204839:	00 00 00 
  800420483c:	be 5b 04 00 00       	mov    $0x45b,%esi
  8004204841:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204848:	00 00 00 
  800420484b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204850:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204857:	00 00 00 
  800420485a:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  800420485d:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004204864:	00 00 00 
  8004204867:	48 8b 00             	mov    (%rax),%rax
  800420486a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  800420486e:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004204875:	00 00 00 
  8004204878:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  800420487f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204884:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  800420488b:	00 00 00 
  800420488e:	ff d0                	callq  *%rax
  8004204890:	48 85 c0             	test   %rax,%rax
  8004204893:	74 35                	je     80042048ca <check_page_alloc+0x5d8>
  8004204895:	48 b9 37 77 21 04 80 	movabs $0x8004217737,%rcx
  800420489c:	00 00 00 
  800420489f:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042048a6:	00 00 00 
  80042048a9:	be 62 04 00 00       	mov    $0x462,%esi
  80042048ae:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042048b5:	00 00 00 
  80042048b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048bd:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042048c4:	00 00 00 
  80042048c7:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  80042048ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048ce:	48 89 c7             	mov    %rax,%rdi
  80042048d1:	48 b8 55 30 20 04 80 	movabs $0x8004203055,%rax
  80042048d8:	00 00 00 
  80042048db:	ff d0                	callq  *%rax
	page_free(pp1);
  80042048dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042048e1:	48 89 c7             	mov    %rax,%rdi
  80042048e4:	48 b8 55 30 20 04 80 	movabs $0x8004203055,%rax
  80042048eb:	00 00 00 
  80042048ee:	ff d0                	callq  *%rax
	page_free(pp2);
  80042048f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042048f4:	48 89 c7             	mov    %rax,%rdi
  80042048f7:	48 b8 55 30 20 04 80 	movabs $0x8004203055,%rax
  80042048fe:	00 00 00 
  8004204901:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204903:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420490a:	00 
  800420490b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420490f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204913:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204917:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  800420491b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204920:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  8004204927:	00 00 00 
  800420492a:	ff d0                	callq  *%rax
  800420492c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204930:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204935:	75 35                	jne    800420496c <check_page_alloc+0x67a>
  8004204937:	48 b9 67 76 21 04 80 	movabs $0x8004217667,%rcx
  800420493e:	00 00 00 
  8004204941:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204948:	00 00 00 
  800420494b:	be 69 04 00 00       	mov    $0x469,%esi
  8004204950:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204957:	00 00 00 
  800420495a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420495f:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204966:	00 00 00 
  8004204969:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  800420496c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204971:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  8004204978:	00 00 00 
  800420497b:	ff d0                	callq  *%rax
  800420497d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204981:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204986:	75 35                	jne    80042049bd <check_page_alloc+0x6cb>
  8004204988:	48 b9 7d 76 21 04 80 	movabs $0x800421767d,%rcx
  800420498f:	00 00 00 
  8004204992:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204999:	00 00 00 
  800420499c:	be 6a 04 00 00       	mov    $0x46a,%esi
  80042049a1:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042049a8:	00 00 00 
  80042049ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049b0:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042049b7:	00 00 00 
  80042049ba:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  80042049bd:	bf 00 00 00 00       	mov    $0x0,%edi
  80042049c2:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  80042049c9:	00 00 00 
  80042049cc:	ff d0                	callq  *%rax
  80042049ce:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042049d2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042049d7:	75 35                	jne    8004204a0e <check_page_alloc+0x71c>
  80042049d9:	48 b9 93 76 21 04 80 	movabs $0x8004217693,%rcx
  80042049e0:	00 00 00 
  80042049e3:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042049ea:	00 00 00 
  80042049ed:	be 6b 04 00 00       	mov    $0x46b,%esi
  80042049f2:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042049f9:	00 00 00 
  80042049fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a01:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204a08:	00 00 00 
  8004204a0b:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204a0e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204a13:	75 35                	jne    8004204a4a <check_page_alloc+0x758>
  8004204a15:	48 b9 a9 76 21 04 80 	movabs $0x80042176a9,%rcx
  8004204a1c:	00 00 00 
  8004204a1f:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204a26:	00 00 00 
  8004204a29:	be 6c 04 00 00       	mov    $0x46c,%esi
  8004204a2e:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204a35:	00 00 00 
  8004204a38:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a3d:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204a44:	00 00 00 
  8004204a47:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204a4a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204a4f:	74 0a                	je     8004204a5b <check_page_alloc+0x769>
  8004204a51:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a55:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204a59:	75 35                	jne    8004204a90 <check_page_alloc+0x79e>
  8004204a5b:	48 b9 ad 76 21 04 80 	movabs $0x80042176ad,%rcx
  8004204a62:	00 00 00 
  8004204a65:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204a6c:	00 00 00 
  8004204a6f:	be 6d 04 00 00       	mov    $0x46d,%esi
  8004204a74:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204a7b:	00 00 00 
  8004204a7e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a83:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204a8a:	00 00 00 
  8004204a8d:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204a90:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204a95:	74 14                	je     8004204aab <check_page_alloc+0x7b9>
  8004204a97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204a9b:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204a9f:	74 0a                	je     8004204aab <check_page_alloc+0x7b9>
  8004204aa1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204aa5:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204aa9:	75 35                	jne    8004204ae0 <check_page_alloc+0x7ee>
  8004204aab:	48 b9 c0 76 21 04 80 	movabs $0x80042176c0,%rcx
  8004204ab2:	00 00 00 
  8004204ab5:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204abc:	00 00 00 
  8004204abf:	be 6e 04 00 00       	mov    $0x46e,%esi
  8004204ac4:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204acb:	00 00 00 
  8004204ace:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ad3:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204ada:	00 00 00 
  8004204add:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004204ae0:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204ae5:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  8004204aec:	00 00 00 
  8004204aef:	ff d0                	callq  *%rax
  8004204af1:	48 85 c0             	test   %rax,%rax
  8004204af4:	74 35                	je     8004204b2b <check_page_alloc+0x839>
  8004204af6:	48 b9 37 77 21 04 80 	movabs $0x8004217737,%rcx
  8004204afd:	00 00 00 
  8004204b00:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204b07:	00 00 00 
  8004204b0a:	be 6f 04 00 00       	mov    $0x46f,%esi
  8004204b0f:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204b16:	00 00 00 
  8004204b19:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b1e:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204b25:	00 00 00 
  8004204b28:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  8004204b2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b2f:	48 89 c7             	mov    %rax,%rdi
  8004204b32:	48 b8 91 1c 20 04 80 	movabs $0x8004201c91,%rax
  8004204b39:	00 00 00 
  8004204b3c:	ff d0                	callq  *%rax
  8004204b3e:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204b43:	be 01 00 00 00       	mov    $0x1,%esi
  8004204b48:	48 89 c7             	mov    %rax,%rdi
  8004204b4b:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004204b52:	00 00 00 
  8004204b55:	ff d0                	callq  *%rax
	page_free(pp0);
  8004204b57:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b5b:	48 89 c7             	mov    %rax,%rdi
  8004204b5e:	48 b8 55 30 20 04 80 	movabs $0x8004203055,%rax
  8004204b65:	00 00 00 
  8004204b68:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  8004204b6a:	bf 01 00 00 00       	mov    $0x1,%edi
  8004204b6f:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  8004204b76:	00 00 00 
  8004204b79:	ff d0                	callq  *%rax
  8004204b7b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204b7f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204b84:	75 35                	jne    8004204bbb <check_page_alloc+0x8c9>
  8004204b86:	48 b9 46 77 21 04 80 	movabs $0x8004217746,%rcx
  8004204b8d:	00 00 00 
  8004204b90:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204b97:	00 00 00 
  8004204b9a:	be 74 04 00 00       	mov    $0x474,%esi
  8004204b9f:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204ba6:	00 00 00 
  8004204ba9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bae:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204bb5:	00 00 00 
  8004204bb8:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  8004204bbb:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204bc0:	74 0a                	je     8004204bcc <check_page_alloc+0x8da>
  8004204bc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204bc6:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004204bca:	74 35                	je     8004204c01 <check_page_alloc+0x90f>
  8004204bcc:	48 b9 64 77 21 04 80 	movabs $0x8004217764,%rcx
  8004204bd3:	00 00 00 
  8004204bd6:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204bdd:	00 00 00 
  8004204be0:	be 75 04 00 00       	mov    $0x475,%esi
  8004204be5:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204bec:	00 00 00 
  8004204bef:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bf4:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204bfb:	00 00 00 
  8004204bfe:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004204c01:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204c05:	48 89 c7             	mov    %rax,%rdi
  8004204c08:	48 b8 91 1c 20 04 80 	movabs $0x8004201c91,%rax
  8004204c0f:	00 00 00 
  8004204c12:	ff d0                	callq  *%rax
  8004204c14:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  8004204c18:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004204c1f:	eb 4d                	jmp    8004204c6e <check_page_alloc+0x97c>
		assert(c[i] == 0);
  8004204c21:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004204c24:	48 63 d0             	movslq %eax,%rdx
  8004204c27:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204c2b:	48 01 d0             	add    %rdx,%rax
  8004204c2e:	0f b6 00             	movzbl (%rax),%eax
  8004204c31:	84 c0                	test   %al,%al
  8004204c33:	74 35                	je     8004204c6a <check_page_alloc+0x978>
  8004204c35:	48 b9 74 77 21 04 80 	movabs $0x8004217774,%rcx
  8004204c3c:	00 00 00 
  8004204c3f:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204c46:	00 00 00 
  8004204c49:	be 78 04 00 00       	mov    $0x478,%esi
  8004204c4e:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204c55:	00 00 00 
  8004204c58:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c5d:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204c64:	00 00 00 
  8004204c67:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  8004204c6a:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004204c6e:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  8004204c75:	7e aa                	jle    8004204c21 <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  8004204c77:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004204c7e:	00 00 00 
  8004204c81:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204c85:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  8004204c88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c8c:	48 89 c7             	mov    %rax,%rdi
  8004204c8f:	48 b8 55 30 20 04 80 	movabs $0x8004203055,%rax
  8004204c96:	00 00 00 
  8004204c99:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204c9b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204c9f:	48 89 c7             	mov    %rax,%rdi
  8004204ca2:	48 b8 55 30 20 04 80 	movabs $0x8004203055,%rax
  8004204ca9:	00 00 00 
  8004204cac:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204cae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204cb2:	48 89 c7             	mov    %rax,%rdi
  8004204cb5:	48 b8 55 30 20 04 80 	movabs $0x8004203055,%rax
  8004204cbc:	00 00 00 
  8004204cbf:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  8004204cc1:	48 bf 80 77 21 04 80 	movabs $0x8004217780,%rdi
  8004204cc8:	00 00 00 
  8004204ccb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204cd0:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004204cd7:	00 00 00 
  8004204cda:	ff d2                	callq  *%rdx
}
  8004204cdc:	c9                   	leaveq 
  8004204cdd:	c3                   	retq   

0000008004204cde <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  8004204cde:	55                   	push   %rbp
  8004204cdf:	48 89 e5             	mov    %rsp,%rbp
  8004204ce2:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004204ce9:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  8004204cf0:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004204cf7:	00 00 00 
  8004204cfa:	48 8b 00             	mov    (%rax),%rax
  8004204cfd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004204d01:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004204d08:	00 
  8004204d09:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004204d10:	00 00 00 
  8004204d13:	48 8b 00             	mov    (%rax),%rax
  8004204d16:	48 c1 e0 04          	shl    $0x4,%rax
  8004204d1a:	48 89 c2             	mov    %rax,%rdx
  8004204d1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204d21:	48 01 d0             	add    %rdx,%rax
  8004204d24:	48 83 e8 01          	sub    $0x1,%rax
  8004204d28:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004204d2c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204d30:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204d35:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004204d39:	48 89 d0             	mov    %rdx,%rax
  8004204d3c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204d40:	48 29 c2             	sub    %rax,%rdx
  8004204d43:	48 89 d0             	mov    %rdx,%rax
  8004204d46:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  8004204d4a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204d51:	00 
  8004204d52:	e9 d4 00 00 00       	jmpq   8004204e2b <check_boot_pml4e+0x14d>
		 //cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  8004204d57:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  8004204d5e:	00 00 00 
  8004204d61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204d65:	48 01 c2             	add    %rax,%rdx
  8004204d68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d6c:	48 89 d6             	mov    %rdx,%rsi
  8004204d6f:	48 89 c7             	mov    %rax,%rdi
  8004204d72:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  8004204d79:	00 00 00 
  8004204d7c:	ff d0                	callq  *%rax
  8004204d7e:	48 ba b8 17 4a 04 80 	movabs $0x80044a17b8,%rdx
  8004204d85:	00 00 00 
  8004204d88:	48 8b 12             	mov    (%rdx),%rdx
  8004204d8b:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004204d8f:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204d96:	00 00 00 
  8004204d99:	48 39 55 d0          	cmp    %rdx,-0x30(%rbp)
  8004204d9d:	77 32                	ja     8004204dd1 <check_boot_pml4e+0xf3>
  8004204d9f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204da3:	48 89 c1             	mov    %rax,%rcx
  8004204da6:	48 ba b0 73 21 04 80 	movabs $0x80042173b0,%rdx
  8004204dad:	00 00 00 
  8004204db0:	be 97 04 00 00       	mov    $0x497,%esi
  8004204db5:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204dbc:	00 00 00 
  8004204dbf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204dc4:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204dcb:	00 00 00 
  8004204dce:	41 ff d0             	callq  *%r8
  8004204dd1:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004204dd8:	ff ff ff 
  8004204ddb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204ddf:	48 01 d1             	add    %rdx,%rcx
  8004204de2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204de6:	48 01 ca             	add    %rcx,%rdx
  8004204de9:	48 39 d0             	cmp    %rdx,%rax
  8004204dec:	74 35                	je     8004204e23 <check_boot_pml4e+0x145>
  8004204dee:	48 b9 a0 77 21 04 80 	movabs $0x80042177a0,%rcx
  8004204df5:	00 00 00 
  8004204df8:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204dff:	00 00 00 
  8004204e02:	be 97 04 00 00       	mov    $0x497,%esi
  8004204e07:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204e0e:	00 00 00 
  8004204e11:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e16:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204e1d:	00 00 00 
  8004204e20:	41 ff d0             	callq  *%r8
	uint64_t i, n;

	pml4e = boot_pml4e;
	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004204e23:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204e2a:	00 
  8004204e2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e2f:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204e33:	0f 82 1e ff ff ff    	jb     8004204d57 <check_boot_pml4e+0x79>
		 //cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004204e39:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  8004204e40:	00 
  8004204e41:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204e45:	48 05 ff 7f 04 00    	add    $0x47fff,%rax
  8004204e4b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204e4f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204e53:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204e58:	48 f7 75 c8          	divq   -0x38(%rbp)
  8004204e5c:	48 89 d0             	mov    %rdx,%rax
  8004204e5f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004204e63:	48 29 c2             	sub    %rax,%rdx
  8004204e66:	48 89 d0             	mov    %rdx,%rax
  8004204e69:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  8004204e6d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204e74:	00 
  8004204e75:	e9 d4 00 00 00       	jmpq   8004204f4e <check_boot_pml4e+0x270>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  8004204e7a:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8004204e81:	00 00 00 
  8004204e84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e88:	48 01 c2             	add    %rax,%rdx
  8004204e8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204e8f:	48 89 d6             	mov    %rdx,%rsi
  8004204e92:	48 89 c7             	mov    %rax,%rdi
  8004204e95:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  8004204e9c:	00 00 00 
  8004204e9f:	ff d0                	callq  *%rax
  8004204ea1:	48 ba 50 02 4a 04 80 	movabs $0x80044a0250,%rdx
  8004204ea8:	00 00 00 
  8004204eab:	48 8b 12             	mov    (%rdx),%rdx
  8004204eae:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004204eb2:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204eb9:	00 00 00 
  8004204ebc:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  8004204ec0:	77 32                	ja     8004204ef4 <check_boot_pml4e+0x216>
  8004204ec2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204ec6:	48 89 c1             	mov    %rax,%rcx
  8004204ec9:	48 ba b0 73 21 04 80 	movabs $0x80042173b0,%rdx
  8004204ed0:	00 00 00 
  8004204ed3:	be 9d 04 00 00       	mov    $0x49d,%esi
  8004204ed8:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204edf:	00 00 00 
  8004204ee2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ee7:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204eee:	00 00 00 
  8004204ef1:	41 ff d0             	callq  *%r8
  8004204ef4:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004204efb:	ff ff ff 
  8004204efe:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004204f02:	48 01 d1             	add    %rdx,%rcx
  8004204f05:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204f09:	48 01 ca             	add    %rcx,%rdx
  8004204f0c:	48 39 d0             	cmp    %rdx,%rax
  8004204f0f:	74 35                	je     8004204f46 <check_boot_pml4e+0x268>
  8004204f11:	48 b9 d8 77 21 04 80 	movabs $0x80042177d8,%rcx
  8004204f18:	00 00 00 
  8004204f1b:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204f22:	00 00 00 
  8004204f25:	be 9d 04 00 00       	mov    $0x49d,%esi
  8004204f2a:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204f31:	00 00 00 
  8004204f34:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f39:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204f40:	00 00 00 
  8004204f43:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  8004204f46:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204f4d:	00 
  8004204f4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f52:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204f56:	0f 82 1e ff ff ff    	jb     8004204e7a <check_boot_pml4e+0x19c>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204f5c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204f63:	00 
  8004204f64:	eb 6a                	jmp    8004204fd0 <check_boot_pml4e+0x2f2>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  8004204f66:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204f6d:	00 00 00 
  8004204f70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f74:	48 01 c2             	add    %rax,%rdx
  8004204f77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204f7b:	48 89 d6             	mov    %rdx,%rsi
  8004204f7e:	48 89 c7             	mov    %rax,%rdi
  8004204f81:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  8004204f88:	00 00 00 
  8004204f8b:	ff d0                	callq  *%rax
  8004204f8d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204f91:	74 35                	je     8004204fc8 <check_boot_pml4e+0x2ea>
  8004204f93:	48 b9 10 78 21 04 80 	movabs $0x8004217810,%rcx
  8004204f9a:	00 00 00 
  8004204f9d:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004204fa4:	00 00 00 
  8004204fa7:	be a1 04 00 00       	mov    $0x4a1,%esi
  8004204fac:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004204fb3:	00 00 00 
  8004204fb6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fbb:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004204fc2:	00 00 00 
  8004204fc5:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204fc8:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204fcf:	00 
  8004204fd0:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004204fd7:	00 00 00 
  8004204fda:	48 8b 00             	mov    (%rax),%rax
  8004204fdd:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204fe1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204fe5:	0f 87 7b ff ff ff    	ja     8004204f66 <check_boot_pml4e+0x288>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004204feb:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004204ff2:	00 
  8004204ff3:	e9 a1 01 00 00       	jmpq   8004205199 <check_boot_pml4e+0x4bb>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004204ff8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204ffc:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004205000:	48 89 d0             	mov    %rdx,%rax
  8004205003:	48 01 c0             	add    %rax,%rax
  8004205006:	48 01 d0             	add    %rdx,%rax
  8004205009:	48 c1 e0 0f          	shl    $0xf,%rax
  800420500d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205014:	00 00 00 
  8004205017:	48 29 c2             	sub    %rax,%rdx
  800420501a:	48 89 d0             	mov    %rdx,%rax
  800420501d:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205021:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205028:	00 
  8004205029:	e9 e0 00 00 00       	jmpq   800420510e <check_boot_pml4e+0x430>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  800420502e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205032:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004205036:	48 01 d0             	add    %rdx,%rax
  8004205039:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  8004205040:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205044:	48 89 d6             	mov    %rdx,%rsi
  8004205047:	48 89 c7             	mov    %rax,%rdi
  800420504a:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  8004205051:	00 00 00 
  8004205054:	ff d0                	callq  *%rax
  8004205056:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420505a:	48 89 d1             	mov    %rdx,%rcx
  800420505d:	48 c1 e1 10          	shl    $0x10,%rcx
  8004205061:	48 ba 00 40 4a 04 80 	movabs $0x80044a4000,%rdx
  8004205068:	00 00 00 
  800420506b:	48 01 ca             	add    %rcx,%rdx
  800420506e:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004205072:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004205079:	00 00 00 
  800420507c:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  8004205080:	77 32                	ja     80042050b4 <check_boot_pml4e+0x3d6>
  8004205082:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205086:	48 89 c1             	mov    %rax,%rcx
  8004205089:	48 ba b0 73 21 04 80 	movabs $0x80042173b0,%rdx
  8004205090:	00 00 00 
  8004205093:	be a9 04 00 00       	mov    $0x4a9,%esi
  8004205098:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420509f:	00 00 00 
  80042050a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050a7:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042050ae:	00 00 00 
  80042050b1:	41 ff d0             	callq  *%r8
  80042050b4:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042050bb:	ff ff ff 
  80042050be:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042050c2:	48 01 d1             	add    %rdx,%rcx
  80042050c5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042050c9:	48 01 ca             	add    %rcx,%rdx
  80042050cc:	48 39 d0             	cmp    %rdx,%rax
  80042050cf:	74 35                	je     8004205106 <check_boot_pml4e+0x428>
  80042050d1:	48 b9 38 78 21 04 80 	movabs $0x8004217838,%rcx
  80042050d8:	00 00 00 
  80042050db:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042050e2:	00 00 00 
  80042050e5:	be a9 04 00 00       	mov    $0x4a9,%esi
  80042050ea:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042050f1:	00 00 00 
  80042050f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050f9:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205100:	00 00 00 
  8004205103:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205106:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420510d:	00 
  800420510e:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  8004205115:	00 
  8004205116:	0f 86 12 ff ff ff    	jbe    800420502e <check_boot_pml4e+0x350>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  800420511c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205123:	00 
  8004205124:	eb 64                	jmp    800420518a <check_boot_pml4e+0x4ac>
			assert(check_va2pa(pml4e, base + i) == ~0);
  8004205126:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420512a:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420512e:	48 01 c2             	add    %rax,%rdx
  8004205131:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205135:	48 89 d6             	mov    %rdx,%rsi
  8004205138:	48 89 c7             	mov    %rax,%rdi
  800420513b:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  8004205142:	00 00 00 
  8004205145:	ff d0                	callq  *%rax
  8004205147:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420514b:	74 35                	je     8004205182 <check_boot_pml4e+0x4a4>
  800420514d:	48 b9 80 78 21 04 80 	movabs $0x8004217880,%rcx
  8004205154:	00 00 00 
  8004205157:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420515e:	00 00 00 
  8004205161:	be ab 04 00 00       	mov    $0x4ab,%esi
  8004205166:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420516d:	00 00 00 
  8004205170:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205175:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420517c:	00 00 00 
  800420517f:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004205182:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205189:	00 
  800420518a:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  8004205191:	00 
  8004205192:	76 92                	jbe    8004205126 <check_boot_pml4e+0x448>
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004205194:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004205199:	48 83 7d f0 07       	cmpq   $0x7,-0x10(%rbp)
  800420519e:	0f 86 54 fe ff ff    	jbe    8004204ff8 <check_boot_pml4e+0x31a>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  80042051a4:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  80042051ab:	00 00 00 
  80042051ae:	48 8b 00             	mov    (%rax),%rax
  80042051b1:	48 83 c0 08          	add    $0x8,%rax
  80042051b5:	48 8b 00             	mov    (%rax),%rax
  80042051b8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042051be:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  80042051c2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042051c6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042051ca:	89 45 9c             	mov    %eax,-0x64(%rbp)
  80042051cd:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042051d0:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  80042051d7:	00 00 00 
  80042051da:	48 8b 00             	mov    (%rax),%rax
  80042051dd:	48 39 c2             	cmp    %rax,%rdx
  80042051e0:	72 32                	jb     8004205214 <check_boot_pml4e+0x536>
  80042051e2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042051e6:	48 89 c1             	mov    %rax,%rcx
  80042051e9:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  80042051f0:	00 00 00 
  80042051f3:	be ae 04 00 00       	mov    $0x4ae,%esi
  80042051f8:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042051ff:	00 00 00 
  8004205202:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205207:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420520e:	00 00 00 
  8004205211:	41 ff d0             	callq  *%r8
  8004205214:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420521b:	00 00 00 
  800420521e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205222:	48 01 d0             	add    %rdx,%rax
  8004205225:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004205229:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420522d:	48 8b 00             	mov    (%rax),%rax
  8004205230:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205236:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  800420523a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420523e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205242:	89 45 84             	mov    %eax,-0x7c(%rbp)
  8004205245:	8b 55 84             	mov    -0x7c(%rbp),%edx
  8004205248:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  800420524f:	00 00 00 
  8004205252:	48 8b 00             	mov    (%rax),%rax
  8004205255:	48 39 c2             	cmp    %rax,%rdx
  8004205258:	72 32                	jb     800420528c <check_boot_pml4e+0x5ae>
  800420525a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420525e:	48 89 c1             	mov    %rax,%rcx
  8004205261:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004205268:	00 00 00 
  800420526b:	be af 04 00 00       	mov    $0x4af,%esi
  8004205270:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205277:	00 00 00 
  800420527a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420527f:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205286:	00 00 00 
  8004205289:	41 ff d0             	callq  *%r8
  800420528c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205293:	00 00 00 
  8004205296:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420529a:	48 01 d0             	add    %rdx,%rax
  800420529d:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  80042052a4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042052ab:	00 
  80042052ac:	e9 50 01 00 00       	jmpq   8004205401 <check_boot_pml4e+0x723>
		switch (i) {
  80042052b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052b5:	48 83 f8 04          	cmp    $0x4,%rax
  80042052b9:	72 67                	jb     8004205322 <check_boot_pml4e+0x644>
  80042052bb:	48 83 f8 05          	cmp    $0x5,%rax
  80042052bf:	76 06                	jbe    80042052c7 <check_boot_pml4e+0x5e9>
  80042052c1:	48 83 f8 1f          	cmp    $0x1f,%rax
  80042052c5:	75 5b                	jne    8004205322 <check_boot_pml4e+0x644>
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
  80042052c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052cb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042052d2:	00 
  80042052d3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042052da:	48 01 d0             	add    %rdx,%rax
  80042052dd:	48 8b 00             	mov    (%rax),%rax
  80042052e0:	83 e0 01             	and    $0x1,%eax
  80042052e3:	48 85 c0             	test   %rax,%rax
  80042052e6:	75 35                	jne    800420531d <check_boot_pml4e+0x63f>
  80042052e8:	48 b9 a3 78 21 04 80 	movabs $0x80042178a3,%rcx
  80042052ef:	00 00 00 
  80042052f2:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042052f9:	00 00 00 
  80042052fc:	be b7 04 00 00       	mov    $0x4b7,%esi
  8004205301:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205308:	00 00 00 
  800420530b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205310:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205317:	00 00 00 
  800420531a:	41 ff d0             	callq  *%r8
			break;
  800420531d:	e9 da 00 00 00       	jmpq   80042053fc <check_boot_pml4e+0x71e>
		default:
			if (i >= PDX(KERNBASE)) {
  8004205322:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  8004205327:	0f 86 ce 00 00 00    	jbe    80042053fb <check_boot_pml4e+0x71d>
				if (pgdir[i] & PTE_P)
  800420532d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205331:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205338:	00 
  8004205339:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205340:	48 01 d0             	add    %rdx,%rax
  8004205343:	48 8b 00             	mov    (%rax),%rax
  8004205346:	83 e0 01             	and    $0x1,%eax
  8004205349:	48 85 c0             	test   %rax,%rax
  800420534c:	74 5a                	je     80042053a8 <check_boot_pml4e+0x6ca>
					assert(pgdir[i] & PTE_W);
  800420534e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205352:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205359:	00 
  800420535a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205361:	48 01 d0             	add    %rdx,%rax
  8004205364:	48 8b 00             	mov    (%rax),%rax
  8004205367:	83 e0 02             	and    $0x2,%eax
  800420536a:	48 85 c0             	test   %rax,%rax
  800420536d:	0f 85 88 00 00 00    	jne    80042053fb <check_boot_pml4e+0x71d>
  8004205373:	48 b9 b4 78 21 04 80 	movabs $0x80042178b4,%rcx
  800420537a:	00 00 00 
  800420537d:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205384:	00 00 00 
  8004205387:	be bc 04 00 00       	mov    $0x4bc,%esi
  800420538c:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205393:	00 00 00 
  8004205396:	b8 00 00 00 00       	mov    $0x0,%eax
  800420539b:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042053a2:	00 00 00 
  80042053a5:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  80042053a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042053ac:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042053b3:	00 
  80042053b4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042053bb:	48 01 d0             	add    %rdx,%rax
  80042053be:	48 8b 00             	mov    (%rax),%rax
  80042053c1:	48 85 c0             	test   %rax,%rax
  80042053c4:	74 35                	je     80042053fb <check_boot_pml4e+0x71d>
  80042053c6:	48 b9 c5 78 21 04 80 	movabs $0x80042178c5,%rcx
  80042053cd:	00 00 00 
  80042053d0:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042053d7:	00 00 00 
  80042053da:	be be 04 00 00       	mov    $0x4be,%esi
  80042053df:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042053e6:	00 00 00 
  80042053e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053ee:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042053f5:	00 00 00 
  80042053f8:	41 ff d0             	callq  *%r8
			} 
			break;
  80042053fb:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  80042053fc:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004205401:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  8004205408:	00 
  8004205409:	0f 86 a2 fe ff ff    	jbe    80042052b1 <check_boot_pml4e+0x5d3>
					assert(pgdir[i] == 0);
			} 
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  800420540f:	48 bf d8 78 21 04 80 	movabs $0x80042178d8,%rdi
  8004205416:	00 00 00 
  8004205419:	b8 00 00 00 00       	mov    $0x0,%eax
  800420541e:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004205425:	00 00 00 
  8004205428:	ff d2                	callq  *%rdx
}
  800420542a:	c9                   	leaveq 
  800420542b:	c3                   	retq   

000000800420542c <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  800420542c:	55                   	push   %rbp
  800420542d:	48 89 e5             	mov    %rsp,%rbp
  8004205430:	48 83 ec 60          	sub    $0x60,%rsp
  8004205434:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004205438:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	pml4e = &pml4e[PML4(va)];
  800420543c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205440:	48 c1 e8 27          	shr    $0x27,%rax
  8004205444:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205449:	48 c1 e0 03          	shl    $0x3,%rax
  800420544d:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	//cprintf("pml4e %x %x \n" , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  8004205451:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205455:	48 8b 00             	mov    (%rax),%rax
  8004205458:	83 e0 01             	and    $0x1,%eax
  800420545b:	48 85 c0             	test   %rax,%rax
  800420545e:	75 0c                	jne    800420546c <check_va2pa+0x40>
		return ~0;
  8004205460:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205467:	e9 38 02 00 00       	jmpq   80042056a4 <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  800420546c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205470:	48 8b 00             	mov    (%rax),%rax
  8004205473:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205479:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420547d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205481:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205485:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004205488:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420548b:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004205492:	00 00 00 
  8004205495:	48 8b 00             	mov    (%rax),%rax
  8004205498:	48 39 c2             	cmp    %rax,%rdx
  800420549b:	72 32                	jb     80042054cf <check_va2pa+0xa3>
  800420549d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054a1:	48 89 c1             	mov    %rax,%rcx
  80042054a4:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  80042054ab:	00 00 00 
  80042054ae:	be d5 04 00 00       	mov    $0x4d5,%esi
  80042054b3:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042054ba:	00 00 00 
  80042054bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054c2:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042054c9:	00 00 00 
  80042054cc:	41 ff d0             	callq  *%r8
  80042054cf:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042054d6:	00 00 00 
  80042054d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054dd:	48 01 d0             	add    %rdx,%rax
  80042054e0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//cprintf("pdpe %x %x \n" , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  80042054e4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042054e8:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042054ec:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042054f1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042054f8:	00 
  80042054f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042054fd:	48 01 d0             	add    %rdx,%rax
  8004205500:	48 8b 00             	mov    (%rax),%rax
  8004205503:	83 e0 01             	and    $0x1,%eax
  8004205506:	48 85 c0             	test   %rax,%rax
  8004205509:	75 0c                	jne    8004205517 <check_va2pa+0xeb>
		return ~0;
  800420550b:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205512:	e9 8d 01 00 00       	jmpq   80042056a4 <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004205517:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420551b:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420551f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205524:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420552b:	00 
  800420552c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205530:	48 01 d0             	add    %rdx,%rax
  8004205533:	48 8b 00             	mov    (%rax),%rax
  8004205536:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420553c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205540:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205544:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205548:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420554b:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420554e:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004205555:	00 00 00 
  8004205558:	48 8b 00             	mov    (%rax),%rax
  800420555b:	48 39 c2             	cmp    %rax,%rdx
  800420555e:	72 32                	jb     8004205592 <check_va2pa+0x166>
  8004205560:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205564:	48 89 c1             	mov    %rax,%rcx
  8004205567:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  800420556e:	00 00 00 
  8004205571:	be d9 04 00 00       	mov    $0x4d9,%esi
  8004205576:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420557d:	00 00 00 
  8004205580:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205585:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420558c:	00 00 00 
  800420558f:	41 ff d0             	callq  *%r8
  8004205592:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205599:	00 00 00 
  800420559c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042055a0:	48 01 d0             	add    %rdx,%rax
  80042055a3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//cprintf("pde %x %x \n" , pde, *pde);
	pde = &pde[PDX(va)];
  80042055a7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042055ab:	48 c1 e8 15          	shr    $0x15,%rax
  80042055af:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042055b4:	48 c1 e0 03          	shl    $0x3,%rax
  80042055b8:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  80042055bc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042055c0:	48 8b 00             	mov    (%rax),%rax
  80042055c3:	83 e0 01             	and    $0x1,%eax
  80042055c6:	48 85 c0             	test   %rax,%rax
  80042055c9:	75 0c                	jne    80042055d7 <check_va2pa+0x1ab>
		return ~0;
  80042055cb:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042055d2:	e9 cd 00 00 00       	jmpq   80042056a4 <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  80042055d7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042055db:	48 8b 00             	mov    (%rax),%rax
  80042055de:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042055e4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042055e8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042055ec:	48 c1 e8 0c          	shr    $0xc,%rax
  80042055f0:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  80042055f3:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042055f6:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  80042055fd:	00 00 00 
  8004205600:	48 8b 00             	mov    (%rax),%rax
  8004205603:	48 39 c2             	cmp    %rax,%rdx
  8004205606:	72 32                	jb     800420563a <check_va2pa+0x20e>
  8004205608:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420560c:	48 89 c1             	mov    %rax,%rcx
  800420560f:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004205616:	00 00 00 
  8004205619:	be de 04 00 00       	mov    $0x4de,%esi
  800420561e:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205625:	00 00 00 
  8004205628:	b8 00 00 00 00       	mov    $0x0,%eax
  800420562d:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205634:	00 00 00 
  8004205637:	41 ff d0             	callq  *%r8
  800420563a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205641:	00 00 00 
  8004205644:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205648:	48 01 d0             	add    %rdx,%rax
  800420564b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	//cprintf("pte %x %x %x \n" , pte, *pte, pte[PTX(va)]);
	if (!(pte[PTX(va)] & PTE_P))
  800420564f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205653:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205657:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420565c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205663:	00 
  8004205664:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205668:	48 01 d0             	add    %rdx,%rax
  800420566b:	48 8b 00             	mov    (%rax),%rax
  800420566e:	83 e0 01             	and    $0x1,%eax
  8004205671:	48 85 c0             	test   %rax,%rax
  8004205674:	75 09                	jne    800420567f <check_va2pa+0x253>
		return ~0;
  8004205676:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420567d:	eb 25                	jmp    80042056a4 <check_va2pa+0x278>
	//cprintf("page Tale Index %x %x \n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  800420567f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205683:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205687:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420568c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205693:	00 
  8004205694:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205698:	48 01 d0             	add    %rdx,%rax
  800420569b:	48 8b 00             	mov    (%rax),%rax
  800420569e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  80042056a4:	c9                   	leaveq 
  80042056a5:	c3                   	retq   

00000080042056a6 <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  80042056a6:	55                   	push   %rbp
  80042056a7:	48 89 e5             	mov    %rsp,%rbp
  80042056aa:	53                   	push   %rbx
  80042056ab:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  80042056b2:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042056b9:	00 
  80042056ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042056be:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042056c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042056c6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042056ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042056ce:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042056d2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042056d6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042056da:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042056de:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  80042056e2:	bf 00 00 00 00       	mov    $0x0,%edi
  80042056e7:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  80042056ee:	00 00 00 
  80042056f1:	ff d0                	callq  *%rax
  80042056f3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  80042056f7:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042056fc:	75 35                	jne    8004205733 <page_check+0x8d>
  80042056fe:	48 b9 f7 78 21 04 80 	movabs $0x80042178f7,%rcx
  8004205705:	00 00 00 
  8004205708:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420570f:	00 00 00 
  8004205712:	be f4 04 00 00       	mov    $0x4f4,%esi
  8004205717:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420571e:	00 00 00 
  8004205721:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205726:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420572d:	00 00 00 
  8004205730:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004205733:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205738:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  800420573f:	00 00 00 
  8004205742:	ff d0                	callq  *%rax
  8004205744:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205748:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800420574d:	75 35                	jne    8004205784 <page_check+0xde>
  800420574f:	48 b9 0b 79 21 04 80 	movabs $0x800421790b,%rcx
  8004205756:	00 00 00 
  8004205759:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205760:	00 00 00 
  8004205763:	be f5 04 00 00       	mov    $0x4f5,%esi
  8004205768:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420576f:	00 00 00 
  8004205772:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205777:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420577e:	00 00 00 
  8004205781:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  8004205784:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205789:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  8004205790:	00 00 00 
  8004205793:	ff d0                	callq  *%rax
  8004205795:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205799:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420579e:	75 35                	jne    80042057d5 <page_check+0x12f>
  80042057a0:	48 b9 1f 79 21 04 80 	movabs $0x800421791f,%rcx
  80042057a7:	00 00 00 
  80042057aa:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042057b1:	00 00 00 
  80042057b4:	be f6 04 00 00       	mov    $0x4f6,%esi
  80042057b9:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042057c0:	00 00 00 
  80042057c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057c8:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042057cf:	00 00 00 
  80042057d2:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  80042057d5:	bf 00 00 00 00       	mov    $0x0,%edi
  80042057da:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  80042057e1:	00 00 00 
  80042057e4:	ff d0                	callq  *%rax
  80042057e6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042057ea:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042057ef:	75 35                	jne    8004205826 <page_check+0x180>
  80042057f1:	48 b9 33 79 21 04 80 	movabs $0x8004217933,%rcx
  80042057f8:	00 00 00 
  80042057fb:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205802:	00 00 00 
  8004205805:	be f7 04 00 00       	mov    $0x4f7,%esi
  800420580a:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205811:	00 00 00 
  8004205814:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205819:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205820:	00 00 00 
  8004205823:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  8004205826:	bf 00 00 00 00       	mov    $0x0,%edi
  800420582b:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  8004205832:	00 00 00 
  8004205835:	ff d0                	callq  *%rax
  8004205837:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420583b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205840:	75 35                	jne    8004205877 <page_check+0x1d1>
  8004205842:	48 b9 47 79 21 04 80 	movabs $0x8004217947,%rcx
  8004205849:	00 00 00 
  800420584c:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205853:	00 00 00 
  8004205856:	be f8 04 00 00       	mov    $0x4f8,%esi
  800420585b:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205862:	00 00 00 
  8004205865:	b8 00 00 00 00       	mov    $0x0,%eax
  800420586a:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205871:	00 00 00 
  8004205874:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  8004205877:	bf 00 00 00 00       	mov    $0x0,%edi
  800420587c:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  8004205883:	00 00 00 
  8004205886:	ff d0                	callq  *%rax
  8004205888:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420588c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205891:	75 35                	jne    80042058c8 <page_check+0x222>
  8004205893:	48 b9 5b 79 21 04 80 	movabs $0x800421795b,%rcx
  800420589a:	00 00 00 
  800420589d:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042058a4:	00 00 00 
  80042058a7:	be f9 04 00 00       	mov    $0x4f9,%esi
  80042058ac:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042058b3:	00 00 00 
  80042058b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058bb:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042058c2:	00 00 00 
  80042058c5:	41 ff d0             	callq  *%r8

	assert(pp0);
  80042058c8:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042058cd:	75 35                	jne    8004205904 <page_check+0x25e>
  80042058cf:	48 b9 a9 76 21 04 80 	movabs $0x80042176a9,%rcx
  80042058d6:	00 00 00 
  80042058d9:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042058e0:	00 00 00 
  80042058e3:	be fb 04 00 00       	mov    $0x4fb,%esi
  80042058e8:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042058ef:	00 00 00 
  80042058f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058f7:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042058fe:	00 00 00 
  8004205901:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004205904:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205909:	74 0a                	je     8004205915 <page_check+0x26f>
  800420590b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420590f:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205913:	75 35                	jne    800420594a <page_check+0x2a4>
  8004205915:	48 b9 ad 76 21 04 80 	movabs $0x80042176ad,%rcx
  800420591c:	00 00 00 
  800420591f:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205926:	00 00 00 
  8004205929:	be fc 04 00 00       	mov    $0x4fc,%esi
  800420592e:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205935:	00 00 00 
  8004205938:	b8 00 00 00 00       	mov    $0x0,%eax
  800420593d:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205944:	00 00 00 
  8004205947:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  800420594a:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420594f:	74 14                	je     8004205965 <page_check+0x2bf>
  8004205951:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205955:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205959:	74 0a                	je     8004205965 <page_check+0x2bf>
  800420595b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420595f:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205963:	75 35                	jne    800420599a <page_check+0x2f4>
  8004205965:	48 b9 c0 76 21 04 80 	movabs $0x80042176c0,%rcx
  800420596c:	00 00 00 
  800420596f:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205976:	00 00 00 
  8004205979:	be fd 04 00 00       	mov    $0x4fd,%esi
  800420597e:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205985:	00 00 00 
  8004205988:	b8 00 00 00 00       	mov    $0x0,%eax
  800420598d:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205994:	00 00 00 
  8004205997:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  800420599a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420599f:	74 1e                	je     80042059bf <page_check+0x319>
  80042059a1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042059a5:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042059a9:	74 14                	je     80042059bf <page_check+0x319>
  80042059ab:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042059af:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042059b3:	74 0a                	je     80042059bf <page_check+0x319>
  80042059b5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042059b9:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042059bd:	75 35                	jne    80042059f4 <page_check+0x34e>
  80042059bf:	48 b9 70 79 21 04 80 	movabs $0x8004217970,%rcx
  80042059c6:	00 00 00 
  80042059c9:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042059d0:	00 00 00 
  80042059d3:	be fe 04 00 00       	mov    $0x4fe,%esi
  80042059d8:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042059df:	00 00 00 
  80042059e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059e7:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042059ee:	00 00 00 
  80042059f1:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  80042059f4:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042059f9:	74 28                	je     8004205a23 <page_check+0x37d>
  80042059fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042059ff:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205a03:	74 1e                	je     8004205a23 <page_check+0x37d>
  8004205a05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a09:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205a0d:	74 14                	je     8004205a23 <page_check+0x37d>
  8004205a0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a13:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205a17:	74 0a                	je     8004205a23 <page_check+0x37d>
  8004205a19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a1d:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205a21:	75 35                	jne    8004205a58 <page_check+0x3b2>
  8004205a23:	48 b9 a0 79 21 04 80 	movabs $0x80042179a0,%rcx
  8004205a2a:	00 00 00 
  8004205a2d:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205a34:	00 00 00 
  8004205a37:	be ff 04 00 00       	mov    $0x4ff,%esi
  8004205a3c:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205a43:	00 00 00 
  8004205a46:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a4b:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205a52:	00 00 00 
  8004205a55:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004205a58:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205a5d:	74 32                	je     8004205a91 <page_check+0x3eb>
  8004205a5f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a63:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205a67:	74 28                	je     8004205a91 <page_check+0x3eb>
  8004205a69:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a6d:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205a71:	74 1e                	je     8004205a91 <page_check+0x3eb>
  8004205a73:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a77:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205a7b:	74 14                	je     8004205a91 <page_check+0x3eb>
  8004205a7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a81:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205a85:	74 0a                	je     8004205a91 <page_check+0x3eb>
  8004205a87:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a8b:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205a8f:	75 35                	jne    8004205ac6 <page_check+0x420>
  8004205a91:	48 b9 e0 79 21 04 80 	movabs $0x80042179e0,%rcx
  8004205a98:	00 00 00 
  8004205a9b:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205aa2:	00 00 00 
  8004205aa5:	be 00 05 00 00       	mov    $0x500,%esi
  8004205aaa:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205ab1:	00 00 00 
  8004205ab4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ab9:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205ac0:	00 00 00 
  8004205ac3:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004205ac6:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004205acd:	00 00 00 
  8004205ad0:	48 8b 00             	mov    (%rax),%rax
  8004205ad3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004205ad7:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  8004205ade:	00 00 00 
  8004205ae1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004205ae8:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205aed:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  8004205af4:	00 00 00 
  8004205af7:	ff d0                	callq  *%rax
  8004205af9:	48 85 c0             	test   %rax,%rax
  8004205afc:	74 35                	je     8004205b33 <page_check+0x48d>
  8004205afe:	48 b9 37 77 21 04 80 	movabs $0x8004217737,%rcx
  8004205b05:	00 00 00 
  8004205b08:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205b0f:	00 00 00 
  8004205b12:	be 07 05 00 00       	mov    $0x507,%esi
  8004205b17:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205b1e:	00 00 00 
  8004205b21:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b26:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205b2d:	00 00 00 
  8004205b30:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004205b33:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004205b3a:	00 00 00 
  8004205b3d:	48 8b 00             	mov    (%rax),%rax
  8004205b40:	48 8d 95 e8 fe ff ff 	lea    -0x118(%rbp),%rdx
  8004205b47:	be 00 00 00 00       	mov    $0x0,%esi
  8004205b4c:	48 89 c7             	mov    %rax,%rdi
  8004205b4f:	48 b8 22 39 20 04 80 	movabs $0x8004203922,%rax
  8004205b56:	00 00 00 
  8004205b59:	ff d0                	callq  *%rax
  8004205b5b:	48 85 c0             	test   %rax,%rax
  8004205b5e:	74 35                	je     8004205b95 <page_check+0x4ef>
  8004205b60:	48 b9 30 7a 21 04 80 	movabs $0x8004217a30,%rcx
  8004205b67:	00 00 00 
  8004205b6a:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205b71:	00 00 00 
  8004205b74:	be 0a 05 00 00       	mov    $0x50a,%esi
  8004205b79:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205b80:	00 00 00 
  8004205b83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b88:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205b8f:	00 00 00 
  8004205b92:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205b95:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004205b9c:	00 00 00 
  8004205b9f:	48 8b 00             	mov    (%rax),%rax
  8004205ba2:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205ba6:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205bab:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205bb0:	48 89 c7             	mov    %rax,%rdi
  8004205bb3:	48 b8 c5 37 20 04 80 	movabs $0x80042037c5,%rax
  8004205bba:	00 00 00 
  8004205bbd:	ff d0                	callq  *%rax
  8004205bbf:	85 c0                	test   %eax,%eax
  8004205bc1:	78 35                	js     8004205bf8 <page_check+0x552>
  8004205bc3:	48 b9 68 7a 21 04 80 	movabs $0x8004217a68,%rcx
  8004205bca:	00 00 00 
  8004205bcd:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205bd4:	00 00 00 
  8004205bd7:	be 0d 05 00 00       	mov    $0x50d,%esi
  8004205bdc:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205be3:	00 00 00 
  8004205be6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205beb:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205bf2:	00 00 00 
  8004205bf5:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  8004205bf8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205bfc:	48 89 c7             	mov    %rax,%rdi
  8004205bff:	48 b8 55 30 20 04 80 	movabs $0x8004203055,%rax
  8004205c06:	00 00 00 
  8004205c09:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205c0b:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004205c12:	00 00 00 
  8004205c15:	48 8b 00             	mov    (%rax),%rax
  8004205c18:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205c1c:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205c21:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205c26:	48 89 c7             	mov    %rax,%rdi
  8004205c29:	48 b8 c5 37 20 04 80 	movabs $0x80042037c5,%rax
  8004205c30:	00 00 00 
  8004205c33:	ff d0                	callq  *%rax
  8004205c35:	85 c0                	test   %eax,%eax
  8004205c37:	78 35                	js     8004205c6e <page_check+0x5c8>
  8004205c39:	48 b9 68 7a 21 04 80 	movabs $0x8004217a68,%rcx
  8004205c40:	00 00 00 
  8004205c43:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205c4a:	00 00 00 
  8004205c4d:	be 11 05 00 00       	mov    $0x511,%esi
  8004205c52:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205c59:	00 00 00 
  8004205c5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c61:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205c68:	00 00 00 
  8004205c6b:	41 ff d0             	callq  *%r8
	page_free(pp2);
  8004205c6e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205c72:	48 89 c7             	mov    %rax,%rdi
  8004205c75:	48 b8 55 30 20 04 80 	movabs $0x8004203055,%rax
  8004205c7c:	00 00 00 
  8004205c7f:	ff d0                	callq  *%rax
	page_free(pp3);
  8004205c81:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205c85:	48 89 c7             	mov    %rax,%rdi
  8004205c88:	48 b8 55 30 20 04 80 	movabs $0x8004203055,%rax
  8004205c8f:	00 00 00 
  8004205c92:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  8004205c94:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004205c9b:	00 00 00 
  8004205c9e:	48 8b 00             	mov    (%rax),%rax
  8004205ca1:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205ca5:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205caa:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205caf:	48 89 c7             	mov    %rax,%rdi
  8004205cb2:	48 b8 c5 37 20 04 80 	movabs $0x80042037c5,%rax
  8004205cb9:	00 00 00 
  8004205cbc:	ff d0                	callq  *%rax
  8004205cbe:	85 c0                	test   %eax,%eax
  8004205cc0:	74 35                	je     8004205cf7 <page_check+0x651>
  8004205cc2:	48 b9 98 7a 21 04 80 	movabs $0x8004217a98,%rcx
  8004205cc9:	00 00 00 
  8004205ccc:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205cd3:	00 00 00 
  8004205cd6:	be 17 05 00 00       	mov    $0x517,%esi
  8004205cdb:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205ce2:	00 00 00 
  8004205ce5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cea:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205cf1:	00 00 00 
  8004205cf4:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004205cf7:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004205cfe:	00 00 00 
  8004205d01:	48 8b 00             	mov    (%rax),%rax
  8004205d04:	48 8b 00             	mov    (%rax),%rax
  8004205d07:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d0d:	48 89 c3             	mov    %rax,%rbx
  8004205d10:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205d14:	48 89 c7             	mov    %rax,%rdi
  8004205d17:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004205d1e:	00 00 00 
  8004205d21:	ff d0                	callq  *%rax
  8004205d23:	48 39 c3             	cmp    %rax,%rbx
  8004205d26:	0f 84 97 00 00 00    	je     8004205dc3 <page_check+0x71d>
  8004205d2c:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004205d33:	00 00 00 
  8004205d36:	48 8b 00             	mov    (%rax),%rax
  8004205d39:	48 8b 00             	mov    (%rax),%rax
  8004205d3c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d42:	48 89 c3             	mov    %rax,%rbx
  8004205d45:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205d49:	48 89 c7             	mov    %rax,%rdi
  8004205d4c:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004205d53:	00 00 00 
  8004205d56:	ff d0                	callq  *%rax
  8004205d58:	48 39 c3             	cmp    %rax,%rbx
  8004205d5b:	74 66                	je     8004205dc3 <page_check+0x71d>
  8004205d5d:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004205d64:	00 00 00 
  8004205d67:	48 8b 00             	mov    (%rax),%rax
  8004205d6a:	48 8b 00             	mov    (%rax),%rax
  8004205d6d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d73:	48 89 c3             	mov    %rax,%rbx
  8004205d76:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205d7a:	48 89 c7             	mov    %rax,%rdi
  8004205d7d:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004205d84:	00 00 00 
  8004205d87:	ff d0                	callq  *%rax
  8004205d89:	48 39 c3             	cmp    %rax,%rbx
  8004205d8c:	74 35                	je     8004205dc3 <page_check+0x71d>
  8004205d8e:	48 b9 c8 7a 21 04 80 	movabs $0x8004217ac8,%rcx
  8004205d95:	00 00 00 
  8004205d98:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205d9f:	00 00 00 
  8004205da2:	be 18 05 00 00       	mov    $0x518,%esi
  8004205da7:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205dae:	00 00 00 
  8004205db1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205db6:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205dbd:	00 00 00 
  8004205dc0:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  8004205dc3:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004205dca:	00 00 00 
  8004205dcd:	48 8b 00             	mov    (%rax),%rax
  8004205dd0:	be 00 00 00 00       	mov    $0x0,%esi
  8004205dd5:	48 89 c7             	mov    %rax,%rdi
  8004205dd8:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  8004205ddf:	00 00 00 
  8004205de2:	ff d0                	callq  *%rax
  8004205de4:	48 89 c3             	mov    %rax,%rbx
  8004205de7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205deb:	48 89 c7             	mov    %rax,%rdi
  8004205dee:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004205df5:	00 00 00 
  8004205df8:	ff d0                	callq  *%rax
  8004205dfa:	48 39 c3             	cmp    %rax,%rbx
  8004205dfd:	74 35                	je     8004205e34 <page_check+0x78e>
  8004205dff:	48 b9 50 7b 21 04 80 	movabs $0x8004217b50,%rcx
  8004205e06:	00 00 00 
  8004205e09:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205e10:	00 00 00 
  8004205e13:	be 19 05 00 00       	mov    $0x519,%esi
  8004205e18:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205e1f:	00 00 00 
  8004205e22:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e27:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205e2e:	00 00 00 
  8004205e31:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004205e34:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205e38:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205e3c:	66 83 f8 01          	cmp    $0x1,%ax
  8004205e40:	74 35                	je     8004205e77 <page_check+0x7d1>
  8004205e42:	48 b9 7d 7b 21 04 80 	movabs $0x8004217b7d,%rcx
  8004205e49:	00 00 00 
  8004205e4c:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205e53:	00 00 00 
  8004205e56:	be 1a 05 00 00       	mov    $0x51a,%esi
  8004205e5b:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205e62:	00 00 00 
  8004205e65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e6a:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205e71:	00 00 00 
  8004205e74:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  8004205e77:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205e7b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205e7f:	66 83 f8 01          	cmp    $0x1,%ax
  8004205e83:	74 35                	je     8004205eba <page_check+0x814>
  8004205e85:	48 b9 8e 7b 21 04 80 	movabs $0x8004217b8e,%rcx
  8004205e8c:	00 00 00 
  8004205e8f:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205e96:	00 00 00 
  8004205e99:	be 1b 05 00 00       	mov    $0x51b,%esi
  8004205e9e:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205ea5:	00 00 00 
  8004205ea8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ead:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205eb4:	00 00 00 
  8004205eb7:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004205eba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205ebe:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205ec2:	66 83 f8 01          	cmp    $0x1,%ax
  8004205ec6:	74 35                	je     8004205efd <page_check+0x857>
  8004205ec8:	48 b9 9f 7b 21 04 80 	movabs $0x8004217b9f,%rcx
  8004205ecf:	00 00 00 
  8004205ed2:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205ed9:	00 00 00 
  8004205edc:	be 1c 05 00 00       	mov    $0x51c,%esi
  8004205ee1:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205ee8:	00 00 00 
  8004205eeb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ef0:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205ef7:	00 00 00 
  8004205efa:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205efd:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004205f04:	00 00 00 
  8004205f07:	48 8b 00             	mov    (%rax),%rax
  8004205f0a:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205f0e:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205f13:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205f18:	48 89 c7             	mov    %rax,%rdi
  8004205f1b:	48 b8 c5 37 20 04 80 	movabs $0x80042037c5,%rax
  8004205f22:	00 00 00 
  8004205f25:	ff d0                	callq  *%rax
  8004205f27:	85 c0                	test   %eax,%eax
  8004205f29:	74 35                	je     8004205f60 <page_check+0x8ba>
  8004205f2b:	48 b9 b0 7b 21 04 80 	movabs $0x8004217bb0,%rcx
  8004205f32:	00 00 00 
  8004205f35:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205f3c:	00 00 00 
  8004205f3f:	be 1e 05 00 00       	mov    $0x51e,%esi
  8004205f44:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205f4b:	00 00 00 
  8004205f4e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f53:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205f5a:	00 00 00 
  8004205f5d:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205f60:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004205f67:	00 00 00 
  8004205f6a:	48 8b 00             	mov    (%rax),%rax
  8004205f6d:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205f72:	48 89 c7             	mov    %rax,%rdi
  8004205f75:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  8004205f7c:	00 00 00 
  8004205f7f:	ff d0                	callq  *%rax
  8004205f81:	48 89 c3             	mov    %rax,%rbx
  8004205f84:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205f88:	48 89 c7             	mov    %rax,%rdi
  8004205f8b:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004205f92:	00 00 00 
  8004205f95:	ff d0                	callq  *%rax
  8004205f97:	48 39 c3             	cmp    %rax,%rbx
  8004205f9a:	74 35                	je     8004205fd1 <page_check+0x92b>
  8004205f9c:	48 b9 e8 7b 21 04 80 	movabs $0x8004217be8,%rcx
  8004205fa3:	00 00 00 
  8004205fa6:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205fad:	00 00 00 
  8004205fb0:	be 1f 05 00 00       	mov    $0x51f,%esi
  8004205fb5:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205fbc:	00 00 00 
  8004205fbf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fc4:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004205fcb:	00 00 00 
  8004205fce:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205fd1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205fd5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205fd9:	66 83 f8 02          	cmp    $0x2,%ax
  8004205fdd:	74 35                	je     8004206014 <page_check+0x96e>
  8004205fdf:	48 b9 18 7c 21 04 80 	movabs $0x8004217c18,%rcx
  8004205fe6:	00 00 00 
  8004205fe9:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004205ff0:	00 00 00 
  8004205ff3:	be 20 05 00 00       	mov    $0x520,%esi
  8004205ff8:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004205fff:	00 00 00 
  8004206002:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206007:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420600e:	00 00 00 
  8004206011:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  8004206014:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206019:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  8004206020:	00 00 00 
  8004206023:	ff d0                	callq  *%rax
  8004206025:	48 85 c0             	test   %rax,%rax
  8004206028:	74 35                	je     800420605f <page_check+0x9b9>
  800420602a:	48 b9 37 77 21 04 80 	movabs $0x8004217737,%rcx
  8004206031:	00 00 00 
  8004206034:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420603b:	00 00 00 
  800420603e:	be 23 05 00 00       	mov    $0x523,%esi
  8004206043:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420604a:	00 00 00 
  800420604d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206052:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206059:	00 00 00 
  800420605c:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  800420605f:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206066:	00 00 00 
  8004206069:	48 8b 00             	mov    (%rax),%rax
  800420606c:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206070:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206075:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420607a:	48 89 c7             	mov    %rax,%rdi
  800420607d:	48 b8 c5 37 20 04 80 	movabs $0x80042037c5,%rax
  8004206084:	00 00 00 
  8004206087:	ff d0                	callq  *%rax
  8004206089:	85 c0                	test   %eax,%eax
  800420608b:	74 35                	je     80042060c2 <page_check+0xa1c>
  800420608d:	48 b9 b0 7b 21 04 80 	movabs $0x8004217bb0,%rcx
  8004206094:	00 00 00 
  8004206097:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420609e:	00 00 00 
  80042060a1:	be 26 05 00 00       	mov    $0x526,%esi
  80042060a6:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042060ad:	00 00 00 
  80042060b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060b5:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042060bc:	00 00 00 
  80042060bf:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042060c2:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  80042060c9:	00 00 00 
  80042060cc:	48 8b 00             	mov    (%rax),%rax
  80042060cf:	be 00 10 00 00       	mov    $0x1000,%esi
  80042060d4:	48 89 c7             	mov    %rax,%rdi
  80042060d7:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  80042060de:	00 00 00 
  80042060e1:	ff d0                	callq  *%rax
  80042060e3:	48 89 c3             	mov    %rax,%rbx
  80042060e6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042060ea:	48 89 c7             	mov    %rax,%rdi
  80042060ed:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  80042060f4:	00 00 00 
  80042060f7:	ff d0                	callq  *%rax
  80042060f9:	48 39 c3             	cmp    %rax,%rbx
  80042060fc:	74 35                	je     8004206133 <page_check+0xa8d>
  80042060fe:	48 b9 e8 7b 21 04 80 	movabs $0x8004217be8,%rcx
  8004206105:	00 00 00 
  8004206108:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420610f:	00 00 00 
  8004206112:	be 27 05 00 00       	mov    $0x527,%esi
  8004206117:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420611e:	00 00 00 
  8004206121:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206126:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420612d:	00 00 00 
  8004206130:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206133:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206137:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420613b:	66 83 f8 02          	cmp    $0x2,%ax
  800420613f:	74 35                	je     8004206176 <page_check+0xad0>
  8004206141:	48 b9 18 7c 21 04 80 	movabs $0x8004217c18,%rcx
  8004206148:	00 00 00 
  800420614b:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206152:	00 00 00 
  8004206155:	be 28 05 00 00       	mov    $0x528,%esi
  800420615a:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206161:	00 00 00 
  8004206164:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206169:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206170:	00 00 00 
  8004206173:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  8004206176:	bf 00 00 00 00       	mov    $0x0,%edi
  800420617b:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  8004206182:	00 00 00 
  8004206185:	ff d0                	callq  *%rax
  8004206187:	48 85 c0             	test   %rax,%rax
  800420618a:	74 35                	je     80042061c1 <page_check+0xb1b>
  800420618c:	48 b9 37 77 21 04 80 	movabs $0x8004217737,%rcx
  8004206193:	00 00 00 
  8004206196:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420619d:	00 00 00 
  80042061a0:	be 2c 05 00 00       	mov    $0x52c,%esi
  80042061a5:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042061ac:	00 00 00 
  80042061af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061b4:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042061bb:	00 00 00 
  80042061be:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  80042061c1:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  80042061c8:	00 00 00 
  80042061cb:	48 8b 00             	mov    (%rax),%rax
  80042061ce:	48 8b 00             	mov    (%rax),%rax
  80042061d1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042061d7:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  80042061db:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042061df:	48 c1 e8 0c          	shr    $0xc,%rax
  80042061e3:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  80042061e6:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  80042061e9:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  80042061f0:	00 00 00 
  80042061f3:	48 8b 00             	mov    (%rax),%rax
  80042061f6:	48 39 c2             	cmp    %rax,%rdx
  80042061f9:	72 32                	jb     800420622d <page_check+0xb87>
  80042061fb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042061ff:	48 89 c1             	mov    %rax,%rcx
  8004206202:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004206209:	00 00 00 
  800420620c:	be 2e 05 00 00       	mov    $0x52e,%esi
  8004206211:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206218:	00 00 00 
  800420621b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206220:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206227:	00 00 00 
  800420622a:	41 ff d0             	callq  *%r8
  800420622d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206234:	00 00 00 
  8004206237:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420623b:	48 01 d0             	add    %rdx,%rax
  800420623e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  8004206242:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206246:	48 8b 00             	mov    (%rax),%rax
  8004206249:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420624f:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004206253:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206257:	48 c1 e8 0c          	shr    $0xc,%rax
  800420625b:	89 45 8c             	mov    %eax,-0x74(%rbp)
  800420625e:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004206261:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004206268:	00 00 00 
  800420626b:	48 8b 00             	mov    (%rax),%rax
  800420626e:	48 39 c2             	cmp    %rax,%rdx
  8004206271:	72 32                	jb     80042062a5 <page_check+0xbff>
  8004206273:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206277:	48 89 c1             	mov    %rax,%rcx
  800420627a:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004206281:	00 00 00 
  8004206284:	be 2f 05 00 00       	mov    $0x52f,%esi
  8004206289:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206290:	00 00 00 
  8004206293:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206298:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420629f:	00 00 00 
  80042062a2:	41 ff d0             	callq  *%r8
  80042062a5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042062ac:	00 00 00 
  80042062af:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042062b3:	48 01 d0             	add    %rdx,%rax
  80042062b6:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  80042062ba:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042062be:	48 8b 00             	mov    (%rax),%rax
  80042062c1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042062c7:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042062ce:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042062d5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042062d9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  80042062df:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  80042062e5:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  80042062ec:	00 00 00 
  80042062ef:	48 8b 00             	mov    (%rax),%rax
  80042062f2:	48 39 c2             	cmp    %rax,%rdx
  80042062f5:	72 35                	jb     800420632c <page_check+0xc86>
  80042062f7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042062fe:	48 89 c1             	mov    %rax,%rcx
  8004206301:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004206308:	00 00 00 
  800420630b:	be 30 05 00 00       	mov    $0x530,%esi
  8004206310:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206317:	00 00 00 
  800420631a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420631f:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206326:	00 00 00 
  8004206329:	41 ff d0             	callq  *%r8
  800420632c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206333:	00 00 00 
  8004206336:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420633d:	48 01 d0             	add    %rdx,%rax
  8004206340:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  8004206347:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  800420634e:	00 00 00 
  8004206351:	48 8b 00             	mov    (%rax),%rax
  8004206354:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206359:	be 00 10 00 00       	mov    $0x1000,%esi
  800420635e:	48 89 c7             	mov    %rax,%rdi
  8004206361:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  8004206368:	00 00 00 
  800420636b:	ff d0                	callq  *%rax
  800420636d:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  8004206374:	48 83 c2 08          	add    $0x8,%rdx
  8004206378:	48 39 d0             	cmp    %rdx,%rax
  800420637b:	74 35                	je     80042063b2 <page_check+0xd0c>
  800420637d:	48 b9 30 7c 21 04 80 	movabs $0x8004217c30,%rcx
  8004206384:	00 00 00 
  8004206387:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420638e:	00 00 00 
  8004206391:	be 31 05 00 00       	mov    $0x531,%esi
  8004206396:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420639d:	00 00 00 
  80042063a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063a5:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042063ac:	00 00 00 
  80042063af:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  80042063b2:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  80042063b9:	00 00 00 
  80042063bc:	48 8b 00             	mov    (%rax),%rax
  80042063bf:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042063c3:	b9 04 00 00 00       	mov    $0x4,%ecx
  80042063c8:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042063cd:	48 89 c7             	mov    %rax,%rdi
  80042063d0:	48 b8 c5 37 20 04 80 	movabs $0x80042037c5,%rax
  80042063d7:	00 00 00 
  80042063da:	ff d0                	callq  *%rax
  80042063dc:	85 c0                	test   %eax,%eax
  80042063de:	74 35                	je     8004206415 <page_check+0xd6f>
  80042063e0:	48 b9 70 7c 21 04 80 	movabs $0x8004217c70,%rcx
  80042063e7:	00 00 00 
  80042063ea:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042063f1:	00 00 00 
  80042063f4:	be 34 05 00 00       	mov    $0x534,%esi
  80042063f9:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206400:	00 00 00 
  8004206403:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206408:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420640f:	00 00 00 
  8004206412:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004206415:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  800420641c:	00 00 00 
  800420641f:	48 8b 00             	mov    (%rax),%rax
  8004206422:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206427:	48 89 c7             	mov    %rax,%rdi
  800420642a:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  8004206431:	00 00 00 
  8004206434:	ff d0                	callq  *%rax
  8004206436:	48 89 c3             	mov    %rax,%rbx
  8004206439:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420643d:	48 89 c7             	mov    %rax,%rdi
  8004206440:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004206447:	00 00 00 
  800420644a:	ff d0                	callq  *%rax
  800420644c:	48 39 c3             	cmp    %rax,%rbx
  800420644f:	74 35                	je     8004206486 <page_check+0xde0>
  8004206451:	48 b9 e8 7b 21 04 80 	movabs $0x8004217be8,%rcx
  8004206458:	00 00 00 
  800420645b:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206462:	00 00 00 
  8004206465:	be 35 05 00 00       	mov    $0x535,%esi
  800420646a:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206471:	00 00 00 
  8004206474:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206479:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206480:	00 00 00 
  8004206483:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206486:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420648a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420648e:	66 83 f8 02          	cmp    $0x2,%ax
  8004206492:	74 35                	je     80042064c9 <page_check+0xe23>
  8004206494:	48 b9 18 7c 21 04 80 	movabs $0x8004217c18,%rcx
  800420649b:	00 00 00 
  800420649e:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042064a5:	00 00 00 
  80042064a8:	be 36 05 00 00       	mov    $0x536,%esi
  80042064ad:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042064b4:	00 00 00 
  80042064b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064bc:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042064c3:	00 00 00 
  80042064c6:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  80042064c9:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  80042064d0:	00 00 00 
  80042064d3:	48 8b 00             	mov    (%rax),%rax
  80042064d6:	ba 00 00 00 00       	mov    $0x0,%edx
  80042064db:	be 00 10 00 00       	mov    $0x1000,%esi
  80042064e0:	48 89 c7             	mov    %rax,%rdi
  80042064e3:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  80042064ea:	00 00 00 
  80042064ed:	ff d0                	callq  *%rax
  80042064ef:	48 8b 00             	mov    (%rax),%rax
  80042064f2:	83 e0 04             	and    $0x4,%eax
  80042064f5:	48 85 c0             	test   %rax,%rax
  80042064f8:	75 35                	jne    800420652f <page_check+0xe89>
  80042064fa:	48 b9 b0 7c 21 04 80 	movabs $0x8004217cb0,%rcx
  8004206501:	00 00 00 
  8004206504:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420650b:	00 00 00 
  800420650e:	be 37 05 00 00       	mov    $0x537,%esi
  8004206513:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420651a:	00 00 00 
  800420651d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206522:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206529:	00 00 00 
  800420652c:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  800420652f:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206536:	00 00 00 
  8004206539:	48 8b 00             	mov    (%rax),%rax
  800420653c:	48 8b 00             	mov    (%rax),%rax
  800420653f:	83 e0 04             	and    $0x4,%eax
  8004206542:	48 85 c0             	test   %rax,%rax
  8004206545:	75 35                	jne    800420657c <page_check+0xed6>
  8004206547:	48 b9 e3 7c 21 04 80 	movabs $0x8004217ce3,%rcx
  800420654e:	00 00 00 
  8004206551:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206558:	00 00 00 
  800420655b:	be 38 05 00 00       	mov    $0x538,%esi
  8004206560:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206567:	00 00 00 
  800420656a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420656f:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206576:	00 00 00 
  8004206579:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  800420657c:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206583:	00 00 00 
  8004206586:	48 8b 00             	mov    (%rax),%rax
  8004206589:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800420658d:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206592:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004206597:	48 89 c7             	mov    %rax,%rdi
  800420659a:	48 b8 c5 37 20 04 80 	movabs $0x80042037c5,%rax
  80042065a1:	00 00 00 
  80042065a4:	ff d0                	callq  *%rax
  80042065a6:	85 c0                	test   %eax,%eax
  80042065a8:	78 35                	js     80042065df <page_check+0xf39>
  80042065aa:	48 b9 00 7d 21 04 80 	movabs $0x8004217d00,%rcx
  80042065b1:	00 00 00 
  80042065b4:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042065bb:	00 00 00 
  80042065be:	be 3c 05 00 00       	mov    $0x53c,%esi
  80042065c3:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042065ca:	00 00 00 
  80042065cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065d2:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042065d9:	00 00 00 
  80042065dc:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  80042065df:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  80042065e6:	00 00 00 
  80042065e9:	48 8b 00             	mov    (%rax),%rax
  80042065ec:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042065f0:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042065f5:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042065fa:	48 89 c7             	mov    %rax,%rdi
  80042065fd:	48 b8 c5 37 20 04 80 	movabs $0x80042037c5,%rax
  8004206604:	00 00 00 
  8004206607:	ff d0                	callq  *%rax
  8004206609:	85 c0                	test   %eax,%eax
  800420660b:	74 35                	je     8004206642 <page_check+0xf9c>
  800420660d:	48 b9 38 7d 21 04 80 	movabs $0x8004217d38,%rcx
  8004206614:	00 00 00 
  8004206617:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420661e:	00 00 00 
  8004206621:	be 3f 05 00 00       	mov    $0x53f,%esi
  8004206626:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420662d:	00 00 00 
  8004206630:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206635:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420663c:	00 00 00 
  800420663f:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  8004206642:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206649:	00 00 00 
  800420664c:	48 8b 00             	mov    (%rax),%rax
  800420664f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206654:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206659:	48 89 c7             	mov    %rax,%rdi
  800420665c:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  8004206663:	00 00 00 
  8004206666:	ff d0                	callq  *%rax
  8004206668:	48 8b 00             	mov    (%rax),%rax
  800420666b:	83 e0 04             	and    $0x4,%eax
  800420666e:	48 85 c0             	test   %rax,%rax
  8004206671:	74 35                	je     80042066a8 <page_check+0x1002>
  8004206673:	48 b9 70 7d 21 04 80 	movabs $0x8004217d70,%rcx
  800420667a:	00 00 00 
  800420667d:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206684:	00 00 00 
  8004206687:	be 40 05 00 00       	mov    $0x540,%esi
  800420668c:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206693:	00 00 00 
  8004206696:	b8 00 00 00 00       	mov    $0x0,%eax
  800420669b:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042066a2:	00 00 00 
  80042066a5:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  80042066a8:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  80042066af:	00 00 00 
  80042066b2:	48 8b 00             	mov    (%rax),%rax
  80042066b5:	be 00 00 00 00       	mov    $0x0,%esi
  80042066ba:	48 89 c7             	mov    %rax,%rdi
  80042066bd:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  80042066c4:	00 00 00 
  80042066c7:	ff d0                	callq  *%rax
  80042066c9:	48 89 c3             	mov    %rax,%rbx
  80042066cc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042066d0:	48 89 c7             	mov    %rax,%rdi
  80042066d3:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  80042066da:	00 00 00 
  80042066dd:	ff d0                	callq  *%rax
  80042066df:	48 39 c3             	cmp    %rax,%rbx
  80042066e2:	74 35                	je     8004206719 <page_check+0x1073>
  80042066e4:	48 b9 a8 7d 21 04 80 	movabs $0x8004217da8,%rcx
  80042066eb:	00 00 00 
  80042066ee:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042066f5:	00 00 00 
  80042066f8:	be 43 05 00 00       	mov    $0x543,%esi
  80042066fd:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206704:	00 00 00 
  8004206707:	b8 00 00 00 00       	mov    $0x0,%eax
  800420670c:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206713:	00 00 00 
  8004206716:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206719:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206720:	00 00 00 
  8004206723:	48 8b 00             	mov    (%rax),%rax
  8004206726:	be 00 10 00 00       	mov    $0x1000,%esi
  800420672b:	48 89 c7             	mov    %rax,%rdi
  800420672e:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  8004206735:	00 00 00 
  8004206738:	ff d0                	callq  *%rax
  800420673a:	48 89 c3             	mov    %rax,%rbx
  800420673d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206741:	48 89 c7             	mov    %rax,%rdi
  8004206744:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  800420674b:	00 00 00 
  800420674e:	ff d0                	callq  *%rax
  8004206750:	48 39 c3             	cmp    %rax,%rbx
  8004206753:	74 35                	je     800420678a <page_check+0x10e4>
  8004206755:	48 b9 d8 7d 21 04 80 	movabs $0x8004217dd8,%rcx
  800420675c:	00 00 00 
  800420675f:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206766:	00 00 00 
  8004206769:	be 44 05 00 00       	mov    $0x544,%esi
  800420676e:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206775:	00 00 00 
  8004206778:	b8 00 00 00 00       	mov    $0x0,%eax
  800420677d:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206784:	00 00 00 
  8004206787:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  800420678a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420678e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206792:	66 83 f8 02          	cmp    $0x2,%ax
  8004206796:	74 35                	je     80042067cd <page_check+0x1127>
  8004206798:	48 b9 08 7e 21 04 80 	movabs $0x8004217e08,%rcx
  800420679f:	00 00 00 
  80042067a2:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042067a9:	00 00 00 
  80042067ac:	be 46 05 00 00       	mov    $0x546,%esi
  80042067b1:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042067b8:	00 00 00 
  80042067bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067c0:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042067c7:	00 00 00 
  80042067ca:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042067cd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042067d1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042067d5:	66 83 f8 01          	cmp    $0x1,%ax
  80042067d9:	74 35                	je     8004206810 <page_check+0x116a>
  80042067db:	48 b9 19 7e 21 04 80 	movabs $0x8004217e19,%rcx
  80042067e2:	00 00 00 
  80042067e5:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042067ec:	00 00 00 
  80042067ef:	be 47 05 00 00       	mov    $0x547,%esi
  80042067f4:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042067fb:	00 00 00 
  80042067fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206803:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420680a:	00 00 00 
  800420680d:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004206810:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206817:	00 00 00 
  800420681a:	48 8b 00             	mov    (%rax),%rax
  800420681d:	be 00 00 00 00       	mov    $0x0,%esi
  8004206822:	48 89 c7             	mov    %rax,%rdi
  8004206825:	48 b8 bc 39 20 04 80 	movabs $0x80042039bc,%rax
  800420682c:	00 00 00 
  800420682f:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206831:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206838:	00 00 00 
  800420683b:	48 8b 00             	mov    (%rax),%rax
  800420683e:	be 00 00 00 00       	mov    $0x0,%esi
  8004206843:	48 89 c7             	mov    %rax,%rdi
  8004206846:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  800420684d:	00 00 00 
  8004206850:	ff d0                	callq  *%rax
  8004206852:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206856:	74 35                	je     800420688d <page_check+0x11e7>
  8004206858:	48 b9 30 7e 21 04 80 	movabs $0x8004217e30,%rcx
  800420685f:	00 00 00 
  8004206862:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206869:	00 00 00 
  800420686c:	be 4c 05 00 00       	mov    $0x54c,%esi
  8004206871:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206878:	00 00 00 
  800420687b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206880:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206887:	00 00 00 
  800420688a:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  800420688d:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206894:	00 00 00 
  8004206897:	48 8b 00             	mov    (%rax),%rax
  800420689a:	be 00 10 00 00       	mov    $0x1000,%esi
  800420689f:	48 89 c7             	mov    %rax,%rdi
  80042068a2:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  80042068a9:	00 00 00 
  80042068ac:	ff d0                	callq  *%rax
  80042068ae:	48 89 c3             	mov    %rax,%rbx
  80042068b1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042068b5:	48 89 c7             	mov    %rax,%rdi
  80042068b8:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  80042068bf:	00 00 00 
  80042068c2:	ff d0                	callq  *%rax
  80042068c4:	48 39 c3             	cmp    %rax,%rbx
  80042068c7:	74 35                	je     80042068fe <page_check+0x1258>
  80042068c9:	48 b9 d8 7d 21 04 80 	movabs $0x8004217dd8,%rcx
  80042068d0:	00 00 00 
  80042068d3:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042068da:	00 00 00 
  80042068dd:	be 4d 05 00 00       	mov    $0x54d,%esi
  80042068e2:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042068e9:	00 00 00 
  80042068ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068f1:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042068f8:	00 00 00 
  80042068fb:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  80042068fe:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206902:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206906:	66 83 f8 01          	cmp    $0x1,%ax
  800420690a:	74 35                	je     8004206941 <page_check+0x129b>
  800420690c:	48 b9 7d 7b 21 04 80 	movabs $0x8004217b7d,%rcx
  8004206913:	00 00 00 
  8004206916:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420691d:	00 00 00 
  8004206920:	be 4e 05 00 00       	mov    $0x54e,%esi
  8004206925:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420692c:	00 00 00 
  800420692f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206934:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420693b:	00 00 00 
  800420693e:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206941:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206945:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206949:	66 83 f8 01          	cmp    $0x1,%ax
  800420694d:	74 35                	je     8004206984 <page_check+0x12de>
  800420694f:	48 b9 19 7e 21 04 80 	movabs $0x8004217e19,%rcx
  8004206956:	00 00 00 
  8004206959:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206960:	00 00 00 
  8004206963:	be 4f 05 00 00       	mov    $0x54f,%esi
  8004206968:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420696f:	00 00 00 
  8004206972:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206977:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420697e:	00 00 00 
  8004206981:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206984:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  800420698b:	00 00 00 
  800420698e:	48 8b 00             	mov    (%rax),%rax
  8004206991:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206995:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420699a:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420699f:	48 89 c7             	mov    %rax,%rdi
  80042069a2:	48 b8 c5 37 20 04 80 	movabs $0x80042037c5,%rax
  80042069a9:	00 00 00 
  80042069ac:	ff d0                	callq  *%rax
  80042069ae:	85 c0                	test   %eax,%eax
  80042069b0:	74 35                	je     80042069e7 <page_check+0x1341>
  80042069b2:	48 b9 38 7d 21 04 80 	movabs $0x8004217d38,%rcx
  80042069b9:	00 00 00 
  80042069bc:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042069c3:	00 00 00 
  80042069c6:	be 53 05 00 00       	mov    $0x553,%esi
  80042069cb:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042069d2:	00 00 00 
  80042069d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069da:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042069e1:	00 00 00 
  80042069e4:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  80042069e7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042069eb:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042069ef:	66 85 c0             	test   %ax,%ax
  80042069f2:	75 35                	jne    8004206a29 <page_check+0x1383>
  80042069f4:	48 b9 53 7e 21 04 80 	movabs $0x8004217e53,%rcx
  80042069fb:	00 00 00 
  80042069fe:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206a05:	00 00 00 
  8004206a08:	be 54 05 00 00       	mov    $0x554,%esi
  8004206a0d:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206a14:	00 00 00 
  8004206a17:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a1c:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206a23:	00 00 00 
  8004206a26:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206a29:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206a2d:	48 8b 00             	mov    (%rax),%rax
  8004206a30:	48 85 c0             	test   %rax,%rax
  8004206a33:	74 35                	je     8004206a6a <page_check+0x13c4>
  8004206a35:	48 b9 5f 7e 21 04 80 	movabs $0x8004217e5f,%rcx
  8004206a3c:	00 00 00 
  8004206a3f:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206a46:	00 00 00 
  8004206a49:	be 55 05 00 00       	mov    $0x555,%esi
  8004206a4e:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206a55:	00 00 00 
  8004206a58:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a5d:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206a64:	00 00 00 
  8004206a67:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206a6a:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206a71:	00 00 00 
  8004206a74:	48 8b 00             	mov    (%rax),%rax
  8004206a77:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206a7c:	48 89 c7             	mov    %rax,%rdi
  8004206a7f:	48 b8 bc 39 20 04 80 	movabs $0x80042039bc,%rax
  8004206a86:	00 00 00 
  8004206a89:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206a8b:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206a92:	00 00 00 
  8004206a95:	48 8b 00             	mov    (%rax),%rax
  8004206a98:	be 00 00 00 00       	mov    $0x0,%esi
  8004206a9d:	48 89 c7             	mov    %rax,%rdi
  8004206aa0:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  8004206aa7:	00 00 00 
  8004206aaa:	ff d0                	callq  *%rax
  8004206aac:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206ab0:	74 35                	je     8004206ae7 <page_check+0x1441>
  8004206ab2:	48 b9 30 7e 21 04 80 	movabs $0x8004217e30,%rcx
  8004206ab9:	00 00 00 
  8004206abc:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206ac3:	00 00 00 
  8004206ac6:	be 59 05 00 00       	mov    $0x559,%esi
  8004206acb:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206ad2:	00 00 00 
  8004206ad5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ada:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206ae1:	00 00 00 
  8004206ae4:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004206ae7:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206aee:	00 00 00 
  8004206af1:	48 8b 00             	mov    (%rax),%rax
  8004206af4:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206af9:	48 89 c7             	mov    %rax,%rdi
  8004206afc:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  8004206b03:	00 00 00 
  8004206b06:	ff d0                	callq  *%rax
  8004206b08:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206b0c:	74 35                	je     8004206b43 <page_check+0x149d>
  8004206b0e:	48 b9 78 7e 21 04 80 	movabs $0x8004217e78,%rcx
  8004206b15:	00 00 00 
  8004206b18:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206b1f:	00 00 00 
  8004206b22:	be 5a 05 00 00       	mov    $0x55a,%esi
  8004206b27:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206b2e:	00 00 00 
  8004206b31:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b36:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206b3d:	00 00 00 
  8004206b40:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206b43:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206b47:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b4b:	66 85 c0             	test   %ax,%ax
  8004206b4e:	74 35                	je     8004206b85 <page_check+0x14df>
  8004206b50:	48 b9 9e 7e 21 04 80 	movabs $0x8004217e9e,%rcx
  8004206b57:	00 00 00 
  8004206b5a:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206b61:	00 00 00 
  8004206b64:	be 5b 05 00 00       	mov    $0x55b,%esi
  8004206b69:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206b70:	00 00 00 
  8004206b73:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b78:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206b7f:	00 00 00 
  8004206b82:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206b85:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206b89:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b8d:	66 83 f8 01          	cmp    $0x1,%ax
  8004206b91:	74 35                	je     8004206bc8 <page_check+0x1522>
  8004206b93:	48 b9 19 7e 21 04 80 	movabs $0x8004217e19,%rcx
  8004206b9a:	00 00 00 
  8004206b9d:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206ba4:	00 00 00 
  8004206ba7:	be 5c 05 00 00       	mov    $0x55c,%esi
  8004206bac:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206bb3:	00 00 00 
  8004206bb6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bbb:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206bc2:	00 00 00 
  8004206bc5:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	assert(PTE_ADDR(boot_pml4e[0]) == page2pa(pp3));
  8004206bc8:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206bcf:	00 00 00 
  8004206bd2:	48 8b 00             	mov    (%rax),%rax
  8004206bd5:	48 8b 00             	mov    (%rax),%rax
  8004206bd8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206bde:	48 89 c3             	mov    %rax,%rbx
  8004206be1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206be5:	48 89 c7             	mov    %rax,%rdi
  8004206be8:	48 b8 fb 1b 20 04 80 	movabs $0x8004201bfb,%rax
  8004206bef:	00 00 00 
  8004206bf2:	ff d0                	callq  *%rax
  8004206bf4:	48 39 c3             	cmp    %rax,%rbx
  8004206bf7:	74 35                	je     8004206c2e <page_check+0x1588>
  8004206bf9:	48 b9 b0 7e 21 04 80 	movabs $0x8004217eb0,%rcx
  8004206c00:	00 00 00 
  8004206c03:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206c0a:	00 00 00 
  8004206c0d:	be 70 05 00 00       	mov    $0x570,%esi
  8004206c12:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206c19:	00 00 00 
  8004206c1c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c21:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206c28:	00 00 00 
  8004206c2b:	41 ff d0             	callq  *%r8
	boot_pml4e[0] = 0;
  8004206c2e:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206c35:	00 00 00 
  8004206c38:	48 8b 00             	mov    (%rax),%rax
  8004206c3b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  8004206c42:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206c46:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206c4a:	66 83 f8 01          	cmp    $0x1,%ax
  8004206c4e:	74 35                	je     8004206c85 <page_check+0x15df>
  8004206c50:	48 b9 19 7e 21 04 80 	movabs $0x8004217e19,%rcx
  8004206c57:	00 00 00 
  8004206c5a:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206c61:	00 00 00 
  8004206c64:	be 72 05 00 00       	mov    $0x572,%esi
  8004206c69:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206c70:	00 00 00 
  8004206c73:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c78:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206c7f:	00 00 00 
  8004206c82:	41 ff d0             	callq  *%r8
	page_decref(pp3);
  8004206c85:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206c89:	48 89 c7             	mov    %rax,%rdi
  8004206c8c:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  8004206c93:	00 00 00 
  8004206c96:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	page_decref(pp0);
  8004206c98:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206c9c:	48 89 c7             	mov    %rax,%rdi
  8004206c9f:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  8004206ca6:	00 00 00 
  8004206ca9:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004206cab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206caf:	48 89 c7             	mov    %rax,%rdi
  8004206cb2:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  8004206cb9:	00 00 00 
  8004206cbc:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  8004206cbe:	48 c7 85 68 ff ff ff 	movq   $0x64000,-0x98(%rbp)
  8004206cc5:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004206cc9:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206cd0:	00 00 00 
  8004206cd3:	48 8b 00             	mov    (%rax),%rax
  8004206cd6:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  8004206cdd:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206ce2:	48 89 ce             	mov    %rcx,%rsi
  8004206ce5:	48 89 c7             	mov    %rax,%rdi
  8004206ce8:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  8004206cef:	00 00 00 
  8004206cf2:	ff d0                	callq  *%rax
  8004206cf4:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004206cfb:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206d02:	00 00 00 
  8004206d05:	48 8b 00             	mov    (%rax),%rax
  8004206d08:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004206d0f:	48 c1 ea 27          	shr    $0x27,%rdx
  8004206d13:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004206d19:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206d1d:	48 01 d0             	add    %rdx,%rax
  8004206d20:	48 8b 00             	mov    (%rax),%rax
  8004206d23:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206d29:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004206d30:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206d37:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206d3b:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
  8004206d41:	8b 95 5c ff ff ff    	mov    -0xa4(%rbp),%edx
  8004206d47:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004206d4e:	00 00 00 
  8004206d51:	48 8b 00             	mov    (%rax),%rax
  8004206d54:	48 39 c2             	cmp    %rax,%rdx
  8004206d57:	72 35                	jb     8004206d8e <page_check+0x16e8>
  8004206d59:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206d60:	48 89 c1             	mov    %rax,%rcx
  8004206d63:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004206d6a:	00 00 00 
  8004206d6d:	be 79 05 00 00       	mov    $0x579,%esi
  8004206d72:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206d79:	00 00 00 
  8004206d7c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d81:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206d88:	00 00 00 
  8004206d8b:	41 ff d0             	callq  *%r8
  8004206d8e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206d95:	00 00 00 
  8004206d98:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206d9f:	48 01 d0             	add    %rdx,%rax
  8004206da2:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004206da6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206dad:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004206db1:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206db6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206dbd:	00 
  8004206dbe:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206dc2:	48 01 d0             	add    %rdx,%rax
  8004206dc5:	48 8b 00             	mov    (%rax),%rax
  8004206dc8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206dce:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004206dd5:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206ddc:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206de0:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  8004206de6:	8b 95 4c ff ff ff    	mov    -0xb4(%rbp),%edx
  8004206dec:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004206df3:	00 00 00 
  8004206df6:	48 8b 00             	mov    (%rax),%rax
  8004206df9:	48 39 c2             	cmp    %rax,%rdx
  8004206dfc:	72 35                	jb     8004206e33 <page_check+0x178d>
  8004206dfe:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206e05:	48 89 c1             	mov    %rax,%rcx
  8004206e08:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004206e0f:	00 00 00 
  8004206e12:	be 7a 05 00 00       	mov    $0x57a,%esi
  8004206e17:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206e1e:	00 00 00 
  8004206e21:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e26:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206e2d:	00 00 00 
  8004206e30:	41 ff d0             	callq  *%r8
  8004206e33:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206e3a:	00 00 00 
  8004206e3d:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206e44:	48 01 d0             	add    %rdx,%rax
  8004206e47:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  8004206e4b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206e52:	48 c1 e8 15          	shr    $0x15,%rax
  8004206e56:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206e5b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206e62:	00 
  8004206e63:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206e67:	48 01 d0             	add    %rdx,%rax
  8004206e6a:	48 8b 00             	mov    (%rax),%rax
  8004206e6d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206e73:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004206e7a:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206e81:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206e85:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
  8004206e8b:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
  8004206e91:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004206e98:	00 00 00 
  8004206e9b:	48 8b 00             	mov    (%rax),%rax
  8004206e9e:	48 39 c2             	cmp    %rax,%rdx
  8004206ea1:	72 35                	jb     8004206ed8 <page_check+0x1832>
  8004206ea3:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206eaa:	48 89 c1             	mov    %rax,%rcx
  8004206ead:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004206eb4:	00 00 00 
  8004206eb7:	be 7b 05 00 00       	mov    $0x57b,%esi
  8004206ebc:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206ec3:	00 00 00 
  8004206ec6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ecb:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206ed2:	00 00 00 
  8004206ed5:	41 ff d0             	callq  *%r8
  8004206ed8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206edf:	00 00 00 
  8004206ee2:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206ee9:	48 01 d0             	add    %rdx,%rax
  8004206eec:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004206ef3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206efa:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206efe:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206f03:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206f0a:	00 
  8004206f0b:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004206f12:	48 01 c2             	add    %rax,%rdx
  8004206f15:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206f1c:	48 39 c2             	cmp    %rax,%rdx
  8004206f1f:	74 35                	je     8004206f56 <page_check+0x18b0>
  8004206f21:	48 b9 d8 7e 21 04 80 	movabs $0x8004217ed8,%rcx
  8004206f28:	00 00 00 
  8004206f2b:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004206f32:	00 00 00 
  8004206f35:	be 7c 05 00 00       	mov    $0x57c,%esi
  8004206f3a:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004206f41:	00 00 00 
  8004206f44:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f49:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004206f50:	00 00 00 
  8004206f53:	41 ff d0             	callq  *%r8
	
	// check that new page tables get cleared
	page_decref(pp4);
  8004206f56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206f5a:	48 89 c7             	mov    %rax,%rdi
  8004206f5d:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  8004206f64:	00 00 00 
  8004206f67:	ff d0                	callq  *%rax
	memset(page2kva(pp4), 0xFF, PGSIZE);
  8004206f69:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206f6d:	48 89 c7             	mov    %rax,%rdi
  8004206f70:	48 b8 91 1c 20 04 80 	movabs $0x8004201c91,%rax
  8004206f77:	00 00 00 
  8004206f7a:	ff d0                	callq  *%rax
  8004206f7c:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206f81:	be ff 00 00 00       	mov    $0xff,%esi
  8004206f86:	48 89 c7             	mov    %rax,%rdi
  8004206f89:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004206f90:	00 00 00 
  8004206f93:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  8004206f95:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206f9c:	00 00 00 
  8004206f9f:	48 8b 00             	mov    (%rax),%rax
  8004206fa2:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206fa7:	be 00 00 00 00       	mov    $0x0,%esi
  8004206fac:	48 89 c7             	mov    %rax,%rdi
  8004206faf:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  8004206fb6:	00 00 00 
  8004206fb9:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004206fbb:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004206fc2:	00 00 00 
  8004206fc5:	48 8b 00             	mov    (%rax),%rax
  8004206fc8:	48 8b 00             	mov    (%rax),%rax
  8004206fcb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206fd1:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004206fd8:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206fdf:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206fe3:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
  8004206fe9:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004206fef:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004206ff6:	00 00 00 
  8004206ff9:	48 8b 00             	mov    (%rax),%rax
  8004206ffc:	48 39 c2             	cmp    %rax,%rdx
  8004206fff:	72 35                	jb     8004207036 <page_check+0x1990>
  8004207001:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207008:	48 89 c1             	mov    %rax,%rcx
  800420700b:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004207012:	00 00 00 
  8004207015:	be 82 05 00 00       	mov    $0x582,%esi
  800420701a:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004207021:	00 00 00 
  8004207024:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207029:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004207030:	00 00 00 
  8004207033:	41 ff d0             	callq  *%r8
  8004207036:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420703d:	00 00 00 
  8004207040:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207047:	48 01 d0             	add    %rdx,%rax
  800420704a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  800420704e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207052:	48 8b 00             	mov    (%rax),%rax
  8004207055:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420705b:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004207062:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004207069:	48 c1 e8 0c          	shr    $0xc,%rax
  800420706d:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
  8004207073:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  8004207079:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004207080:	00 00 00 
  8004207083:	48 8b 00             	mov    (%rax),%rax
  8004207086:	48 39 c2             	cmp    %rax,%rdx
  8004207089:	72 35                	jb     80042070c0 <page_check+0x1a1a>
  800420708b:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004207092:	48 89 c1             	mov    %rax,%rcx
  8004207095:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  800420709c:	00 00 00 
  800420709f:	be 83 05 00 00       	mov    $0x583,%esi
  80042070a4:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042070ab:	00 00 00 
  80042070ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070b3:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042070ba:	00 00 00 
  80042070bd:	41 ff d0             	callq  *%r8
  80042070c0:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042070c7:	00 00 00 
  80042070ca:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042070d1:	48 01 d0             	add    %rdx,%rax
  80042070d4:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  80042070d8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042070dc:	48 8b 00             	mov    (%rax),%rax
  80042070df:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042070e5:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  80042070ec:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042070f3:	48 c1 e8 0c          	shr    $0xc,%rax
  80042070f7:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  80042070fd:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  8004207103:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  800420710a:	00 00 00 
  800420710d:	48 8b 00             	mov    (%rax),%rax
  8004207110:	48 39 c2             	cmp    %rax,%rdx
  8004207113:	72 35                	jb     800420714a <page_check+0x1aa4>
  8004207115:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420711c:	48 89 c1             	mov    %rax,%rcx
  800420711f:	48 ba 18 72 21 04 80 	movabs $0x8004217218,%rdx
  8004207126:	00 00 00 
  8004207129:	be 84 05 00 00       	mov    $0x584,%esi
  800420712e:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004207135:	00 00 00 
  8004207138:	b8 00 00 00 00       	mov    $0x0,%eax
  800420713d:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004207144:	00 00 00 
  8004207147:	41 ff d0             	callq  *%r8
  800420714a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207151:	00 00 00 
  8004207154:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420715b:	48 01 d0             	add    %rdx,%rax
  800420715e:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  8004207165:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800420716c:	eb 58                	jmp    80042071c6 <page_check+0x1b20>
		assert((ptep[i] & PTE_P) == 0);
  800420716e:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004207175:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004207178:	48 63 d2             	movslq %edx,%rdx
  800420717b:	48 c1 e2 03          	shl    $0x3,%rdx
  800420717f:	48 01 d0             	add    %rdx,%rax
  8004207182:	48 8b 00             	mov    (%rax),%rax
  8004207185:	83 e0 01             	and    $0x1,%eax
  8004207188:	48 85 c0             	test   %rax,%rax
  800420718b:	74 35                	je     80042071c2 <page_check+0x1b1c>
  800420718d:	48 b9 f0 7e 21 04 80 	movabs $0x8004217ef0,%rcx
  8004207194:	00 00 00 
  8004207197:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420719e:	00 00 00 
  80042071a1:	be 86 05 00 00       	mov    $0x586,%esi
  80042071a6:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042071ad:	00 00 00 
  80042071b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042071b5:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042071bc:	00 00 00 
  80042071bf:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  80042071c2:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042071c6:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  80042071cd:	7e 9f                	jle    800420716e <page_check+0x1ac8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  80042071cf:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  80042071d6:	00 00 00 
  80042071d9:	48 8b 00             	mov    (%rax),%rax
  80042071dc:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  80042071e3:	48 b8 38 02 4a 04 80 	movabs $0x80044a0238,%rax
  80042071ea:	00 00 00 
  80042071ed:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042071f1:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  80042071f4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042071f8:	48 89 c7             	mov    %rax,%rdi
  80042071fb:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  8004207202:	00 00 00 
  8004207205:	ff d0                	callq  *%rax
	page_decref(pp1);
  8004207207:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420720b:	48 89 c7             	mov    %rax,%rdi
  800420720e:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  8004207215:	00 00 00 
  8004207218:	ff d0                	callq  *%rax
	page_decref(pp2);
  800420721a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420721e:	48 89 c7             	mov    %rax,%rdi
  8004207221:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  8004207228:	00 00 00 
  800420722b:	ff d0                	callq  *%rax

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  800420722d:	be 01 10 00 00       	mov    $0x1001,%esi
  8004207232:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207237:	48 b8 1b 3b 20 04 80 	movabs $0x8004203b1b,%rax
  800420723e:	00 00 00 
  8004207241:	ff d0                	callq  *%rax
  8004207243:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  800420724a:	be 00 10 00 00       	mov    $0x1000,%esi
  800420724f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207254:	48 b8 1b 3b 20 04 80 	movabs $0x8004203b1b,%rax
  800420725b:	00 00 00 
  800420725e:	ff d0                	callq  *%rax
  8004207260:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  8004207267:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420726e:	00 00 00 
  8004207271:	48 39 85 f8 fe ff ff 	cmp    %rax,-0x108(%rbp)
  8004207278:	76 1d                	jbe    8004207297 <page_check+0x1bf1>
  800420727a:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207281:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004207288:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  800420728f:	00 00 00 
  8004207292:	48 39 c2             	cmp    %rax,%rdx
  8004207295:	76 35                	jbe    80042072cc <page_check+0x1c26>
  8004207297:	48 b9 08 7f 21 04 80 	movabs $0x8004217f08,%rcx
  800420729e:	00 00 00 
  80042072a1:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042072a8:	00 00 00 
  80042072ab:	be 95 05 00 00       	mov    $0x595,%esi
  80042072b0:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042072b7:	00 00 00 
  80042072ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072bf:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042072c6:	00 00 00 
  80042072c9:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  80042072cc:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042072d3:	00 00 00 
  80042072d6:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  80042072dd:	76 1d                	jbe    80042072fc <page_check+0x1c56>
  80042072df:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042072e6:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  80042072ed:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042072f4:	00 00 00 
  80042072f7:	48 39 c2             	cmp    %rax,%rdx
  80042072fa:	76 35                	jbe    8004207331 <page_check+0x1c8b>
  80042072fc:	48 b9 30 7f 21 04 80 	movabs $0x8004217f30,%rcx
  8004207303:	00 00 00 
  8004207306:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420730d:	00 00 00 
  8004207310:	be 96 05 00 00       	mov    $0x596,%esi
  8004207315:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420731c:	00 00 00 
  800420731f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207324:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420732b:	00 00 00 
  800420732e:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  8004207331:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207338:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420733d:	48 85 c0             	test   %rax,%rax
  8004207340:	75 11                	jne    8004207353 <page_check+0x1cad>
  8004207342:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207349:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420734e:	48 85 c0             	test   %rax,%rax
  8004207351:	74 35                	je     8004207388 <page_check+0x1ce2>
  8004207353:	48 b9 58 7f 21 04 80 	movabs $0x8004217f58,%rcx
  800420735a:	00 00 00 
  800420735d:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004207364:	00 00 00 
  8004207367:	be 98 05 00 00       	mov    $0x598,%esi
  800420736c:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004207373:	00 00 00 
  8004207376:	b8 00 00 00 00       	mov    $0x0,%eax
  800420737b:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004207382:	00 00 00 
  8004207385:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  8004207388:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800420738f:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  8004207395:	48 3b 85 f0 fe ff ff 	cmp    -0x110(%rbp),%rax
  800420739c:	76 35                	jbe    80042073d3 <page_check+0x1d2d>
  800420739e:	48 b9 7f 7f 21 04 80 	movabs $0x8004217f7f,%rcx
  80042073a5:	00 00 00 
  80042073a8:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042073af:	00 00 00 
  80042073b2:	be 9a 05 00 00       	mov    $0x59a,%esi
  80042073b7:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042073be:	00 00 00 
  80042073c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073c6:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042073cd:	00 00 00 
  80042073d0:	41 ff d0             	callq  *%r8
	// check page mappings
	
	assert(check_va2pa(boot_pml4e, mm1) == 0);
  80042073d3:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  80042073da:	00 00 00 
  80042073dd:	48 8b 00             	mov    (%rax),%rax
  80042073e0:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  80042073e7:	48 89 d6             	mov    %rdx,%rsi
  80042073ea:	48 89 c7             	mov    %rax,%rdi
  80042073ed:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  80042073f4:	00 00 00 
  80042073f7:	ff d0                	callq  *%rax
  80042073f9:	48 85 c0             	test   %rax,%rax
  80042073fc:	74 35                	je     8004207433 <page_check+0x1d8d>
  80042073fe:	48 b9 98 7f 21 04 80 	movabs $0x8004217f98,%rcx
  8004207405:	00 00 00 
  8004207408:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  800420740f:	00 00 00 
  8004207412:	be 9d 05 00 00       	mov    $0x59d,%esi
  8004207417:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  800420741e:	00 00 00 
  8004207421:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207426:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420742d:	00 00 00 
  8004207430:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  8004207433:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800420743a:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207441:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004207448:	00 00 00 
  800420744b:	48 8b 00             	mov    (%rax),%rax
  800420744e:	48 89 d6             	mov    %rdx,%rsi
  8004207451:	48 89 c7             	mov    %rax,%rdi
  8004207454:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  800420745b:	00 00 00 
  800420745e:	ff d0                	callq  *%rax
  8004207460:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  8004207466:	74 35                	je     800420749d <page_check+0x1df7>
  8004207468:	48 b9 c0 7f 21 04 80 	movabs $0x8004217fc0,%rcx
  800420746f:	00 00 00 
  8004207472:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004207479:	00 00 00 
  800420747c:	be 9e 05 00 00       	mov    $0x59e,%esi
  8004207481:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004207488:	00 00 00 
  800420748b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207490:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004207497:	00 00 00 
  800420749a:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  800420749d:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  80042074a4:	00 00 00 
  80042074a7:	48 8b 00             	mov    (%rax),%rax
  80042074aa:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  80042074b1:	48 89 d6             	mov    %rdx,%rsi
  80042074b4:	48 89 c7             	mov    %rax,%rdi
  80042074b7:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  80042074be:	00 00 00 
  80042074c1:	ff d0                	callq  *%rax
  80042074c3:	48 85 c0             	test   %rax,%rax
  80042074c6:	74 35                	je     80042074fd <page_check+0x1e57>
  80042074c8:	48 b9 f0 7f 21 04 80 	movabs $0x8004217ff0,%rcx
  80042074cf:	00 00 00 
  80042074d2:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042074d9:	00 00 00 
  80042074dc:	be 9f 05 00 00       	mov    $0x59f,%esi
  80042074e1:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042074e8:	00 00 00 
  80042074eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074f0:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042074f7:	00 00 00 
  80042074fa:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  80042074fd:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207504:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  800420750b:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004207512:	00 00 00 
  8004207515:	48 8b 00             	mov    (%rax),%rax
  8004207518:	48 89 d6             	mov    %rdx,%rsi
  800420751b:	48 89 c7             	mov    %rax,%rdi
  800420751e:	48 b8 2c 54 20 04 80 	movabs $0x800420542c,%rax
  8004207525:	00 00 00 
  8004207528:	ff d0                	callq  *%rax
  800420752a:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420752e:	74 35                	je     8004207565 <page_check+0x1ebf>
  8004207530:	48 b9 18 80 21 04 80 	movabs $0x8004218018,%rcx
  8004207537:	00 00 00 
  800420753a:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004207541:	00 00 00 
  8004207544:	be a0 05 00 00       	mov    $0x5a0,%esi
  8004207549:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004207550:	00 00 00 
  8004207553:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207558:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420755f:	00 00 00 
  8004207562:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  8004207565:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  800420756c:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004207573:	00 00 00 
  8004207576:	48 8b 00             	mov    (%rax),%rax
  8004207579:	ba 00 00 00 00       	mov    $0x0,%edx
  800420757e:	48 89 ce             	mov    %rcx,%rsi
  8004207581:	48 89 c7             	mov    %rax,%rdi
  8004207584:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  800420758b:	00 00 00 
  800420758e:	ff d0                	callq  *%rax
  8004207590:	48 8b 00             	mov    (%rax),%rax
  8004207593:	83 e0 1a             	and    $0x1a,%eax
  8004207596:	48 85 c0             	test   %rax,%rax
  8004207599:	75 35                	jne    80042075d0 <page_check+0x1f2a>
  800420759b:	48 b9 48 80 21 04 80 	movabs $0x8004218048,%rcx
  80042075a2:	00 00 00 
  80042075a5:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  80042075ac:	00 00 00 
  80042075af:	be a2 05 00 00       	mov    $0x5a2,%esi
  80042075b4:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  80042075bb:	00 00 00 
  80042075be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075c3:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042075ca:	00 00 00 
  80042075cd:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  80042075d0:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  80042075d7:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  80042075de:	00 00 00 
  80042075e1:	48 8b 00             	mov    (%rax),%rax
  80042075e4:	ba 00 00 00 00       	mov    $0x0,%edx
  80042075e9:	48 89 ce             	mov    %rcx,%rsi
  80042075ec:	48 89 c7             	mov    %rax,%rdi
  80042075ef:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  80042075f6:	00 00 00 
  80042075f9:	ff d0                	callq  *%rax
  80042075fb:	48 8b 00             	mov    (%rax),%rax
  80042075fe:	83 e0 04             	and    $0x4,%eax
  8004207601:	48 85 c0             	test   %rax,%rax
  8004207604:	74 35                	je     800420763b <page_check+0x1f95>
  8004207606:	48 b9 90 80 21 04 80 	movabs $0x8004218090,%rcx
  800420760d:	00 00 00 
  8004207610:	48 ba 91 72 21 04 80 	movabs $0x8004217291,%rdx
  8004207617:	00 00 00 
  800420761a:	be a3 05 00 00       	mov    $0x5a3,%esi
  800420761f:	48 bf a6 72 21 04 80 	movabs $0x80042172a6,%rdi
  8004207626:	00 00 00 
  8004207629:	b8 00 00 00 00       	mov    $0x0,%eax
  800420762e:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004207635:	00 00 00 
  8004207638:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  800420763b:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  8004207642:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004207649:	00 00 00 
  800420764c:	48 8b 00             	mov    (%rax),%rax
  800420764f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207654:	48 89 ce             	mov    %rcx,%rsi
  8004207657:	48 89 c7             	mov    %rax,%rdi
  800420765a:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  8004207661:	00 00 00 
  8004207664:	ff d0                	callq  *%rax
  8004207666:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  800420766d:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207674:	48 05 00 10 00 00    	add    $0x1000,%rax
  800420767a:	48 89 c1             	mov    %rax,%rcx
  800420767d:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004207684:	00 00 00 
  8004207687:	48 8b 00             	mov    (%rax),%rax
  800420768a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420768f:	48 89 ce             	mov    %rcx,%rsi
  8004207692:	48 89 c7             	mov    %rax,%rdi
  8004207695:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  800420769c:	00 00 00 
  800420769f:	ff d0                	callq  *%rax
  80042076a1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  80042076a8:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  80042076af:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  80042076b6:	00 00 00 
  80042076b9:	48 8b 00             	mov    (%rax),%rax
  80042076bc:	ba 00 00 00 00       	mov    $0x0,%edx
  80042076c1:	48 89 ce             	mov    %rcx,%rsi
  80042076c4:	48 89 c7             	mov    %rax,%rdi
  80042076c7:	48 b8 2e 31 20 04 80 	movabs $0x800420312e,%rax
  80042076ce:	00 00 00 
  80042076d1:	ff d0                	callq  *%rax
  80042076d3:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  80042076da:	48 bf c3 80 21 04 80 	movabs $0x80042180c3,%rdi
  80042076e1:	00 00 00 
  80042076e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042076e9:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042076f0:	00 00 00 
  80042076f3:	ff d2                	callq  *%rdx
}
  80042076f5:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  80042076fc:	5b                   	pop    %rbx
  80042076fd:	5d                   	pop    %rbp
  80042076fe:	c3                   	retq   

00000080042076ff <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  80042076ff:	55                   	push   %rbp
  8004207700:	48 89 e5             	mov    %rsp,%rbp
  8004207703:	48 83 ec 08          	sub    $0x8,%rsp
  8004207707:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800420770b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420770f:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  8004207716:	00 00 00 
  8004207719:	48 8b 00             	mov    (%rax),%rax
  800420771c:	48 29 c2             	sub    %rax,%rdx
  800420771f:	48 89 d0             	mov    %rdx,%rax
  8004207722:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004207726:	c9                   	leaveq 
  8004207727:	c3                   	retq   

0000008004207728 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004207728:	55                   	push   %rbp
  8004207729:	48 89 e5             	mov    %rsp,%rbp
  800420772c:	48 83 ec 08          	sub    $0x8,%rsp
  8004207730:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004207734:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207738:	48 89 c7             	mov    %rax,%rdi
  800420773b:	48 b8 ff 76 20 04 80 	movabs $0x80042076ff,%rax
  8004207742:	00 00 00 
  8004207745:	ff d0                	callq  *%rax
  8004207747:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800420774b:	c9                   	leaveq 
  800420774c:	c3                   	retq   

000000800420774d <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  800420774d:	55                   	push   %rbp
  800420774e:	48 89 e5             	mov    %rsp,%rbp
  8004207751:	48 83 ec 10          	sub    $0x10,%rsp
  8004207755:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004207759:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420775d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207761:	48 89 c2             	mov    %rax,%rdx
  8004207764:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  800420776b:	00 00 00 
  800420776e:	48 8b 00             	mov    (%rax),%rax
  8004207771:	48 39 c2             	cmp    %rax,%rdx
  8004207774:	72 2a                	jb     80042077a0 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004207776:	48 ba e0 80 21 04 80 	movabs $0x80042180e0,%rdx
  800420777d:	00 00 00 
  8004207780:	be 54 00 00 00       	mov    $0x54,%esi
  8004207785:	48 bf ff 80 21 04 80 	movabs $0x80042180ff,%rdi
  800420778c:	00 00 00 
  800420778f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207794:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  800420779b:	00 00 00 
  800420779e:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  80042077a0:	48 b8 b8 17 4a 04 80 	movabs $0x80044a17b8,%rax
  80042077a7:	00 00 00 
  80042077aa:	48 8b 00             	mov    (%rax),%rax
  80042077ad:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042077b1:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042077b5:	48 c1 e2 04          	shl    $0x4,%rdx
  80042077b9:	48 01 d0             	add    %rdx,%rax
}
  80042077bc:	c9                   	leaveq 
  80042077bd:	c3                   	retq   

00000080042077be <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  80042077be:	55                   	push   %rbp
  80042077bf:	48 89 e5             	mov    %rsp,%rbp
  80042077c2:	48 83 ec 20          	sub    $0x20,%rsp
  80042077c6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  80042077ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042077ce:	48 89 c7             	mov    %rax,%rdi
  80042077d1:	48 b8 28 77 20 04 80 	movabs $0x8004207728,%rax
  80042077d8:	00 00 00 
  80042077db:	ff d0                	callq  *%rax
  80042077dd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042077e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042077e5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042077e9:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042077ec:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042077ef:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  80042077f6:	00 00 00 
  80042077f9:	48 8b 00             	mov    (%rax),%rax
  80042077fc:	48 39 c2             	cmp    %rax,%rdx
  80042077ff:	72 32                	jb     8004207833 <page2kva+0x75>
  8004207801:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207805:	48 89 c1             	mov    %rax,%rcx
  8004207808:	48 ba 10 81 21 04 80 	movabs $0x8004218110,%rdx
  800420780f:	00 00 00 
  8004207812:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004207817:	48 bf ff 80 21 04 80 	movabs $0x80042180ff,%rdi
  800420781e:	00 00 00 
  8004207821:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207826:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420782d:	00 00 00 
  8004207830:	41 ff d0             	callq  *%r8
  8004207833:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420783a:	00 00 00 
  800420783d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207841:	48 01 d0             	add    %rdx,%rax
}
  8004207844:	c9                   	leaveq 
  8004207845:	c3                   	retq   

0000008004207846 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  8004207846:	55                   	push   %rbp
  8004207847:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420784a:	48 bf 80 c7 22 04 80 	movabs $0x800422c780,%rdi
  8004207851:	00 00 00 
  8004207854:	48 b8 b7 6b 21 04 80 	movabs $0x8004216bb7,%rax
  800420785b:	00 00 00 
  800420785e:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  8004207860:	f3 90                	pause  
}
  8004207862:	5d                   	pop    %rbp
  8004207863:	c3                   	retq   

0000008004207864 <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  8004207864:	55                   	push   %rbp
  8004207865:	48 89 e5             	mov    %rsp,%rbp
  8004207868:	53                   	push   %rbx
  8004207869:	48 83 ec 28          	sub    $0x28,%rsp
  800420786d:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8004207870:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207874:	89 d0                	mov    %edx,%eax
  8004207876:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  8004207879:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420787d:	75 42                	jne    80042078c1 <envid2env+0x5d>
		*env_store = curenv;
  800420787f:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004207886:	00 00 00 
  8004207889:	ff d0                	callq  *%rax
  800420788b:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  8004207892:	00 00 00 
  8004207895:	48 98                	cltq   
  8004207897:	48 c1 e0 03          	shl    $0x3,%rax
  800420789b:	48 89 c2             	mov    %rax,%rdx
  800420789e:	48 c1 e2 04          	shl    $0x4,%rdx
  80042078a2:	48 29 c2             	sub    %rax,%rdx
  80042078a5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042078a9:	48 83 c0 08          	add    $0x8,%rax
  80042078ad:	48 8b 10             	mov    (%rax),%rdx
  80042078b0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042078b4:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  80042078b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078bc:	e9 09 01 00 00       	jmpq   80042079ca <envid2env+0x166>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  80042078c1:	48 b8 50 02 4a 04 80 	movabs $0x80044a0250,%rax
  80042078c8:	00 00 00 
  80042078cb:	48 8b 08             	mov    (%rax),%rcx
  80042078ce:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042078d1:	48 98                	cltq   
  80042078d3:	25 ff 03 00 00       	and    $0x3ff,%eax
  80042078d8:	48 89 c2             	mov    %rax,%rdx
  80042078db:	48 89 d0             	mov    %rdx,%rax
  80042078de:	48 c1 e0 03          	shl    $0x3,%rax
  80042078e2:	48 01 d0             	add    %rdx,%rax
  80042078e5:	48 c1 e0 05          	shl    $0x5,%rax
  80042078e9:	48 01 c8             	add    %rcx,%rax
  80042078ec:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  80042078f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042078f4:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042078fa:	85 c0                	test   %eax,%eax
  80042078fc:	74 0f                	je     800420790d <envid2env+0xa9>
  80042078fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207902:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207908:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  800420790b:	74 15                	je     8004207922 <envid2env+0xbe>
		*env_store = 0;
  800420790d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207911:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207918:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420791d:	e9 a8 00 00 00       	jmpq   80042079ca <envid2env+0x166>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207922:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207926:	0f 84 8e 00 00 00    	je     80042079ba <envid2env+0x156>
  800420792c:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004207933:	00 00 00 
  8004207936:	ff d0                	callq  *%rax
  8004207938:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420793f:	00 00 00 
  8004207942:	48 98                	cltq   
  8004207944:	48 c1 e0 03          	shl    $0x3,%rax
  8004207948:	48 89 c2             	mov    %rax,%rdx
  800420794b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420794f:	48 29 c2             	sub    %rax,%rdx
  8004207952:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207956:	48 83 c0 08          	add    $0x8,%rax
  800420795a:	48 8b 00             	mov    (%rax),%rax
  800420795d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207961:	74 57                	je     80042079ba <envid2env+0x156>
  8004207963:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207967:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  800420796d:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004207974:	00 00 00 
  8004207977:	ff d0                	callq  *%rax
  8004207979:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  8004207980:	00 00 00 
  8004207983:	48 98                	cltq   
  8004207985:	48 c1 e0 03          	shl    $0x3,%rax
  8004207989:	48 89 c2             	mov    %rax,%rdx
  800420798c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207990:	48 29 c2             	sub    %rax,%rdx
  8004207993:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207997:	48 83 c0 08          	add    $0x8,%rax
  800420799b:	48 8b 00             	mov    (%rax),%rax
  800420799e:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042079a4:	39 c3                	cmp    %eax,%ebx
  80042079a6:	74 12                	je     80042079ba <envid2env+0x156>
		*env_store = 0;
  80042079a8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042079ac:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  80042079b3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80042079b8:	eb 10                	jmp    80042079ca <envid2env+0x166>
	}

	*env_store = e;
  80042079ba:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042079be:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042079c2:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  80042079c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042079ca:	48 83 c4 28          	add    $0x28,%rsp
  80042079ce:	5b                   	pop    %rbx
  80042079cf:	5d                   	pop    %rbp
  80042079d0:	c3                   	retq   

00000080042079d1 <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  80042079d1:	55                   	push   %rbp
  80042079d2:	48 89 e5             	mov    %rsp,%rbp
  80042079d5:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.
	size_t i;
	struct Env* last = NULL;
  80042079d9:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042079e0:	00 
	memset(envs, 0, NENV * sizeof(struct Env));
  80042079e1:	48 b8 50 02 4a 04 80 	movabs $0x80044a0250,%rax
  80042079e8:	00 00 00 
  80042079eb:	48 8b 00             	mov    (%rax),%rax
  80042079ee:	ba 00 80 04 00       	mov    $0x48000,%edx
  80042079f3:	be 00 00 00 00       	mov    $0x0,%esi
  80042079f8:	48 89 c7             	mov    %rax,%rdi
  80042079fb:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004207a02:	00 00 00 
  8004207a05:	ff d0                	callq  *%rax
	for (i = 0; i < NENV; i++) {
  8004207a07:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207a0e:	00 
  8004207a0f:	e9 92 00 00 00       	jmpq   8004207aa6 <env_init+0xd5>
		if(last)
  8004207a14:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004207a19:	74 30                	je     8004207a4b <env_init+0x7a>
			last->env_link = &envs[i];
  8004207a1b:	48 b8 50 02 4a 04 80 	movabs $0x80044a0250,%rax
  8004207a22:	00 00 00 
  8004207a25:	48 8b 08             	mov    (%rax),%rcx
  8004207a28:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207a2c:	48 89 d0             	mov    %rdx,%rax
  8004207a2f:	48 c1 e0 03          	shl    $0x3,%rax
  8004207a33:	48 01 d0             	add    %rdx,%rax
  8004207a36:	48 c1 e0 05          	shl    $0x5,%rax
  8004207a3a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004207a3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207a42:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
  8004207a49:	eb 30                	jmp    8004207a7b <env_init+0xaa>
		else
			env_free_list = &envs[i];
  8004207a4b:	48 b8 50 02 4a 04 80 	movabs $0x80044a0250,%rax
  8004207a52:	00 00 00 
  8004207a55:	48 8b 08             	mov    (%rax),%rcx
  8004207a58:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207a5c:	48 89 d0             	mov    %rdx,%rax
  8004207a5f:	48 c1 e0 03          	shl    $0x3,%rax
  8004207a63:	48 01 d0             	add    %rdx,%rax
  8004207a66:	48 c1 e0 05          	shl    $0x5,%rax
  8004207a6a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004207a6e:	48 b8 58 02 4a 04 80 	movabs $0x80044a0258,%rax
  8004207a75:	00 00 00 
  8004207a78:	48 89 10             	mov    %rdx,(%rax)
		last = &envs[i];
  8004207a7b:	48 b8 50 02 4a 04 80 	movabs $0x80044a0250,%rax
  8004207a82:	00 00 00 
  8004207a85:	48 8b 08             	mov    (%rax),%rcx
  8004207a88:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207a8c:	48 89 d0             	mov    %rdx,%rax
  8004207a8f:	48 c1 e0 03          	shl    $0x3,%rax
  8004207a93:	48 01 d0             	add    %rdx,%rax
  8004207a96:	48 c1 e0 05          	shl    $0x5,%rax
  8004207a9a:	48 01 c8             	add    %rcx,%rax
  8004207a9d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// Set up envs array
	// LAB 3: Your code here.
	size_t i;
	struct Env* last = NULL;
	memset(envs, 0, NENV * sizeof(struct Env));
	for (i = 0; i < NENV; i++) {
  8004207aa1:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004207aa6:	48 81 7d f8 ff 03 00 	cmpq   $0x3ff,-0x8(%rbp)
  8004207aad:	00 
  8004207aae:	0f 86 60 ff ff ff    	jbe    8004207a14 <env_init+0x43>
		else
			env_free_list = &envs[i];
		last = &envs[i];
	}
	// Per-CPU part of the initialization
	env_init_percpu();
  8004207ab4:	48 b8 c2 7a 20 04 80 	movabs $0x8004207ac2,%rax
  8004207abb:	00 00 00 
  8004207abe:	ff d0                	callq  *%rax
}
  8004207ac0:	c9                   	leaveq 
  8004207ac1:	c3                   	retq   

0000008004207ac2 <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004207ac2:	55                   	push   %rbp
  8004207ac3:	48 89 e5             	mov    %rsp,%rbp
  8004207ac6:	53                   	push   %rbx
  8004207ac7:	48 83 ec 10          	sub    $0x10,%rsp
  8004207acb:	48 b8 88 c6 22 04 80 	movabs $0x800422c688,%rax
  8004207ad2:	00 00 00 
  8004207ad5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  8004207ad9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207add:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

// The kernel never uses GS or FS, so we leave those set to
// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  8004207ae0:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207ae5:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004207ae7:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207aec:	8e e0                	mov    %eax,%fs
// The kernel does use ES, DS, and SS.  We'll change between
// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  8004207aee:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207af3:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004207af5:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207afa:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  8004207afc:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207b01:	8e d0                	mov    %eax,%ss
// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  8004207b03:	b8 08 00 00 00       	mov    $0x8,%eax
  8004207b08:	89 c3                	mov    %eax,%ebx
  8004207b0a:	53                   	push   %rbx
  8004207b0b:	48 b8 18 7b 20 04 80 	movabs $0x8004207b18,%rax
  8004207b12:	00 00 00 
  8004207b15:	50                   	push   %rax
  8004207b16:	48 cb                	lretq  
  8004207b18:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  8004207b1e:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8004207b22:	0f 00 d0             	lldt   %ax
// For good measure, clear the local descriptor table (LDT),
// since we don't use it.
	lldt(0);
}
  8004207b25:	48 83 c4 10          	add    $0x10,%rsp
  8004207b29:	5b                   	pop    %rbx
  8004207b2a:	5d                   	pop    %rbp
  8004207b2b:	c3                   	retq   

0000008004207b2c <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  8004207b2c:	55                   	push   %rbp
  8004207b2d:	48 89 e5             	mov    %rsp,%rbp
  8004207b30:	48 83 ec 20          	sub    $0x20,%rsp
  8004207b34:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  8004207b38:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207b3f:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  8004207b40:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207b45:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  8004207b4c:	00 00 00 
  8004207b4f:	ff d0                	callq  *%rax
  8004207b51:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207b55:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004207b5a:	75 0a                	jne    8004207b66 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  8004207b5c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207b61:	e9 98 00 00 00       	jmpq   8004207bfe <env_setup_vm+0xd2>
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.

	//Increment page reference here
	p->pp_ref++;
  8004207b66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b6a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207b6e:	8d 50 01             	lea    0x1(%rax),%edx
  8004207b71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b75:	66 89 50 08          	mov    %dx,0x8(%rax)

	//fill structure values
	e->env_pml4e = (pml4e_t *)page2kva(p);
  8004207b79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b7d:	48 89 c7             	mov    %rax,%rdi
  8004207b80:	48 b8 be 77 20 04 80 	movabs $0x80042077be,%rax
  8004207b87:	00 00 00 
  8004207b8a:	ff d0                	callq  *%rax
  8004207b8c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207b90:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3= page2pa(p);
  8004207b97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b9b:	48 89 c7             	mov    %rax,%rdi
  8004207b9e:	48 b8 28 77 20 04 80 	movabs $0x8004207728,%rax
  8004207ba5:	00 00 00 
  8004207ba8:	ff d0                	callq  *%rax
  8004207baa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207bae:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)

	//copy kernel pml4e entries 
    //for (i = PML4(UTOP); i != NPDENTRIES; i++)
    //    e->env_pml4e[i] = boot_pml4e[i]|PTE_USER;
	
	e->env_pml4e[1] = boot_pml4e[1];
  8004207bb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207bb9:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207bc0:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004207bc4:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  8004207bcb:	00 00 00 
  8004207bce:	48 8b 00             	mov    (%rax),%rax
  8004207bd1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207bd5:	48 89 02             	mov    %rax,(%rdx)
	//cprintf("envpml4e[0] [%x],envpml4e[1] [%x], env cr3[%x] ,  UTOP [%x] PML4e1 [%x]",e->env_pml4e[0],e->env_pml4e[0], e->env_cr3, UTOP, PML4(UTOP));

	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 |PTE_P|PTE_W|PTE_U;
  8004207bd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207bdc:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207be3:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8004207be7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207beb:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207bf2:	48 83 c8 07          	or     $0x7,%rax
  8004207bf6:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  8004207bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207bfe:	c9                   	leaveq 
  8004207bff:	c3                   	retq   

0000008004207c00 <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  8004207c00:	55                   	push   %rbp
  8004207c01:	48 89 e5             	mov    %rsp,%rbp
  8004207c04:	48 83 ec 30          	sub    $0x30,%rsp
  8004207c08:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004207c0c:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  8004207c0f:	48 b8 58 02 4a 04 80 	movabs $0x80044a0258,%rax
  8004207c16:	00 00 00 
  8004207c19:	48 8b 00             	mov    (%rax),%rax
  8004207c1c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004207c20:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004207c25:	75 0a                	jne    8004207c31 <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  8004207c27:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004207c2c:	e9 76 01 00 00       	jmpq   8004207da7 <env_alloc+0x1a7>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  8004207c31:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c35:	48 89 c7             	mov    %rax,%rdi
  8004207c38:	48 b8 2c 7b 20 04 80 	movabs $0x8004207b2c,%rax
  8004207c3f:	00 00 00 
  8004207c42:	ff d0                	callq  *%rax
  8004207c44:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004207c47:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004207c4b:	79 08                	jns    8004207c55 <env_alloc+0x55>
		return r;
  8004207c4d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207c50:	e9 52 01 00 00       	jmpq   8004207da7 <env_alloc+0x1a7>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004207c55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c59:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207c5f:	05 00 10 00 00       	add    $0x1000,%eax
  8004207c64:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004207c69:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004207c6c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004207c70:	7f 07                	jg     8004207c79 <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  8004207c72:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  8004207c79:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207c7d:	48 b8 50 02 4a 04 80 	movabs $0x80044a0250,%rax
  8004207c84:	00 00 00 
  8004207c87:	48 8b 00             	mov    (%rax),%rax
  8004207c8a:	48 29 c2             	sub    %rax,%rdx
  8004207c8d:	48 89 d0             	mov    %rdx,%rax
  8004207c90:	48 c1 f8 05          	sar    $0x5,%rax
  8004207c94:	48 89 c2             	mov    %rax,%rdx
  8004207c97:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  8004207c9e:	e3 38 8e 
  8004207ca1:	48 0f af c2          	imul   %rdx,%rax
  8004207ca5:	0b 45 fc             	or     -0x4(%rbp),%eax
  8004207ca8:	89 c2                	mov    %eax,%edx
  8004207caa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cae:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004207cb4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cb8:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004207cbb:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004207cc1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cc5:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  8004207ccc:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004207ccf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cd3:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004207cda:	00 00 00 
	e->env_runs = 0;
  8004207cdd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ce1:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004207ce8:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004207ceb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cef:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004207cf4:	be 00 00 00 00       	mov    $0x0,%esi
  8004207cf9:	48 89 c7             	mov    %rax,%rdi
  8004207cfc:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004207d03:	00 00 00 
  8004207d06:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004207d08:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d0c:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  8004207d13:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  8004207d15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d19:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  8004207d1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d23:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  8004207d2a:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  8004207d2c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d30:	b9 00 e0 7f ef       	mov    $0xef7fe000,%ecx
  8004207d35:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  8004207d3c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d40:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  8004207d47:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags = e->env_tf.tf_eflags |FL_IF;
  8004207d49:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d4d:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004207d54:	80 cc 02             	or     $0x2,%ah
  8004207d57:	48 89 c2             	mov    %rax,%rdx
  8004207d5a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d5e:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	
	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  8004207d65:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d69:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004207d70:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  8004207d74:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d78:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004207d7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d83:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004207d8a:	48 b8 58 02 4a 04 80 	movabs $0x80044a0258,%rax
  8004207d91:	00 00 00 
  8004207d94:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004207d97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207d9b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207d9f:	48 89 10             	mov    %rdx,(%rax)
	//cprintf("env.tf->rsp [%x], e->env_id [%d]\n", e->env_tf.tf_rsp, e->env_id);

	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
	return 0;
  8004207da2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207da7:	c9                   	leaveq 
  8004207da8:	c3                   	retq   

0000008004207da9 <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  8004207da9:	55                   	push   %rbp
  8004207daa:	48 89 e5             	mov    %rsp,%rbp
  8004207dad:	48 83 ec 40          	sub    $0x40,%rsp
  8004207db1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004207db5:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207db9:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	uint64_t temp = (uint64_t)va;
  8004207dbd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207dc1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	size_t lenDown = (uint64_t)va - temp;
  8004207dc5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207dc9:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004207dcd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	int i = 0;
  8004207dd1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	struct PageInfo *p;
	// Address round down
	temp =  (temp / PGSIZE) * PGSIZE;
  8004207dd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207ddc:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207de0:	48 c1 e0 0c          	shl    $0xc,%rax
  8004207de4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	// size round up
	len += lenDown;
  8004207de8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207dec:	48 01 45 c8          	add    %rax,-0x38(%rbp)
	len = ((len + PGSIZE) / PGSIZE) * PGSIZE;
  8004207df0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207df4:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207dfa:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207dfe:	48 c1 e0 0c          	shl    $0xc,%rax
  8004207e02:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//cprintf("region_alloc entry PML4 is [%x] va [%x], memsize [%ld]\n", e->env_pml4e[0], va, len);

	//Alloc pages and insert physical pages in page table
	for(; i < len/PGSIZE; i++)
  8004207e06:	eb 79                	jmp    8004207e81 <region_alloc+0xd8>
	{	
		p = page_alloc(ALLOC_ZERO);
  8004207e08:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207e0d:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  8004207e14:	00 00 00 
  8004207e17:	ff d0                	callq  *%rax
  8004207e19:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if(p == NULL)
  8004207e1d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004207e22:	75 2a                	jne    8004207e4e <region_alloc+0xa5>
		    panic("Page alloc fail\n");
  8004207e24:	48 ba 33 81 21 04 80 	movabs $0x8004218133,%rdx
  8004207e2b:	00 00 00 
  8004207e2e:	be 4a 01 00 00       	mov    $0x14a,%esi
  8004207e33:	48 bf 44 81 21 04 80 	movabs $0x8004218144,%rdi
  8004207e3a:	00 00 00 
  8004207e3d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e42:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  8004207e49:	00 00 00 
  8004207e4c:	ff d1                	callq  *%rcx
		page_insert(e->env_pml4e, p, (void*)temp, PTE_U|PTE_P|PTE_W);
  8004207e4e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207e52:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207e56:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207e5d:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004207e61:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004207e66:	48 89 c7             	mov    %rax,%rdi
  8004207e69:	48 b8 c5 37 20 04 80 	movabs $0x80042037c5,%rax
  8004207e70:	00 00 00 
  8004207e73:	ff d0                	callq  *%rax
		temp+=PGSIZE;
  8004207e75:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004207e7c:	00 
	len += lenDown;
	len = ((len + PGSIZE) / PGSIZE) * PGSIZE;
	//cprintf("region_alloc entry PML4 is [%x] va [%x], memsize [%ld]\n", e->env_pml4e[0], va, len);

	//Alloc pages and insert physical pages in page table
	for(; i < len/PGSIZE; i++)
  8004207e7d:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004207e81:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004207e84:	48 98                	cltq   
  8004207e86:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004207e8a:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207e8e:	48 39 d0             	cmp    %rdx,%rax
  8004207e91:	0f 82 71 ff ff ff    	jb     8004207e08 <region_alloc+0x5f>
		temp+=PGSIZE;
		//cprintf("region_alloc temp = [%x] , index = [%x], e->env_pml4e is [%x], PML40 is [%x]\n", temp, PML4(temp), e->env_pml4e, e->env_pml4e[0]);
	}
	//cprintf("region_alloc end temp = [%x] , index = [%x], e->env_pml4e is [%x], PML40 is [%x]\n", temp, PML4(temp), e->env_pml4e, e->env_pml4e[0]);

}
  8004207e97:	c9                   	leaveq 
  8004207e98:	c3                   	retq   

0000008004207e99 <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004207e99:	55                   	push   %rbp
  8004207e9a:	48 89 e5             	mov    %rsp,%rbp
  8004207e9d:	48 83 ec 40          	sub    $0x40,%rsp
  8004207ea1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004207ea5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)

	struct PageInfo *p;
	struct Elf * elfHeader;
	struct Proghdr *ph, *eph;

	if(e == NULL || binary == NULL)
  8004207ea9:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004207eae:	74 07                	je     8004207eb7 <load_icode+0x1e>
  8004207eb0:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004207eb5:	75 2a                	jne    8004207ee1 <load_icode+0x48>
		panic("load icode Failed due to NULL input");
  8004207eb7:	48 ba 50 81 21 04 80 	movabs $0x8004218150,%rdx
  8004207ebe:	00 00 00 
  8004207ec1:	be 94 01 00 00       	mov    $0x194,%esi
  8004207ec6:	48 bf 44 81 21 04 80 	movabs $0x8004218144,%rdi
  8004207ecd:	00 00 00 
  8004207ed0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ed5:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  8004207edc:	00 00 00 
  8004207edf:	ff d1                	callq  *%rcx


	elfHeader = (struct Elf *) binary;	
  8004207ee1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207ee5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// is this a valid ELF?
	if (elfHeader->e_magic != ELF_MAGIC)
  8004207ee9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207eed:	8b 00                	mov    (%rax),%eax
  8004207eef:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  8004207ef4:	74 2a                	je     8004207f20 <load_icode+0x87>
		panic("load icode Failed due to Corrupt ELF");
  8004207ef6:	48 ba 78 81 21 04 80 	movabs $0x8004218178,%rdx
  8004207efd:	00 00 00 
  8004207f00:	be 9a 01 00 00       	mov    $0x19a,%esi
  8004207f05:	48 bf 44 81 21 04 80 	movabs $0x8004218144,%rdi
  8004207f0c:	00 00 00 
  8004207f0f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f14:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  8004207f1b:	00 00 00 
  8004207f1e:	ff d1                	callq  *%rcx

  	ph = (struct Proghdr *) (binary + elfHeader->e_phoff);
  8004207f20:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207f24:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207f28:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207f2c:	48 01 d0             	add    %rdx,%rax
  8004207f2f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	eph = ph + elfHeader->e_phnum;
  8004207f33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207f37:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  8004207f3b:	0f b7 c0             	movzwl %ax,%eax
  8004207f3e:	48 c1 e0 03          	shl    $0x3,%rax
  8004207f42:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207f49:	00 
  8004207f4a:	48 29 c2             	sub    %rax,%rdx
  8004207f4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f51:	48 01 d0             	add    %rdx,%rax
  8004207f54:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	lcr3(e->env_cr3);
  8004207f58:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f5c:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207f63:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004207f67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207f6b:	0f 22 d8             	mov    %rax,%cr3
	for (;ph < eph; ph++){
  8004207f6e:	e9 d3 00 00 00       	jmpq   8004208046 <load_icode+0x1ad>
		if(ELF_PROG_LOAD == ph->p_type){
  8004207f73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f77:	8b 00                	mov    (%rax),%eax
  8004207f79:	83 f8 01             	cmp    $0x1,%eax
  8004207f7c:	0f 85 bf 00 00 00    	jne    8004208041 <load_icode+0x1a8>
			if(ph->p_filesz <= ph->p_memsz){
  8004207f82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f86:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207f8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f8e:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004207f92:	48 39 c2             	cmp    %rax,%rdx
  8004207f95:	0f 87 a6 00 00 00    	ja     8004208041 <load_icode+0x1a8>
				region_alloc(e, (void *)ph->p_va, ph->p_memsz);
  8004207f9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f9f:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004207fa3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fa7:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207fab:	48 89 c1             	mov    %rax,%rcx
  8004207fae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207fb2:	48 89 ce             	mov    %rcx,%rsi
  8004207fb5:	48 89 c7             	mov    %rax,%rdi
  8004207fb8:	48 b8 a9 7d 20 04 80 	movabs $0x8004207da9,%rax
  8004207fbf:	00 00 00 
  8004207fc2:	ff d0                	callq  *%rax
				size_t a = e->env_pml4e[0];
  8004207fc4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207fc8:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207fcf:	48 8b 00             	mov    (%rax),%rax
  8004207fd2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				//cprintf("load icode Inter  e->env_pml4e is [%x], PML40 is [%x], PML41 is [%x], ph->p_filesz [%ld]\n",  e->env_pml4e, e->env_pml4e[0],e->env_pml4e[1], ph->p_filesz);

				memcpy((void*)ph->p_va, binary + ph->p_offset, ph->p_filesz);
  8004207fd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fda:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207fde:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fe2:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004207fe6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207fea:	48 01 c1             	add    %rax,%rcx
  8004207fed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207ff1:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207ff5:	48 89 ce             	mov    %rcx,%rsi
  8004207ff8:	48 89 c7             	mov    %rax,%rdi
  8004207ffb:	48 b8 48 fa 20 04 80 	movabs $0x800420fa48,%rax
  8004208002:	00 00 00 
  8004208005:	ff d0                	callq  *%rax
				memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
  8004208007:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420800b:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420800f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208013:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208017:	48 29 c2             	sub    %rax,%rdx
  800420801a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420801e:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004208022:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208026:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420802a:	48 01 c8             	add    %rcx,%rax
  800420802d:	be 00 00 00 00       	mov    $0x0,%esi
  8004208032:	48 89 c7             	mov    %rax,%rdi
  8004208035:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  800420803c:	00 00 00 
  800420803f:	ff d0                	callq  *%rax
		panic("load icode Failed due to Corrupt ELF");

  	ph = (struct Proghdr *) (binary + elfHeader->e_phoff);
	eph = ph + elfHeader->e_phnum;
	lcr3(e->env_cr3);
	for (;ph < eph; ph++){
  8004208041:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  8004208046:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420804a:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420804e:	0f 82 1f ff ff ff    	jb     8004207f73 <load_icode+0xda>
		}
	}
	// call the entry point from the ELF header
	// note: does not return!
	
	region_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE);
  8004208054:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208058:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420805d:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004208062:	48 89 c7             	mov    %rax,%rdi
  8004208065:	48 b8 a9 7d 20 04 80 	movabs $0x8004207da9,%rax
  800420806c:	00 00 00 
  800420806f:	ff d0                	callq  *%rax
	e->env_tf.tf_rip = (uintptr_t)(elfHeader->e_entry);
  8004208071:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208075:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208079:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420807d:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	e->elf = binary;
  8004208084:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208088:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420808c:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
}
  8004208093:	c9                   	leaveq 
  8004208094:	c3                   	retq   

0000008004208095 <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  8004208095:	55                   	push   %rbp
  8004208096:	48 89 e5             	mov    %rsp,%rbp
  8004208099:	48 83 ec 20          	sub    $0x20,%rsp
  800420809d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042080a1:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.

	struct Env *e;
	envid_t parent_id;
	if(env_alloc(&e, 0) != 0)
  80042080a4:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  80042080a8:	be 00 00 00 00       	mov    $0x0,%esi
  80042080ad:	48 89 c7             	mov    %rax,%rdi
  80042080b0:	48 b8 00 7c 20 04 80 	movabs $0x8004207c00,%rax
  80042080b7:	00 00 00 
  80042080ba:	ff d0                	callq  *%rax
  80042080bc:	85 c0                	test   %eax,%eax
  80042080be:	74 2a                	je     80042080ea <env_create+0x55>
	{
		panic("Failed in env_alloc");
  80042080c0:	48 ba 9d 81 21 04 80 	movabs $0x800421819d,%rdx
  80042080c7:	00 00 00 
  80042080ca:	be c7 01 00 00       	mov    $0x1c7,%esi
  80042080cf:	48 bf 44 81 21 04 80 	movabs $0x8004218144,%rdi
  80042080d6:	00 00 00 
  80042080d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042080de:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  80042080e5:	00 00 00 
  80042080e8:	ff d1                	callq  *%rcx
	}
	e->env_type = type;
  80042080ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042080ee:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042080f1:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
	if(type == ENV_TYPE_FS)
  80042080f7:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80042080fb:	75 19                	jne    8004208116 <env_create+0x81>
	{
			e->env_tf.tf_eflags |= FL_IOPL_MASK;
  80042080fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208101:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208105:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  800420810c:	80 ce 30             	or     $0x30,%dh
  800420810f:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	}
	load_icode(e, binary);
  8004208116:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420811a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420811e:	48 89 d6             	mov    %rdx,%rsi
  8004208121:	48 89 c7             	mov    %rax,%rdi
  8004208124:	48 b8 99 7e 20 04 80 	movabs $0x8004207e99,%rax
  800420812b:	00 00 00 
  800420812e:	ff d0                	callq  *%rax
}
  8004208130:	c9                   	leaveq 
  8004208131:	c3                   	retq   

0000008004208132 <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  8004208132:	55                   	push   %rbp
  8004208133:	48 89 e5             	mov    %rsp,%rbp
  8004208136:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  800420813d:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	physaddr_t pa;

	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004208144:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420814b:	00 00 00 
  800420814e:	ff d0                	callq  *%rax
  8004208150:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  8004208157:	00 00 00 
  800420815a:	48 98                	cltq   
  800420815c:	48 c1 e0 03          	shl    $0x3,%rax
  8004208160:	48 89 c2             	mov    %rax,%rdx
  8004208163:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208167:	48 29 c2             	sub    %rax,%rdx
  800420816a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420816e:	48 83 c0 08          	add    $0x8,%rax
  8004208172:	48 8b 00             	mov    (%rax),%rax
  8004208175:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  800420817c:	75 18                	jne    8004208196 <env_free+0x64>
		lcr3(boot_cr3);
  800420817e:	48 b8 a0 17 4a 04 80 	movabs $0x80044a17a0,%rax
  8004208185:	00 00 00 
  8004208188:	48 8b 00             	mov    (%rax),%rax
  800420818b:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  800420818f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004208193:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004208196:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420819d:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042081a4:	48 8b 00             	mov    (%rax),%rax
  80042081a7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042081ad:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042081b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042081b5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042081b9:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042081bc:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042081bf:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  80042081c6:	00 00 00 
  80042081c9:	48 8b 00             	mov    (%rax),%rax
  80042081cc:	48 39 c2             	cmp    %rax,%rdx
  80042081cf:	72 32                	jb     8004208203 <env_free+0xd1>
  80042081d1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042081d5:	48 89 c1             	mov    %rax,%rcx
  80042081d8:	48 ba 10 81 21 04 80 	movabs $0x8004218110,%rdx
  80042081df:	00 00 00 
  80042081e2:	be e5 01 00 00       	mov    $0x1e5,%esi
  80042081e7:	48 bf 44 81 21 04 80 	movabs $0x8004218144,%rdi
  80042081ee:	00 00 00 
  80042081f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042081f6:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042081fd:	00 00 00 
  8004208200:	41 ff d0             	callq  *%r8
  8004208203:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420820a:	00 00 00 
  800420820d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208211:	48 01 d0             	add    %rdx,%rax
  8004208214:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208218:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420821f:	00 
  8004208220:	e9 ab 02 00 00       	jmpq   80042084d0 <env_free+0x39e>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  8004208225:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208229:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208230:	00 
  8004208231:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208235:	48 01 d0             	add    %rdx,%rax
  8004208238:	48 8b 00             	mov    (%rax),%rax
  800420823b:	83 e0 01             	and    $0x1,%eax
  800420823e:	48 85 c0             	test   %rax,%rax
  8004208241:	75 05                	jne    8004208248 <env_free+0x116>
			continue;
  8004208243:	e9 83 02 00 00       	jmpq   80042084cb <env_free+0x399>
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004208248:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420824c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208253:	00 
  8004208254:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208258:	48 01 d0             	add    %rdx,%rax
  800420825b:	48 8b 00             	mov    (%rax),%rax
  800420825e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208264:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004208268:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420826c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208270:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004208273:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208276:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  800420827d:	00 00 00 
  8004208280:	48 8b 00             	mov    (%rax),%rax
  8004208283:	48 39 c2             	cmp    %rax,%rdx
  8004208286:	72 32                	jb     80042082ba <env_free+0x188>
  8004208288:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420828c:	48 89 c1             	mov    %rax,%rcx
  800420828f:	48 ba 10 81 21 04 80 	movabs $0x8004218110,%rdx
  8004208296:	00 00 00 
  8004208299:	be ed 01 00 00       	mov    $0x1ed,%esi
  800420829e:	48 bf 44 81 21 04 80 	movabs $0x8004218144,%rdi
  80042082a5:	00 00 00 
  80042082a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042082ad:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042082b4:	00 00 00 
  80042082b7:	41 ff d0             	callq  *%r8
  80042082ba:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042082c1:	00 00 00 
  80042082c4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042082c8:	48 01 d0             	add    %rdx,%rax
  80042082cb:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  80042082cf:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  80042082d4:	75 07                	jne    80042082dd <env_free+0x1ab>
  80042082d6:	b8 04 00 00 00       	mov    $0x4,%eax
  80042082db:	eb 05                	jmp    80042082e2 <env_free+0x1b0>
  80042082dd:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  80042082e2:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  80042082e5:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042082ec:	00 
  80042082ed:	e9 6e 01 00 00       	jmpq   8004208460 <env_free+0x32e>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  80042082f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042082f6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042082fd:	00 
  80042082fe:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208302:	48 01 d0             	add    %rdx,%rax
  8004208305:	48 8b 00             	mov    (%rax),%rax
  8004208308:	83 e0 01             	and    $0x1,%eax
  800420830b:	48 85 c0             	test   %rax,%rax
  800420830e:	75 05                	jne    8004208315 <env_free+0x1e3>
				continue;
  8004208310:	e9 46 01 00 00       	jmpq   800420845b <env_free+0x329>
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  8004208315:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208319:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208320:	00 
  8004208321:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208325:	48 01 d0             	add    %rdx,%rax
  8004208328:	48 8b 00             	mov    (%rax),%rax
  800420832b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208331:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pt = (pte_t*) KADDR(pa);
  8004208335:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208339:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800420833d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208341:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208345:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004208348:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420834b:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004208352:	00 00 00 
  8004208355:	48 8b 00             	mov    (%rax),%rax
  8004208358:	48 39 c2             	cmp    %rax,%rdx
  800420835b:	72 32                	jb     800420838f <env_free+0x25d>
  800420835d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208361:	48 89 c1             	mov    %rax,%rcx
  8004208364:	48 ba 10 81 21 04 80 	movabs $0x8004218110,%rdx
  800420836b:	00 00 00 
  800420836e:	be f7 01 00 00       	mov    $0x1f7,%esi
  8004208373:	48 bf 44 81 21 04 80 	movabs $0x8004218144,%rdi
  800420837a:	00 00 00 
  800420837d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208382:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004208389:	00 00 00 
  800420838c:	41 ff d0             	callq  *%r8
  800420838f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208396:	00 00 00 
  8004208399:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420839d:	48 01 d0             	add    %rdx,%rax
  80042083a0:	48 89 45 90          	mov    %rax,-0x70(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  80042083a4:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042083ab:	00 
  80042083ac:	eb 67                	jmp    8004208415 <env_free+0x2e3>
				if (pt[pteno] & PTE_P){
  80042083ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083b2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042083b9:	00 
  80042083ba:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042083be:	48 01 d0             	add    %rdx,%rax
  80042083c1:	48 8b 00             	mov    (%rax),%rax
  80042083c4:	83 e0 01             	and    $0x1,%eax
  80042083c7:	48 85 c0             	test   %rax,%rax
  80042083ca:	74 44                	je     8004208410 <env_free+0x2de>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  80042083cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042083d0:	48 c1 e0 1e          	shl    $0x1e,%rax
  80042083d4:	48 89 c2             	mov    %rax,%rdx
  80042083d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042083db:	48 c1 e0 15          	shl    $0x15,%rax
  80042083df:	48 09 c2             	or     %rax,%rdx
  80042083e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083e6:	48 c1 e0 0c          	shl    $0xc,%rax
  80042083ea:	48 09 d0             	or     %rdx,%rax
  80042083ed:	48 89 c2             	mov    %rax,%rdx
  80042083f0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042083f7:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042083fe:	48 89 d6             	mov    %rdx,%rsi
  8004208401:	48 89 c7             	mov    %rax,%rdi
  8004208404:	48 b8 bc 39 20 04 80 	movabs $0x80042039bc,%rax
  800420840b:	00 00 00 
  800420840e:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208410:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004208415:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  800420841c:	00 
  800420841d:	76 8f                	jbe    80042083ae <env_free+0x27c>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  800420841f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208423:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420842a:	00 
  800420842b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420842f:	48 01 d0             	add    %rdx,%rax
  8004208432:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  8004208439:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420843d:	48 89 c7             	mov    %rax,%rdi
  8004208440:	48 b8 4d 77 20 04 80 	movabs $0x800420774d,%rax
  8004208447:	00 00 00 
  800420844a:	ff d0                	callq  *%rax
  800420844c:	48 89 c7             	mov    %rax,%rdi
  800420844f:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  8004208456:	00 00 00 
  8004208459:	ff d0                	callq  *%rax
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  800420845b:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004208460:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004208463:	48 98                	cltq   
  8004208465:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208469:	0f 87 83 fe ff ff    	ja     80042082f2 <env_free+0x1c0>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  800420846f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208473:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420847a:	00 
  800420847b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420847f:	48 01 d0             	add    %rdx,%rax
  8004208482:	48 8b 00             	mov    (%rax),%rax
  8004208485:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420848b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		env_pdpe[pdpe_index] = 0;
  800420848f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208493:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420849a:	00 
  800420849b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420849f:	48 01 d0             	add    %rdx,%rax
  80042084a2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  80042084a9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042084ad:	48 89 c7             	mov    %rax,%rdi
  80042084b0:	48 b8 4d 77 20 04 80 	movabs $0x800420774d,%rax
  80042084b7:	00 00 00 
  80042084ba:	ff d0                	callq  *%rax
  80042084bc:	48 89 c7             	mov    %rax,%rdi
  80042084bf:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  80042084c6:	00 00 00 
  80042084c9:	ff d0                	callq  *%rax
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  80042084cb:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042084d0:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  80042084d5:	0f 86 4a fd ff ff    	jbe    8004208225 <env_free+0xf3>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  80042084db:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042084e2:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042084e9:	48 8b 00             	mov    (%rax),%rax
  80042084ec:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042084f2:	48 89 c7             	mov    %rax,%rdi
  80042084f5:	48 b8 4d 77 20 04 80 	movabs $0x800420774d,%rax
  80042084fc:	00 00 00 
  80042084ff:	ff d0                	callq  *%rax
  8004208501:	48 89 c7             	mov    %rax,%rdi
  8004208504:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  800420850b:	00 00 00 
  800420850e:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  8004208510:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208517:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420851e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  8004208525:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420852c:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208533:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  8004208537:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420853e:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004208545:	00 00 00 00 
	e->env_cr3 = 0;
  8004208549:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208550:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004208557:	00 00 00 00 
	page_decref(pa2page(pa));
  800420855b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420855f:	48 89 c7             	mov    %rax,%rdi
  8004208562:	48 b8 4d 77 20 04 80 	movabs $0x800420774d,%rax
  8004208569:	00 00 00 
  800420856c:	ff d0                	callq  *%rax
  800420856e:	48 89 c7             	mov    %rax,%rdi
  8004208571:	48 b8 ed 30 20 04 80 	movabs $0x80042030ed,%rax
  8004208578:	00 00 00 
  800420857b:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  800420857d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208584:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  800420858b:	00 00 00 
	e->env_link = env_free_list;
  800420858e:	48 b8 58 02 4a 04 80 	movabs $0x80044a0258,%rax
  8004208595:	00 00 00 
  8004208598:	48 8b 10             	mov    (%rax),%rdx
  800420859b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042085a2:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  80042085a9:	48 b8 58 02 4a 04 80 	movabs $0x80044a0258,%rax
  80042085b0:	00 00 00 
  80042085b3:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042085ba:	48 89 10             	mov    %rdx,(%rax)
}
  80042085bd:	c9                   	leaveq 
  80042085be:	c3                   	retq   

00000080042085bf <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  80042085bf:	55                   	push   %rbp
  80042085c0:	48 89 e5             	mov    %rsp,%rbp
  80042085c3:	48 83 ec 10          	sub    $0x10,%rsp
  80042085c7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  80042085cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042085cf:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042085d5:	83 f8 03             	cmp    $0x3,%eax
  80042085d8:	75 4a                	jne    8004208624 <env_destroy+0x65>
  80042085da:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  80042085e1:	00 00 00 
  80042085e4:	ff d0                	callq  *%rax
  80042085e6:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  80042085ed:	00 00 00 
  80042085f0:	48 98                	cltq   
  80042085f2:	48 c1 e0 03          	shl    $0x3,%rax
  80042085f6:	48 89 c2             	mov    %rax,%rdx
  80042085f9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042085fd:	48 29 c2             	sub    %rax,%rdx
  8004208600:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208604:	48 83 c0 08          	add    $0x8,%rax
  8004208608:	48 8b 00             	mov    (%rax),%rax
  800420860b:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420860f:	74 13                	je     8004208624 <env_destroy+0x65>
		e->env_status = ENV_DYING;
  8004208611:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208615:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  800420861c:	00 00 00 
		return;
  800420861f:	e9 8b 00 00 00       	jmpq   80042086af <env_destroy+0xf0>
	}

	env_free(e);
  8004208624:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208628:	48 89 c7             	mov    %rax,%rdi
  800420862b:	48 b8 32 81 20 04 80 	movabs $0x8004208132,%rax
  8004208632:	00 00 00 
  8004208635:	ff d0                	callq  *%rax

	if (curenv == e) {
  8004208637:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420863e:	00 00 00 
  8004208641:	ff d0                	callq  *%rax
  8004208643:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420864a:	00 00 00 
  800420864d:	48 98                	cltq   
  800420864f:	48 c1 e0 03          	shl    $0x3,%rax
  8004208653:	48 89 c2             	mov    %rax,%rdx
  8004208656:	48 c1 e2 04          	shl    $0x4,%rdx
  800420865a:	48 29 c2             	sub    %rax,%rdx
  800420865d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208661:	48 83 c0 08          	add    $0x8,%rax
  8004208665:	48 8b 00             	mov    (%rax),%rax
  8004208668:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420866c:	75 41                	jne    80042086af <env_destroy+0xf0>
		curenv = NULL;
  800420866e:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004208675:	00 00 00 
  8004208678:	ff d0                	callq  *%rax
  800420867a:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  8004208681:	00 00 00 
  8004208684:	48 98                	cltq   
  8004208686:	48 c1 e0 03          	shl    $0x3,%rax
  800420868a:	48 89 c2             	mov    %rax,%rdx
  800420868d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208691:	48 29 c2             	sub    %rax,%rdx
  8004208694:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208698:	48 83 c0 08          	add    $0x8,%rax
  800420869c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  80042086a3:	48 b8 93 ce 20 04 80 	movabs $0x800420ce93,%rax
  80042086aa:	00 00 00 
  80042086ad:	ff d0                	callq  *%rax
	}
}
  80042086af:	c9                   	leaveq 
  80042086b0:	c3                   	retq   

00000080042086b1 <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  80042086b1:	55                   	push   %rbp
  80042086b2:	48 89 e5             	mov    %rsp,%rbp
  80042086b5:	53                   	push   %rbx
  80042086b6:	48 83 ec 18          	sub    $0x18,%rsp
  80042086ba:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  80042086be:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  80042086c5:	00 00 00 
  80042086c8:	ff d0                	callq  *%rax
  80042086ca:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  80042086d1:	00 00 00 
  80042086d4:	48 98                	cltq   
  80042086d6:	48 c1 e0 03          	shl    $0x3,%rax
  80042086da:	48 89 c2             	mov    %rax,%rdx
  80042086dd:	48 c1 e2 04          	shl    $0x4,%rdx
  80042086e1:	48 29 c2             	sub    %rax,%rdx
  80042086e4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042086e8:	48 83 c0 08          	add    $0x8,%rax
  80042086ec:	48 8b 18             	mov    (%rax),%rbx
  80042086ef:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  80042086f6:	00 00 00 
  80042086f9:	ff d0                	callq  *%rax
  80042086fb:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)

	//cprintf("tf->rsp [%x]\n", tf->tf_rsp);
	__asm __volatile("movq %0,%%rsp\n"
  8004208701:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  8004208705:	4c 8b 3c 24          	mov    (%rsp),%r15
  8004208709:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420870e:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004208713:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  8004208718:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420871d:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  8004208722:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  8004208727:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420872c:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  8004208731:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  8004208736:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420873b:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  8004208740:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  8004208745:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420874a:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420874f:	48 83 c4 78          	add    $0x78,%rsp
  8004208753:	8e 04 24             	mov    (%rsp),%es
  8004208756:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  800420875a:	48 83 c4 10          	add    $0x10,%rsp
  800420875e:	48 83 c4 10          	add    $0x10,%rsp
  8004208762:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  8004208764:	48 ba b1 81 21 04 80 	movabs $0x80042181b1,%rdx
  800420876b:	00 00 00 
  800420876e:	be 46 02 00 00       	mov    $0x246,%esi
  8004208773:	48 bf 44 81 21 04 80 	movabs $0x8004218144,%rdi
  800420877a:	00 00 00 
  800420877d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208782:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  8004208789:	00 00 00 
  800420878c:	ff d1                	callq  *%rcx

000000800420878e <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  800420878e:	55                   	push   %rbp
  800420878f:	48 89 e5             	mov    %rsp,%rbp
  8004208792:	48 83 ec 20          	sub    $0x20,%rsp
  8004208796:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//	and make sure you have set the relevant parts of
	//	e->env_tf to sensible values.

	// LAB 3: Your code here.
	//cprintf("ENV_RUN being called from here: e->env_id [%d]",e->env_id); 
	if(curenv == e){
  800420879a:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  80042087a1:	00 00 00 
  80042087a4:	ff d0                	callq  *%rax
  80042087a6:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  80042087ad:	00 00 00 
  80042087b0:	48 98                	cltq   
  80042087b2:	48 c1 e0 03          	shl    $0x3,%rax
  80042087b6:	48 89 c2             	mov    %rax,%rdx
  80042087b9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042087bd:	48 29 c2             	sub    %rax,%rdx
  80042087c0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042087c4:	48 83 c0 08          	add    $0x8,%rax
  80042087c8:	48 8b 00             	mov    (%rax),%rax
  80042087cb:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042087cf:	0f 85 8c 00 00 00    	jne    8004208861 <env_run+0xd3>
		curenv->env_runs += 1;
  80042087d5:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  80042087dc:	00 00 00 
  80042087df:	ff d0                	callq  *%rax
  80042087e1:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  80042087e8:	00 00 00 
  80042087eb:	48 98                	cltq   
  80042087ed:	48 c1 e0 03          	shl    $0x3,%rax
  80042087f1:	48 89 c2             	mov    %rax,%rdx
  80042087f4:	48 c1 e2 04          	shl    $0x4,%rdx
  80042087f8:	48 29 c2             	sub    %rax,%rdx
  80042087fb:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042087ff:	48 83 c0 08          	add    $0x8,%rax
  8004208803:	48 8b 00             	mov    (%rax),%rax
  8004208806:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  800420880c:	83 c2 01             	add    $0x1,%edx
  800420880f:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
		unlock_kernel();
  8004208815:	48 b8 46 78 20 04 80 	movabs $0x8004207846,%rax
  800420881c:	00 00 00 
  800420881f:	ff d0                	callq  *%rax
		env_pop_tf(&curenv->env_tf);
  8004208821:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004208828:	00 00 00 
  800420882b:	ff d0                	callq  *%rax
  800420882d:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  8004208834:	00 00 00 
  8004208837:	48 98                	cltq   
  8004208839:	48 c1 e0 03          	shl    $0x3,%rax
  800420883d:	48 89 c2             	mov    %rax,%rdx
  8004208840:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208844:	48 29 c2             	sub    %rax,%rdx
  8004208847:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420884b:	48 83 c0 08          	add    $0x8,%rax
  800420884f:	48 8b 00             	mov    (%rax),%rax
  8004208852:	48 89 c7             	mov    %rax,%rdi
  8004208855:	48 b8 b1 86 20 04 80 	movabs $0x80042086b1,%rax
  800420885c:	00 00 00 
  800420885f:	ff d0                	callq  *%rax
	}
	if(curenv) //If this is a context switch
  8004208861:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004208868:	00 00 00 
  800420886b:	ff d0                	callq  *%rax
  800420886d:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  8004208874:	00 00 00 
  8004208877:	48 98                	cltq   
  8004208879:	48 c1 e0 03          	shl    $0x3,%rax
  800420887d:	48 89 c2             	mov    %rax,%rdx
  8004208880:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208884:	48 29 c2             	sub    %rax,%rdx
  8004208887:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420888b:	48 83 c0 08          	add    $0x8,%rax
  800420888f:	48 8b 00             	mov    (%rax),%rax
  8004208892:	48 85 c0             	test   %rax,%rax
  8004208895:	74 77                	je     800420890e <env_run+0x180>
	{
		if(curenv->env_status == ENV_RUNNING)
  8004208897:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420889e:	00 00 00 
  80042088a1:	ff d0                	callq  *%rax
  80042088a3:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  80042088aa:	00 00 00 
  80042088ad:	48 98                	cltq   
  80042088af:	48 c1 e0 03          	shl    $0x3,%rax
  80042088b3:	48 89 c2             	mov    %rax,%rdx
  80042088b6:	48 c1 e2 04          	shl    $0x4,%rdx
  80042088ba:	48 29 c2             	sub    %rax,%rdx
  80042088bd:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042088c1:	48 83 c0 08          	add    $0x8,%rax
  80042088c5:	48 8b 00             	mov    (%rax),%rax
  80042088c8:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042088ce:	83 f8 03             	cmp    $0x3,%eax
  80042088d1:	75 3b                	jne    800420890e <env_run+0x180>
		{
			curenv->env_status = ENV_RUNNABLE;	
  80042088d3:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  80042088da:	00 00 00 
  80042088dd:	ff d0                	callq  *%rax
  80042088df:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  80042088e6:	00 00 00 
  80042088e9:	48 98                	cltq   
  80042088eb:	48 c1 e0 03          	shl    $0x3,%rax
  80042088ef:	48 89 c2             	mov    %rax,%rdx
  80042088f2:	48 c1 e2 04          	shl    $0x4,%rdx
  80042088f6:	48 29 c2             	sub    %rax,%rdx
  80042088f9:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042088fd:	48 83 c0 08          	add    $0x8,%rax
  8004208901:	48 8b 00             	mov    (%rax),%rax
  8004208904:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420890b:	00 00 00 
		}
	}
	//make new enviornment as current enviornment
	
	curenv = e;
  800420890e:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004208915:	00 00 00 
  8004208918:	ff d0                	callq  *%rax
  800420891a:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  8004208921:	00 00 00 
  8004208924:	48 98                	cltq   
  8004208926:	48 c1 e0 03          	shl    $0x3,%rax
  800420892a:	48 89 c2             	mov    %rax,%rdx
  800420892d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208931:	48 29 c2             	sub    %rax,%rdx
  8004208934:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208938:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420893c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208940:	48 89 02             	mov    %rax,(%rdx)
	curenv->env_status = ENV_RUNNING;
  8004208943:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420894a:	00 00 00 
  800420894d:	ff d0                	callq  *%rax
  800420894f:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  8004208956:	00 00 00 
  8004208959:	48 98                	cltq   
  800420895b:	48 c1 e0 03          	shl    $0x3,%rax
  800420895f:	48 89 c2             	mov    %rax,%rdx
  8004208962:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208966:	48 29 c2             	sub    %rax,%rdx
  8004208969:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420896d:	48 83 c0 08          	add    $0x8,%rax
  8004208971:	48 8b 00             	mov    (%rax),%rax
  8004208974:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  800420897b:	00 00 00 
	curenv->env_runs += 1;
  800420897e:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004208985:	00 00 00 
  8004208988:	ff d0                	callq  *%rax
  800420898a:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  8004208991:	00 00 00 
  8004208994:	48 98                	cltq   
  8004208996:	48 c1 e0 03          	shl    $0x3,%rax
  800420899a:	48 89 c2             	mov    %rax,%rdx
  800420899d:	48 c1 e2 04          	shl    $0x4,%rdx
  80042089a1:	48 29 c2             	sub    %rax,%rdx
  80042089a4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042089a8:	48 83 c0 08          	add    $0x8,%rax
  80042089ac:	48 8b 00             	mov    (%rax),%rax
  80042089af:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  80042089b5:	83 c2 01             	add    $0x1,%edx
  80042089b8:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
	unlock_kernel();
  80042089be:	48 b8 46 78 20 04 80 	movabs $0x8004207846,%rax
  80042089c5:	00 00 00 
  80042089c8:	ff d0                	callq  *%rax
	lcr3(curenv->env_cr3);
  80042089ca:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  80042089d1:	00 00 00 
  80042089d4:	ff d0                	callq  *%rax
  80042089d6:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  80042089dd:	00 00 00 
  80042089e0:	48 98                	cltq   
  80042089e2:	48 c1 e0 03          	shl    $0x3,%rax
  80042089e6:	48 89 c2             	mov    %rax,%rdx
  80042089e9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042089ed:	48 29 c2             	sub    %rax,%rdx
  80042089f0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042089f4:	48 83 c0 08          	add    $0x8,%rax
  80042089f8:	48 8b 00             	mov    (%rax),%rax
  80042089fb:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208a02:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208a06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208a0a:	0f 22 d8             	mov    %rax,%cr3
	//restore the environment's registers
	//if(curenv->env_runs > 0)
	{
		env_pop_tf(&curenv->env_tf);
  8004208a0d:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004208a14:	00 00 00 
  8004208a17:	ff d0                	callq  *%rax
  8004208a19:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  8004208a20:	00 00 00 
  8004208a23:	48 98                	cltq   
  8004208a25:	48 c1 e0 03          	shl    $0x3,%rax
  8004208a29:	48 89 c2             	mov    %rax,%rdx
  8004208a2c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208a30:	48 29 c2             	sub    %rax,%rdx
  8004208a33:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208a37:	48 83 c0 08          	add    $0x8,%rax
  8004208a3b:	48 8b 00             	mov    (%rax),%rax
  8004208a3e:	48 89 c7             	mov    %rax,%rdi
  8004208a41:	48 b8 b1 86 20 04 80 	movabs $0x80042086b1,%rax
  8004208a48:	00 00 00 
  8004208a4b:	ff d0                	callq  *%rax

0000008004208a4d <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004208a4d:	55                   	push   %rbp
  8004208a4e:	48 89 e5             	mov    %rsp,%rbp
  8004208a51:	48 83 ec 14          	sub    $0x14,%rsp
  8004208a55:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  8004208a58:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208a5b:	0f b6 c0             	movzbl %al,%eax
  8004208a5e:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208a65:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208a68:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208a6c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208a6f:	ee                   	out    %al,(%dx)
  8004208a70:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004208a77:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004208a7a:	89 c2                	mov    %eax,%edx
  8004208a7c:	ec                   	in     (%dx),%al
  8004208a7d:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004208a80:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  8004208a84:	0f b6 c0             	movzbl %al,%eax
}
  8004208a87:	c9                   	leaveq 
  8004208a88:	c3                   	retq   

0000008004208a89 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  8004208a89:	55                   	push   %rbp
  8004208a8a:	48 89 e5             	mov    %rsp,%rbp
  8004208a8d:	48 83 ec 18          	sub    $0x18,%rsp
  8004208a91:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004208a94:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  8004208a97:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208a9a:	0f b6 c0             	movzbl %al,%eax
  8004208a9d:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208aa4:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208aa7:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208aab:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208aae:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004208aaf:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004208ab2:	0f b6 c0             	movzbl %al,%eax
  8004208ab5:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  8004208abc:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004208abf:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208ac3:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208ac6:	ee                   	out    %al,(%dx)
}
  8004208ac7:	c9                   	leaveq 
  8004208ac8:	c3                   	retq   

0000008004208ac9 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  8004208ac9:	55                   	push   %rbp
  8004208aca:	48 89 e5             	mov    %rsp,%rbp
  8004208acd:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  8004208ad1:	48 b8 60 02 4a 04 80 	movabs $0x80044a0260,%rax
  8004208ad8:	00 00 00 
  8004208adb:	c6 00 01             	movb   $0x1,(%rax)
  8004208ade:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004208ae5:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  8004208ae9:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208aed:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208af0:	ee                   	out    %al,(%dx)
  8004208af1:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004208af8:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  8004208afc:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208b00:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208b03:	ee                   	out    %al,(%dx)
  8004208b04:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  8004208b0b:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  8004208b0f:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004208b13:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004208b16:	ee                   	out    %al,(%dx)
  8004208b17:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  8004208b1e:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  8004208b22:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004208b26:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004208b29:	ee                   	out    %al,(%dx)
  8004208b2a:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  8004208b31:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  8004208b35:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004208b39:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004208b3c:	ee                   	out    %al,(%dx)
  8004208b3d:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  8004208b44:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  8004208b48:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004208b4c:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208b4f:	ee                   	out    %al,(%dx)
  8004208b50:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  8004208b57:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  8004208b5b:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004208b5f:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004208b62:	ee                   	out    %al,(%dx)
  8004208b63:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  8004208b6a:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  8004208b6e:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004208b72:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208b75:	ee                   	out    %al,(%dx)
  8004208b76:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  8004208b7d:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  8004208b81:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004208b85:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004208b88:	ee                   	out    %al,(%dx)
  8004208b89:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  8004208b90:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  8004208b94:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  8004208b98:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004208b9b:	ee                   	out    %al,(%dx)
  8004208b9c:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  8004208ba3:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  8004208ba7:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  8004208bab:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004208bae:	ee                   	out    %al,(%dx)
  8004208baf:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  8004208bb6:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  8004208bba:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  8004208bbe:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004208bc1:	ee                   	out    %al,(%dx)
  8004208bc2:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  8004208bc9:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  8004208bcd:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  8004208bd1:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208bd4:	ee                   	out    %al,(%dx)
  8004208bd5:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  8004208bdc:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004208be0:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  8004208be4:	8b 55 94             	mov    -0x6c(%rbp),%edx
  8004208be7:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004208be8:	48 b8 92 c6 22 04 80 	movabs $0x800422c692,%rax
  8004208bef:	00 00 00 
  8004208bf2:	0f b7 00             	movzwl (%rax),%eax
  8004208bf5:	66 83 f8 ff          	cmp    $0xffff,%ax
  8004208bf9:	74 1e                	je     8004208c19 <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  8004208bfb:	48 b8 92 c6 22 04 80 	movabs $0x800422c692,%rax
  8004208c02:	00 00 00 
  8004208c05:	0f b7 00             	movzwl (%rax),%eax
  8004208c08:	0f b7 c0             	movzwl %ax,%eax
  8004208c0b:	89 c7                	mov    %eax,%edi
  8004208c0d:	48 b8 1b 8c 20 04 80 	movabs $0x8004208c1b,%rax
  8004208c14:	00 00 00 
  8004208c17:	ff d0                	callq  *%rax
}
  8004208c19:	c9                   	leaveq 
  8004208c1a:	c3                   	retq   

0000008004208c1b <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  8004208c1b:	55                   	push   %rbp
  8004208c1c:	48 89 e5             	mov    %rsp,%rbp
  8004208c1f:	48 83 ec 30          	sub    $0x30,%rsp
  8004208c23:	89 f8                	mov    %edi,%eax
  8004208c25:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  8004208c29:	48 b8 92 c6 22 04 80 	movabs $0x800422c692,%rax
  8004208c30:	00 00 00 
  8004208c33:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8004208c37:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  8004208c3a:	48 b8 60 02 4a 04 80 	movabs $0x80044a0260,%rax
  8004208c41:	00 00 00 
  8004208c44:	0f b6 00             	movzbl (%rax),%eax
  8004208c47:	83 f0 01             	xor    $0x1,%eax
  8004208c4a:	84 c0                	test   %al,%al
  8004208c4c:	74 05                	je     8004208c53 <irq_setmask_8259A+0x38>
		return;
  8004208c4e:	e9 b7 00 00 00       	jmpq   8004208d0a <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  8004208c53:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208c57:	0f b6 c0             	movzbl %al,%eax
  8004208c5a:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  8004208c61:	88 45 f7             	mov    %al,-0x9(%rbp)
  8004208c64:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004208c68:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004208c6b:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  8004208c6c:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208c70:	66 c1 e8 08          	shr    $0x8,%ax
  8004208c74:	0f b6 c0             	movzbl %al,%eax
  8004208c77:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  8004208c7e:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004208c81:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004208c85:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004208c88:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  8004208c89:	48 bf bd 81 21 04 80 	movabs $0x80042181bd,%rdi
  8004208c90:	00 00 00 
  8004208c93:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208c98:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004208c9f:	00 00 00 
  8004208ca2:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  8004208ca4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004208cab:	eb 3c                	jmp    8004208ce9 <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  8004208cad:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208cb1:	f7 d0                	not    %eax
  8004208cb3:	89 c2                	mov    %eax,%edx
  8004208cb5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208cb8:	89 c1                	mov    %eax,%ecx
  8004208cba:	d3 fa                	sar    %cl,%edx
  8004208cbc:	89 d0                	mov    %edx,%eax
  8004208cbe:	83 e0 01             	and    $0x1,%eax
  8004208cc1:	85 c0                	test   %eax,%eax
  8004208cc3:	74 20                	je     8004208ce5 <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  8004208cc5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208cc8:	89 c6                	mov    %eax,%esi
  8004208cca:	48 bf d1 81 21 04 80 	movabs $0x80042181d1,%rdi
  8004208cd1:	00 00 00 
  8004208cd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208cd9:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004208ce0:	00 00 00 
  8004208ce3:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  8004208ce5:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004208ce9:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004208ced:	7e be                	jle    8004208cad <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004208cef:	48 bf d5 81 21 04 80 	movabs $0x80042181d5,%rdi
  8004208cf6:	00 00 00 
  8004208cf9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208cfe:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004208d05:	00 00 00 
  8004208d08:	ff d2                	callq  *%rdx
}
  8004208d0a:	c9                   	leaveq 
  8004208d0b:	c3                   	retq   

0000008004208d0c <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004208d0c:	55                   	push   %rbp
  8004208d0d:	48 89 e5             	mov    %rsp,%rbp
  8004208d10:	48 83 ec 10          	sub    $0x10,%rsp
  8004208d14:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004208d17:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004208d1b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208d1e:	89 c7                	mov    %eax,%edi
  8004208d20:	48 b8 50 12 20 04 80 	movabs $0x8004201250,%rax
  8004208d27:	00 00 00 
  8004208d2a:	ff d0                	callq  *%rax
	*cnt++;
  8004208d2c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208d30:	48 83 c0 04          	add    $0x4,%rax
  8004208d34:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  8004208d38:	c9                   	leaveq 
  8004208d39:	c3                   	retq   

0000008004208d3a <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004208d3a:	55                   	push   %rbp
  8004208d3b:	48 89 e5             	mov    %rsp,%rbp
  8004208d3e:	48 83 ec 30          	sub    $0x30,%rsp
  8004208d42:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208d46:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  8004208d4a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    va_list aq;
    va_copy(aq,ap);
  8004208d51:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004208d55:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208d59:	48 8b 0a             	mov    (%rdx),%rcx
  8004208d5c:	48 89 08             	mov    %rcx,(%rax)
  8004208d5f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208d63:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208d67:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208d6b:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004208d6f:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004208d73:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004208d77:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004208d7b:	48 89 c6             	mov    %rax,%rsi
  8004208d7e:	48 bf 0c 8d 20 04 80 	movabs $0x8004208d0c,%rdi
  8004208d85:	00 00 00 
  8004208d88:	48 b8 b6 ec 20 04 80 	movabs $0x800420ecb6,%rax
  8004208d8f:	00 00 00 
  8004208d92:	ff d0                	callq  *%rax
    va_end(aq);
	return cnt;
  8004208d94:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8004208d97:	c9                   	leaveq 
  8004208d98:	c3                   	retq   

0000008004208d99 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8004208d99:	55                   	push   %rbp
  8004208d9a:	48 89 e5             	mov    %rsp,%rbp
  8004208d9d:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004208da4:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004208dab:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004208db2:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004208db9:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004208dc0:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004208dc7:	84 c0                	test   %al,%al
  8004208dc9:	74 20                	je     8004208deb <cprintf+0x52>
  8004208dcb:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004208dcf:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004208dd3:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004208dd7:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004208ddb:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004208ddf:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004208de3:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004208de7:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004208deb:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004208df2:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8004208df9:	00 00 00 
  8004208dfc:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004208e03:	00 00 00 
  8004208e06:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004208e0a:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004208e11:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004208e18:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    va_list aq;
    va_copy(aq,ap);
  8004208e1f:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004208e26:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004208e2d:	48 8b 0a             	mov    (%rdx),%rcx
  8004208e30:	48 89 08             	mov    %rcx,(%rax)
  8004208e33:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208e37:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208e3b:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208e3f:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004208e43:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004208e4a:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004208e51:	48 89 d6             	mov    %rdx,%rsi
  8004208e54:	48 89 c7             	mov    %rax,%rdi
  8004208e57:	48 b8 3a 8d 20 04 80 	movabs $0x8004208d3a,%rax
  8004208e5e:	00 00 00 
  8004208e61:	ff d0                	callq  *%rax
  8004208e63:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  8004208e69:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004208e6f:	c9                   	leaveq 
  8004208e70:	c3                   	retq   

0000008004208e71 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004208e71:	55                   	push   %rbp
  8004208e72:	48 89 e5             	mov    %rsp,%rbp
  8004208e75:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004208e79:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004208e7d:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004208e80:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208e84:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004208e87:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004208e8b:	f0 87 02             	lock xchg %eax,(%rdx)
  8004208e8e:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004208e91:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004208e94:	c9                   	leaveq 
  8004208e95:	c3                   	retq   

0000008004208e96 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  8004208e96:	55                   	push   %rbp
  8004208e97:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004208e9a:	48 bf 80 c7 22 04 80 	movabs $0x800422c780,%rdi
  8004208ea1:	00 00 00 
  8004208ea4:	48 b8 e0 6a 21 04 80 	movabs $0x8004216ae0,%rax
  8004208eab:	00 00 00 
  8004208eae:	ff d0                	callq  *%rax
}
  8004208eb0:	5d                   	pop    %rbp
  8004208eb1:	c3                   	retq   

0000008004208eb2 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004208eb2:	55                   	push   %rbp
  8004208eb3:	48 89 e5             	mov    %rsp,%rbp
  8004208eb6:	48 83 ec 04          	sub    $0x4,%rsp
  8004208eba:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  8004208ebd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208ec0:	83 f8 13             	cmp    $0x13,%eax
  8004208ec3:	77 16                	ja     8004208edb <trapname+0x29>
		return excnames[trapno];
  8004208ec5:	48 b8 20 86 21 04 80 	movabs $0x8004218620,%rax
  8004208ecc:	00 00 00 
  8004208ecf:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208ed2:	48 63 d2             	movslq %edx,%rdx
  8004208ed5:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004208ed9:	eb 34                	jmp    8004208f0f <trapname+0x5d>
	if (trapno == T_SYSCALL)
  8004208edb:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004208edf:	75 0c                	jne    8004208eed <trapname+0x3b>
		return "System call";
  8004208ee1:	48 b8 e0 81 21 04 80 	movabs $0x80042181e0,%rax
  8004208ee8:	00 00 00 
  8004208eeb:	eb 22                	jmp    8004208f0f <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  8004208eed:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8004208ef1:	7e 12                	jle    8004208f05 <trapname+0x53>
  8004208ef3:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  8004208ef7:	7f 0c                	jg     8004208f05 <trapname+0x53>
		return "Hardware Interrupt";
  8004208ef9:	48 b8 ec 81 21 04 80 	movabs $0x80042181ec,%rax
  8004208f00:	00 00 00 
  8004208f03:	eb 0a                	jmp    8004208f0f <trapname+0x5d>
	return "(unknown trap)";
  8004208f05:	48 b8 ff 81 21 04 80 	movabs $0x80042181ff,%rax
  8004208f0c:	00 00 00 
}
  8004208f0f:	c9                   	leaveq 
  8004208f10:	c3                   	retq   

0000008004208f11 <trap_init>:


void
trap_init(void)
{
  8004208f11:	55                   	push   %rbp
  8004208f12:	48 89 e5             	mov    %rsp,%rbp
	extern struct Segdesc gdt[];

	// LAB 3: Your code here.
    SETGATE(idt[T_DIVIDE], 0, GD_KT, XTRPX_divzero, 0);  
  8004208f15:	48 b8 76 cc 20 04 80 	movabs $0x800420cc76,%rax
  8004208f1c:	00 00 00 
  8004208f1f:	89 c2                	mov    %eax,%edx
  8004208f21:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004208f28:	00 00 00 
  8004208f2b:	66 89 10             	mov    %dx,(%rax)
  8004208f2e:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004208f35:	00 00 00 
  8004208f38:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  8004208f3e:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004208f45:	00 00 00 
  8004208f48:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004208f4c:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208f4f:	88 50 04             	mov    %dl,0x4(%rax)
  8004208f52:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004208f59:	00 00 00 
  8004208f5c:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004208f60:	83 e2 07             	and    $0x7,%edx
  8004208f63:	88 50 04             	mov    %dl,0x4(%rax)
  8004208f66:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004208f6d:	00 00 00 
  8004208f70:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208f74:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208f77:	83 ca 0e             	or     $0xe,%edx
  8004208f7a:	88 50 05             	mov    %dl,0x5(%rax)
  8004208f7d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004208f84:	00 00 00 
  8004208f87:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208f8b:	83 e2 ef             	and    $0xffffffef,%edx
  8004208f8e:	88 50 05             	mov    %dl,0x5(%rax)
  8004208f91:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004208f98:	00 00 00 
  8004208f9b:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208f9f:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208fa2:	88 50 05             	mov    %dl,0x5(%rax)
  8004208fa5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004208fac:	00 00 00 
  8004208faf:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208fb3:	83 ca 80             	or     $0xffffff80,%edx
  8004208fb6:	88 50 05             	mov    %dl,0x5(%rax)
  8004208fb9:	48 b8 76 cc 20 04 80 	movabs $0x800420cc76,%rax
  8004208fc0:	00 00 00 
  8004208fc3:	48 c1 e8 10          	shr    $0x10,%rax
  8004208fc7:	89 c2                	mov    %eax,%edx
  8004208fc9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004208fd0:	00 00 00 
  8004208fd3:	66 89 50 06          	mov    %dx,0x6(%rax)
  8004208fd7:	48 b8 76 cc 20 04 80 	movabs $0x800420cc76,%rax
  8004208fde:	00 00 00 
  8004208fe1:	48 c1 e8 20          	shr    $0x20,%rax
  8004208fe5:	89 c2                	mov    %eax,%edx
  8004208fe7:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004208fee:	00 00 00 
  8004208ff1:	89 50 08             	mov    %edx,0x8(%rax)
  8004208ff4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004208ffb:	00 00 00 
  8004208ffe:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
    SETGATE(idt[T_DEBUG], 0, GD_KT, XTRPX_Debug, 0);  
  8004209005:	48 b8 80 cc 20 04 80 	movabs $0x800420cc80,%rax
  800420900c:	00 00 00 
  800420900f:	89 c2                	mov    %eax,%edx
  8004209011:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209018:	00 00 00 
  800420901b:	66 89 50 10          	mov    %dx,0x10(%rax)
  800420901f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209026:	00 00 00 
  8004209029:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  800420902f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209036:	00 00 00 
  8004209039:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  800420903d:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209040:	88 50 14             	mov    %dl,0x14(%rax)
  8004209043:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420904a:	00 00 00 
  800420904d:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004209051:	83 e2 07             	and    $0x7,%edx
  8004209054:	88 50 14             	mov    %dl,0x14(%rax)
  8004209057:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420905e:	00 00 00 
  8004209061:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004209065:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209068:	83 ca 0e             	or     $0xe,%edx
  800420906b:	88 50 15             	mov    %dl,0x15(%rax)
  800420906e:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209075:	00 00 00 
  8004209078:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420907c:	83 e2 ef             	and    $0xffffffef,%edx
  800420907f:	88 50 15             	mov    %dl,0x15(%rax)
  8004209082:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209089:	00 00 00 
  800420908c:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004209090:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209093:	88 50 15             	mov    %dl,0x15(%rax)
  8004209096:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420909d:	00 00 00 
  80042090a0:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042090a4:	83 ca 80             	or     $0xffffff80,%edx
  80042090a7:	88 50 15             	mov    %dl,0x15(%rax)
  80042090aa:	48 b8 80 cc 20 04 80 	movabs $0x800420cc80,%rax
  80042090b1:	00 00 00 
  80042090b4:	48 c1 e8 10          	shr    $0x10,%rax
  80042090b8:	89 c2                	mov    %eax,%edx
  80042090ba:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042090c1:	00 00 00 
  80042090c4:	66 89 50 16          	mov    %dx,0x16(%rax)
  80042090c8:	48 b8 80 cc 20 04 80 	movabs $0x800420cc80,%rax
  80042090cf:	00 00 00 
  80042090d2:	48 c1 e8 20          	shr    $0x20,%rax
  80042090d6:	89 c2                	mov    %eax,%edx
  80042090d8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042090df:	00 00 00 
  80042090e2:	89 50 18             	mov    %edx,0x18(%rax)
  80042090e5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042090ec:	00 00 00 
  80042090ef:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
    SETGATE(idt[T_NMI], 0, GD_KT, XTRPX_NonMaskI, 0);  
  80042090f6:	48 b8 8a cc 20 04 80 	movabs $0x800420cc8a,%rax
  80042090fd:	00 00 00 
  8004209100:	89 c2                	mov    %eax,%edx
  8004209102:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209109:	00 00 00 
  800420910c:	66 89 50 20          	mov    %dx,0x20(%rax)
  8004209110:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209117:	00 00 00 
  800420911a:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  8004209120:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209127:	00 00 00 
  800420912a:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  800420912e:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209131:	88 50 24             	mov    %dl,0x24(%rax)
  8004209134:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420913b:	00 00 00 
  800420913e:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004209142:	83 e2 07             	and    $0x7,%edx
  8004209145:	88 50 24             	mov    %dl,0x24(%rax)
  8004209148:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420914f:	00 00 00 
  8004209152:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209156:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209159:	83 ca 0e             	or     $0xe,%edx
  800420915c:	88 50 25             	mov    %dl,0x25(%rax)
  800420915f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209166:	00 00 00 
  8004209169:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  800420916d:	83 e2 ef             	and    $0xffffffef,%edx
  8004209170:	88 50 25             	mov    %dl,0x25(%rax)
  8004209173:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420917a:	00 00 00 
  800420917d:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209181:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209184:	88 50 25             	mov    %dl,0x25(%rax)
  8004209187:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420918e:	00 00 00 
  8004209191:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209195:	83 ca 80             	or     $0xffffff80,%edx
  8004209198:	88 50 25             	mov    %dl,0x25(%rax)
  800420919b:	48 b8 8a cc 20 04 80 	movabs $0x800420cc8a,%rax
  80042091a2:	00 00 00 
  80042091a5:	48 c1 e8 10          	shr    $0x10,%rax
  80042091a9:	89 c2                	mov    %eax,%edx
  80042091ab:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042091b2:	00 00 00 
  80042091b5:	66 89 50 26          	mov    %dx,0x26(%rax)
  80042091b9:	48 b8 8a cc 20 04 80 	movabs $0x800420cc8a,%rax
  80042091c0:	00 00 00 
  80042091c3:	48 c1 e8 20          	shr    $0x20,%rax
  80042091c7:	89 c2                	mov    %eax,%edx
  80042091c9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042091d0:	00 00 00 
  80042091d3:	89 50 28             	mov    %edx,0x28(%rax)
  80042091d6:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042091dd:	00 00 00 
  80042091e0:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
    SETGATE(idt[T_BRKPT], 0, GD_KT, XTRPX_Brkpt, 3);  
  80042091e7:	48 b8 94 cc 20 04 80 	movabs $0x800420cc94,%rax
  80042091ee:	00 00 00 
  80042091f1:	89 c2                	mov    %eax,%edx
  80042091f3:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042091fa:	00 00 00 
  80042091fd:	66 89 50 30          	mov    %dx,0x30(%rax)
  8004209201:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209208:	00 00 00 
  800420920b:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  8004209211:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209218:	00 00 00 
  800420921b:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  800420921f:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209222:	88 50 34             	mov    %dl,0x34(%rax)
  8004209225:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420922c:	00 00 00 
  800420922f:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004209233:	83 e2 07             	and    $0x7,%edx
  8004209236:	88 50 34             	mov    %dl,0x34(%rax)
  8004209239:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209240:	00 00 00 
  8004209243:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209247:	83 e2 f0             	and    $0xfffffff0,%edx
  800420924a:	83 ca 0e             	or     $0xe,%edx
  800420924d:	88 50 35             	mov    %dl,0x35(%rax)
  8004209250:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209257:	00 00 00 
  800420925a:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420925e:	83 e2 ef             	and    $0xffffffef,%edx
  8004209261:	88 50 35             	mov    %dl,0x35(%rax)
  8004209264:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420926b:	00 00 00 
  800420926e:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209272:	83 ca 60             	or     $0x60,%edx
  8004209275:	88 50 35             	mov    %dl,0x35(%rax)
  8004209278:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420927f:	00 00 00 
  8004209282:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209286:	83 ca 80             	or     $0xffffff80,%edx
  8004209289:	88 50 35             	mov    %dl,0x35(%rax)
  800420928c:	48 b8 94 cc 20 04 80 	movabs $0x800420cc94,%rax
  8004209293:	00 00 00 
  8004209296:	48 c1 e8 10          	shr    $0x10,%rax
  800420929a:	89 c2                	mov    %eax,%edx
  800420929c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042092a3:	00 00 00 
  80042092a6:	66 89 50 36          	mov    %dx,0x36(%rax)
  80042092aa:	48 b8 94 cc 20 04 80 	movabs $0x800420cc94,%rax
  80042092b1:	00 00 00 
  80042092b4:	48 c1 e8 20          	shr    $0x20,%rax
  80042092b8:	89 c2                	mov    %eax,%edx
  80042092ba:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042092c1:	00 00 00 
  80042092c4:	89 50 38             	mov    %edx,0x38(%rax)
  80042092c7:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042092ce:	00 00 00 
  80042092d1:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
    SETGATE(idt[T_OFLOW], 0, GD_KT, XTRPX_OFlow, 0);  
  80042092d8:	48 b8 9e cc 20 04 80 	movabs $0x800420cc9e,%rax
  80042092df:	00 00 00 
  80042092e2:	89 c2                	mov    %eax,%edx
  80042092e4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042092eb:	00 00 00 
  80042092ee:	66 89 50 40          	mov    %dx,0x40(%rax)
  80042092f2:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042092f9:	00 00 00 
  80042092fc:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  8004209302:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209309:	00 00 00 
  800420930c:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209310:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209313:	88 50 44             	mov    %dl,0x44(%rax)
  8004209316:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420931d:	00 00 00 
  8004209320:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209324:	83 e2 07             	and    $0x7,%edx
  8004209327:	88 50 44             	mov    %dl,0x44(%rax)
  800420932a:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209331:	00 00 00 
  8004209334:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209338:	83 e2 f0             	and    $0xfffffff0,%edx
  800420933b:	83 ca 0e             	or     $0xe,%edx
  800420933e:	88 50 45             	mov    %dl,0x45(%rax)
  8004209341:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209348:	00 00 00 
  800420934b:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420934f:	83 e2 ef             	and    $0xffffffef,%edx
  8004209352:	88 50 45             	mov    %dl,0x45(%rax)
  8004209355:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420935c:	00 00 00 
  800420935f:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209363:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209366:	88 50 45             	mov    %dl,0x45(%rax)
  8004209369:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209370:	00 00 00 
  8004209373:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209377:	83 ca 80             	or     $0xffffff80,%edx
  800420937a:	88 50 45             	mov    %dl,0x45(%rax)
  800420937d:	48 b8 9e cc 20 04 80 	movabs $0x800420cc9e,%rax
  8004209384:	00 00 00 
  8004209387:	48 c1 e8 10          	shr    $0x10,%rax
  800420938b:	89 c2                	mov    %eax,%edx
  800420938d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209394:	00 00 00 
  8004209397:	66 89 50 46          	mov    %dx,0x46(%rax)
  800420939b:	48 b8 9e cc 20 04 80 	movabs $0x800420cc9e,%rax
  80042093a2:	00 00 00 
  80042093a5:	48 c1 e8 20          	shr    $0x20,%rax
  80042093a9:	89 c2                	mov    %eax,%edx
  80042093ab:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042093b2:	00 00 00 
  80042093b5:	89 50 48             	mov    %edx,0x48(%rax)
  80042093b8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042093bf:	00 00 00 
  80042093c2:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
    SETGATE(idt[T_BOUND], 0, GD_KT, XTRPX_Bound, 0);  
  80042093c9:	48 b8 a8 cc 20 04 80 	movabs $0x800420cca8,%rax
  80042093d0:	00 00 00 
  80042093d3:	89 c2                	mov    %eax,%edx
  80042093d5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042093dc:	00 00 00 
  80042093df:	66 89 50 50          	mov    %dx,0x50(%rax)
  80042093e3:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042093ea:	00 00 00 
  80042093ed:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  80042093f3:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042093fa:	00 00 00 
  80042093fd:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004209401:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209404:	88 50 54             	mov    %dl,0x54(%rax)
  8004209407:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420940e:	00 00 00 
  8004209411:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004209415:	83 e2 07             	and    $0x7,%edx
  8004209418:	88 50 54             	mov    %dl,0x54(%rax)
  800420941b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209422:	00 00 00 
  8004209425:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209429:	83 e2 f0             	and    $0xfffffff0,%edx
  800420942c:	83 ca 0e             	or     $0xe,%edx
  800420942f:	88 50 55             	mov    %dl,0x55(%rax)
  8004209432:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209439:	00 00 00 
  800420943c:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209440:	83 e2 ef             	and    $0xffffffef,%edx
  8004209443:	88 50 55             	mov    %dl,0x55(%rax)
  8004209446:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420944d:	00 00 00 
  8004209450:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209454:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209457:	88 50 55             	mov    %dl,0x55(%rax)
  800420945a:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209461:	00 00 00 
  8004209464:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209468:	83 ca 80             	or     $0xffffff80,%edx
  800420946b:	88 50 55             	mov    %dl,0x55(%rax)
  800420946e:	48 b8 a8 cc 20 04 80 	movabs $0x800420cca8,%rax
  8004209475:	00 00 00 
  8004209478:	48 c1 e8 10          	shr    $0x10,%rax
  800420947c:	89 c2                	mov    %eax,%edx
  800420947e:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209485:	00 00 00 
  8004209488:	66 89 50 56          	mov    %dx,0x56(%rax)
  800420948c:	48 b8 a8 cc 20 04 80 	movabs $0x800420cca8,%rax
  8004209493:	00 00 00 
  8004209496:	48 c1 e8 20          	shr    $0x20,%rax
  800420949a:	89 c2                	mov    %eax,%edx
  800420949c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042094a3:	00 00 00 
  80042094a6:	89 50 58             	mov    %edx,0x58(%rax)
  80042094a9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042094b0:	00 00 00 
  80042094b3:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
    SETGATE(idt[T_ILLOP], 0, GD_KT, XTRPX_Illop, 0);  
  80042094ba:	48 b8 b2 cc 20 04 80 	movabs $0x800420ccb2,%rax
  80042094c1:	00 00 00 
  80042094c4:	89 c2                	mov    %eax,%edx
  80042094c6:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042094cd:	00 00 00 
  80042094d0:	66 89 50 60          	mov    %dx,0x60(%rax)
  80042094d4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042094db:	00 00 00 
  80042094de:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  80042094e4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042094eb:	00 00 00 
  80042094ee:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  80042094f2:	83 e2 f8             	and    $0xfffffff8,%edx
  80042094f5:	88 50 64             	mov    %dl,0x64(%rax)
  80042094f8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042094ff:	00 00 00 
  8004209502:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004209506:	83 e2 07             	and    $0x7,%edx
  8004209509:	88 50 64             	mov    %dl,0x64(%rax)
  800420950c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209513:	00 00 00 
  8004209516:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420951a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420951d:	83 ca 0e             	or     $0xe,%edx
  8004209520:	88 50 65             	mov    %dl,0x65(%rax)
  8004209523:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420952a:	00 00 00 
  800420952d:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209531:	83 e2 ef             	and    $0xffffffef,%edx
  8004209534:	88 50 65             	mov    %dl,0x65(%rax)
  8004209537:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420953e:	00 00 00 
  8004209541:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209545:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209548:	88 50 65             	mov    %dl,0x65(%rax)
  800420954b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209552:	00 00 00 
  8004209555:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209559:	83 ca 80             	or     $0xffffff80,%edx
  800420955c:	88 50 65             	mov    %dl,0x65(%rax)
  800420955f:	48 b8 b2 cc 20 04 80 	movabs $0x800420ccb2,%rax
  8004209566:	00 00 00 
  8004209569:	48 c1 e8 10          	shr    $0x10,%rax
  800420956d:	89 c2                	mov    %eax,%edx
  800420956f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209576:	00 00 00 
  8004209579:	66 89 50 66          	mov    %dx,0x66(%rax)
  800420957d:	48 b8 b2 cc 20 04 80 	movabs $0x800420ccb2,%rax
  8004209584:	00 00 00 
  8004209587:	48 c1 e8 20          	shr    $0x20,%rax
  800420958b:	89 c2                	mov    %eax,%edx
  800420958d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209594:	00 00 00 
  8004209597:	89 50 68             	mov    %edx,0x68(%rax)
  800420959a:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042095a1:	00 00 00 
  80042095a4:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
    SETGATE(idt[T_DEVICE], 0, GD_KT, XTRPX_Device, 0);  
  80042095ab:	48 b8 bc cc 20 04 80 	movabs $0x800420ccbc,%rax
  80042095b2:	00 00 00 
  80042095b5:	89 c2                	mov    %eax,%edx
  80042095b7:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042095be:	00 00 00 
  80042095c1:	66 89 50 70          	mov    %dx,0x70(%rax)
  80042095c5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042095cc:	00 00 00 
  80042095cf:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  80042095d5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042095dc:	00 00 00 
  80042095df:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  80042095e3:	83 e2 f8             	and    $0xfffffff8,%edx
  80042095e6:	88 50 74             	mov    %dl,0x74(%rax)
  80042095e9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042095f0:	00 00 00 
  80042095f3:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  80042095f7:	83 e2 07             	and    $0x7,%edx
  80042095fa:	88 50 74             	mov    %dl,0x74(%rax)
  80042095fd:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209604:	00 00 00 
  8004209607:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420960b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420960e:	83 ca 0e             	or     $0xe,%edx
  8004209611:	88 50 75             	mov    %dl,0x75(%rax)
  8004209614:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420961b:	00 00 00 
  800420961e:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209622:	83 e2 ef             	and    $0xffffffef,%edx
  8004209625:	88 50 75             	mov    %dl,0x75(%rax)
  8004209628:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420962f:	00 00 00 
  8004209632:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209636:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209639:	88 50 75             	mov    %dl,0x75(%rax)
  800420963c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209643:	00 00 00 
  8004209646:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420964a:	83 ca 80             	or     $0xffffff80,%edx
  800420964d:	88 50 75             	mov    %dl,0x75(%rax)
  8004209650:	48 b8 bc cc 20 04 80 	movabs $0x800420ccbc,%rax
  8004209657:	00 00 00 
  800420965a:	48 c1 e8 10          	shr    $0x10,%rax
  800420965e:	89 c2                	mov    %eax,%edx
  8004209660:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209667:	00 00 00 
  800420966a:	66 89 50 76          	mov    %dx,0x76(%rax)
  800420966e:	48 b8 bc cc 20 04 80 	movabs $0x800420ccbc,%rax
  8004209675:	00 00 00 
  8004209678:	48 c1 e8 20          	shr    $0x20,%rax
  800420967c:	89 c2                	mov    %eax,%edx
  800420967e:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209685:	00 00 00 
  8004209688:	89 50 78             	mov    %edx,0x78(%rax)
  800420968b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209692:	00 00 00 
  8004209695:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
    SETGATE(idt[T_DBLFLT], 0, GD_KT, XTRPX_DblFlt, 0);  
  800420969c:	48 b8 c6 cc 20 04 80 	movabs $0x800420ccc6,%rax
  80042096a3:	00 00 00 
  80042096a6:	89 c2                	mov    %eax,%edx
  80042096a8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042096af:	00 00 00 
  80042096b2:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  80042096b9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042096c0:	00 00 00 
  80042096c3:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  80042096ca:	08 00 
  80042096cc:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042096d3:	00 00 00 
  80042096d6:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  80042096dd:	83 e2 f8             	and    $0xfffffff8,%edx
  80042096e0:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  80042096e6:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042096ed:	00 00 00 
  80042096f0:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  80042096f7:	83 e2 07             	and    $0x7,%edx
  80042096fa:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209700:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209707:	00 00 00 
  800420970a:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209711:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209714:	83 ca 0e             	or     $0xe,%edx
  8004209717:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420971d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209724:	00 00 00 
  8004209727:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420972e:	83 e2 ef             	and    $0xffffffef,%edx
  8004209731:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209737:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420973e:	00 00 00 
  8004209741:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209748:	83 e2 9f             	and    $0xffffff9f,%edx
  800420974b:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209751:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209758:	00 00 00 
  800420975b:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209762:	83 ca 80             	or     $0xffffff80,%edx
  8004209765:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420976b:	48 b8 c6 cc 20 04 80 	movabs $0x800420ccc6,%rax
  8004209772:	00 00 00 
  8004209775:	48 c1 e8 10          	shr    $0x10,%rax
  8004209779:	89 c2                	mov    %eax,%edx
  800420977b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209782:	00 00 00 
  8004209785:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  800420978c:	48 b8 c6 cc 20 04 80 	movabs $0x800420ccc6,%rax
  8004209793:	00 00 00 
  8004209796:	48 c1 e8 20          	shr    $0x20,%rax
  800420979a:	89 c2                	mov    %eax,%edx
  800420979c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042097a3:	00 00 00 
  80042097a6:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  80042097ac:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042097b3:	00 00 00 
  80042097b6:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  80042097bd:	00 00 00 
    SETGATE(idt[T_TSS], 0, GD_KT, XTRPX_Tss, 0);  
  80042097c0:	48 b8 ce cc 20 04 80 	movabs $0x800420ccce,%rax
  80042097c7:	00 00 00 
  80042097ca:	89 c2                	mov    %eax,%edx
  80042097cc:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042097d3:	00 00 00 
  80042097d6:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  80042097dd:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042097e4:	00 00 00 
  80042097e7:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  80042097ee:	08 00 
  80042097f0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042097f7:	00 00 00 
  80042097fa:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004209801:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209804:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420980a:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209811:	00 00 00 
  8004209814:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420981b:	83 e2 07             	and    $0x7,%edx
  800420981e:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  8004209824:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420982b:	00 00 00 
  800420982e:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209835:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209838:	83 ca 0e             	or     $0xe,%edx
  800420983b:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209841:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209848:	00 00 00 
  800420984b:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209852:	83 e2 ef             	and    $0xffffffef,%edx
  8004209855:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420985b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209862:	00 00 00 
  8004209865:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420986c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420986f:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209875:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420987c:	00 00 00 
  800420987f:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209886:	83 ca 80             	or     $0xffffff80,%edx
  8004209889:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420988f:	48 b8 ce cc 20 04 80 	movabs $0x800420ccce,%rax
  8004209896:	00 00 00 
  8004209899:	48 c1 e8 10          	shr    $0x10,%rax
  800420989d:	89 c2                	mov    %eax,%edx
  800420989f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042098a6:	00 00 00 
  80042098a9:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  80042098b0:	48 b8 ce cc 20 04 80 	movabs $0x800420ccce,%rax
  80042098b7:	00 00 00 
  80042098ba:	48 c1 e8 20          	shr    $0x20,%rax
  80042098be:	89 c2                	mov    %eax,%edx
  80042098c0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042098c7:	00 00 00 
  80042098ca:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  80042098d0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042098d7:	00 00 00 
  80042098da:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  80042098e1:	00 00 00 
    SETGATE(idt[T_SEGNP], 0, GD_KT, XTRPX_Segnp, 0);  
  80042098e4:	48 b8 d6 cc 20 04 80 	movabs $0x800420ccd6,%rax
  80042098eb:	00 00 00 
  80042098ee:	89 c2                	mov    %eax,%edx
  80042098f0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042098f7:	00 00 00 
  80042098fa:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  8004209901:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209908:	00 00 00 
  800420990b:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  8004209912:	08 00 
  8004209914:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420991b:	00 00 00 
  800420991e:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004209925:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209928:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420992e:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209935:	00 00 00 
  8004209938:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420993f:	83 e2 07             	and    $0x7,%edx
  8004209942:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  8004209948:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420994f:	00 00 00 
  8004209952:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209959:	83 e2 f0             	and    $0xfffffff0,%edx
  800420995c:	83 ca 0e             	or     $0xe,%edx
  800420995f:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209965:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420996c:	00 00 00 
  800420996f:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209976:	83 e2 ef             	and    $0xffffffef,%edx
  8004209979:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420997f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209986:	00 00 00 
  8004209989:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209990:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209993:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209999:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042099a0:	00 00 00 
  80042099a3:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042099aa:	83 ca 80             	or     $0xffffff80,%edx
  80042099ad:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042099b3:	48 b8 d6 cc 20 04 80 	movabs $0x800420ccd6,%rax
  80042099ba:	00 00 00 
  80042099bd:	48 c1 e8 10          	shr    $0x10,%rax
  80042099c1:	89 c2                	mov    %eax,%edx
  80042099c3:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042099ca:	00 00 00 
  80042099cd:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  80042099d4:	48 b8 d6 cc 20 04 80 	movabs $0x800420ccd6,%rax
  80042099db:	00 00 00 
  80042099de:	48 c1 e8 20          	shr    $0x20,%rax
  80042099e2:	89 c2                	mov    %eax,%edx
  80042099e4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042099eb:	00 00 00 
  80042099ee:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  80042099f4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  80042099fb:	00 00 00 
  80042099fe:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  8004209a05:	00 00 00 
    SETGATE(idt[T_STACK], 0, GD_KT, XTRPX_Stack, 0);  
  8004209a08:	48 b8 de cc 20 04 80 	movabs $0x800420ccde,%rax
  8004209a0f:	00 00 00 
  8004209a12:	89 c2                	mov    %eax,%edx
  8004209a14:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209a1b:	00 00 00 
  8004209a1e:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  8004209a25:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209a2c:	00 00 00 
  8004209a2f:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  8004209a36:	08 00 
  8004209a38:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209a3f:	00 00 00 
  8004209a42:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209a49:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209a4c:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209a52:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209a59:	00 00 00 
  8004209a5c:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209a63:	83 e2 07             	and    $0x7,%edx
  8004209a66:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209a6c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209a73:	00 00 00 
  8004209a76:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209a7d:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209a80:	83 ca 0e             	or     $0xe,%edx
  8004209a83:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209a89:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209a90:	00 00 00 
  8004209a93:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209a9a:	83 e2 ef             	and    $0xffffffef,%edx
  8004209a9d:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209aa3:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209aaa:	00 00 00 
  8004209aad:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209ab4:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209ab7:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209abd:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209ac4:	00 00 00 
  8004209ac7:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209ace:	83 ca 80             	or     $0xffffff80,%edx
  8004209ad1:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209ad7:	48 b8 de cc 20 04 80 	movabs $0x800420ccde,%rax
  8004209ade:	00 00 00 
  8004209ae1:	48 c1 e8 10          	shr    $0x10,%rax
  8004209ae5:	89 c2                	mov    %eax,%edx
  8004209ae7:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209aee:	00 00 00 
  8004209af1:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  8004209af8:	48 b8 de cc 20 04 80 	movabs $0x800420ccde,%rax
  8004209aff:	00 00 00 
  8004209b02:	48 c1 e8 20          	shr    $0x20,%rax
  8004209b06:	89 c2                	mov    %eax,%edx
  8004209b08:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209b0f:	00 00 00 
  8004209b12:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  8004209b18:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209b1f:	00 00 00 
  8004209b22:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  8004209b29:	00 00 00 
    SETGATE(idt[T_GPFLT], 0, GD_KT, XTRPX_Gpflt, 0);  
  8004209b2c:	48 b8 e6 cc 20 04 80 	movabs $0x800420cce6,%rax
  8004209b33:	00 00 00 
  8004209b36:	89 c2                	mov    %eax,%edx
  8004209b38:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209b3f:	00 00 00 
  8004209b42:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  8004209b49:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209b50:	00 00 00 
  8004209b53:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  8004209b5a:	08 00 
  8004209b5c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209b63:	00 00 00 
  8004209b66:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  8004209b6d:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209b70:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209b76:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209b7d:	00 00 00 
  8004209b80:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  8004209b87:	83 e2 07             	and    $0x7,%edx
  8004209b8a:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209b90:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209b97:	00 00 00 
  8004209b9a:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209ba1:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209ba4:	83 ca 0e             	or     $0xe,%edx
  8004209ba7:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209bad:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209bb4:	00 00 00 
  8004209bb7:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209bbe:	83 e2 ef             	and    $0xffffffef,%edx
  8004209bc1:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209bc7:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209bce:	00 00 00 
  8004209bd1:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209bd8:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209bdb:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209be1:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209be8:	00 00 00 
  8004209beb:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209bf2:	83 ca 80             	or     $0xffffff80,%edx
  8004209bf5:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209bfb:	48 b8 e6 cc 20 04 80 	movabs $0x800420cce6,%rax
  8004209c02:	00 00 00 
  8004209c05:	48 c1 e8 10          	shr    $0x10,%rax
  8004209c09:	89 c2                	mov    %eax,%edx
  8004209c0b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209c12:	00 00 00 
  8004209c15:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  8004209c1c:	48 b8 e6 cc 20 04 80 	movabs $0x800420cce6,%rax
  8004209c23:	00 00 00 
  8004209c26:	48 c1 e8 20          	shr    $0x20,%rax
  8004209c2a:	89 c2                	mov    %eax,%edx
  8004209c2c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209c33:	00 00 00 
  8004209c36:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  8004209c3c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209c43:	00 00 00 
  8004209c46:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  8004209c4d:	00 00 00 
    SETGATE(idt[T_PGFLT], 0, GD_KT, XTRPX_Pgflt, 0);  
  8004209c50:	48 b8 ee cc 20 04 80 	movabs $0x800420ccee,%rax
  8004209c57:	00 00 00 
  8004209c5a:	89 c2                	mov    %eax,%edx
  8004209c5c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209c63:	00 00 00 
  8004209c66:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  8004209c6d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209c74:	00 00 00 
  8004209c77:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  8004209c7e:	08 00 
  8004209c80:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209c87:	00 00 00 
  8004209c8a:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209c91:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209c94:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209c9a:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209ca1:	00 00 00 
  8004209ca4:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209cab:	83 e2 07             	and    $0x7,%edx
  8004209cae:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209cb4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209cbb:	00 00 00 
  8004209cbe:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209cc5:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209cc8:	83 ca 0e             	or     $0xe,%edx
  8004209ccb:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209cd1:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209cd8:	00 00 00 
  8004209cdb:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209ce2:	83 e2 ef             	and    $0xffffffef,%edx
  8004209ce5:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209ceb:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209cf2:	00 00 00 
  8004209cf5:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209cfc:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209cff:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d05:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209d0c:	00 00 00 
  8004209d0f:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209d16:	83 ca 80             	or     $0xffffff80,%edx
  8004209d19:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d1f:	48 b8 ee cc 20 04 80 	movabs $0x800420ccee,%rax
  8004209d26:	00 00 00 
  8004209d29:	48 c1 e8 10          	shr    $0x10,%rax
  8004209d2d:	89 c2                	mov    %eax,%edx
  8004209d2f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209d36:	00 00 00 
  8004209d39:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  8004209d40:	48 b8 ee cc 20 04 80 	movabs $0x800420ccee,%rax
  8004209d47:	00 00 00 
  8004209d4a:	48 c1 e8 20          	shr    $0x20,%rax
  8004209d4e:	89 c2                	mov    %eax,%edx
  8004209d50:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209d57:	00 00 00 
  8004209d5a:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  8004209d60:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209d67:	00 00 00 
  8004209d6a:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  8004209d71:	00 00 00 
    SETGATE(idt[T_FPERR], 0, GD_KT, XTRPX_FpErr, 0);  
  8004209d74:	48 b8 f6 cc 20 04 80 	movabs $0x800420ccf6,%rax
  8004209d7b:	00 00 00 
  8004209d7e:	89 c2                	mov    %eax,%edx
  8004209d80:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209d87:	00 00 00 
  8004209d8a:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  8004209d91:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209d98:	00 00 00 
  8004209d9b:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  8004209da2:	08 00 
  8004209da4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209dab:	00 00 00 
  8004209dae:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209db5:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209db8:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209dbe:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209dc5:	00 00 00 
  8004209dc8:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209dcf:	83 e2 07             	and    $0x7,%edx
  8004209dd2:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209dd8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209ddf:	00 00 00 
  8004209de2:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209de9:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209dec:	83 ca 0e             	or     $0xe,%edx
  8004209def:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209df5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209dfc:	00 00 00 
  8004209dff:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e06:	83 e2 ef             	and    $0xffffffef,%edx
  8004209e09:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e0f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209e16:	00 00 00 
  8004209e19:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e20:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209e23:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e29:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209e30:	00 00 00 
  8004209e33:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e3a:	83 ca 80             	or     $0xffffff80,%edx
  8004209e3d:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e43:	48 b8 f6 cc 20 04 80 	movabs $0x800420ccf6,%rax
  8004209e4a:	00 00 00 
  8004209e4d:	48 c1 e8 10          	shr    $0x10,%rax
  8004209e51:	89 c2                	mov    %eax,%edx
  8004209e53:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209e5a:	00 00 00 
  8004209e5d:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  8004209e64:	48 b8 f6 cc 20 04 80 	movabs $0x800420ccf6,%rax
  8004209e6b:	00 00 00 
  8004209e6e:	48 c1 e8 20          	shr    $0x20,%rax
  8004209e72:	89 c2                	mov    %eax,%edx
  8004209e74:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209e7b:	00 00 00 
  8004209e7e:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  8004209e84:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209e8b:	00 00 00 
  8004209e8e:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  8004209e95:	00 00 00 
    SETGATE(idt[T_ALIGN], 0, GD_KT, XTRPX_Align, 0);  
  8004209e98:	48 b8 00 cd 20 04 80 	movabs $0x800420cd00,%rax
  8004209e9f:	00 00 00 
  8004209ea2:	89 c2                	mov    %eax,%edx
  8004209ea4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209eab:	00 00 00 
  8004209eae:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  8004209eb5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209ebc:	00 00 00 
  8004209ebf:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  8004209ec6:	08 00 
  8004209ec8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209ecf:	00 00 00 
  8004209ed2:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209ed9:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209edc:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209ee2:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209ee9:	00 00 00 
  8004209eec:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209ef3:	83 e2 07             	and    $0x7,%edx
  8004209ef6:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209efc:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209f03:	00 00 00 
  8004209f06:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f0d:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f10:	83 ca 0e             	or     $0xe,%edx
  8004209f13:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209f19:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209f20:	00 00 00 
  8004209f23:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f2a:	83 e2 ef             	and    $0xffffffef,%edx
  8004209f2d:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209f33:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209f3a:	00 00 00 
  8004209f3d:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f44:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209f47:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209f4d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209f54:	00 00 00 
  8004209f57:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f5e:	83 ca 80             	or     $0xffffff80,%edx
  8004209f61:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209f67:	48 b8 00 cd 20 04 80 	movabs $0x800420cd00,%rax
  8004209f6e:	00 00 00 
  8004209f71:	48 c1 e8 10          	shr    $0x10,%rax
  8004209f75:	89 c2                	mov    %eax,%edx
  8004209f77:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209f7e:	00 00 00 
  8004209f81:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  8004209f88:	48 b8 00 cd 20 04 80 	movabs $0x800420cd00,%rax
  8004209f8f:	00 00 00 
  8004209f92:	48 c1 e8 20          	shr    $0x20,%rax
  8004209f96:	89 c2                	mov    %eax,%edx
  8004209f98:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209f9f:	00 00 00 
  8004209fa2:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  8004209fa8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209faf:	00 00 00 
  8004209fb2:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  8004209fb9:	00 00 00 
    SETGATE(idt[T_MCHK], 0, GD_KT, XTRPX_Mchk, 0);  
  8004209fbc:	48 b8 04 cd 20 04 80 	movabs $0x800420cd04,%rax
  8004209fc3:	00 00 00 
  8004209fc6:	89 c2                	mov    %eax,%edx
  8004209fc8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209fcf:	00 00 00 
  8004209fd2:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  8004209fd9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209fe0:	00 00 00 
  8004209fe3:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  8004209fea:	08 00 
  8004209fec:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  8004209ff3:	00 00 00 
  8004209ff6:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  8004209ffd:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a000:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a006:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a00d:	00 00 00 
  800420a010:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a017:	83 e2 07             	and    $0x7,%edx
  800420a01a:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a020:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a027:	00 00 00 
  800420a02a:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a031:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a034:	83 ca 0e             	or     $0xe,%edx
  800420a037:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a03d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a044:	00 00 00 
  800420a047:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a04e:	83 e2 ef             	and    $0xffffffef,%edx
  800420a051:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a057:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a05e:	00 00 00 
  800420a061:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a068:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a06b:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a071:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a078:	00 00 00 
  800420a07b:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a082:	83 ca 80             	or     $0xffffff80,%edx
  800420a085:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a08b:	48 b8 04 cd 20 04 80 	movabs $0x800420cd04,%rax
  800420a092:	00 00 00 
  800420a095:	48 c1 e8 10          	shr    $0x10,%rax
  800420a099:	89 c2                	mov    %eax,%edx
  800420a09b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a0a2:	00 00 00 
  800420a0a5:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  800420a0ac:	48 b8 04 cd 20 04 80 	movabs $0x800420cd04,%rax
  800420a0b3:	00 00 00 
  800420a0b6:	48 c1 e8 20          	shr    $0x20,%rax
  800420a0ba:	89 c2                	mov    %eax,%edx
  800420a0bc:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a0c3:	00 00 00 
  800420a0c6:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  800420a0cc:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a0d3:	00 00 00 
  800420a0d6:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  800420a0dd:	00 00 00 
    SETGATE(idt[T_SIMDERR], 0, GD_KT, XTRPX_SimdErr, 0);  
  800420a0e0:	48 b8 0a cd 20 04 80 	movabs $0x800420cd0a,%rax
  800420a0e7:	00 00 00 
  800420a0ea:	89 c2                	mov    %eax,%edx
  800420a0ec:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a0f3:	00 00 00 
  800420a0f6:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  800420a0fd:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a104:	00 00 00 
  800420a107:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  800420a10e:	08 00 
  800420a110:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a117:	00 00 00 
  800420a11a:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a121:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a124:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a12a:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a131:	00 00 00 
  800420a134:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a13b:	83 e2 07             	and    $0x7,%edx
  800420a13e:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a144:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a14b:	00 00 00 
  800420a14e:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a155:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a158:	83 ca 0e             	or     $0xe,%edx
  800420a15b:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a161:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a168:	00 00 00 
  800420a16b:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a172:	83 e2 ef             	and    $0xffffffef,%edx
  800420a175:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a17b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a182:	00 00 00 
  800420a185:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a18c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a18f:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a195:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a19c:	00 00 00 
  800420a19f:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a1a6:	83 ca 80             	or     $0xffffff80,%edx
  800420a1a9:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a1af:	48 b8 0a cd 20 04 80 	movabs $0x800420cd0a,%rax
  800420a1b6:	00 00 00 
  800420a1b9:	48 c1 e8 10          	shr    $0x10,%rax
  800420a1bd:	89 c2                	mov    %eax,%edx
  800420a1bf:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a1c6:	00 00 00 
  800420a1c9:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  800420a1d0:	48 b8 0a cd 20 04 80 	movabs $0x800420cd0a,%rax
  800420a1d7:	00 00 00 
  800420a1da:	48 c1 e8 20          	shr    $0x20,%rax
  800420a1de:	89 c2                	mov    %eax,%edx
  800420a1e0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a1e7:	00 00 00 
  800420a1ea:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  800420a1f0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a1f7:	00 00 00 
  800420a1fa:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  800420a201:	00 00 00 
    SETGATE(idt[T_SYSCALL], 0, GD_KT, XTRPX_Syscall, 3);
  800420a204:	48 b8 10 cd 20 04 80 	movabs $0x800420cd10,%rax
  800420a20b:	00 00 00 
  800420a20e:	89 c2                	mov    %eax,%edx
  800420a210:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a217:	00 00 00 
  800420a21a:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  800420a221:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a228:	00 00 00 
  800420a22b:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  800420a232:	08 00 
  800420a234:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a23b:	00 00 00 
  800420a23e:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420a245:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a248:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420a24e:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a255:	00 00 00 
  800420a258:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420a25f:	83 e2 07             	and    $0x7,%edx
  800420a262:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420a268:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a26f:	00 00 00 
  800420a272:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a279:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a27c:	83 ca 0e             	or     $0xe,%edx
  800420a27f:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a285:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a28c:	00 00 00 
  800420a28f:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a296:	83 e2 ef             	and    $0xffffffef,%edx
  800420a299:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a29f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a2a6:	00 00 00 
  800420a2a9:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a2b0:	83 ca 60             	or     $0x60,%edx
  800420a2b3:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a2b9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a2c0:	00 00 00 
  800420a2c3:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a2ca:	83 ca 80             	or     $0xffffff80,%edx
  800420a2cd:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a2d3:	48 b8 10 cd 20 04 80 	movabs $0x800420cd10,%rax
  800420a2da:	00 00 00 
  800420a2dd:	48 c1 e8 10          	shr    $0x10,%rax
  800420a2e1:	89 c2                	mov    %eax,%edx
  800420a2e3:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a2ea:	00 00 00 
  800420a2ed:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  800420a2f4:	48 b8 10 cd 20 04 80 	movabs $0x800420cd10,%rax
  800420a2fb:	00 00 00 
  800420a2fe:	48 c1 e8 20          	shr    $0x20,%rax
  800420a302:	89 c2                	mov    %eax,%edx
  800420a304:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a30b:	00 00 00 
  800420a30e:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  800420a314:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a31b:	00 00 00 
  800420a31e:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420a325:	00 00 00 
    SETGATE(idt[T_DEFAULT], 0, GD_KT, XTRPX_Default, 0);
  800420a328:	48 b8 16 cd 20 04 80 	movabs $0x800420cd16,%rax
  800420a32f:	00 00 00 
  800420a332:	89 c2                	mov    %eax,%edx
  800420a334:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a33b:	00 00 00 
  800420a33e:	66 89 90 40 1f 00 00 	mov    %dx,0x1f40(%rax)
  800420a345:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a34c:	00 00 00 
  800420a34f:	66 c7 80 42 1f 00 00 	movw   $0x8,0x1f42(%rax)
  800420a356:	08 00 
  800420a358:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a35f:	00 00 00 
  800420a362:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420a369:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a36c:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  800420a372:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a379:	00 00 00 
  800420a37c:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420a383:	83 e2 07             	and    $0x7,%edx
  800420a386:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  800420a38c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a393:	00 00 00 
  800420a396:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a39d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a3a0:	83 ca 0e             	or     $0xe,%edx
  800420a3a3:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a3a9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a3b0:	00 00 00 
  800420a3b3:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a3ba:	83 e2 ef             	and    $0xffffffef,%edx
  800420a3bd:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a3c3:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a3ca:	00 00 00 
  800420a3cd:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a3d4:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a3d7:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a3dd:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a3e4:	00 00 00 
  800420a3e7:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a3ee:	83 ca 80             	or     $0xffffff80,%edx
  800420a3f1:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a3f7:	48 b8 16 cd 20 04 80 	movabs $0x800420cd16,%rax
  800420a3fe:	00 00 00 
  800420a401:	48 c1 e8 10          	shr    $0x10,%rax
  800420a405:	89 c2                	mov    %eax,%edx
  800420a407:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a40e:	00 00 00 
  800420a411:	66 89 90 46 1f 00 00 	mov    %dx,0x1f46(%rax)
  800420a418:	48 b8 16 cd 20 04 80 	movabs $0x800420cd16,%rax
  800420a41f:	00 00 00 
  800420a422:	48 c1 e8 20          	shr    $0x20,%rax
  800420a426:	89 c2                	mov    %eax,%edx
  800420a428:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a42f:	00 00 00 
  800420a432:	89 90 48 1f 00 00    	mov    %edx,0x1f48(%rax)
  800420a438:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a43f:	00 00 00 
  800420a442:	c7 80 4c 1f 00 00 00 	movl   $0x0,0x1f4c(%rax)
  800420a449:	00 00 00 
	
    SETGATE(idt[IRQ_OFFSET+IRQ_TIMER], 0, GD_KT, XTRPX_IRQ0, 0);
  800420a44c:	48 b8 20 cd 20 04 80 	movabs $0x800420cd20,%rax
  800420a453:	00 00 00 
  800420a456:	89 c2                	mov    %eax,%edx
  800420a458:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a45f:	00 00 00 
  800420a462:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  800420a469:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a470:	00 00 00 
  800420a473:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  800420a47a:	08 00 
  800420a47c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a483:	00 00 00 
  800420a486:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a48d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a490:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a496:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a49d:	00 00 00 
  800420a4a0:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a4a7:	83 e2 07             	and    $0x7,%edx
  800420a4aa:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a4b0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a4b7:	00 00 00 
  800420a4ba:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a4c1:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a4c4:	83 ca 0e             	or     $0xe,%edx
  800420a4c7:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a4cd:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a4d4:	00 00 00 
  800420a4d7:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a4de:	83 e2 ef             	and    $0xffffffef,%edx
  800420a4e1:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a4e7:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a4ee:	00 00 00 
  800420a4f1:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a4f8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a4fb:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a501:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a508:	00 00 00 
  800420a50b:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a512:	83 ca 80             	or     $0xffffff80,%edx
  800420a515:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a51b:	48 b8 20 cd 20 04 80 	movabs $0x800420cd20,%rax
  800420a522:	00 00 00 
  800420a525:	48 c1 e8 10          	shr    $0x10,%rax
  800420a529:	89 c2                	mov    %eax,%edx
  800420a52b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a532:	00 00 00 
  800420a535:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420a53c:	48 b8 20 cd 20 04 80 	movabs $0x800420cd20,%rax
  800420a543:	00 00 00 
  800420a546:	48 c1 e8 20          	shr    $0x20,%rax
  800420a54a:	89 c2                	mov    %eax,%edx
  800420a54c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a553:	00 00 00 
  800420a556:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420a55c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a563:	00 00 00 
  800420a566:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420a56d:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_KBD], 0, GD_KT, XTRPX_IRQ1, 0);
  800420a570:	48 b8 26 cd 20 04 80 	movabs $0x800420cd26,%rax
  800420a577:	00 00 00 
  800420a57a:	89 c2                	mov    %eax,%edx
  800420a57c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a583:	00 00 00 
  800420a586:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420a58d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a594:	00 00 00 
  800420a597:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420a59e:	08 00 
  800420a5a0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a5a7:	00 00 00 
  800420a5aa:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a5b1:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a5b4:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a5ba:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a5c1:	00 00 00 
  800420a5c4:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a5cb:	83 e2 07             	and    $0x7,%edx
  800420a5ce:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a5d4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a5db:	00 00 00 
  800420a5de:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a5e5:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a5e8:	83 ca 0e             	or     $0xe,%edx
  800420a5eb:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a5f1:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a5f8:	00 00 00 
  800420a5fb:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a602:	83 e2 ef             	and    $0xffffffef,%edx
  800420a605:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a60b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a612:	00 00 00 
  800420a615:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a61c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a61f:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a625:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a62c:	00 00 00 
  800420a62f:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a636:	83 ca 80             	or     $0xffffff80,%edx
  800420a639:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a63f:	48 b8 26 cd 20 04 80 	movabs $0x800420cd26,%rax
  800420a646:	00 00 00 
  800420a649:	48 c1 e8 10          	shr    $0x10,%rax
  800420a64d:	89 c2                	mov    %eax,%edx
  800420a64f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a656:	00 00 00 
  800420a659:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420a660:	48 b8 26 cd 20 04 80 	movabs $0x800420cd26,%rax
  800420a667:	00 00 00 
  800420a66a:	48 c1 e8 20          	shr    $0x20,%rax
  800420a66e:	89 c2                	mov    %eax,%edx
  800420a670:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a677:	00 00 00 
  800420a67a:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420a680:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a687:	00 00 00 
  800420a68a:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420a691:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+2], 0, GD_KT, XTRPX_IRQ2, 0);
  800420a694:	48 b8 2c cd 20 04 80 	movabs $0x800420cd2c,%rax
  800420a69b:	00 00 00 
  800420a69e:	89 c2                	mov    %eax,%edx
  800420a6a0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a6a7:	00 00 00 
  800420a6aa:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  800420a6b1:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a6b8:	00 00 00 
  800420a6bb:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  800420a6c2:	08 00 
  800420a6c4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a6cb:	00 00 00 
  800420a6ce:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420a6d5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a6d8:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420a6de:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a6e5:	00 00 00 
  800420a6e8:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420a6ef:	83 e2 07             	and    $0x7,%edx
  800420a6f2:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420a6f8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a6ff:	00 00 00 
  800420a702:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a709:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a70c:	83 ca 0e             	or     $0xe,%edx
  800420a70f:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a715:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a71c:	00 00 00 
  800420a71f:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a726:	83 e2 ef             	and    $0xffffffef,%edx
  800420a729:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a72f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a736:	00 00 00 
  800420a739:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a740:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a743:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a749:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a750:	00 00 00 
  800420a753:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a75a:	83 ca 80             	or     $0xffffff80,%edx
  800420a75d:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a763:	48 b8 2c cd 20 04 80 	movabs $0x800420cd2c,%rax
  800420a76a:	00 00 00 
  800420a76d:	48 c1 e8 10          	shr    $0x10,%rax
  800420a771:	89 c2                	mov    %eax,%edx
  800420a773:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a77a:	00 00 00 
  800420a77d:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  800420a784:	48 b8 2c cd 20 04 80 	movabs $0x800420cd2c,%rax
  800420a78b:	00 00 00 
  800420a78e:	48 c1 e8 20          	shr    $0x20,%rax
  800420a792:	89 c2                	mov    %eax,%edx
  800420a794:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a79b:	00 00 00 
  800420a79e:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  800420a7a4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a7ab:	00 00 00 
  800420a7ae:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  800420a7b5:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+3], 0, GD_KT, XTRPX_IRQ3, 0);
  800420a7b8:	48 b8 32 cd 20 04 80 	movabs $0x800420cd32,%rax
  800420a7bf:	00 00 00 
  800420a7c2:	89 c2                	mov    %eax,%edx
  800420a7c4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a7cb:	00 00 00 
  800420a7ce:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  800420a7d5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a7dc:	00 00 00 
  800420a7df:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  800420a7e6:	08 00 
  800420a7e8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a7ef:	00 00 00 
  800420a7f2:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420a7f9:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a7fc:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420a802:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a809:	00 00 00 
  800420a80c:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420a813:	83 e2 07             	and    $0x7,%edx
  800420a816:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420a81c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a823:	00 00 00 
  800420a826:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a82d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a830:	83 ca 0e             	or     $0xe,%edx
  800420a833:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a839:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a840:	00 00 00 
  800420a843:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a84a:	83 e2 ef             	and    $0xffffffef,%edx
  800420a84d:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a853:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a85a:	00 00 00 
  800420a85d:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a864:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a867:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a86d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a874:	00 00 00 
  800420a877:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a87e:	83 ca 80             	or     $0xffffff80,%edx
  800420a881:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a887:	48 b8 32 cd 20 04 80 	movabs $0x800420cd32,%rax
  800420a88e:	00 00 00 
  800420a891:	48 c1 e8 10          	shr    $0x10,%rax
  800420a895:	89 c2                	mov    %eax,%edx
  800420a897:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a89e:	00 00 00 
  800420a8a1:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420a8a8:	48 b8 32 cd 20 04 80 	movabs $0x800420cd32,%rax
  800420a8af:	00 00 00 
  800420a8b2:	48 c1 e8 20          	shr    $0x20,%rax
  800420a8b6:	89 c2                	mov    %eax,%edx
  800420a8b8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a8bf:	00 00 00 
  800420a8c2:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420a8c8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a8cf:	00 00 00 
  800420a8d2:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420a8d9:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_SERIAL], 0, GD_KT, XTRPX_IRQ4, 0);
  800420a8dc:	48 b8 38 cd 20 04 80 	movabs $0x800420cd38,%rax
  800420a8e3:	00 00 00 
  800420a8e6:	89 c2                	mov    %eax,%edx
  800420a8e8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a8ef:	00 00 00 
  800420a8f2:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420a8f9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a900:	00 00 00 
  800420a903:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420a90a:	08 00 
  800420a90c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a913:	00 00 00 
  800420a916:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a91d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a920:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a926:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a92d:	00 00 00 
  800420a930:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a937:	83 e2 07             	and    $0x7,%edx
  800420a93a:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a940:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a947:	00 00 00 
  800420a94a:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a951:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a954:	83 ca 0e             	or     $0xe,%edx
  800420a957:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a95d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a964:	00 00 00 
  800420a967:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a96e:	83 e2 ef             	and    $0xffffffef,%edx
  800420a971:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a977:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a97e:	00 00 00 
  800420a981:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a988:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a98b:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a991:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a998:	00 00 00 
  800420a99b:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a9a2:	83 ca 80             	or     $0xffffff80,%edx
  800420a9a5:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a9ab:	48 b8 38 cd 20 04 80 	movabs $0x800420cd38,%rax
  800420a9b2:	00 00 00 
  800420a9b5:	48 c1 e8 10          	shr    $0x10,%rax
  800420a9b9:	89 c2                	mov    %eax,%edx
  800420a9bb:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a9c2:	00 00 00 
  800420a9c5:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420a9cc:	48 b8 38 cd 20 04 80 	movabs $0x800420cd38,%rax
  800420a9d3:	00 00 00 
  800420a9d6:	48 c1 e8 20          	shr    $0x20,%rax
  800420a9da:	89 c2                	mov    %eax,%edx
  800420a9dc:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a9e3:	00 00 00 
  800420a9e6:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420a9ec:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420a9f3:	00 00 00 
  800420a9f6:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420a9fd:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+5], 0, GD_KT, XTRPX_IRQ5, 0);
  800420aa00:	48 b8 3e cd 20 04 80 	movabs $0x800420cd3e,%rax
  800420aa07:	00 00 00 
  800420aa0a:	89 c2                	mov    %eax,%edx
  800420aa0c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aa13:	00 00 00 
  800420aa16:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420aa1d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aa24:	00 00 00 
  800420aa27:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420aa2e:	08 00 
  800420aa30:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aa37:	00 00 00 
  800420aa3a:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420aa41:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aa44:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420aa4a:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aa51:	00 00 00 
  800420aa54:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420aa5b:	83 e2 07             	and    $0x7,%edx
  800420aa5e:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420aa64:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aa6b:	00 00 00 
  800420aa6e:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420aa75:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aa78:	83 ca 0e             	or     $0xe,%edx
  800420aa7b:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420aa81:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aa88:	00 00 00 
  800420aa8b:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420aa92:	83 e2 ef             	and    $0xffffffef,%edx
  800420aa95:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420aa9b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aaa2:	00 00 00 
  800420aaa5:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420aaac:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aaaf:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420aab5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aabc:	00 00 00 
  800420aabf:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420aac6:	83 ca 80             	or     $0xffffff80,%edx
  800420aac9:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420aacf:	48 b8 3e cd 20 04 80 	movabs $0x800420cd3e,%rax
  800420aad6:	00 00 00 
  800420aad9:	48 c1 e8 10          	shr    $0x10,%rax
  800420aadd:	89 c2                	mov    %eax,%edx
  800420aadf:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aae6:	00 00 00 
  800420aae9:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420aaf0:	48 b8 3e cd 20 04 80 	movabs $0x800420cd3e,%rax
  800420aaf7:	00 00 00 
  800420aafa:	48 c1 e8 20          	shr    $0x20,%rax
  800420aafe:	89 c2                	mov    %eax,%edx
  800420ab00:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ab07:	00 00 00 
  800420ab0a:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420ab10:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ab17:	00 00 00 
  800420ab1a:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420ab21:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+6], 0, GD_KT, XTRPX_IRQ6, 0);
  800420ab24:	48 b8 44 cd 20 04 80 	movabs $0x800420cd44,%rax
  800420ab2b:	00 00 00 
  800420ab2e:	89 c2                	mov    %eax,%edx
  800420ab30:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ab37:	00 00 00 
  800420ab3a:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420ab41:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ab48:	00 00 00 
  800420ab4b:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420ab52:	08 00 
  800420ab54:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ab5b:	00 00 00 
  800420ab5e:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420ab65:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ab68:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420ab6e:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ab75:	00 00 00 
  800420ab78:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420ab7f:	83 e2 07             	and    $0x7,%edx
  800420ab82:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420ab88:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ab8f:	00 00 00 
  800420ab92:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420ab99:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ab9c:	83 ca 0e             	or     $0xe,%edx
  800420ab9f:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420aba5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420abac:	00 00 00 
  800420abaf:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420abb6:	83 e2 ef             	and    $0xffffffef,%edx
  800420abb9:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420abbf:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420abc6:	00 00 00 
  800420abc9:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420abd0:	83 e2 9f             	and    $0xffffff9f,%edx
  800420abd3:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420abd9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420abe0:	00 00 00 
  800420abe3:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420abea:	83 ca 80             	or     $0xffffff80,%edx
  800420abed:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420abf3:	48 b8 44 cd 20 04 80 	movabs $0x800420cd44,%rax
  800420abfa:	00 00 00 
  800420abfd:	48 c1 e8 10          	shr    $0x10,%rax
  800420ac01:	89 c2                	mov    %eax,%edx
  800420ac03:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ac0a:	00 00 00 
  800420ac0d:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420ac14:	48 b8 44 cd 20 04 80 	movabs $0x800420cd44,%rax
  800420ac1b:	00 00 00 
  800420ac1e:	48 c1 e8 20          	shr    $0x20,%rax
  800420ac22:	89 c2                	mov    %eax,%edx
  800420ac24:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ac2b:	00 00 00 
  800420ac2e:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420ac34:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ac3b:	00 00 00 
  800420ac3e:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420ac45:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_SPURIOUS], 0, GD_KT, XTRPX_IRQ7, 0);
  800420ac48:	48 b8 4a cd 20 04 80 	movabs $0x800420cd4a,%rax
  800420ac4f:	00 00 00 
  800420ac52:	89 c2                	mov    %eax,%edx
  800420ac54:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ac5b:	00 00 00 
  800420ac5e:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420ac65:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ac6c:	00 00 00 
  800420ac6f:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420ac76:	08 00 
  800420ac78:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ac7f:	00 00 00 
  800420ac82:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420ac89:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ac8c:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420ac92:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ac99:	00 00 00 
  800420ac9c:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420aca3:	83 e2 07             	and    $0x7,%edx
  800420aca6:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420acac:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420acb3:	00 00 00 
  800420acb6:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420acbd:	83 e2 f0             	and    $0xfffffff0,%edx
  800420acc0:	83 ca 0e             	or     $0xe,%edx
  800420acc3:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420acc9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420acd0:	00 00 00 
  800420acd3:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420acda:	83 e2 ef             	and    $0xffffffef,%edx
  800420acdd:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ace3:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420acea:	00 00 00 
  800420aced:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420acf4:	83 e2 9f             	and    $0xffffff9f,%edx
  800420acf7:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420acfd:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ad04:	00 00 00 
  800420ad07:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ad0e:	83 ca 80             	or     $0xffffff80,%edx
  800420ad11:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ad17:	48 b8 4a cd 20 04 80 	movabs $0x800420cd4a,%rax
  800420ad1e:	00 00 00 
  800420ad21:	48 c1 e8 10          	shr    $0x10,%rax
  800420ad25:	89 c2                	mov    %eax,%edx
  800420ad27:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ad2e:	00 00 00 
  800420ad31:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420ad38:	48 b8 4a cd 20 04 80 	movabs $0x800420cd4a,%rax
  800420ad3f:	00 00 00 
  800420ad42:	48 c1 e8 20          	shr    $0x20,%rax
  800420ad46:	89 c2                	mov    %eax,%edx
  800420ad48:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ad4f:	00 00 00 
  800420ad52:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420ad58:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ad5f:	00 00 00 
  800420ad62:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420ad69:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+8], 0, GD_KT, XTRPX_IRQ8, 0);
  800420ad6c:	48 b8 50 cd 20 04 80 	movabs $0x800420cd50,%rax
  800420ad73:	00 00 00 
  800420ad76:	89 c2                	mov    %eax,%edx
  800420ad78:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ad7f:	00 00 00 
  800420ad82:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420ad89:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ad90:	00 00 00 
  800420ad93:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420ad9a:	08 00 
  800420ad9c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ada3:	00 00 00 
  800420ada6:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420adad:	83 e2 f8             	and    $0xfffffff8,%edx
  800420adb0:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420adb6:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420adbd:	00 00 00 
  800420adc0:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420adc7:	83 e2 07             	and    $0x7,%edx
  800420adca:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420add0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420add7:	00 00 00 
  800420adda:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420ade1:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ade4:	83 ca 0e             	or     $0xe,%edx
  800420ade7:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420aded:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420adf4:	00 00 00 
  800420adf7:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420adfe:	83 e2 ef             	and    $0xffffffef,%edx
  800420ae01:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420ae07:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ae0e:	00 00 00 
  800420ae11:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420ae18:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ae1b:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420ae21:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ae28:	00 00 00 
  800420ae2b:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420ae32:	83 ca 80             	or     $0xffffff80,%edx
  800420ae35:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420ae3b:	48 b8 50 cd 20 04 80 	movabs $0x800420cd50,%rax
  800420ae42:	00 00 00 
  800420ae45:	48 c1 e8 10          	shr    $0x10,%rax
  800420ae49:	89 c2                	mov    %eax,%edx
  800420ae4b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ae52:	00 00 00 
  800420ae55:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420ae5c:	48 b8 50 cd 20 04 80 	movabs $0x800420cd50,%rax
  800420ae63:	00 00 00 
  800420ae66:	48 c1 e8 20          	shr    $0x20,%rax
  800420ae6a:	89 c2                	mov    %eax,%edx
  800420ae6c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ae73:	00 00 00 
  800420ae76:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420ae7c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420ae83:	00 00 00 
  800420ae86:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420ae8d:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+9], 0, GD_KT, XTRPX_IRQ9, 0);
  800420ae90:	48 b8 56 cd 20 04 80 	movabs $0x800420cd56,%rax
  800420ae97:	00 00 00 
  800420ae9a:	89 c2                	mov    %eax,%edx
  800420ae9c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aea3:	00 00 00 
  800420aea6:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420aead:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aeb4:	00 00 00 
  800420aeb7:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420aebe:	08 00 
  800420aec0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aec7:	00 00 00 
  800420aeca:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420aed1:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aed4:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420aeda:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aee1:	00 00 00 
  800420aee4:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420aeeb:	83 e2 07             	and    $0x7,%edx
  800420aeee:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420aef4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420aefb:	00 00 00 
  800420aefe:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420af05:	83 e2 f0             	and    $0xfffffff0,%edx
  800420af08:	83 ca 0e             	or     $0xe,%edx
  800420af0b:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420af11:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420af18:	00 00 00 
  800420af1b:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420af22:	83 e2 ef             	and    $0xffffffef,%edx
  800420af25:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420af2b:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420af32:	00 00 00 
  800420af35:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420af3c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420af3f:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420af45:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420af4c:	00 00 00 
  800420af4f:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420af56:	83 ca 80             	or     $0xffffff80,%edx
  800420af59:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420af5f:	48 b8 56 cd 20 04 80 	movabs $0x800420cd56,%rax
  800420af66:	00 00 00 
  800420af69:	48 c1 e8 10          	shr    $0x10,%rax
  800420af6d:	89 c2                	mov    %eax,%edx
  800420af6f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420af76:	00 00 00 
  800420af79:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420af80:	48 b8 56 cd 20 04 80 	movabs $0x800420cd56,%rax
  800420af87:	00 00 00 
  800420af8a:	48 c1 e8 20          	shr    $0x20,%rax
  800420af8e:	89 c2                	mov    %eax,%edx
  800420af90:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420af97:	00 00 00 
  800420af9a:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420afa0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420afa7:	00 00 00 
  800420afaa:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420afb1:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+10], 0, GD_KT, XTRPX_IRQa, 0);
  800420afb4:	48 b8 5c cd 20 04 80 	movabs $0x800420cd5c,%rax
  800420afbb:	00 00 00 
  800420afbe:	89 c2                	mov    %eax,%edx
  800420afc0:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420afc7:	00 00 00 
  800420afca:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420afd1:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420afd8:	00 00 00 
  800420afdb:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420afe2:	08 00 
  800420afe4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420afeb:	00 00 00 
  800420afee:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420aff5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aff8:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420affe:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b005:	00 00 00 
  800420b008:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b00f:	83 e2 07             	and    $0x7,%edx
  800420b012:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b018:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b01f:	00 00 00 
  800420b022:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b029:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b02c:	83 ca 0e             	or     $0xe,%edx
  800420b02f:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b035:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b03c:	00 00 00 
  800420b03f:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b046:	83 e2 ef             	and    $0xffffffef,%edx
  800420b049:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b04f:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b056:	00 00 00 
  800420b059:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b060:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b063:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b069:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b070:	00 00 00 
  800420b073:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b07a:	83 ca 80             	or     $0xffffff80,%edx
  800420b07d:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b083:	48 b8 5c cd 20 04 80 	movabs $0x800420cd5c,%rax
  800420b08a:	00 00 00 
  800420b08d:	48 c1 e8 10          	shr    $0x10,%rax
  800420b091:	89 c2                	mov    %eax,%edx
  800420b093:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b09a:	00 00 00 
  800420b09d:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420b0a4:	48 b8 5c cd 20 04 80 	movabs $0x800420cd5c,%rax
  800420b0ab:	00 00 00 
  800420b0ae:	48 c1 e8 20          	shr    $0x20,%rax
  800420b0b2:	89 c2                	mov    %eax,%edx
  800420b0b4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b0bb:	00 00 00 
  800420b0be:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420b0c4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b0cb:	00 00 00 
  800420b0ce:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420b0d5:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+11], 0, GD_KT, XTRPX_IRQb, 0);
  800420b0d8:	48 b8 62 cd 20 04 80 	movabs $0x800420cd62,%rax
  800420b0df:	00 00 00 
  800420b0e2:	89 c2                	mov    %eax,%edx
  800420b0e4:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b0eb:	00 00 00 
  800420b0ee:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420b0f5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b0fc:	00 00 00 
  800420b0ff:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420b106:	08 00 
  800420b108:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b10f:	00 00 00 
  800420b112:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b119:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b11c:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b122:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b129:	00 00 00 
  800420b12c:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b133:	83 e2 07             	and    $0x7,%edx
  800420b136:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b13c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b143:	00 00 00 
  800420b146:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b14d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b150:	83 ca 0e             	or     $0xe,%edx
  800420b153:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b159:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b160:	00 00 00 
  800420b163:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b16a:	83 e2 ef             	and    $0xffffffef,%edx
  800420b16d:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b173:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b17a:	00 00 00 
  800420b17d:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b184:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b187:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b18d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b194:	00 00 00 
  800420b197:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b19e:	83 ca 80             	or     $0xffffff80,%edx
  800420b1a1:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b1a7:	48 b8 62 cd 20 04 80 	movabs $0x800420cd62,%rax
  800420b1ae:	00 00 00 
  800420b1b1:	48 c1 e8 10          	shr    $0x10,%rax
  800420b1b5:	89 c2                	mov    %eax,%edx
  800420b1b7:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b1be:	00 00 00 
  800420b1c1:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420b1c8:	48 b8 62 cd 20 04 80 	movabs $0x800420cd62,%rax
  800420b1cf:	00 00 00 
  800420b1d2:	48 c1 e8 20          	shr    $0x20,%rax
  800420b1d6:	89 c2                	mov    %eax,%edx
  800420b1d8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b1df:	00 00 00 
  800420b1e2:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420b1e8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b1ef:	00 00 00 
  800420b1f2:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420b1f9:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+12], 0, GD_KT, XTRPX_IRQc, 0);
  800420b1fc:	48 b8 68 cd 20 04 80 	movabs $0x800420cd68,%rax
  800420b203:	00 00 00 
  800420b206:	89 c2                	mov    %eax,%edx
  800420b208:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b20f:	00 00 00 
  800420b212:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420b219:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b220:	00 00 00 
  800420b223:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420b22a:	08 00 
  800420b22c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b233:	00 00 00 
  800420b236:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b23d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b240:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b246:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b24d:	00 00 00 
  800420b250:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b257:	83 e2 07             	and    $0x7,%edx
  800420b25a:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b260:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b267:	00 00 00 
  800420b26a:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b271:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b274:	83 ca 0e             	or     $0xe,%edx
  800420b277:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b27d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b284:	00 00 00 
  800420b287:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b28e:	83 e2 ef             	and    $0xffffffef,%edx
  800420b291:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b297:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b29e:	00 00 00 
  800420b2a1:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b2a8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b2ab:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b2b1:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b2b8:	00 00 00 
  800420b2bb:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b2c2:	83 ca 80             	or     $0xffffff80,%edx
  800420b2c5:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b2cb:	48 b8 68 cd 20 04 80 	movabs $0x800420cd68,%rax
  800420b2d2:	00 00 00 
  800420b2d5:	48 c1 e8 10          	shr    $0x10,%rax
  800420b2d9:	89 c2                	mov    %eax,%edx
  800420b2db:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b2e2:	00 00 00 
  800420b2e5:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420b2ec:	48 b8 68 cd 20 04 80 	movabs $0x800420cd68,%rax
  800420b2f3:	00 00 00 
  800420b2f6:	48 c1 e8 20          	shr    $0x20,%rax
  800420b2fa:	89 c2                	mov    %eax,%edx
  800420b2fc:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b303:	00 00 00 
  800420b306:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420b30c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b313:	00 00 00 
  800420b316:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420b31d:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+13], 0, GD_KT, XTRPX_IRQd, 0);
  800420b320:	48 b8 6e cd 20 04 80 	movabs $0x800420cd6e,%rax
  800420b327:	00 00 00 
  800420b32a:	89 c2                	mov    %eax,%edx
  800420b32c:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b333:	00 00 00 
  800420b336:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420b33d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b344:	00 00 00 
  800420b347:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420b34e:	08 00 
  800420b350:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b357:	00 00 00 
  800420b35a:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420b361:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b364:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420b36a:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b371:	00 00 00 
  800420b374:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420b37b:	83 e2 07             	and    $0x7,%edx
  800420b37e:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420b384:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b38b:	00 00 00 
  800420b38e:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b395:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b398:	83 ca 0e             	or     $0xe,%edx
  800420b39b:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b3a1:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b3a8:	00 00 00 
  800420b3ab:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b3b2:	83 e2 ef             	and    $0xffffffef,%edx
  800420b3b5:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b3bb:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b3c2:	00 00 00 
  800420b3c5:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b3cc:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b3cf:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b3d5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b3dc:	00 00 00 
  800420b3df:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b3e6:	83 ca 80             	or     $0xffffff80,%edx
  800420b3e9:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b3ef:	48 b8 6e cd 20 04 80 	movabs $0x800420cd6e,%rax
  800420b3f6:	00 00 00 
  800420b3f9:	48 c1 e8 10          	shr    $0x10,%rax
  800420b3fd:	89 c2                	mov    %eax,%edx
  800420b3ff:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b406:	00 00 00 
  800420b409:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420b410:	48 b8 6e cd 20 04 80 	movabs $0x800420cd6e,%rax
  800420b417:	00 00 00 
  800420b41a:	48 c1 e8 20          	shr    $0x20,%rax
  800420b41e:	89 c2                	mov    %eax,%edx
  800420b420:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b427:	00 00 00 
  800420b42a:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420b430:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b437:	00 00 00 
  800420b43a:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420b441:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_IDE], 0, GD_KT, XTRPX_IRQe, 0);
  800420b444:	48 b8 74 cd 20 04 80 	movabs $0x800420cd74,%rax
  800420b44b:	00 00 00 
  800420b44e:	89 c2                	mov    %eax,%edx
  800420b450:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b457:	00 00 00 
  800420b45a:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420b461:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b468:	00 00 00 
  800420b46b:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420b472:	08 00 
  800420b474:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b47b:	00 00 00 
  800420b47e:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420b485:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b488:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420b48e:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b495:	00 00 00 
  800420b498:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420b49f:	83 e2 07             	and    $0x7,%edx
  800420b4a2:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420b4a8:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b4af:	00 00 00 
  800420b4b2:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b4b9:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b4bc:	83 ca 0e             	or     $0xe,%edx
  800420b4bf:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b4c5:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b4cc:	00 00 00 
  800420b4cf:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b4d6:	83 e2 ef             	and    $0xffffffef,%edx
  800420b4d9:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b4df:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b4e6:	00 00 00 
  800420b4e9:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b4f0:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b4f3:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b4f9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b500:	00 00 00 
  800420b503:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b50a:	83 ca 80             	or     $0xffffff80,%edx
  800420b50d:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b513:	48 b8 74 cd 20 04 80 	movabs $0x800420cd74,%rax
  800420b51a:	00 00 00 
  800420b51d:	48 c1 e8 10          	shr    $0x10,%rax
  800420b521:	89 c2                	mov    %eax,%edx
  800420b523:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b52a:	00 00 00 
  800420b52d:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420b534:	48 b8 74 cd 20 04 80 	movabs $0x800420cd74,%rax
  800420b53b:	00 00 00 
  800420b53e:	48 c1 e8 20          	shr    $0x20,%rax
  800420b542:	89 c2                	mov    %eax,%edx
  800420b544:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b54b:	00 00 00 
  800420b54e:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420b554:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b55b:	00 00 00 
  800420b55e:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420b565:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+15], 0, GD_KT, XTRPX_IRQf, 0);
  800420b568:	48 b8 7a cd 20 04 80 	movabs $0x800420cd7a,%rax
  800420b56f:	00 00 00 
  800420b572:	89 c2                	mov    %eax,%edx
  800420b574:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b57b:	00 00 00 
  800420b57e:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420b585:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b58c:	00 00 00 
  800420b58f:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420b596:	08 00 
  800420b598:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b59f:	00 00 00 
  800420b5a2:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420b5a9:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b5ac:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420b5b2:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b5b9:	00 00 00 
  800420b5bc:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420b5c3:	83 e2 07             	and    $0x7,%edx
  800420b5c6:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420b5cc:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b5d3:	00 00 00 
  800420b5d6:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b5dd:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b5e0:	83 ca 0e             	or     $0xe,%edx
  800420b5e3:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b5e9:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b5f0:	00 00 00 
  800420b5f3:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b5fa:	83 e2 ef             	and    $0xffffffef,%edx
  800420b5fd:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b603:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b60a:	00 00 00 
  800420b60d:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b614:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b617:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b61d:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b624:	00 00 00 
  800420b627:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b62e:	83 ca 80             	or     $0xffffff80,%edx
  800420b631:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b637:	48 b8 7a cd 20 04 80 	movabs $0x800420cd7a,%rax
  800420b63e:	00 00 00 
  800420b641:	48 c1 e8 10          	shr    $0x10,%rax
  800420b645:	89 c2                	mov    %eax,%edx
  800420b647:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b64e:	00 00 00 
  800420b651:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420b658:	48 b8 7a cd 20 04 80 	movabs $0x800420cd7a,%rax
  800420b65f:	00 00 00 
  800420b662:	48 c1 e8 20          	shr    $0x20,%rax
  800420b666:	89 c2                	mov    %eax,%edx
  800420b668:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b66f:	00 00 00 
  800420b672:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420b678:	48 b8 80 02 4a 04 80 	movabs $0x80044a0280,%rax
  800420b67f:	00 00 00 
  800420b682:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420b689:	00 00 00 
	
    idt_pd.pd_lim = sizeof(idt)-1;
  800420b68c:	48 b8 80 12 4a 04 80 	movabs $0x80044a1280,%rax
  800420b693:	00 00 00 
  800420b696:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
    idt_pd.pd_base = (uint64_t)idt;
  800420b69b:	48 ba 80 02 4a 04 80 	movabs $0x80044a0280,%rdx
  800420b6a2:	00 00 00 
  800420b6a5:	48 b8 80 12 4a 04 80 	movabs $0x80044a1280,%rax
  800420b6ac:	00 00 00 
  800420b6af:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420b6b3:	48 b8 c1 b6 20 04 80 	movabs $0x800420b6c1,%rax
  800420b6ba:	00 00 00 
  800420b6bd:	ff d0                	callq  *%rax
}
  800420b6bf:	5d                   	pop    %rbp
  800420b6c0:	c3                   	retq   

000000800420b6c1 <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420b6c1:	55                   	push   %rbp
  800420b6c2:	48 89 e5             	mov    %rsp,%rbp
  800420b6c5:	53                   	push   %rbx
  800420b6c6:	48 83 ec 18          	sub    $0x18,%rsp
	//
	// LAB 4: Your code here:

	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP + thiscpu->cpu_id * (KSTKSIZE+KSTKGAP);
  800420b6ca:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420b6d1:	00 00 00 
  800420b6d4:	ff d0                	callq  *%rax
  800420b6d6:	89 c3                	mov    %eax,%ebx
  800420b6d8:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420b6df:	00 00 00 
  800420b6e2:	ff d0                	callq  *%rax
  800420b6e4:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420b6eb:	00 00 00 
  800420b6ee:	48 98                	cltq   
  800420b6f0:	48 c1 e0 03          	shl    $0x3,%rax
  800420b6f4:	48 89 c2             	mov    %rax,%rdx
  800420b6f7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b6fb:	48 29 c2             	sub    %rax,%rdx
  800420b6fe:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b702:	0f b6 00             	movzbl (%rax),%eax
  800420b705:	0f b6 d0             	movzbl %al,%edx
  800420b708:	89 d0                	mov    %edx,%eax
  800420b70a:	01 c0                	add    %eax,%eax
  800420b70c:	01 d0                	add    %edx,%eax
  800420b70e:	c1 e0 0f             	shl    $0xf,%eax
  800420b711:	48 63 d0             	movslq %eax,%rdx
  800420b714:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420b71b:	00 00 00 
  800420b71e:	48 01 d0             	add    %rdx,%rax
  800420b721:	48 89 c1             	mov    %rax,%rcx
  800420b724:	48 be 20 30 4a 04 80 	movabs $0x80044a3020,%rsi
  800420b72b:	00 00 00 
  800420b72e:	48 63 c3             	movslq %ebx,%rax
  800420b731:	48 c1 e0 03          	shl    $0x3,%rax
  800420b735:	48 89 c2             	mov    %rax,%rdx
  800420b738:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b73c:	48 29 c2             	sub    %rax,%rdx
  800420b73f:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  800420b743:	48 83 c0 10          	add    $0x10,%rax
  800420b747:	48 89 48 04          	mov    %rcx,0x4(%rax)
	//	thiscpu->cpu_ts.ts_ss0 = GD_KD;
	// Initialize the TSS slot of the gdt.
	SETTSS((struct SystemSegdesc64 *) (&gdt[(GD_TSS0>>3) + (thiscpu->cpu_id*2)]),STS_T64A,
  800420b74b:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420b752:	00 00 00 
  800420b755:	ff d0                	callq  *%rax
  800420b757:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420b75e:	00 00 00 
  800420b761:	48 98                	cltq   
  800420b763:	48 c1 e0 03          	shl    $0x3,%rax
  800420b767:	48 89 c2             	mov    %rax,%rdx
  800420b76a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b76e:	48 29 c2             	sub    %rax,%rdx
  800420b771:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b775:	0f b6 00             	movzbl (%rax),%eax
  800420b778:	0f b6 c0             	movzbl %al,%eax
  800420b77b:	01 c0                	add    %eax,%eax
  800420b77d:	83 c0 05             	add    $0x5,%eax
  800420b780:	48 98                	cltq   
  800420b782:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b789:	00 
  800420b78a:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420b791:	00 00 00 
  800420b794:	48 01 d0             	add    %rdx,%rax
  800420b797:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420b79c:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420b7a3:	00 00 00 
  800420b7a6:	ff d0                	callq  *%rax
  800420b7a8:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420b7af:	00 00 00 
  800420b7b2:	48 98                	cltq   
  800420b7b4:	48 c1 e0 03          	shl    $0x3,%rax
  800420b7b8:	48 89 c2             	mov    %rax,%rdx
  800420b7bb:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b7bf:	48 29 c2             	sub    %rax,%rdx
  800420b7c2:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b7c6:	0f b6 00             	movzbl (%rax),%eax
  800420b7c9:	0f b6 c0             	movzbl %al,%eax
  800420b7cc:	01 c0                	add    %eax,%eax
  800420b7ce:	83 c0 05             	add    $0x5,%eax
  800420b7d1:	48 98                	cltq   
  800420b7d3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b7da:	00 
  800420b7db:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420b7e2:	00 00 00 
  800420b7e5:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420b7e9:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420b7f0:	00 00 00 
  800420b7f3:	ff d0                	callq  *%rax
  800420b7f5:	48 98                	cltq   
  800420b7f7:	48 c1 e0 03          	shl    $0x3,%rax
  800420b7fb:	48 89 c2             	mov    %rax,%rdx
  800420b7fe:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b802:	48 29 c2             	sub    %rax,%rdx
  800420b805:	48 83 c2 10          	add    $0x10,%rdx
  800420b809:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  800420b810:	00 00 00 
  800420b813:	48 01 d0             	add    %rdx,%rax
  800420b816:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420b81a:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420b821:	00 00 00 
  800420b824:	ff d0                	callq  *%rax
  800420b826:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420b82d:	00 00 00 
  800420b830:	48 98                	cltq   
  800420b832:	48 c1 e0 03          	shl    $0x3,%rax
  800420b836:	48 89 c2             	mov    %rax,%rdx
  800420b839:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b83d:	48 29 c2             	sub    %rax,%rdx
  800420b840:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b844:	0f b6 00             	movzbl (%rax),%eax
  800420b847:	0f b6 c0             	movzbl %al,%eax
  800420b84a:	01 c0                	add    %eax,%eax
  800420b84c:	83 c0 05             	add    $0x5,%eax
  800420b84f:	48 98                	cltq   
  800420b851:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b858:	00 
  800420b859:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420b860:	00 00 00 
  800420b863:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420b867:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420b86e:	00 00 00 
  800420b871:	ff d0                	callq  *%rax
  800420b873:	48 98                	cltq   
  800420b875:	48 c1 e0 03          	shl    $0x3,%rax
  800420b879:	48 89 c2             	mov    %rax,%rdx
  800420b87c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b880:	48 29 c2             	sub    %rax,%rdx
  800420b883:	48 83 c2 10          	add    $0x10,%rdx
  800420b887:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  800420b88e:	00 00 00 
  800420b891:	48 01 d0             	add    %rdx,%rax
  800420b894:	48 c1 e8 10          	shr    $0x10,%rax
  800420b898:	88 43 04             	mov    %al,0x4(%rbx)
  800420b89b:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420b8a2:	00 00 00 
  800420b8a5:	ff d0                	callq  *%rax
  800420b8a7:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420b8ae:	00 00 00 
  800420b8b1:	48 98                	cltq   
  800420b8b3:	48 c1 e0 03          	shl    $0x3,%rax
  800420b8b7:	48 89 c2             	mov    %rax,%rdx
  800420b8ba:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b8be:	48 29 c2             	sub    %rax,%rdx
  800420b8c1:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b8c5:	0f b6 00             	movzbl (%rax),%eax
  800420b8c8:	0f b6 c0             	movzbl %al,%eax
  800420b8cb:	01 c0                	add    %eax,%eax
  800420b8cd:	83 c0 05             	add    $0x5,%eax
  800420b8d0:	48 98                	cltq   
  800420b8d2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b8d9:	00 
  800420b8da:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420b8e1:	00 00 00 
  800420b8e4:	48 01 d0             	add    %rdx,%rax
  800420b8e7:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b8eb:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b8ee:	83 ca 09             	or     $0x9,%edx
  800420b8f1:	88 50 05             	mov    %dl,0x5(%rax)
  800420b8f4:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420b8fb:	00 00 00 
  800420b8fe:	ff d0                	callq  *%rax
  800420b900:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420b907:	00 00 00 
  800420b90a:	48 98                	cltq   
  800420b90c:	48 c1 e0 03          	shl    $0x3,%rax
  800420b910:	48 89 c2             	mov    %rax,%rdx
  800420b913:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b917:	48 29 c2             	sub    %rax,%rdx
  800420b91a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b91e:	0f b6 00             	movzbl (%rax),%eax
  800420b921:	0f b6 c0             	movzbl %al,%eax
  800420b924:	01 c0                	add    %eax,%eax
  800420b926:	83 c0 05             	add    $0x5,%eax
  800420b929:	48 98                	cltq   
  800420b92b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b932:	00 
  800420b933:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420b93a:	00 00 00 
  800420b93d:	48 01 d0             	add    %rdx,%rax
  800420b940:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b944:	83 e2 ef             	and    $0xffffffef,%edx
  800420b947:	88 50 05             	mov    %dl,0x5(%rax)
  800420b94a:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420b951:	00 00 00 
  800420b954:	ff d0                	callq  *%rax
  800420b956:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420b95d:	00 00 00 
  800420b960:	48 98                	cltq   
  800420b962:	48 c1 e0 03          	shl    $0x3,%rax
  800420b966:	48 89 c2             	mov    %rax,%rdx
  800420b969:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b96d:	48 29 c2             	sub    %rax,%rdx
  800420b970:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b974:	0f b6 00             	movzbl (%rax),%eax
  800420b977:	0f b6 c0             	movzbl %al,%eax
  800420b97a:	01 c0                	add    %eax,%eax
  800420b97c:	83 c0 05             	add    $0x5,%eax
  800420b97f:	48 98                	cltq   
  800420b981:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b988:	00 
  800420b989:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420b990:	00 00 00 
  800420b993:	48 01 d0             	add    %rdx,%rax
  800420b996:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b99a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b99d:	88 50 05             	mov    %dl,0x5(%rax)
  800420b9a0:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420b9a7:	00 00 00 
  800420b9aa:	ff d0                	callq  *%rax
  800420b9ac:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420b9b3:	00 00 00 
  800420b9b6:	48 98                	cltq   
  800420b9b8:	48 c1 e0 03          	shl    $0x3,%rax
  800420b9bc:	48 89 c2             	mov    %rax,%rdx
  800420b9bf:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b9c3:	48 29 c2             	sub    %rax,%rdx
  800420b9c6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b9ca:	0f b6 00             	movzbl (%rax),%eax
  800420b9cd:	0f b6 c0             	movzbl %al,%eax
  800420b9d0:	01 c0                	add    %eax,%eax
  800420b9d2:	83 c0 05             	add    $0x5,%eax
  800420b9d5:	48 98                	cltq   
  800420b9d7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b9de:	00 
  800420b9df:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420b9e6:	00 00 00 
  800420b9e9:	48 01 d0             	add    %rdx,%rax
  800420b9ec:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b9f0:	83 ca 80             	or     $0xffffff80,%edx
  800420b9f3:	88 50 05             	mov    %dl,0x5(%rax)
  800420b9f6:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420b9fd:	00 00 00 
  800420ba00:	ff d0                	callq  *%rax
  800420ba02:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420ba09:	00 00 00 
  800420ba0c:	48 98                	cltq   
  800420ba0e:	48 c1 e0 03          	shl    $0x3,%rax
  800420ba12:	48 89 c2             	mov    %rax,%rdx
  800420ba15:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ba19:	48 29 c2             	sub    %rax,%rdx
  800420ba1c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ba20:	0f b6 00             	movzbl (%rax),%eax
  800420ba23:	0f b6 c0             	movzbl %al,%eax
  800420ba26:	01 c0                	add    %eax,%eax
  800420ba28:	83 c0 05             	add    $0x5,%eax
  800420ba2b:	48 98                	cltq   
  800420ba2d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ba34:	00 
  800420ba35:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420ba3c:	00 00 00 
  800420ba3f:	48 01 d0             	add    %rdx,%rax
  800420ba42:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420ba46:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ba49:	88 50 06             	mov    %dl,0x6(%rax)
  800420ba4c:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420ba53:	00 00 00 
  800420ba56:	ff d0                	callq  *%rax
  800420ba58:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420ba5f:	00 00 00 
  800420ba62:	48 98                	cltq   
  800420ba64:	48 c1 e0 03          	shl    $0x3,%rax
  800420ba68:	48 89 c2             	mov    %rax,%rdx
  800420ba6b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ba6f:	48 29 c2             	sub    %rax,%rdx
  800420ba72:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ba76:	0f b6 00             	movzbl (%rax),%eax
  800420ba79:	0f b6 c0             	movzbl %al,%eax
  800420ba7c:	01 c0                	add    %eax,%eax
  800420ba7e:	83 c0 05             	add    $0x5,%eax
  800420ba81:	48 98                	cltq   
  800420ba83:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ba8a:	00 
  800420ba8b:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420ba92:	00 00 00 
  800420ba95:	48 01 d0             	add    %rdx,%rax
  800420ba98:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420ba9c:	83 e2 ef             	and    $0xffffffef,%edx
  800420ba9f:	88 50 06             	mov    %dl,0x6(%rax)
  800420baa2:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420baa9:	00 00 00 
  800420baac:	ff d0                	callq  *%rax
  800420baae:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420bab5:	00 00 00 
  800420bab8:	48 98                	cltq   
  800420baba:	48 c1 e0 03          	shl    $0x3,%rax
  800420babe:	48 89 c2             	mov    %rax,%rdx
  800420bac1:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bac5:	48 29 c2             	sub    %rax,%rdx
  800420bac8:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bacc:	0f b6 00             	movzbl (%rax),%eax
  800420bacf:	0f b6 c0             	movzbl %al,%eax
  800420bad2:	01 c0                	add    %eax,%eax
  800420bad4:	83 c0 05             	add    $0x5,%eax
  800420bad7:	48 98                	cltq   
  800420bad9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bae0:	00 
  800420bae1:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420bae8:	00 00 00 
  800420baeb:	48 01 d0             	add    %rdx,%rax
  800420baee:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420baf2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420baf5:	88 50 06             	mov    %dl,0x6(%rax)
  800420baf8:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420baff:	00 00 00 
  800420bb02:	ff d0                	callq  *%rax
  800420bb04:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420bb0b:	00 00 00 
  800420bb0e:	48 98                	cltq   
  800420bb10:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb14:	48 89 c2             	mov    %rax,%rdx
  800420bb17:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bb1b:	48 29 c2             	sub    %rax,%rdx
  800420bb1e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bb22:	0f b6 00             	movzbl (%rax),%eax
  800420bb25:	0f b6 c0             	movzbl %al,%eax
  800420bb28:	01 c0                	add    %eax,%eax
  800420bb2a:	83 c0 05             	add    $0x5,%eax
  800420bb2d:	48 98                	cltq   
  800420bb2f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bb36:	00 
  800420bb37:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420bb3e:	00 00 00 
  800420bb41:	48 01 d0             	add    %rdx,%rax
  800420bb44:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420bb48:	83 e2 7f             	and    $0x7f,%edx
  800420bb4b:	88 50 06             	mov    %dl,0x6(%rax)
  800420bb4e:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420bb55:	00 00 00 
  800420bb58:	ff d0                	callq  *%rax
  800420bb5a:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420bb61:	00 00 00 
  800420bb64:	48 98                	cltq   
  800420bb66:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb6a:	48 89 c2             	mov    %rax,%rdx
  800420bb6d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bb71:	48 29 c2             	sub    %rax,%rdx
  800420bb74:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bb78:	0f b6 00             	movzbl (%rax),%eax
  800420bb7b:	0f b6 c0             	movzbl %al,%eax
  800420bb7e:	01 c0                	add    %eax,%eax
  800420bb80:	83 c0 05             	add    $0x5,%eax
  800420bb83:	48 98                	cltq   
  800420bb85:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bb8c:	00 
  800420bb8d:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420bb94:	00 00 00 
  800420bb97:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420bb9b:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420bba2:	00 00 00 
  800420bba5:	ff d0                	callq  *%rax
  800420bba7:	48 98                	cltq   
  800420bba9:	48 c1 e0 03          	shl    $0x3,%rax
  800420bbad:	48 89 c2             	mov    %rax,%rdx
  800420bbb0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bbb4:	48 29 c2             	sub    %rax,%rdx
  800420bbb7:	48 83 c2 10          	add    $0x10,%rdx
  800420bbbb:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  800420bbc2:	00 00 00 
  800420bbc5:	48 01 d0             	add    %rdx,%rax
  800420bbc8:	48 c1 e8 18          	shr    $0x18,%rax
  800420bbcc:	88 43 07             	mov    %al,0x7(%rbx)
  800420bbcf:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420bbd6:	00 00 00 
  800420bbd9:	ff d0                	callq  *%rax
  800420bbdb:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420bbe2:	00 00 00 
  800420bbe5:	48 98                	cltq   
  800420bbe7:	48 c1 e0 03          	shl    $0x3,%rax
  800420bbeb:	48 89 c2             	mov    %rax,%rdx
  800420bbee:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bbf2:	48 29 c2             	sub    %rax,%rdx
  800420bbf5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bbf9:	0f b6 00             	movzbl (%rax),%eax
  800420bbfc:	0f b6 c0             	movzbl %al,%eax
  800420bbff:	01 c0                	add    %eax,%eax
  800420bc01:	83 c0 05             	add    $0x5,%eax
  800420bc04:	48 98                	cltq   
  800420bc06:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bc0d:	00 
  800420bc0e:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420bc15:	00 00 00 
  800420bc18:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420bc1c:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420bc23:	00 00 00 
  800420bc26:	ff d0                	callq  *%rax
  800420bc28:	48 98                	cltq   
  800420bc2a:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc2e:	48 89 c2             	mov    %rax,%rdx
  800420bc31:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc35:	48 29 c2             	sub    %rax,%rdx
  800420bc38:	48 83 c2 10          	add    $0x10,%rdx
  800420bc3c:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  800420bc43:	00 00 00 
  800420bc46:	48 01 d0             	add    %rdx,%rax
  800420bc49:	48 c1 e8 20          	shr    $0x20,%rax
  800420bc4d:	89 43 08             	mov    %eax,0x8(%rbx)
  800420bc50:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420bc57:	00 00 00 
  800420bc5a:	ff d0                	callq  *%rax
  800420bc5c:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420bc63:	00 00 00 
  800420bc66:	48 98                	cltq   
  800420bc68:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc6c:	48 89 c2             	mov    %rax,%rdx
  800420bc6f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc73:	48 29 c2             	sub    %rax,%rdx
  800420bc76:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bc7a:	0f b6 00             	movzbl (%rax),%eax
  800420bc7d:	0f b6 c0             	movzbl %al,%eax
  800420bc80:	01 c0                	add    %eax,%eax
  800420bc82:	83 c0 05             	add    $0x5,%eax
  800420bc85:	48 98                	cltq   
  800420bc87:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bc8e:	00 
  800420bc8f:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420bc96:	00 00 00 
  800420bc99:	48 01 d0             	add    %rdx,%rax
  800420bc9c:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420bca0:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420bca7:	00 00 00 
  800420bcaa:	ff d0                	callq  *%rax
  800420bcac:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420bcb3:	00 00 00 
  800420bcb6:	48 98                	cltq   
  800420bcb8:	48 c1 e0 03          	shl    $0x3,%rax
  800420bcbc:	48 89 c2             	mov    %rax,%rdx
  800420bcbf:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bcc3:	48 29 c2             	sub    %rax,%rdx
  800420bcc6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bcca:	0f b6 00             	movzbl (%rax),%eax
  800420bccd:	0f b6 c0             	movzbl %al,%eax
  800420bcd0:	01 c0                	add    %eax,%eax
  800420bcd2:	83 c0 05             	add    $0x5,%eax
  800420bcd5:	48 98                	cltq   
  800420bcd7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bcde:	00 
  800420bcdf:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420bce6:	00 00 00 
  800420bce9:	48 01 d0             	add    %rdx,%rax
  800420bcec:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420bcf0:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420bcf7:	00 00 00 
  800420bcfa:	ff d0                	callq  *%rax
  800420bcfc:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420bd03:	00 00 00 
  800420bd06:	48 98                	cltq   
  800420bd08:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd0c:	48 89 c2             	mov    %rax,%rdx
  800420bd0f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd13:	48 29 c2             	sub    %rax,%rdx
  800420bd16:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bd1a:	0f b6 00             	movzbl (%rax),%eax
  800420bd1d:	0f b6 c0             	movzbl %al,%eax
  800420bd20:	01 c0                	add    %eax,%eax
  800420bd22:	83 c0 05             	add    $0x5,%eax
  800420bd25:	48 98                	cltq   
  800420bd27:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bd2e:	00 
  800420bd2f:	48 b8 e0 c5 22 04 80 	movabs $0x800422c5e0,%rax
  800420bd36:	00 00 00 
  800420bd39:	48 01 d0             	add    %rdx,%rax
  800420bd3c:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
				(uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)
	ltr(((GD_TSS0>>3) + (thiscpu->cpu_id*2))*8);
  800420bd42:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420bd49:	00 00 00 
  800420bd4c:	ff d0                	callq  *%rax
  800420bd4e:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420bd55:	00 00 00 
  800420bd58:	48 98                	cltq   
  800420bd5a:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd5e:	48 89 c2             	mov    %rax,%rdx
  800420bd61:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd65:	48 29 c2             	sub    %rax,%rdx
  800420bd68:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bd6c:	0f b6 00             	movzbl (%rax),%eax
  800420bd6f:	0f b6 c0             	movzbl %al,%eax
  800420bd72:	c1 e0 04             	shl    $0x4,%eax
  800420bd75:	83 c0 28             	add    $0x28,%eax
  800420bd78:	0f b7 c0             	movzwl %ax,%eax
  800420bd7b:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420bd7f:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  800420bd83:	0f 00 d8             	ltr    %ax
  800420bd86:	48 b8 80 12 4a 04 80 	movabs $0x80044a1280,%rax
  800420bd8d:	00 00 00 
  800420bd90:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420bd94:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420bd98:	0f 01 18             	lidt   (%rax)

	// Load the IDT
	lidt(&idt_pd);
}
  800420bd9b:	48 83 c4 18          	add    $0x18,%rsp
  800420bd9f:	5b                   	pop    %rbx
  800420bda0:	5d                   	pop    %rbp
  800420bda1:	c3                   	retq   

000000800420bda2 <print_trapframe>:
void
print_trapframe(struct Trapframe *tf)
{
  800420bda2:	55                   	push   %rbp
  800420bda3:	48 89 e5             	mov    %rsp,%rbp
  800420bda6:	48 83 ec 20          	sub    $0x20,%rsp
  800420bdaa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420bdae:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420bdb5:	00 00 00 
  800420bdb8:	ff d0                	callq  *%rax
  800420bdba:	89 c2                	mov    %eax,%edx
  800420bdbc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bdc0:	48 89 c6             	mov    %rax,%rsi
  800420bdc3:	48 bf 0e 82 21 04 80 	movabs $0x800421820e,%rdi
  800420bdca:	00 00 00 
  800420bdcd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bdd2:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  800420bdd9:	00 00 00 
  800420bddc:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420bdde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bde2:	48 89 c7             	mov    %rax,%rdi
  800420bde5:	48 b8 b3 c0 20 04 80 	movabs $0x800420c0b3,%rax
  800420bdec:	00 00 00 
  800420bdef:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420bdf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bdf5:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420bdf9:	0f b7 c0             	movzwl %ax,%eax
  800420bdfc:	89 c6                	mov    %eax,%esi
  800420bdfe:	48 bf 2c 82 21 04 80 	movabs $0x800421822c,%rdi
  800420be05:	00 00 00 
  800420be08:	b8 00 00 00 00       	mov    $0x0,%eax
  800420be0d:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420be14:	00 00 00 
  800420be17:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420be19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be1d:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420be24:	0f b7 c0             	movzwl %ax,%eax
  800420be27:	89 c6                	mov    %eax,%esi
  800420be29:	48 bf 3f 82 21 04 80 	movabs $0x800421823f,%rdi
  800420be30:	00 00 00 
  800420be33:	b8 00 00 00 00       	mov    $0x0,%eax
  800420be38:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420be3f:	00 00 00 
  800420be42:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420be44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be48:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420be4f:	89 c7                	mov    %eax,%edi
  800420be51:	48 b8 b2 8e 20 04 80 	movabs $0x8004208eb2,%rax
  800420be58:	00 00 00 
  800420be5b:	ff d0                	callq  *%rax
  800420be5d:	48 89 c2             	mov    %rax,%rdx
  800420be60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be64:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420be6b:	48 89 c6             	mov    %rax,%rsi
  800420be6e:	48 bf 52 82 21 04 80 	movabs $0x8004218252,%rdi
  800420be75:	00 00 00 
  800420be78:	b8 00 00 00 00       	mov    $0x0,%eax
  800420be7d:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  800420be84:	00 00 00 
  800420be87:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420be89:	48 b8 08 13 4a 04 80 	movabs $0x80044a1308,%rax
  800420be90:	00 00 00 
  800420be93:	48 8b 00             	mov    (%rax),%rax
  800420be96:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420be9a:	75 3a                	jne    800420bed6 <print_trapframe+0x134>
  800420be9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bea0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420bea7:	48 83 f8 0e          	cmp    $0xe,%rax
  800420beab:	75 29                	jne    800420bed6 <print_trapframe+0x134>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420bead:	0f 20 d0             	mov    %cr2,%rax
  800420beb0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800420beb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420beb8:	48 89 c6             	mov    %rax,%rsi
  800420bebb:	48 bf 64 82 21 04 80 	movabs $0x8004218264,%rdi
  800420bec2:	00 00 00 
  800420bec5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420beca:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420bed1:	00 00 00 
  800420bed4:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420bed6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420beda:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420bee1:	48 89 c6             	mov    %rax,%rsi
  800420bee4:	48 bf 73 82 21 04 80 	movabs $0x8004218273,%rdi
  800420beeb:	00 00 00 
  800420beee:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bef3:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420befa:	00 00 00 
  800420befd:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420beff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf03:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420bf0a:	48 83 f8 0e          	cmp    $0xe,%rax
  800420bf0e:	0f 85 9c 00 00 00    	jne    800420bfb0 <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420bf14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf18:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420bf1f:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420bf22:	48 85 c0             	test   %rax,%rax
  800420bf25:	74 0c                	je     800420bf33 <print_trapframe+0x191>
  800420bf27:	48 b9 81 82 21 04 80 	movabs $0x8004218281,%rcx
  800420bf2e:	00 00 00 
  800420bf31:	eb 0a                	jmp    800420bf3d <print_trapframe+0x19b>
  800420bf33:	48 b9 8c 82 21 04 80 	movabs $0x800421828c,%rcx
  800420bf3a:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420bf3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf41:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420bf48:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420bf4b:	48 85 c0             	test   %rax,%rax
  800420bf4e:	74 0c                	je     800420bf5c <print_trapframe+0x1ba>
  800420bf50:	48 ba 98 82 21 04 80 	movabs $0x8004218298,%rdx
  800420bf57:	00 00 00 
  800420bf5a:	eb 0a                	jmp    800420bf66 <print_trapframe+0x1c4>
  800420bf5c:	48 ba 9e 82 21 04 80 	movabs $0x800421829e,%rdx
  800420bf63:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420bf66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf6a:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420bf71:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420bf74:	48 85 c0             	test   %rax,%rax
  800420bf77:	74 0c                	je     800420bf85 <print_trapframe+0x1e3>
  800420bf79:	48 b8 a3 82 21 04 80 	movabs $0x80042182a3,%rax
  800420bf80:	00 00 00 
  800420bf83:	eb 0a                	jmp    800420bf8f <print_trapframe+0x1ed>
  800420bf85:	48 b8 a8 82 21 04 80 	movabs $0x80042182a8,%rax
  800420bf8c:	00 00 00 
  800420bf8f:	48 89 c6             	mov    %rax,%rsi
  800420bf92:	48 bf af 82 21 04 80 	movabs $0x80042182af,%rdi
  800420bf99:	00 00 00 
  800420bf9c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bfa1:	49 b8 99 8d 20 04 80 	movabs $0x8004208d99,%r8
  800420bfa8:	00 00 00 
  800420bfab:	41 ff d0             	callq  *%r8
  800420bfae:	eb 1b                	jmp    800420bfcb <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420bfb0:	48 bf be 82 21 04 80 	movabs $0x80042182be,%rdi
  800420bfb7:	00 00 00 
  800420bfba:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bfbf:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420bfc6:	00 00 00 
  800420bfc9:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420bfcb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bfcf:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420bfd6:	48 89 c6             	mov    %rax,%rsi
  800420bfd9:	48 bf c0 82 21 04 80 	movabs $0x80042182c0,%rdi
  800420bfe0:	00 00 00 
  800420bfe3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bfe8:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420bfef:	00 00 00 
  800420bff2:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420bff4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bff8:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420bfff:	0f b7 c0             	movzwl %ax,%eax
  800420c002:	89 c6                	mov    %eax,%esi
  800420c004:	48 bf cf 82 21 04 80 	movabs $0x80042182cf,%rdi
  800420c00b:	00 00 00 
  800420c00e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c013:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c01a:	00 00 00 
  800420c01d:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420c01f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c023:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420c02a:	48 89 c6             	mov    %rax,%rsi
  800420c02d:	48 bf e2 82 21 04 80 	movabs $0x80042182e2,%rdi
  800420c034:	00 00 00 
  800420c037:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c03c:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c043:	00 00 00 
  800420c046:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420c048:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c04c:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c053:	0f b7 c0             	movzwl %ax,%eax
  800420c056:	83 e0 03             	and    $0x3,%eax
  800420c059:	85 c0                	test   %eax,%eax
  800420c05b:	74 54                	je     800420c0b1 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420c05d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c061:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420c068:	48 89 c6             	mov    %rax,%rsi
  800420c06b:	48 bf f1 82 21 04 80 	movabs $0x80042182f1,%rdi
  800420c072:	00 00 00 
  800420c075:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c07a:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c081:	00 00 00 
  800420c084:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420c086:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c08a:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420c091:	0f b7 c0             	movzwl %ax,%eax
  800420c094:	89 c6                	mov    %eax,%esi
  800420c096:	48 bf 00 83 21 04 80 	movabs $0x8004218300,%rdi
  800420c09d:	00 00 00 
  800420c0a0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c0a5:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c0ac:	00 00 00 
  800420c0af:	ff d2                	callq  *%rdx
	}
}
  800420c0b1:	c9                   	leaveq 
  800420c0b2:	c3                   	retq   

000000800420c0b3 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420c0b3:	55                   	push   %rbp
  800420c0b4:	48 89 e5             	mov    %rsp,%rbp
  800420c0b7:	48 83 ec 10          	sub    $0x10,%rsp
  800420c0bb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420c0bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c0c3:	48 8b 00             	mov    (%rax),%rax
  800420c0c6:	48 89 c6             	mov    %rax,%rsi
  800420c0c9:	48 bf 13 83 21 04 80 	movabs $0x8004218313,%rdi
  800420c0d0:	00 00 00 
  800420c0d3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c0d8:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c0df:	00 00 00 
  800420c0e2:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420c0e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c0e8:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c0ec:	48 89 c6             	mov    %rax,%rsi
  800420c0ef:	48 bf 22 83 21 04 80 	movabs $0x8004218322,%rdi
  800420c0f6:	00 00 00 
  800420c0f9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c0fe:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c105:	00 00 00 
  800420c108:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420c10a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c10e:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420c112:	48 89 c6             	mov    %rax,%rsi
  800420c115:	48 bf 31 83 21 04 80 	movabs $0x8004218331,%rdi
  800420c11c:	00 00 00 
  800420c11f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c124:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c12b:	00 00 00 
  800420c12e:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420c130:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c134:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420c138:	48 89 c6             	mov    %rax,%rsi
  800420c13b:	48 bf 40 83 21 04 80 	movabs $0x8004218340,%rdi
  800420c142:	00 00 00 
  800420c145:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c14a:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c151:	00 00 00 
  800420c154:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420c156:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c15a:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420c15e:	48 89 c6             	mov    %rax,%rsi
  800420c161:	48 bf 4f 83 21 04 80 	movabs $0x800421834f,%rdi
  800420c168:	00 00 00 
  800420c16b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c170:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c177:	00 00 00 
  800420c17a:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420c17c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c180:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c184:	48 89 c6             	mov    %rax,%rsi
  800420c187:	48 bf 5e 83 21 04 80 	movabs $0x800421835e,%rdi
  800420c18e:	00 00 00 
  800420c191:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c196:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c19d:	00 00 00 
  800420c1a0:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420c1a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c1a6:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420c1aa:	48 89 c6             	mov    %rax,%rsi
  800420c1ad:	48 bf 6d 83 21 04 80 	movabs $0x800421836d,%rdi
  800420c1b4:	00 00 00 
  800420c1b7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c1bc:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c1c3:	00 00 00 
  800420c1c6:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420c1c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c1cc:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420c1d0:	48 89 c6             	mov    %rax,%rsi
  800420c1d3:	48 bf 7b 83 21 04 80 	movabs $0x800421837b,%rdi
  800420c1da:	00 00 00 
  800420c1dd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c1e2:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c1e9:	00 00 00 
  800420c1ec:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420c1ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c1f2:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420c1f6:	48 89 c6             	mov    %rax,%rsi
  800420c1f9:	48 bf 89 83 21 04 80 	movabs $0x8004218389,%rdi
  800420c200:	00 00 00 
  800420c203:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c208:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c20f:	00 00 00 
  800420c212:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420c214:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c218:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420c21c:	48 89 c6             	mov    %rax,%rsi
  800420c21f:	48 bf 98 83 21 04 80 	movabs $0x8004218398,%rdi
  800420c226:	00 00 00 
  800420c229:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c22e:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c235:	00 00 00 
  800420c238:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420c23a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c23e:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420c242:	48 89 c6             	mov    %rax,%rsi
  800420c245:	48 bf a7 83 21 04 80 	movabs $0x80042183a7,%rdi
  800420c24c:	00 00 00 
  800420c24f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c254:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c25b:	00 00 00 
  800420c25e:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420c260:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c264:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420c268:	48 89 c6             	mov    %rax,%rsi
  800420c26b:	48 bf b6 83 21 04 80 	movabs $0x80042183b6,%rdi
  800420c272:	00 00 00 
  800420c275:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c27a:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c281:	00 00 00 
  800420c284:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420c286:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c28a:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420c28e:	48 89 c6             	mov    %rax,%rsi
  800420c291:	48 bf c5 83 21 04 80 	movabs $0x80042183c5,%rdi
  800420c298:	00 00 00 
  800420c29b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2a0:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c2a7:	00 00 00 
  800420c2aa:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420c2ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c2b0:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420c2b4:	48 89 c6             	mov    %rax,%rsi
  800420c2b7:	48 bf d4 83 21 04 80 	movabs $0x80042183d4,%rdi
  800420c2be:	00 00 00 
  800420c2c1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2c6:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c2cd:	00 00 00 
  800420c2d0:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420c2d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c2d6:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c2da:	48 89 c6             	mov    %rax,%rsi
  800420c2dd:	48 bf e3 83 21 04 80 	movabs $0x80042183e3,%rdi
  800420c2e4:	00 00 00 
  800420c2e7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2ec:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c2f3:	00 00 00 
  800420c2f6:	ff d2                	callq  *%rdx
}
  800420c2f8:	c9                   	leaveq 
  800420c2f9:	c3                   	retq   

000000800420c2fa <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420c2fa:	55                   	push   %rbp
  800420c2fb:	48 89 e5             	mov    %rsp,%rbp
  800420c2fe:	48 83 ec 10          	sub    $0x10,%rsp
  800420c302:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Handle processor exceptions.
	// LAB 3: Your code here.
	//print_trapframe(tf);
	if(tf->tf_trapno == T_PGFLT)
  800420c306:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c30a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c311:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c315:	75 18                	jne    800420c32f <trap_dispatch+0x35>
    {
        page_fault_handler(tf);
  800420c317:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c31b:	48 89 c7             	mov    %rax,%rdi
  800420c31e:	48 b8 75 c8 20 04 80 	movabs $0x800420c875,%rax
  800420c325:	00 00 00 
  800420c328:	ff d0                	callq  *%rax
  800420c32a:	e9 8c 00 00 00       	jmpq   800420c3bb <trap_dispatch+0xc1>
    }
    else if(tf->tf_trapno == T_BRKPT)
  800420c32f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c333:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c33a:	48 83 f8 03          	cmp    $0x3,%rax
  800420c33e:	75 15                	jne    800420c355 <trap_dispatch+0x5b>
    {
        monitor(tf);
  800420c340:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c344:	48 89 c7             	mov    %rax,%rdi
  800420c347:	48 b8 31 1b 20 04 80 	movabs $0x8004201b31,%rax
  800420c34e:	00 00 00 
  800420c351:	ff d0                	callq  *%rax
  800420c353:	eb 66                	jmp    800420c3bb <trap_dispatch+0xc1>
    }
    else if(tf->tf_trapno == T_SYSCALL)
  800420c355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c359:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c360:	48 83 f8 30          	cmp    $0x30,%rax
  800420c364:	75 55                	jne    800420c3bb <trap_dispatch+0xc1>
    {
        tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, tf->tf_regs.reg_rdx,
  800420c366:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c36a:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420c36e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c372:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420c376:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c37a:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420c37e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c382:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420c386:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c38a:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420c38e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c392:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c396:	4d 89 c1             	mov    %r8,%r9
  800420c399:	49 89 f8             	mov    %rdi,%r8
  800420c39c:	48 89 c7             	mov    %rax,%rdi
  800420c39f:	48 b8 9c db 20 04 80 	movabs $0x800420db9c,%rax
  800420c3a6:	00 00 00 
  800420c3a9:	ff d0                	callq  *%rax
  800420c3ab:	48 89 c2             	mov    %rax,%rdx
  800420c3ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3b2:	48 89 50 70          	mov    %rdx,0x70(%rax)
                        tf->tf_regs.reg_rcx, tf->tf_regs.reg_rbx,
                        tf->tf_regs.reg_rdi, tf->tf_regs.reg_rsi);
        return;
  800420c3b6:	e9 4e 01 00 00       	jmpq   800420c509 <trap_dispatch+0x20f>
    }

	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420c3bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3bf:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c3c6:	48 83 f8 27          	cmp    $0x27,%rax
  800420c3ca:	75 33                	jne    800420c3ff <trap_dispatch+0x105>
		cprintf("Spurious interrupt on irq 7\n");
  800420c3cc:	48 bf f2 83 21 04 80 	movabs $0x80042183f2,%rdi
  800420c3d3:	00 00 00 
  800420c3d6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c3db:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c3e2:	00 00 00 
  800420c3e5:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420c3e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3eb:	48 89 c7             	mov    %rax,%rdi
  800420c3ee:	48 b8 a2 bd 20 04 80 	movabs $0x800420bda2,%rax
  800420c3f5:	00 00 00 
  800420c3f8:	ff d0                	callq  *%rax
		return;
  800420c3fa:	e9 0a 01 00 00       	jmpq   800420c509 <trap_dispatch+0x20f>
	// LAB 4: Your code here.


	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_TIMER))
  800420c3ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c403:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c40a:	48 83 f8 20          	cmp    $0x20,%rax
  800420c40e:	75 18                	jne    800420c428 <trap_dispatch+0x12e>
	{
		lapic_eoi();
  800420c410:	48 b8 8a 67 21 04 80 	movabs $0x800421678a,%rax
  800420c417:	00 00 00 
  800420c41a:	ff d0                	callq  *%rax
		sched_yield();
  800420c41c:	48 b8 93 ce 20 04 80 	movabs $0x800420ce93,%rax
  800420c423:	00 00 00 
  800420c426:	ff d0                	callq  *%rax
	}
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_KBD))
  800420c428:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c42c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c433:	48 83 f8 21          	cmp    $0x21,%rax
  800420c437:	75 18                	jne    800420c451 <trap_dispatch+0x157>
	{
		kbd_intr();
  800420c439:	48 b8 29 10 20 04 80 	movabs $0x8004201029,%rax
  800420c440:	00 00 00 
  800420c443:	ff d0                	callq  *%rax
		sched_yield();
  800420c445:	48 b8 93 ce 20 04 80 	movabs $0x800420ce93,%rax
  800420c44c:	00 00 00 
  800420c44f:	ff d0                	callq  *%rax
	}
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_SERIAL))
  800420c451:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c455:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c45c:	48 83 f8 24          	cmp    $0x24,%rax
  800420c460:	75 18                	jne    800420c47a <trap_dispatch+0x180>
	{
		serial_intr();
  800420c462:	48 b8 da 07 20 04 80 	movabs $0x80042007da,%rax
  800420c469:	00 00 00 
  800420c46c:	ff d0                	callq  *%rax
		sched_yield();
  800420c46e:	48 b8 93 ce 20 04 80 	movabs $0x800420ce93,%rax
  800420c475:	00 00 00 
  800420c478:	ff d0                	callq  *%rax
	}
	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420c47a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c47e:	48 89 c7             	mov    %rax,%rdi
  800420c481:	48 b8 a2 bd 20 04 80 	movabs $0x800420bda2,%rax
  800420c488:	00 00 00 
  800420c48b:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420c48d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c491:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c498:	66 83 f8 08          	cmp    $0x8,%ax
  800420c49c:	75 2a                	jne    800420c4c8 <trap_dispatch+0x1ce>
		panic("unhandled trap in kernel");
  800420c49e:	48 ba 0f 84 21 04 80 	movabs $0x800421840f,%rdx
  800420c4a5:	00 00 00 
  800420c4a8:	be 0e 01 00 00       	mov    $0x10e,%esi
  800420c4ad:	48 bf 28 84 21 04 80 	movabs $0x8004218428,%rdi
  800420c4b4:	00 00 00 
  800420c4b7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c4bc:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  800420c4c3:	00 00 00 
  800420c4c6:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420c4c8:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c4cf:	00 00 00 
  800420c4d2:	ff d0                	callq  *%rax
  800420c4d4:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c4db:	00 00 00 
  800420c4de:	48 98                	cltq   
  800420c4e0:	48 c1 e0 03          	shl    $0x3,%rax
  800420c4e4:	48 89 c2             	mov    %rax,%rdx
  800420c4e7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c4eb:	48 29 c2             	sub    %rax,%rdx
  800420c4ee:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c4f2:	48 83 c0 08          	add    $0x8,%rax
  800420c4f6:	48 8b 00             	mov    (%rax),%rax
  800420c4f9:	48 89 c7             	mov    %rax,%rdi
  800420c4fc:	48 b8 bf 85 20 04 80 	movabs $0x80042085bf,%rax
  800420c503:	00 00 00 
  800420c506:	ff d0                	callq  *%rax
		return;
  800420c508:	90                   	nop
	}
}
  800420c509:	c9                   	leaveq 
  800420c50a:	c3                   	retq   

000000800420c50b <trap>:

void
trap(struct Trapframe *tf)
{
  800420c50b:	55                   	push   %rbp
  800420c50c:	48 89 e5             	mov    %rsp,%rbp
  800420c50f:	48 83 ec 20          	sub    $0x20,%rsp
  800420c513:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    //struct Trapframe *tf = &tf_;
	// The environmentmay have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420c517:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420c518:	48 b8 90 17 4a 04 80 	movabs $0x80044a1790,%rax
  800420c51f:	00 00 00 
  800420c522:	48 8b 00             	mov    (%rax),%rax
  800420c525:	48 85 c0             	test   %rax,%rax
  800420c528:	74 01                	je     800420c52b <trap+0x20>
		asm volatile("hlt");
  800420c52a:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420c52b:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c532:	00 00 00 
  800420c535:	ff d0                	callq  *%rax
  800420c537:	48 98                	cltq   
  800420c539:	48 c1 e0 03          	shl    $0x3,%rax
  800420c53d:	48 89 c2             	mov    %rax,%rdx
  800420c540:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c544:	48 29 c2             	sub    %rax,%rdx
  800420c547:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  800420c54e:	00 00 00 
  800420c551:	48 01 d0             	add    %rdx,%rax
  800420c554:	48 83 c0 04          	add    $0x4,%rax
  800420c558:	be 01 00 00 00       	mov    $0x1,%esi
  800420c55d:	48 89 c7             	mov    %rax,%rdi
  800420c560:	48 b8 71 8e 20 04 80 	movabs $0x8004208e71,%rax
  800420c567:	00 00 00 
  800420c56a:	ff d0                	callq  *%rax
  800420c56c:	83 f8 02             	cmp    $0x2,%eax
  800420c56f:	75 0c                	jne    800420c57d <trap+0x72>
		lock_kernel();
  800420c571:	48 b8 96 8e 20 04 80 	movabs $0x8004208e96,%rax
  800420c578:	00 00 00 
  800420c57b:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
        uint64_t rflags;
        __asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420c57d:	9c                   	pushfq 
  800420c57e:	58                   	pop    %rax
  800420c57f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        return rflags;
  800420c583:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420c587:	25 00 02 00 00       	and    $0x200,%eax
  800420c58c:	48 85 c0             	test   %rax,%rax
  800420c58f:	74 35                	je     800420c5c6 <trap+0xbb>
  800420c591:	48 b9 34 84 21 04 80 	movabs $0x8004218434,%rcx
  800420c598:	00 00 00 
  800420c59b:	48 ba 4d 84 21 04 80 	movabs $0x800421844d,%rdx
  800420c5a2:	00 00 00 
  800420c5a5:	be 29 01 00 00       	mov    $0x129,%esi
  800420c5aa:	48 bf 28 84 21 04 80 	movabs $0x8004218428,%rdi
  800420c5b1:	00 00 00 
  800420c5b4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c5b9:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420c5c0:	00 00 00 
  800420c5c3:	41 ff d0             	callq  *%r8

	if ((tf->tf_cs & 3) == 3) {
  800420c5c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c5ca:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c5d1:	0f b7 c0             	movzwl %ax,%eax
  800420c5d4:	83 e0 03             	and    $0x3,%eax
  800420c5d7:	83 f8 03             	cmp    $0x3,%eax
  800420c5da:	0f 85 b3 01 00 00    	jne    800420c793 <trap+0x288>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420c5e0:	48 b8 96 8e 20 04 80 	movabs $0x8004208e96,%rax
  800420c5e7:	00 00 00 
  800420c5ea:	ff d0                	callq  *%rax
		assert(curenv);
  800420c5ec:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c5f3:	00 00 00 
  800420c5f6:	ff d0                	callq  *%rax
  800420c5f8:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c5ff:	00 00 00 
  800420c602:	48 98                	cltq   
  800420c604:	48 c1 e0 03          	shl    $0x3,%rax
  800420c608:	48 89 c2             	mov    %rax,%rdx
  800420c60b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c60f:	48 29 c2             	sub    %rax,%rdx
  800420c612:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c616:	48 83 c0 08          	add    $0x8,%rax
  800420c61a:	48 8b 00             	mov    (%rax),%rax
  800420c61d:	48 85 c0             	test   %rax,%rax
  800420c620:	75 35                	jne    800420c657 <trap+0x14c>
  800420c622:	48 b9 62 84 21 04 80 	movabs $0x8004218462,%rcx
  800420c629:	00 00 00 
  800420c62c:	48 ba 4d 84 21 04 80 	movabs $0x800421844d,%rdx
  800420c633:	00 00 00 
  800420c636:	be 31 01 00 00       	mov    $0x131,%esi
  800420c63b:	48 bf 28 84 21 04 80 	movabs $0x8004218428,%rdi
  800420c642:	00 00 00 
  800420c645:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c64a:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420c651:	00 00 00 
  800420c654:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420c657:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c65e:	00 00 00 
  800420c661:	ff d0                	callq  *%rax
  800420c663:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c66a:	00 00 00 
  800420c66d:	48 98                	cltq   
  800420c66f:	48 c1 e0 03          	shl    $0x3,%rax
  800420c673:	48 89 c2             	mov    %rax,%rdx
  800420c676:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c67a:	48 29 c2             	sub    %rax,%rdx
  800420c67d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c681:	48 83 c0 08          	add    $0x8,%rax
  800420c685:	48 8b 00             	mov    (%rax),%rax
  800420c688:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c68e:	83 f8 01             	cmp    $0x1,%eax
  800420c691:	0f 85 81 00 00 00    	jne    800420c718 <trap+0x20d>
			env_free(curenv);
  800420c697:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c69e:	00 00 00 
  800420c6a1:	ff d0                	callq  *%rax
  800420c6a3:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c6aa:	00 00 00 
  800420c6ad:	48 98                	cltq   
  800420c6af:	48 c1 e0 03          	shl    $0x3,%rax
  800420c6b3:	48 89 c2             	mov    %rax,%rdx
  800420c6b6:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c6ba:	48 29 c2             	sub    %rax,%rdx
  800420c6bd:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c6c1:	48 83 c0 08          	add    $0x8,%rax
  800420c6c5:	48 8b 00             	mov    (%rax),%rax
  800420c6c8:	48 89 c7             	mov    %rax,%rdi
  800420c6cb:	48 b8 32 81 20 04 80 	movabs $0x8004208132,%rax
  800420c6d2:	00 00 00 
  800420c6d5:	ff d0                	callq  *%rax
			curenv = NULL;
  800420c6d7:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c6de:	00 00 00 
  800420c6e1:	ff d0                	callq  *%rax
  800420c6e3:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c6ea:	00 00 00 
  800420c6ed:	48 98                	cltq   
  800420c6ef:	48 c1 e0 03          	shl    $0x3,%rax
  800420c6f3:	48 89 c2             	mov    %rax,%rdx
  800420c6f6:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c6fa:	48 29 c2             	sub    %rax,%rdx
  800420c6fd:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c701:	48 83 c0 08          	add    $0x8,%rax
  800420c705:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420c70c:	48 b8 93 ce 20 04 80 	movabs $0x800420ce93,%rax
  800420c713:	00 00 00 
  800420c716:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420c718:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c71f:	00 00 00 
  800420c722:	ff d0                	callq  *%rax
  800420c724:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c72b:	00 00 00 
  800420c72e:	48 98                	cltq   
  800420c730:	48 c1 e0 03          	shl    $0x3,%rax
  800420c734:	48 89 c2             	mov    %rax,%rdx
  800420c737:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c73b:	48 29 c2             	sub    %rax,%rdx
  800420c73e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c742:	48 83 c0 08          	add    $0x8,%rax
  800420c746:	48 8b 10             	mov    (%rax),%rdx
  800420c749:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c74d:	48 89 c6             	mov    %rax,%rsi
  800420c750:	b8 18 00 00 00       	mov    $0x18,%eax
  800420c755:	48 89 d7             	mov    %rdx,%rdi
  800420c758:	48 89 c1             	mov    %rax,%rcx
  800420c75b:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420c75e:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c765:	00 00 00 
  800420c768:	ff d0                	callq  *%rax
  800420c76a:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c771:	00 00 00 
  800420c774:	48 98                	cltq   
  800420c776:	48 c1 e0 03          	shl    $0x3,%rax
  800420c77a:	48 89 c2             	mov    %rax,%rdx
  800420c77d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c781:	48 29 c2             	sub    %rax,%rdx
  800420c784:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c788:	48 83 c0 08          	add    $0x8,%rax
  800420c78c:	48 8b 00             	mov    (%rax),%rax
  800420c78f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420c793:	48 b8 08 13 4a 04 80 	movabs $0x80044a1308,%rax
  800420c79a:	00 00 00 
  800420c79d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c7a1:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420c7a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c7a8:	48 89 c7             	mov    %rax,%rdi
  800420c7ab:	48 b8 fa c2 20 04 80 	movabs $0x800420c2fa,%rax
  800420c7b2:	00 00 00 
  800420c7b5:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420c7b7:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c7be:	00 00 00 
  800420c7c1:	ff d0                	callq  *%rax
  800420c7c3:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c7ca:	00 00 00 
  800420c7cd:	48 98                	cltq   
  800420c7cf:	48 c1 e0 03          	shl    $0x3,%rax
  800420c7d3:	48 89 c2             	mov    %rax,%rdx
  800420c7d6:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c7da:	48 29 c2             	sub    %rax,%rdx
  800420c7dd:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c7e1:	48 83 c0 08          	add    $0x8,%rax
  800420c7e5:	48 8b 00             	mov    (%rax),%rax
  800420c7e8:	48 85 c0             	test   %rax,%rax
  800420c7eb:	74 7c                	je     800420c869 <trap+0x35e>
  800420c7ed:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c7f4:	00 00 00 
  800420c7f7:	ff d0                	callq  *%rax
  800420c7f9:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c800:	00 00 00 
  800420c803:	48 98                	cltq   
  800420c805:	48 c1 e0 03          	shl    $0x3,%rax
  800420c809:	48 89 c2             	mov    %rax,%rdx
  800420c80c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c810:	48 29 c2             	sub    %rax,%rdx
  800420c813:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c817:	48 83 c0 08          	add    $0x8,%rax
  800420c81b:	48 8b 00             	mov    (%rax),%rax
  800420c81e:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c824:	83 f8 03             	cmp    $0x3,%eax
  800420c827:	75 40                	jne    800420c869 <trap+0x35e>
		env_run(curenv);
  800420c829:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c830:	00 00 00 
  800420c833:	ff d0                	callq  *%rax
  800420c835:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c83c:	00 00 00 
  800420c83f:	48 98                	cltq   
  800420c841:	48 c1 e0 03          	shl    $0x3,%rax
  800420c845:	48 89 c2             	mov    %rax,%rdx
  800420c848:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c84c:	48 29 c2             	sub    %rax,%rdx
  800420c84f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c853:	48 83 c0 08          	add    $0x8,%rax
  800420c857:	48 8b 00             	mov    (%rax),%rax
  800420c85a:	48 89 c7             	mov    %rax,%rdi
  800420c85d:	48 b8 8e 87 20 04 80 	movabs $0x800420878e,%rax
  800420c864:	00 00 00 
  800420c867:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420c869:	48 b8 93 ce 20 04 80 	movabs $0x800420ce93,%rax
  800420c870:	00 00 00 
  800420c873:	ff d0                	callq  *%rax

000000800420c875 <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420c875:	55                   	push   %rbp
  800420c876:	48 89 e5             	mov    %rsp,%rbp
  800420c879:	53                   	push   %rbx
  800420c87a:	48 83 ec 38          	sub    $0x38,%rsp
  800420c87e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420c882:	0f 20 d0             	mov    %cr2,%rax
  800420c885:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	return val;
  800420c889:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420c88d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	struct PageInfo *pp;

	// Handle kernel-mode page faults.
	
	// LAB 3: Your code here.
	if((tf->tf_cs & 3) == 0)
  800420c891:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c895:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c89c:	0f b7 c0             	movzwl %ax,%eax
  800420c89f:	83 e0 03             	and    $0x3,%eax
  800420c8a2:	85 c0                	test   %eax,%eax
  800420c8a4:	75 5f                	jne    800420c905 <page_fault_handler+0x90>
	{
		cprintf("fault_va is [%x]",fault_va);
  800420c8a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c8aa:	48 89 c6             	mov    %rax,%rsi
  800420c8ad:	48 bf 69 84 21 04 80 	movabs $0x8004218469,%rdi
  800420c8b4:	00 00 00 
  800420c8b7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c8bc:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420c8c3:	00 00 00 
  800420c8c6:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420c8c8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c8cc:	48 89 c7             	mov    %rax,%rdi
  800420c8cf:	48 b8 a2 bd 20 04 80 	movabs $0x800420bda2,%rax
  800420c8d6:	00 00 00 
  800420c8d9:	ff d0                	callq  *%rax
		panic("Page fault hapened in kernel mode");
  800420c8db:	48 ba 80 84 21 04 80 	movabs $0x8004218480,%rdx
  800420c8e2:	00 00 00 
  800420c8e5:	be 64 01 00 00       	mov    $0x164,%esi
  800420c8ea:	48 bf 28 84 21 04 80 	movabs $0x8004218428,%rdi
  800420c8f1:	00 00 00 
  800420c8f4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c8f9:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  800420c900:	00 00 00 
  800420c903:	ff d1                	callq  *%rcx
	// LAB 4: Your code here.
	
	/*check if user env has registered a pg fault upcall.*/
		//cprintf("hello1");
	//cprintf("hello2");
    if(curenv->env_pgfault_upcall){
  800420c905:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c90c:	00 00 00 
  800420c90f:	ff d0                	callq  *%rax
  800420c911:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c918:	00 00 00 
  800420c91b:	48 98                	cltq   
  800420c91d:	48 c1 e0 03          	shl    $0x3,%rax
  800420c921:	48 89 c2             	mov    %rax,%rdx
  800420c924:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c928:	48 29 c2             	sub    %rax,%rdx
  800420c92b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c92f:	48 83 c0 08          	add    $0x8,%rax
  800420c933:	48 8b 00             	mov    (%rax),%rax
  800420c936:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420c93d:	48 85 c0             	test   %rax,%rax
  800420c940:	0f 84 6e 02 00 00    	je     800420cbb4 <page_fault_handler+0x33f>
		//user_mem_assert(curenv,(const void *)curenv->env_pgfault_upcall,8,PTE_P|PTE_U);
		user_mem_assert(curenv,(const void *)UXSTACKTOP-PGSIZE,PGSIZE, PTE_W | PTE_U | PTE_P);
  800420c946:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c94d:	00 00 00 
  800420c950:	ff d0                	callq  *%rax
  800420c952:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c959:	00 00 00 
  800420c95c:	48 98                	cltq   
  800420c95e:	48 c1 e0 03          	shl    $0x3,%rax
  800420c962:	48 89 c2             	mov    %rax,%rdx
  800420c965:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c969:	48 29 c2             	sub    %rax,%rdx
  800420c96c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c970:	48 83 c0 08          	add    $0x8,%rax
  800420c974:	48 8b 00             	mov    (%rax),%rax
  800420c977:	b9 07 00 00 00       	mov    $0x7,%ecx
  800420c97c:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420c981:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  800420c986:	48 89 c7             	mov    %rax,%rdi
  800420c989:	48 b8 3e 3d 20 04 80 	movabs $0x8004203d3e,%rax
  800420c990:	00 00 00 
  800420c993:	ff d0                	callq  *%rax
		/*If user mem assert returns , then the address is valid for the env*/	
		if(!(tf->tf_rsp < UXSTACKTOP && tf->tf_rsp > UXSTACKTOP-PGSIZE)){
  800420c995:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c999:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420c9a0:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420c9a5:	48 39 c2             	cmp    %rax,%rdx
  800420c9a8:	77 15                	ja     800420c9bf <page_fault_handler+0x14a>
  800420c9aa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c9ae:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420c9b5:	b8 00 f0 7f ef       	mov    $0xef7ff000,%eax
  800420c9ba:	48 39 c2             	cmp    %rax,%rdx
  800420c9bd:	77 0b                	ja     800420c9ca <page_fault_handler+0x155>
			/*1st Page Fault*/
			utf = (struct UTrapframe *)(UXSTACKTOP - sizeof(struct UTrapframe));
  800420c9bf:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420c9c4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420c9c8:	eb 73                	jmp    800420ca3d <page_fault_handler+0x1c8>
		}else{
			if(tf->tf_rsp - sizeof(struct UTrapframe) - 8 < (UXSTACKTOP-PGSIZE)){
  800420c9ca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c9ce:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420c9d5:	48 8d 90 58 ff ff ff 	lea    -0xa8(%rax),%rdx
  800420c9dc:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420c9e1:	48 39 c2             	cmp    %rax,%rdx
  800420c9e4:	77 42                	ja     800420ca28 <page_fault_handler+0x1b3>
				env_destroy(curenv);
  800420c9e6:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420c9ed:	00 00 00 
  800420c9f0:	ff d0                	callq  *%rax
  800420c9f2:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420c9f9:	00 00 00 
  800420c9fc:	48 98                	cltq   
  800420c9fe:	48 c1 e0 03          	shl    $0x3,%rax
  800420ca02:	48 89 c2             	mov    %rax,%rdx
  800420ca05:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ca09:	48 29 c2             	sub    %rax,%rdx
  800420ca0c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ca10:	48 83 c0 08          	add    $0x8,%rax
  800420ca14:	48 8b 00             	mov    (%rax),%rax
  800420ca17:	48 89 c7             	mov    %rax,%rdi
  800420ca1a:	48 b8 bf 85 20 04 80 	movabs $0x80042085bf,%rax
  800420ca21:	00 00 00 
  800420ca24:	ff d0                	callq  *%rax
  800420ca26:	eb 15                	jmp    800420ca3d <page_fault_handler+0x1c8>
			}
			else
			{
				utf = (struct UTrapframe *)(tf->tf_rsp - sizeof(struct UTrapframe) - 8);
  800420ca28:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca2c:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420ca33:	48 2d a8 00 00 00    	sub    $0xa8,%rax
  800420ca39:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			/*Nested Page Fault*/
			
		}
		/*Populate the Utrapframe*/
		//user_mem_assert(curenv,(const void *)utf,sizeof(struct UTrapframe),PTE_W|PTE_U);
		utf->utf_eflags = tf->tf_eflags;
  800420ca3d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca41:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420ca48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca4c:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
		utf->utf_err = tf->tf_err;
  800420ca53:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca57:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420ca5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca62:	48 89 50 08          	mov    %rdx,0x8(%rax)
		utf->utf_fault_va = fault_va;
  800420ca66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca6a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ca6e:	48 89 10             	mov    %rdx,(%rax)
		utf->utf_regs = tf->tf_regs;
  800420ca71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca75:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ca79:	48 8b 0a             	mov    (%rdx),%rcx
  800420ca7c:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420ca80:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420ca84:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420ca88:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420ca8c:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420ca90:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420ca94:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420ca98:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420ca9c:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420caa0:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420caa4:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420caa8:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420caac:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420cab0:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420cab4:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420cab8:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420cabc:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420cac0:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420cac4:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420cac8:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420cacc:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420cad0:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420cad4:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420cad8:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420cadc:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420cae0:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420cae4:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420cae8:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420caec:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		utf->utf_rip = tf->tf_rip;
  800420caf3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420caf7:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420cafe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb02:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		utf->utf_rsp = tf->tf_rsp;
  800420cb09:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cb0d:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420cb14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb18:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rip = (uint64_t)curenv->env_pgfault_upcall;
  800420cb1f:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420cb26:	00 00 00 
  800420cb29:	ff d0                	callq  *%rax
  800420cb2b:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420cb32:	00 00 00 
  800420cb35:	48 98                	cltq   
  800420cb37:	48 c1 e0 03          	shl    $0x3,%rax
  800420cb3b:	48 89 c2             	mov    %rax,%rdx
  800420cb3e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cb42:	48 29 c2             	sub    %rax,%rdx
  800420cb45:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cb49:	48 83 c0 08          	add    $0x8,%rax
  800420cb4d:	48 8b 00             	mov    (%rax),%rax
  800420cb50:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420cb57:	48 89 c2             	mov    %rax,%rdx
  800420cb5a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cb5e:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rsp = (uint64_t)utf;
  800420cb65:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cb69:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cb6d:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
		

		
		env_run(curenv);
  800420cb74:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420cb7b:	00 00 00 
  800420cb7e:	ff d0                	callq  *%rax
  800420cb80:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420cb87:	00 00 00 
  800420cb8a:	48 98                	cltq   
  800420cb8c:	48 c1 e0 03          	shl    $0x3,%rax
  800420cb90:	48 89 c2             	mov    %rax,%rdx
  800420cb93:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cb97:	48 29 c2             	sub    %rax,%rdx
  800420cb9a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cb9e:	48 83 c0 08          	add    $0x8,%rax
  800420cba2:	48 8b 00             	mov    (%rax),%rax
  800420cba5:	48 89 c7             	mov    %rax,%rdi
  800420cba8:	48 b8 8e 87 20 04 80 	movabs $0x800420878e,%rax
  800420cbaf:	00 00 00 
  800420cbb2:	ff d0                	callq  *%rax
	
    }else{
		// Destroy the environment that caused the fault.
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420cbb4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cbb8:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
			curenv->env_id, fault_va, tf->tf_rip);
  800420cbbf:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420cbc6:	00 00 00 
  800420cbc9:	ff d0                	callq  *%rax
  800420cbcb:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420cbd2:	00 00 00 
  800420cbd5:	48 98                	cltq   
  800420cbd7:	48 c1 e0 03          	shl    $0x3,%rax
  800420cbdb:	48 89 c2             	mov    %rax,%rdx
  800420cbde:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cbe2:	48 29 c2             	sub    %rax,%rdx
  800420cbe5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cbe9:	48 83 c0 08          	add    $0x8,%rax
  800420cbed:	48 8b 00             	mov    (%rax),%rax
		
		env_run(curenv);
	
    }else{
		// Destroy the environment that caused the fault.
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420cbf0:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420cbf6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cbfa:	48 89 d9             	mov    %rbx,%rcx
  800420cbfd:	89 c6                	mov    %eax,%esi
  800420cbff:	48 bf a8 84 21 04 80 	movabs $0x80042184a8,%rdi
  800420cc06:	00 00 00 
  800420cc09:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc0e:	49 b8 99 8d 20 04 80 	movabs $0x8004208d99,%r8
  800420cc15:	00 00 00 
  800420cc18:	41 ff d0             	callq  *%r8
			curenv->env_id, fault_va, tf->tf_rip);
		print_trapframe(tf);
  800420cc1b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cc1f:	48 89 c7             	mov    %rax,%rdi
  800420cc22:	48 b8 a2 bd 20 04 80 	movabs $0x800420bda2,%rax
  800420cc29:	00 00 00 
  800420cc2c:	ff d0                	callq  *%rax
		env_destroy(curenv);
  800420cc2e:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420cc35:	00 00 00 
  800420cc38:	ff d0                	callq  *%rax
  800420cc3a:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420cc41:	00 00 00 
  800420cc44:	48 98                	cltq   
  800420cc46:	48 c1 e0 03          	shl    $0x3,%rax
  800420cc4a:	48 89 c2             	mov    %rax,%rdx
  800420cc4d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cc51:	48 29 c2             	sub    %rax,%rdx
  800420cc54:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cc58:	48 83 c0 08          	add    $0x8,%rax
  800420cc5c:	48 8b 00             	mov    (%rax),%rax
  800420cc5f:	48 89 c7             	mov    %rax,%rdi
  800420cc62:	48 b8 bf 85 20 04 80 	movabs $0x80042085bf,%rax
  800420cc69:	00 00 00 
  800420cc6c:	ff d0                	callq  *%rax
    }
}
  800420cc6e:	48 83 c4 38          	add    $0x38,%rsp
  800420cc72:	5b                   	pop    %rbx
  800420cc73:	5d                   	pop    %rbp
  800420cc74:	c3                   	retq   
  800420cc75:	90                   	nop

000000800420cc76 <XTRPX_divzero>:
 * Lab 3: Your code here for generating entry points for the different traps.
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */

	TRAPHANDLER_NOEC(XTRPX_divzero, T_DIVIDE)
  800420cc76:	6a 00                	pushq  $0x0
  800420cc78:	6a 00                	pushq  $0x0
  800420cc7a:	e9 01 01 00 00       	jmpq   800420cd80 <_alltraps>
  800420cc7f:	90                   	nop

000000800420cc80 <XTRPX_Debug>:
	TRAPHANDLER_NOEC(XTRPX_Debug, T_DEBUG)
  800420cc80:	6a 00                	pushq  $0x0
  800420cc82:	6a 01                	pushq  $0x1
  800420cc84:	e9 f7 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420cc89:	90                   	nop

000000800420cc8a <XTRPX_NonMaskI>:
	TRAPHANDLER_NOEC(XTRPX_NonMaskI, T_NMI)
  800420cc8a:	6a 00                	pushq  $0x0
  800420cc8c:	6a 02                	pushq  $0x2
  800420cc8e:	e9 ed 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420cc93:	90                   	nop

000000800420cc94 <XTRPX_Brkpt>:
	TRAPHANDLER_NOEC(XTRPX_Brkpt, T_BRKPT)
  800420cc94:	6a 00                	pushq  $0x0
  800420cc96:	6a 03                	pushq  $0x3
  800420cc98:	e9 e3 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420cc9d:	90                   	nop

000000800420cc9e <XTRPX_OFlow>:
	TRAPHANDLER_NOEC(XTRPX_OFlow, T_OFLOW)
  800420cc9e:	6a 00                	pushq  $0x0
  800420cca0:	6a 04                	pushq  $0x4
  800420cca2:	e9 d9 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420cca7:	90                   	nop

000000800420cca8 <XTRPX_Bound>:
	TRAPHANDLER_NOEC(XTRPX_Bound, T_BOUND)
  800420cca8:	6a 00                	pushq  $0x0
  800420ccaa:	6a 05                	pushq  $0x5
  800420ccac:	e9 cf 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420ccb1:	90                   	nop

000000800420ccb2 <XTRPX_Illop>:
	TRAPHANDLER_NOEC(XTRPX_Illop, T_ILLOP)
  800420ccb2:	6a 00                	pushq  $0x0
  800420ccb4:	6a 06                	pushq  $0x6
  800420ccb6:	e9 c5 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420ccbb:	90                   	nop

000000800420ccbc <XTRPX_Device>:
	TRAPHANDLER_NOEC(XTRPX_Device, T_DEVICE)
  800420ccbc:	6a 00                	pushq  $0x0
  800420ccbe:	6a 07                	pushq  $0x7
  800420ccc0:	e9 bb 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420ccc5:	90                   	nop

000000800420ccc6 <XTRPX_DblFlt>:
	TRAPHANDLER(XTRPX_DblFlt, T_DBLFLT)
  800420ccc6:	6a 08                	pushq  $0x8
  800420ccc8:	e9 b3 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420cccd:	90                   	nop

000000800420ccce <XTRPX_Tss>:
	TRAPHANDLER(XTRPX_Tss, T_TSS)
  800420ccce:	6a 0a                	pushq  $0xa
  800420ccd0:	e9 ab 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420ccd5:	90                   	nop

000000800420ccd6 <XTRPX_Segnp>:
	TRAPHANDLER(XTRPX_Segnp, T_SEGNP)
  800420ccd6:	6a 0b                	pushq  $0xb
  800420ccd8:	e9 a3 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420ccdd:	90                   	nop

000000800420ccde <XTRPX_Stack>:
	TRAPHANDLER(XTRPX_Stack, T_STACK)
  800420ccde:	6a 0c                	pushq  $0xc
  800420cce0:	e9 9b 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420cce5:	90                   	nop

000000800420cce6 <XTRPX_Gpflt>:
	TRAPHANDLER(XTRPX_Gpflt, T_GPFLT)
  800420cce6:	6a 0d                	pushq  $0xd
  800420cce8:	e9 93 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420cced:	90                   	nop

000000800420ccee <XTRPX_Pgflt>:
	TRAPHANDLER(XTRPX_Pgflt, T_PGFLT)
  800420ccee:	6a 0e                	pushq  $0xe
  800420ccf0:	e9 8b 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420ccf5:	90                   	nop

000000800420ccf6 <XTRPX_FpErr>:
	TRAPHANDLER_NOEC(XTRPX_FpErr, T_FPERR)
  800420ccf6:	6a 00                	pushq  $0x0
  800420ccf8:	6a 10                	pushq  $0x10
  800420ccfa:	e9 81 00 00 00       	jmpq   800420cd80 <_alltraps>
  800420ccff:	90                   	nop

000000800420cd00 <XTRPX_Align>:
	TRAPHANDLER(XTRPX_Align, T_ALIGN)
  800420cd00:	6a 11                	pushq  $0x11
  800420cd02:	eb 7c                	jmp    800420cd80 <_alltraps>

000000800420cd04 <XTRPX_Mchk>:
	TRAPHANDLER_NOEC(XTRPX_Mchk, T_MCHK)
  800420cd04:	6a 00                	pushq  $0x0
  800420cd06:	6a 12                	pushq  $0x12
  800420cd08:	eb 76                	jmp    800420cd80 <_alltraps>

000000800420cd0a <XTRPX_SimdErr>:
	TRAPHANDLER_NOEC(XTRPX_SimdErr, T_SIMDERR)
  800420cd0a:	6a 00                	pushq  $0x0
  800420cd0c:	6a 13                	pushq  $0x13
  800420cd0e:	eb 70                	jmp    800420cd80 <_alltraps>

000000800420cd10 <XTRPX_Syscall>:
	TRAPHANDLER_NOEC(XTRPX_Syscall, T_SYSCALL)
  800420cd10:	6a 00                	pushq  $0x0
  800420cd12:	6a 30                	pushq  $0x30
  800420cd14:	eb 6a                	jmp    800420cd80 <_alltraps>

000000800420cd16 <XTRPX_Default>:
	TRAPHANDLER_NOEC(XTRPX_Default, T_DEFAULT)
  800420cd16:	6a 00                	pushq  $0x0
  800420cd18:	68 f4 01 00 00       	pushq  $0x1f4
  800420cd1d:	eb 61                	jmp    800420cd80 <_alltraps>
  800420cd1f:	90                   	nop

000000800420cd20 <XTRPX_IRQ0>:
	TRAPHANDLER_NOEC(XTRPX_IRQ0, IRQ_OFFSET+IRQ_TIMER)
  800420cd20:	6a 00                	pushq  $0x0
  800420cd22:	6a 20                	pushq  $0x20
  800420cd24:	eb 5a                	jmp    800420cd80 <_alltraps>

000000800420cd26 <XTRPX_IRQ1>:
	TRAPHANDLER_NOEC(XTRPX_IRQ1, IRQ_OFFSET+IRQ_KBD)
  800420cd26:	6a 00                	pushq  $0x0
  800420cd28:	6a 21                	pushq  $0x21
  800420cd2a:	eb 54                	jmp    800420cd80 <_alltraps>

000000800420cd2c <XTRPX_IRQ2>:
	TRAPHANDLER_NOEC(XTRPX_IRQ2, IRQ_OFFSET+2)
  800420cd2c:	6a 00                	pushq  $0x0
  800420cd2e:	6a 22                	pushq  $0x22
  800420cd30:	eb 4e                	jmp    800420cd80 <_alltraps>

000000800420cd32 <XTRPX_IRQ3>:
	TRAPHANDLER_NOEC(XTRPX_IRQ3, IRQ_OFFSET+3)
  800420cd32:	6a 00                	pushq  $0x0
  800420cd34:	6a 23                	pushq  $0x23
  800420cd36:	eb 48                	jmp    800420cd80 <_alltraps>

000000800420cd38 <XTRPX_IRQ4>:
	TRAPHANDLER_NOEC(XTRPX_IRQ4, IRQ_OFFSET+IRQ_SERIAL)
  800420cd38:	6a 00                	pushq  $0x0
  800420cd3a:	6a 24                	pushq  $0x24
  800420cd3c:	eb 42                	jmp    800420cd80 <_alltraps>

000000800420cd3e <XTRPX_IRQ5>:
	TRAPHANDLER_NOEC(XTRPX_IRQ5, IRQ_OFFSET+5)
  800420cd3e:	6a 00                	pushq  $0x0
  800420cd40:	6a 25                	pushq  $0x25
  800420cd42:	eb 3c                	jmp    800420cd80 <_alltraps>

000000800420cd44 <XTRPX_IRQ6>:
	TRAPHANDLER_NOEC(XTRPX_IRQ6, IRQ_OFFSET+6)
  800420cd44:	6a 00                	pushq  $0x0
  800420cd46:	6a 26                	pushq  $0x26
  800420cd48:	eb 36                	jmp    800420cd80 <_alltraps>

000000800420cd4a <XTRPX_IRQ7>:
	TRAPHANDLER_NOEC(XTRPX_IRQ7, IRQ_OFFSET+IRQ_SPURIOUS)
  800420cd4a:	6a 00                	pushq  $0x0
  800420cd4c:	6a 27                	pushq  $0x27
  800420cd4e:	eb 30                	jmp    800420cd80 <_alltraps>

000000800420cd50 <XTRPX_IRQ8>:
	TRAPHANDLER_NOEC(XTRPX_IRQ8, IRQ_OFFSET+8)
  800420cd50:	6a 00                	pushq  $0x0
  800420cd52:	6a 28                	pushq  $0x28
  800420cd54:	eb 2a                	jmp    800420cd80 <_alltraps>

000000800420cd56 <XTRPX_IRQ9>:
	TRAPHANDLER_NOEC(XTRPX_IRQ9, IRQ_OFFSET+9)
  800420cd56:	6a 00                	pushq  $0x0
  800420cd58:	6a 29                	pushq  $0x29
  800420cd5a:	eb 24                	jmp    800420cd80 <_alltraps>

000000800420cd5c <XTRPX_IRQa>:
	TRAPHANDLER_NOEC(XTRPX_IRQa, IRQ_OFFSET+10)
  800420cd5c:	6a 00                	pushq  $0x0
  800420cd5e:	6a 2a                	pushq  $0x2a
  800420cd60:	eb 1e                	jmp    800420cd80 <_alltraps>

000000800420cd62 <XTRPX_IRQb>:
	TRAPHANDLER_NOEC(XTRPX_IRQb, IRQ_OFFSET+11)
  800420cd62:	6a 00                	pushq  $0x0
  800420cd64:	6a 2b                	pushq  $0x2b
  800420cd66:	eb 18                	jmp    800420cd80 <_alltraps>

000000800420cd68 <XTRPX_IRQc>:
	TRAPHANDLER_NOEC(XTRPX_IRQc, IRQ_OFFSET+12)
  800420cd68:	6a 00                	pushq  $0x0
  800420cd6a:	6a 2c                	pushq  $0x2c
  800420cd6c:	eb 12                	jmp    800420cd80 <_alltraps>

000000800420cd6e <XTRPX_IRQd>:
	TRAPHANDLER_NOEC(XTRPX_IRQd, IRQ_OFFSET+13)
  800420cd6e:	6a 00                	pushq  $0x0
  800420cd70:	6a 2d                	pushq  $0x2d
  800420cd72:	eb 0c                	jmp    800420cd80 <_alltraps>

000000800420cd74 <XTRPX_IRQe>:
	TRAPHANDLER_NOEC(XTRPX_IRQe, IRQ_OFFSET+IRQ_IDE)
  800420cd74:	6a 00                	pushq  $0x0
  800420cd76:	6a 2e                	pushq  $0x2e
  800420cd78:	eb 06                	jmp    800420cd80 <_alltraps>

000000800420cd7a <XTRPX_IRQf>:
	TRAPHANDLER_NOEC(XTRPX_IRQf, IRQ_OFFSET+15)
  800420cd7a:	6a 00                	pushq  $0x0
  800420cd7c:	6a 2f                	pushq  $0x2f
  800420cd7e:	eb 00                	jmp    800420cd80 <_alltraps>

000000800420cd80 <_alltraps>:
 * Hint: Be sure to review the x64 calling convention from lab1
 *       for how to pass a pointer to the trapframe.
 */
    _alltraps:
    	/* Since ES and DS registers can't be pushed in x86-64. So moving them to r15 first */
		xor %r15, %r15
  800420cd80:	4d 31 ff             	xor    %r15,%r15
		movw %ds,%r15 
  800420cd83:	66 41 8c df          	mov    %ds,%r15w
		pushq %r15
  800420cd87:	41 57                	push   %r15
		movw %es, %r15
  800420cd89:	66 41 8c c7          	mov    %es,%r15w
		pushq %r15
  800420cd8d:	41 57                	push   %r15
		/* Now push all registers onto the stack */
		PUSHA
  800420cd8f:	48 83 ec 78          	sub    $0x78,%rsp
  800420cd93:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420cd98:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420cd9d:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420cda2:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420cda7:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420cdac:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420cdb1:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420cdb6:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420cdbb:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420cdc0:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420cdc5:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420cdca:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420cdcf:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420cdd4:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420cdd9:	4c 89 3c 24          	mov    %r15,(%rsp)
		/* Far pointer addressing*/
		mov %rsp, %rdi
  800420cddd:	48 89 e7             	mov    %rsp,%rdi
		/* filling es and ds now */
		xor %r15, %r15
  800420cde0:	4d 31 ff             	xor    %r15,%r15
		movw $(GD_KD), %r15
  800420cde3:	66 41 c7 c7 10 00    	mov    $0x10,%r15w
		movw %r15, %es
  800420cde9:	41 8e c7             	mov    %r15d,%es
		movw %r15, %ds
  800420cdec:	41 8e df             	mov    %r15d,%ds
		call trap
  800420cdef:	e8 17 f7 ff ff       	callq  800420c50b <trap>
		POPA_
  800420cdf4:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420cdf8:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420cdfd:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800420ce02:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420ce07:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420ce0c:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800420ce11:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420ce16:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420ce1b:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420ce20:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420ce25:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420ce2a:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420ce2f:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420ce34:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420ce39:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420ce3e:	48 83 c4 78          	add    $0x78,%rsp
		/*Now make the stack same as we got from CPU*/
		xor %r15, %r15
  800420ce42:	4d 31 ff             	xor    %r15,%r15
		popq %r15
  800420ce45:	41 5f                	pop    %r15
		movw %r15, %es
  800420ce47:	41 8e c7             	mov    %r15d,%es
		popq %r15
  800420ce4a:	41 5f                	pop    %r15
		movw %r15, %ds
  800420ce4c:	41 8e df             	mov    %r15d,%ds
		iret 
  800420ce4f:	cf                   	iret   

000000800420ce50 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420ce50:	55                   	push   %rbp
  800420ce51:	48 89 e5             	mov    %rsp,%rbp
  800420ce54:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ce58:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ce5c:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420ce5f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ce63:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420ce66:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420ce6a:	f0 87 02             	lock xchg %eax,(%rdx)
  800420ce6d:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420ce70:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420ce73:	c9                   	leaveq 
  800420ce74:	c3                   	retq   

000000800420ce75 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420ce75:	55                   	push   %rbp
  800420ce76:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420ce79:	48 bf 80 c7 22 04 80 	movabs $0x800422c780,%rdi
  800420ce80:	00 00 00 
  800420ce83:	48 b8 b7 6b 21 04 80 	movabs $0x8004216bb7,%rax
  800420ce8a:	00 00 00 
  800420ce8d:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420ce8f:	f3 90                	pause  
}
  800420ce91:	5d                   	pop    %rbp
  800420ce92:	c3                   	retq   

000000800420ce93 <sched_yield>:
void sched_halt(void);

// Choose a user environment to run and run it.
void
sched_yield(void)
	{
  800420ce93:	55                   	push   %rbp
  800420ce94:	48 89 e5             	mov    %rsp,%rbp
  800420ce97:	48 83 ec 10          	sub    $0x10,%rsp
		// no runnable environments, simply drop through to the code
		// below to halt the cpu.	
	
		// LAB 4: Your code here.
		static uint32_t env_counter = 0;
		uint32_t i = 0;
  800420ce9b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		//cprintf("envcounter1 = [%d]\n",env_counter);
		for(i=1;i<= NENV;i++){
  800420cea2:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  800420cea9:	e9 a7 00 00 00       	jmpq   800420cf55 <sched_yield+0xc2>
			if(envs[(env_counter+i)%NENV].env_status == ENV_RUNNABLE){
  800420ceae:	48 b8 50 02 4a 04 80 	movabs $0x80044a0250,%rax
  800420ceb5:	00 00 00 
  800420ceb8:	48 8b 08             	mov    (%rax),%rcx
  800420cebb:	48 b8 10 13 4a 04 80 	movabs $0x80044a1310,%rax
  800420cec2:	00 00 00 
  800420cec5:	8b 10                	mov    (%rax),%edx
  800420cec7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ceca:	01 d0                	add    %edx,%eax
  800420cecc:	89 c0                	mov    %eax,%eax
  800420cece:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420ced3:	48 89 c2             	mov    %rax,%rdx
  800420ced6:	48 89 d0             	mov    %rdx,%rax
  800420ced9:	48 c1 e0 03          	shl    $0x3,%rax
  800420cedd:	48 01 d0             	add    %rdx,%rax
  800420cee0:	48 c1 e0 05          	shl    $0x5,%rax
  800420cee4:	48 01 c8             	add    %rcx,%rax
  800420cee7:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420ceed:	83 f8 02             	cmp    $0x2,%eax
  800420cef0:	75 5f                	jne    800420cf51 <sched_yield+0xbe>
				env_counter = (env_counter+i)%NENV;
  800420cef2:	48 b8 10 13 4a 04 80 	movabs $0x80044a1310,%rax
  800420cef9:	00 00 00 
  800420cefc:	8b 10                	mov    (%rax),%edx
  800420cefe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cf01:	01 d0                	add    %edx,%eax
  800420cf03:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420cf08:	89 c2                	mov    %eax,%edx
  800420cf0a:	48 b8 10 13 4a 04 80 	movabs $0x80044a1310,%rax
  800420cf11:	00 00 00 
  800420cf14:	89 10                	mov    %edx,(%rax)
				//cprintf("going to run now = [%d],status is [%d]\n",env_counter,envs[env_counter].env_status);
				env_run(&envs[env_counter]);
  800420cf16:	48 b8 50 02 4a 04 80 	movabs $0x80044a0250,%rax
  800420cf1d:	00 00 00 
  800420cf20:	48 8b 08             	mov    (%rax),%rcx
  800420cf23:	48 b8 10 13 4a 04 80 	movabs $0x80044a1310,%rax
  800420cf2a:	00 00 00 
  800420cf2d:	8b 00                	mov    (%rax),%eax
  800420cf2f:	89 c2                	mov    %eax,%edx
  800420cf31:	48 89 d0             	mov    %rdx,%rax
  800420cf34:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf38:	48 01 d0             	add    %rdx,%rax
  800420cf3b:	48 c1 e0 05          	shl    $0x5,%rax
  800420cf3f:	48 01 c8             	add    %rcx,%rax
  800420cf42:	48 89 c7             	mov    %rax,%rdi
  800420cf45:	48 b8 8e 87 20 04 80 	movabs $0x800420878e,%rax
  800420cf4c:	00 00 00 
  800420cf4f:	ff d0                	callq  *%rax
	
		// LAB 4: Your code here.
		static uint32_t env_counter = 0;
		uint32_t i = 0;
		//cprintf("envcounter1 = [%d]\n",env_counter);
		for(i=1;i<= NENV;i++){
  800420cf51:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420cf55:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420cf5c:	0f 86 4c ff ff ff    	jbe    800420ceae <sched_yield+0x1b>
				env_run(&envs[env_counter]);
				break;
			}
		}
		//cprintf("envcounter2 = [%d]\n",env_counter);
		if(curenv && curenv->env_status == ENV_RUNNING){
  800420cf62:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420cf69:	00 00 00 
  800420cf6c:	ff d0                	callq  *%rax
  800420cf6e:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420cf75:	00 00 00 
  800420cf78:	48 98                	cltq   
  800420cf7a:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf7e:	48 89 c2             	mov    %rax,%rdx
  800420cf81:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cf85:	48 29 c2             	sub    %rax,%rdx
  800420cf88:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cf8c:	48 83 c0 08          	add    $0x8,%rax
  800420cf90:	48 8b 00             	mov    (%rax),%rax
  800420cf93:	48 85 c0             	test   %rax,%rax
  800420cf96:	74 7c                	je     800420d014 <sched_yield+0x181>
  800420cf98:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420cf9f:	00 00 00 
  800420cfa2:	ff d0                	callq  *%rax
  800420cfa4:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420cfab:	00 00 00 
  800420cfae:	48 98                	cltq   
  800420cfb0:	48 c1 e0 03          	shl    $0x3,%rax
  800420cfb4:	48 89 c2             	mov    %rax,%rdx
  800420cfb7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cfbb:	48 29 c2             	sub    %rax,%rdx
  800420cfbe:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cfc2:	48 83 c0 08          	add    $0x8,%rax
  800420cfc6:	48 8b 00             	mov    (%rax),%rax
  800420cfc9:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420cfcf:	83 f8 03             	cmp    $0x3,%eax
  800420cfd2:	75 40                	jne    800420d014 <sched_yield+0x181>
			env_run(curenv);
  800420cfd4:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420cfdb:	00 00 00 
  800420cfde:	ff d0                	callq  *%rax
  800420cfe0:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420cfe7:	00 00 00 
  800420cfea:	48 98                	cltq   
  800420cfec:	48 c1 e0 03          	shl    $0x3,%rax
  800420cff0:	48 89 c2             	mov    %rax,%rdx
  800420cff3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cff7:	48 29 c2             	sub    %rax,%rdx
  800420cffa:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cffe:	48 83 c0 08          	add    $0x8,%rax
  800420d002:	48 8b 00             	mov    (%rax),%rax
  800420d005:	48 89 c7             	mov    %rax,%rdi
  800420d008:	48 b8 8e 87 20 04 80 	movabs $0x800420878e,%rax
  800420d00f:	00 00 00 
  800420d012:	ff d0                	callq  *%rax
			
		}else{
			sched_halt();	
  800420d014:	48 b8 22 d0 20 04 80 	movabs $0x800420d022,%rax
  800420d01b:	00 00 00 
  800420d01e:	ff d0                	callq  *%rax
		}
	}
  800420d020:	c9                   	leaveq 
  800420d021:	c3                   	retq   

000000800420d022 <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
	{
  800420d022:	55                   	push   %rbp
  800420d023:	48 89 e5             	mov    %rsp,%rbp
  800420d026:	48 83 ec 20          	sub    $0x20,%rsp
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
  800420d02a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420d031:	e9 91 00 00 00       	jmpq   800420d0c7 <sched_halt+0xa5>
			if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d036:	48 b8 50 02 4a 04 80 	movabs $0x80044a0250,%rax
  800420d03d:	00 00 00 
  800420d040:	48 8b 08             	mov    (%rax),%rcx
  800420d043:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d046:	48 63 d0             	movslq %eax,%rdx
  800420d049:	48 89 d0             	mov    %rdx,%rax
  800420d04c:	48 c1 e0 03          	shl    $0x3,%rax
  800420d050:	48 01 d0             	add    %rdx,%rax
  800420d053:	48 c1 e0 05          	shl    $0x5,%rax
  800420d057:	48 01 c8             	add    %rcx,%rax
  800420d05a:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d060:	83 f8 02             	cmp    $0x2,%eax
  800420d063:	74 6f                	je     800420d0d4 <sched_halt+0xb2>
				 envs[i].env_status == ENV_RUNNING ||
  800420d065:	48 b8 50 02 4a 04 80 	movabs $0x80044a0250,%rax
  800420d06c:	00 00 00 
  800420d06f:	48 8b 08             	mov    (%rax),%rcx
  800420d072:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d075:	48 63 d0             	movslq %eax,%rdx
  800420d078:	48 89 d0             	mov    %rdx,%rax
  800420d07b:	48 c1 e0 03          	shl    $0x3,%rax
  800420d07f:	48 01 d0             	add    %rdx,%rax
  800420d082:	48 c1 e0 05          	shl    $0x5,%rax
  800420d086:	48 01 c8             	add    %rcx,%rax
  800420d089:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
			if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d08f:	83 f8 03             	cmp    $0x3,%eax
  800420d092:	74 40                	je     800420d0d4 <sched_halt+0xb2>
				 envs[i].env_status == ENV_RUNNING ||
				 envs[i].env_status == ENV_DYING))
  800420d094:	48 b8 50 02 4a 04 80 	movabs $0x80044a0250,%rax
  800420d09b:	00 00 00 
  800420d09e:	48 8b 08             	mov    (%rax),%rcx
  800420d0a1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d0a4:	48 63 d0             	movslq %eax,%rdx
  800420d0a7:	48 89 d0             	mov    %rdx,%rax
  800420d0aa:	48 c1 e0 03          	shl    $0x3,%rax
  800420d0ae:	48 01 d0             	add    %rdx,%rax
  800420d0b1:	48 c1 e0 05          	shl    $0x5,%rax
  800420d0b5:	48 01 c8             	add    %rcx,%rax
  800420d0b8:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
			if ((envs[i].env_status == ENV_RUNNABLE ||
				 envs[i].env_status == ENV_RUNNING ||
  800420d0be:	83 f8 01             	cmp    $0x1,%eax
  800420d0c1:	74 11                	je     800420d0d4 <sched_halt+0xb2>
	{
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
  800420d0c3:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420d0c7:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420d0ce:	0f 8e 62 ff ff ff    	jle    800420d036 <sched_halt+0x14>
			if ((envs[i].env_status == ENV_RUNNABLE ||
				 envs[i].env_status == ENV_RUNNING ||
				 envs[i].env_status == ENV_DYING))
				break;
		}
		if (i == NENV) {
  800420d0d4:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420d0db:	75 2e                	jne    800420d10b <sched_halt+0xe9>
			cprintf("No runnable environments in the system!\n");
  800420d0dd:	48 bf c0 86 21 04 80 	movabs $0x80042186c0,%rdi
  800420d0e4:	00 00 00 
  800420d0e7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d0ec:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420d0f3:	00 00 00 
  800420d0f6:	ff d2                	callq  *%rdx
			while (1)
				monitor(NULL);
  800420d0f8:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d0fd:	48 b8 31 1b 20 04 80 	movabs $0x8004201b31,%rax
  800420d104:	00 00 00 
  800420d107:	ff d0                	callq  *%rax
  800420d109:	eb ed                	jmp    800420d0f8 <sched_halt+0xd6>
		}
	
		// Mark that no environment is running on this CPU
		curenv = NULL;
  800420d10b:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420d112:	00 00 00 
  800420d115:	ff d0                	callq  *%rax
  800420d117:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420d11e:	00 00 00 
  800420d121:	48 98                	cltq   
  800420d123:	48 c1 e0 03          	shl    $0x3,%rax
  800420d127:	48 89 c2             	mov    %rax,%rdx
  800420d12a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d12e:	48 29 c2             	sub    %rax,%rdx
  800420d131:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d135:	48 83 c0 08          	add    $0x8,%rax
  800420d139:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		lcr3(PADDR(boot_pml4e));
  800420d140:	48 b8 a8 17 4a 04 80 	movabs $0x80044a17a8,%rax
  800420d147:	00 00 00 
  800420d14a:	48 8b 00             	mov    (%rax),%rax
  800420d14d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420d151:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420d158:	00 00 00 
  800420d15b:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420d15f:	77 32                	ja     800420d193 <sched_halt+0x171>
  800420d161:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d165:	48 89 c1             	mov    %rax,%rcx
  800420d168:	48 ba f0 86 21 04 80 	movabs $0x80042186f0,%rdx
  800420d16f:	00 00 00 
  800420d172:	be 4e 00 00 00       	mov    $0x4e,%esi
  800420d177:	48 bf 14 87 21 04 80 	movabs $0x8004218714,%rdi
  800420d17e:	00 00 00 
  800420d181:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d186:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420d18d:	00 00 00 
  800420d190:	41 ff d0             	callq  *%r8
  800420d193:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420d19a:	ff ff ff 
  800420d19d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d1a1:	48 01 d0             	add    %rdx,%rax
  800420d1a4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420d1a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d1ac:	0f 22 d8             	mov    %rax,%cr3
	
		// Mark that this CPU is in the HALT state, so that when
		// timer interupts come in, we know we should re-acquire the
		// big kernel lock
		xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420d1af:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420d1b6:	00 00 00 
  800420d1b9:	ff d0                	callq  *%rax
  800420d1bb:	48 98                	cltq   
  800420d1bd:	48 c1 e0 03          	shl    $0x3,%rax
  800420d1c1:	48 89 c2             	mov    %rax,%rdx
  800420d1c4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d1c8:	48 29 c2             	sub    %rax,%rdx
  800420d1cb:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  800420d1d2:	00 00 00 
  800420d1d5:	48 01 d0             	add    %rdx,%rax
  800420d1d8:	48 83 c0 04          	add    $0x4,%rax
  800420d1dc:	be 02 00 00 00       	mov    $0x2,%esi
  800420d1e1:	48 89 c7             	mov    %rax,%rdi
  800420d1e4:	48 b8 50 ce 20 04 80 	movabs $0x800420ce50,%rax
  800420d1eb:	00 00 00 
  800420d1ee:	ff d0                	callq  *%rax
	
		// Release the big kernel lock as if we were "leaving" the kernel
		unlock_kernel();
  800420d1f0:	48 b8 75 ce 20 04 80 	movabs $0x800420ce75,%rax
  800420d1f7:	00 00 00 
  800420d1fa:	ff d0                	callq  *%rax
			"movq %0, %%rsp\n"
			"pushq $0\n"
			"pushq $0\n"
			"sti\n"
			"hlt\n"
			: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420d1fc:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420d203:	00 00 00 
  800420d206:	ff d0                	callq  *%rax
  800420d208:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420d20f:	00 00 00 
  800420d212:	48 98                	cltq   
  800420d214:	48 c1 e0 03          	shl    $0x3,%rax
  800420d218:	48 89 c2             	mov    %rax,%rdx
  800420d21b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d21f:	48 29 c2             	sub    %rax,%rdx
  800420d222:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d226:	48 83 c0 10          	add    $0x10,%rax
  800420d22a:	48 8b 40 04          	mov    0x4(%rax),%rax
	
		// Release the big kernel lock as if we were "leaving" the kernel
		unlock_kernel();
	
		// Reset stack pointer, enable interrupts and then halt.
		asm volatile (
  800420d22e:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420d235:	48 89 c4             	mov    %rax,%rsp
  800420d238:	6a 00                	pushq  $0x0
  800420d23a:	6a 00                	pushq  $0x0
  800420d23c:	fb                   	sti    
  800420d23d:	f4                   	hlt    
			"pushq $0\n"
			"pushq $0\n"
			"sti\n"
			"hlt\n"
			: : "a" (thiscpu->cpu_ts.ts_esp0));
	}
  800420d23e:	c9                   	leaveq 
  800420d23f:	c3                   	retq   

000000800420d240 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420d240:	55                   	push   %rbp
  800420d241:	48 89 e5             	mov    %rsp,%rbp
  800420d244:	48 83 ec 10          	sub    $0x10,%rsp
  800420d248:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420d24c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, (const void *)s, len, PTE_U );
  800420d250:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420d257:	00 00 00 
  800420d25a:	ff d0                	callq  *%rax
  800420d25c:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420d263:	00 00 00 
  800420d266:	48 98                	cltq   
  800420d268:	48 c1 e0 03          	shl    $0x3,%rax
  800420d26c:	48 89 c2             	mov    %rax,%rdx
  800420d26f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d273:	48 29 c2             	sub    %rax,%rdx
  800420d276:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d27a:	48 83 c0 08          	add    $0x8,%rax
  800420d27e:	48 8b 00             	mov    (%rax),%rax
  800420d281:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d285:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420d289:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420d28e:	48 89 c7             	mov    %rax,%rdi
  800420d291:	48 b8 3e 3d 20 04 80 	movabs $0x8004203d3e,%rax
  800420d298:	00 00 00 
  800420d29b:	ff d0                	callq  *%rax
	
	// Print the string supplied by the user.
	
	cprintf("%.*s", len, s);
  800420d29d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d2a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d2a5:	48 89 c6             	mov    %rax,%rsi
  800420d2a8:	48 bf 28 87 21 04 80 	movabs $0x8004218728,%rdi
  800420d2af:	00 00 00 
  800420d2b2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d2b7:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  800420d2be:	00 00 00 
  800420d2c1:	ff d1                	callq  *%rcx
}
  800420d2c3:	c9                   	leaveq 
  800420d2c4:	c3                   	retq   

000000800420d2c5 <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420d2c5:	55                   	push   %rbp
  800420d2c6:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420d2c9:	48 b8 03 11 20 04 80 	movabs $0x8004201103,%rax
  800420d2d0:	00 00 00 
  800420d2d3:	ff d0                	callq  *%rax
}
  800420d2d5:	5d                   	pop    %rbp
  800420d2d6:	c3                   	retq   

000000800420d2d7 <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420d2d7:	55                   	push   %rbp
  800420d2d8:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420d2db:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420d2e2:	00 00 00 
  800420d2e5:	ff d0                	callq  *%rax
  800420d2e7:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420d2ee:	00 00 00 
  800420d2f1:	48 98                	cltq   
  800420d2f3:	48 c1 e0 03          	shl    $0x3,%rax
  800420d2f7:	48 89 c2             	mov    %rax,%rdx
  800420d2fa:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d2fe:	48 29 c2             	sub    %rax,%rdx
  800420d301:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d305:	48 83 c0 08          	add    $0x8,%rax
  800420d309:	48 8b 00             	mov    (%rax),%rax
  800420d30c:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420d312:	5d                   	pop    %rbp
  800420d313:	c3                   	retq   

000000800420d314 <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420d314:	55                   	push   %rbp
  800420d315:	48 89 e5             	mov    %rsp,%rbp
  800420d318:	48 83 ec 20          	sub    $0x20,%rsp
  800420d31c:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420d31f:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d323:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d326:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d32b:	48 89 ce             	mov    %rcx,%rsi
  800420d32e:	89 c7                	mov    %eax,%edi
  800420d330:	48 b8 64 78 20 04 80 	movabs $0x8004207864,%rax
  800420d337:	00 00 00 
  800420d33a:	ff d0                	callq  *%rax
  800420d33c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420d33f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d343:	79 05                	jns    800420d34a <sys_env_destroy+0x36>
		return r;
  800420d345:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d348:	eb 18                	jmp    800420d362 <sys_env_destroy+0x4e>
	env_destroy(e);
  800420d34a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d34e:	48 89 c7             	mov    %rax,%rdi
  800420d351:	48 b8 bf 85 20 04 80 	movabs $0x80042085bf,%rax
  800420d358:	00 00 00 
  800420d35b:	ff d0                	callq  *%rax
	return 0;
  800420d35d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d362:	c9                   	leaveq 
  800420d363:	c3                   	retq   

000000800420d364 <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420d364:	55                   	push   %rbp
  800420d365:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420d368:	48 b8 93 ce 20 04 80 	movabs $0x800420ce93,%rax
  800420d36f:	00 00 00 
  800420d372:	ff d0                	callq  *%rax

000000800420d374 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420d374:	55                   	push   %rbp
  800420d375:	48 89 e5             	mov    %rsp,%rbp
  800420d378:	53                   	push   %rbx
  800420d379:	48 83 ec 18          	sub    $0x18,%rsp
	// from the current environment -- but tweaked so sys_exofork
	// will appear to return 0.

	// LAB 4: Your code here.
	struct Env *newenv_store;
	uint32_t  result = 0;
  800420d37d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	result= env_alloc(&newenv_store, curenv->env_id);
  800420d384:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420d38b:	00 00 00 
  800420d38e:	ff d0                	callq  *%rax
  800420d390:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420d397:	00 00 00 
  800420d39a:	48 98                	cltq   
  800420d39c:	48 c1 e0 03          	shl    $0x3,%rax
  800420d3a0:	48 89 c2             	mov    %rax,%rdx
  800420d3a3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d3a7:	48 29 c2             	sub    %rax,%rdx
  800420d3aa:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d3ae:	48 83 c0 08          	add    $0x8,%rax
  800420d3b2:	48 8b 00             	mov    (%rax),%rax
  800420d3b5:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420d3bb:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420d3bf:	89 d6                	mov    %edx,%esi
  800420d3c1:	48 89 c7             	mov    %rax,%rdi
  800420d3c4:	48 b8 00 7c 20 04 80 	movabs $0x8004207c00,%rax
  800420d3cb:	00 00 00 
  800420d3ce:	ff d0                	callq  *%rax
  800420d3d0:	89 45 ec             	mov    %eax,-0x14(%rbp)

	if(result != 0)
  800420d3d3:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420d3d7:	74 05                	je     800420d3de <sys_exofork+0x6a>
		return result;
  800420d3d9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d3dc:	eb 6d                	jmp    800420d44b <sys_exofork+0xd7>
	//cprintf("curenv->env_id [%d], newenv_store->env_parent_id [%d],  newenv_store->env_id [%d]\n",curenv->env_id, newenv_store->env_parent_id,newenv_store->env_id);

	newenv_store->env_status = ENV_NOT_RUNNABLE;
  800420d3de:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d3e2:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420d3e9:	00 00 00 
	newenv_store->env_tf = curenv->env_tf;
  800420d3ec:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420d3f0:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420d3f7:	00 00 00 
  800420d3fa:	ff d0                	callq  *%rax
  800420d3fc:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420d403:	00 00 00 
  800420d406:	48 98                	cltq   
  800420d408:	48 c1 e0 03          	shl    $0x3,%rax
  800420d40c:	48 89 c2             	mov    %rax,%rdx
  800420d40f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d413:	48 29 c2             	sub    %rax,%rdx
  800420d416:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d41a:	48 83 c0 08          	add    $0x8,%rax
  800420d41e:	48 8b 00             	mov    (%rax),%rax
  800420d421:	48 89 da             	mov    %rbx,%rdx
  800420d424:	48 89 c6             	mov    %rax,%rsi
  800420d427:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d42c:	48 89 d7             	mov    %rdx,%rdi
  800420d42f:	48 89 c1             	mov    %rax,%rcx
  800420d432:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	newenv_store->env_tf.tf_regs.reg_rax = 0x00;
  800420d435:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d439:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420d440:	00 
	return newenv_store->env_id;
  800420d441:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d445:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax

	//panic("sys_exofork not implemented");
}
  800420d44b:	48 83 c4 18          	add    $0x18,%rsp
  800420d44f:	5b                   	pop    %rbx
  800420d450:	5d                   	pop    %rbp
  800420d451:	c3                   	retq   

000000800420d452 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420d452:	55                   	push   %rbp
  800420d453:	48 89 e5             	mov    %rsp,%rbp
  800420d456:	48 83 ec 20          	sub    $0x20,%rsp
  800420d45a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d45d:	89 75 e8             	mov    %esi,-0x18(%rbp)
	// You should set envid2env's third argument to 1, which will
	// check whether the current environment has permission to set
	// envid's status.

	// LAB 4: Your code here.
	uint32_t  result =0;
  800420d460:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	result = envid2env(envid,&env_store,1);
  800420d467:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d46b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d46e:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d473:	48 89 ce             	mov    %rcx,%rsi
  800420d476:	89 c7                	mov    %eax,%edi
  800420d478:	48 b8 64 78 20 04 80 	movabs $0x8004207864,%rax
  800420d47f:	00 00 00 
  800420d482:	ff d0                	callq  *%rax
  800420d484:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420d487:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d48b:	74 05                	je     800420d492 <sys_env_set_status+0x40>
		return result;
  800420d48d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d490:	eb 23                	jmp    800420d4b5 <sys_env_set_status+0x63>
	if(status< 0 || status >4)
  800420d492:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800420d496:	78 06                	js     800420d49e <sys_env_set_status+0x4c>
  800420d498:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420d49c:	7e 07                	jle    800420d4a5 <sys_env_set_status+0x53>
		return -E_INVAL;
  800420d49e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d4a3:	eb 10                	jmp    800420d4b5 <sys_env_set_status+0x63>
	
	env_store->env_status = status;
  800420d4a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d4a9:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420d4ac:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return result;
  800420d4b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_env_set_status not implemented");
}
  800420d4b5:	c9                   	leaveq 
  800420d4b6:	c3                   	retq   

000000800420d4b7 <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
	{
  800420d4b7:	55                   	push   %rbp
  800420d4b8:	48 89 e5             	mov    %rsp,%rbp
  800420d4bb:	48 83 ec 20          	sub    $0x20,%rsp
  800420d4bf:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d4c2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
		// LAB 5: Your code here.
		// Remember to check whether the user has supplied us with a good
		// address!
		//panic("sys_env_set_trapframe not implemented");
		uint32_t  result = 0;
  800420d4c6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		struct Env *env_store;
		if(!tf)
  800420d4cd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420d4d2:	75 07                	jne    800420d4db <sys_env_set_trapframe+0x24>
			return -E_BAD_ENV;
  800420d4d4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d4d9:	eb 73                	jmp    800420d54e <sys_env_set_trapframe+0x97>
		result = envid2env(envid,&env_store,1);
  800420d4db:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d4df:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d4e2:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d4e7:	48 89 ce             	mov    %rcx,%rsi
  800420d4ea:	89 c7                	mov    %eax,%edi
  800420d4ec:	48 b8 64 78 20 04 80 	movabs $0x8004207864,%rax
  800420d4f3:	00 00 00 
  800420d4f6:	ff d0                	callq  *%rax
  800420d4f8:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(result < 0)
			return result;
		//user_mem_assert(env_store, tf, sizeof(struct Trapframe), PTE_U|PTE_P);
		tf->tf_cs |= 0x3;
  800420d4fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d4ff:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420d506:	83 c8 03             	or     $0x3,%eax
  800420d509:	89 c2                	mov    %eax,%edx
  800420d50b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d50f:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
		tf->tf_eflags |= FL_IF;
  800420d516:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d51a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420d521:	80 cc 02             	or     $0x2,%ah
  800420d524:	48 89 c2             	mov    %rax,%rdx
  800420d527:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d52b:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
		env_store->env_tf = *tf;
  800420d532:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d536:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d53a:	48 89 c6             	mov    %rax,%rsi
  800420d53d:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d542:	48 89 d7             	mov    %rdx,%rdi
  800420d545:	48 89 c1             	mov    %rax,%rcx
  800420d548:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		return result;
  800420d54b:	8b 45 fc             	mov    -0x4(%rbp),%eax
	}
  800420d54e:	c9                   	leaveq 
  800420d54f:	c3                   	retq   

000000800420d550 <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420d550:	55                   	push   %rbp
  800420d551:	48 89 e5             	mov    %rsp,%rbp
  800420d554:	48 83 ec 20          	sub    $0x20,%rsp
  800420d558:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d55b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 4: Your code here.
	
	uint32_t  result =0;
  800420d55f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	result = envid2env(envid,&env_store,1);
  800420d566:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d56a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d56d:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d572:	48 89 ce             	mov    %rcx,%rsi
  800420d575:	89 c7                	mov    %eax,%edi
  800420d577:	48 b8 64 78 20 04 80 	movabs $0x8004207864,%rax
  800420d57e:	00 00 00 
  800420d581:	ff d0                	callq  *%rax
  800420d583:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420d586:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d58a:	74 05                	je     800420d591 <sys_env_set_pgfault_upcall+0x41>
		return result;
  800420d58c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d58f:	eb 14                	jmp    800420d5a5 <sys_env_set_pgfault_upcall+0x55>

	env_store->env_pgfault_upcall = func;
  800420d591:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d595:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d599:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420d5a0:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_env_set_pgfault_upcall not implemented");
}
  800420d5a5:	c9                   	leaveq 
  800420d5a6:	c3                   	retq   

000000800420d5a7 <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420d5a7:	55                   	push   %rbp
  800420d5a8:	48 89 e5             	mov    %rsp,%rbp
  800420d5ab:	48 83 ec 30          	sub    $0x30,%rsp
  800420d5af:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420d5b2:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420d5b6:	89 55 d8             	mov    %edx,-0x28(%rbp)
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	// LAB 4: Your code here.
	uint32_t  result =0;
  800420d5b9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	struct PageInfo * pp;
	pte_t *pte_store;
	//cprintf("sys page alloc [%d]",result);
	result = envid2env(envid,&env_store,1);
  800420d5c0:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420d5c4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420d5c7:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d5cc:	48 89 ce             	mov    %rcx,%rsi
  800420d5cf:	89 c7                	mov    %eax,%edi
  800420d5d1:	48 b8 64 78 20 04 80 	movabs $0x8004207864,%rax
  800420d5d8:	00 00 00 
  800420d5db:	ff d0                	callq  *%rax
  800420d5dd:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420d5e0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d5e4:	74 08                	je     800420d5ee <sys_page_alloc+0x47>
		return result;
  800420d5e6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d5e9:	e9 a2 00 00 00       	jmpq   800420d690 <sys_page_alloc+0xe9>

	if(!(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL))
  800420d5ee:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d5f1:	83 e0 04             	and    $0x4,%eax
  800420d5f4:	85 c0                	test   %eax,%eax
  800420d5f6:	74 16                	je     800420d60e <sys_page_alloc+0x67>
  800420d5f8:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d5fb:	83 e0 01             	and    $0x1,%eax
  800420d5fe:	85 c0                	test   %eax,%eax
  800420d600:	74 0c                	je     800420d60e <sys_page_alloc+0x67>
  800420d602:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d605:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420d60a:	85 c0                	test   %eax,%eax
  800420d60c:	74 07                	je     800420d615 <sys_page_alloc+0x6e>
		return -E_INVAL;
  800420d60e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d613:	eb 7b                	jmp    800420d690 <sys_page_alloc+0xe9>

	if(((uint64_t)va%PGSIZE !=0) ||((uint64_t)va> UTOP))
  800420d615:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d619:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d61e:	48 85 c0             	test   %rax,%rax
  800420d621:	75 13                	jne    800420d636 <sys_page_alloc+0x8f>
  800420d623:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420d627:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420d62e:	00 00 00 
  800420d631:	48 39 c2             	cmp    %rax,%rdx
  800420d634:	76 07                	jbe    800420d63d <sys_page_alloc+0x96>
		return -E_INVAL;
  800420d636:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d63b:	eb 53                	jmp    800420d690 <sys_page_alloc+0xe9>
	
    pp = page_alloc(0);
  800420d63d:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d642:	48 b8 39 2f 20 04 80 	movabs $0x8004202f39,%rax
  800420d649:	00 00 00 
  800420d64c:	ff d0                	callq  *%rax
  800420d64e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(!pp)
  800420d652:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d657:	75 07                	jne    800420d660 <sys_page_alloc+0xb9>
		return -E_NO_MEM;
  800420d659:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420d65e:	eb 30                	jmp    800420d690 <sys_page_alloc+0xe9>
	

	result = page_insert(env_store->env_pml4e,pp,va,perm|PTE_P);
  800420d660:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d663:	83 c8 01             	or     $0x1,%eax
  800420d666:	89 c1                	mov    %eax,%ecx
  800420d668:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d66c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d673:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420d677:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420d67b:	48 89 c7             	mov    %rax,%rdi
  800420d67e:	48 b8 c5 37 20 04 80 	movabs $0x80042037c5,%rax
  800420d685:	00 00 00 
  800420d688:	ff d0                	callq  *%rax
  800420d68a:	89 45 fc             	mov    %eax,-0x4(%rbp)
	//cprintf("sys page alloc [%d]",result);
	return result;
  800420d68d:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_page_alloc not implemented");
}
  800420d690:	c9                   	leaveq 
  800420d691:	c3                   	retq   

000000800420d692 <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420d692:	55                   	push   %rbp
  800420d693:	48 89 e5             	mov    %rsp,%rbp
  800420d696:	48 83 ec 50          	sub    $0x50,%rsp
  800420d69a:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420d69d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420d6a1:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420d6a4:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420d6a8:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
	//   check the current permissions on the page.

	// LAB 4: Your code here.

	
	uint32_t  result =0;
  800420d6ac:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store_src;
	struct Env *env_store_dst;
	struct PageInfo * pp;
	pte_t *pte_store;
	result = envid2env(srcenvid,&env_store_src,1);
  800420d6b3:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420d6b7:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420d6ba:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d6bf:	48 89 ce             	mov    %rcx,%rsi
  800420d6c2:	89 c7                	mov    %eax,%edi
  800420d6c4:	48 b8 64 78 20 04 80 	movabs $0x8004207864,%rax
  800420d6cb:	00 00 00 
  800420d6ce:	ff d0                	callq  *%rax
  800420d6d0:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0){
  800420d6d3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d6d7:	74 08                	je     800420d6e1 <sys_page_map+0x4f>
		//cprintf("need 1stcheckperm to be 0\n");
		return result;
  800420d6d9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d6dc:	e9 1c 01 00 00       	jmpq   800420d7fd <sys_page_map+0x16b>
	}
	result = envid2env(dstenvid,&env_store_dst,0);
  800420d6e1:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420d6e5:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420d6e8:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d6ed:	48 89 ce             	mov    %rcx,%rsi
  800420d6f0:	89 c7                	mov    %eax,%edi
  800420d6f2:	48 b8 64 78 20 04 80 	movabs $0x8004207864,%rax
  800420d6f9:	00 00 00 
  800420d6fc:	ff d0                	callq  *%rax
  800420d6fe:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result != 0){
  800420d701:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d705:	74 08                	je     800420d70f <sys_page_map+0x7d>
		//cprintf("need 2ndcheckperm to be 0\n");
		return result;
  800420d707:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d70a:	e9 ee 00 00 00       	jmpq   800420d7fd <sys_page_map+0x16b>
	}

	if(!(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL))
  800420d70f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d712:	83 e0 04             	and    $0x4,%eax
  800420d715:	85 c0                	test   %eax,%eax
  800420d717:	74 16                	je     800420d72f <sys_page_map+0x9d>
  800420d719:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d71c:	83 e0 01             	and    $0x1,%eax
  800420d71f:	85 c0                	test   %eax,%eax
  800420d721:	74 0c                	je     800420d72f <sys_page_map+0x9d>
  800420d723:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d726:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420d72b:	85 c0                	test   %eax,%eax
  800420d72d:	74 0a                	je     800420d739 <sys_page_map+0xa7>
		return -E_INVAL;
  800420d72f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d734:	e9 c4 00 00 00       	jmpq   800420d7fd <sys_page_map+0x16b>

	
	if(((uint64_t)dstva%PGSIZE !=0 || (uint64_t)dstva> UTOP)||((uint64_t)srcva%PGSIZE !=0 || (uint64_t)srcva> UTOP))
  800420d739:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420d73d:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d742:	48 85 c0             	test   %rax,%rax
  800420d745:	75 34                	jne    800420d77b <sys_page_map+0xe9>
  800420d747:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420d74b:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420d752:	00 00 00 
  800420d755:	48 39 c2             	cmp    %rax,%rdx
  800420d758:	77 21                	ja     800420d77b <sys_page_map+0xe9>
  800420d75a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420d75e:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d763:	48 85 c0             	test   %rax,%rax
  800420d766:	75 13                	jne    800420d77b <sys_page_map+0xe9>
  800420d768:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420d76c:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420d773:	00 00 00 
  800420d776:	48 39 c2             	cmp    %rax,%rdx
  800420d779:	76 07                	jbe    800420d782 <sys_page_map+0xf0>
		return -E_INVAL;
  800420d77b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d780:	eb 7b                	jmp    800420d7fd <sys_page_map+0x16b>
	pp = page_lookup(env_store_src->env_pml4e, srcva, &pte_store);
  800420d782:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d786:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d78d:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800420d791:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420d795:	48 89 ce             	mov    %rcx,%rsi
  800420d798:	48 89 c7             	mov    %rax,%rdi
  800420d79b:	48 b8 22 39 20 04 80 	movabs $0x8004203922,%rax
  800420d7a2:	00 00 00 
  800420d7a5:	ff d0                	callq  *%rax
  800420d7a7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(NULL == pp || (((*(pte_store) & PTE_W) == 0) && ((perm & PTE_W) != 0)))
  800420d7ab:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d7b0:	74 19                	je     800420d7cb <sys_page_map+0x139>
  800420d7b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d7b6:	48 8b 00             	mov    (%rax),%rax
  800420d7b9:	83 e0 02             	and    $0x2,%eax
  800420d7bc:	48 85 c0             	test   %rax,%rax
  800420d7bf:	75 11                	jne    800420d7d2 <sys_page_map+0x140>
  800420d7c1:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d7c4:	83 e0 02             	and    $0x2,%eax
  800420d7c7:	85 c0                	test   %eax,%eax
  800420d7c9:	74 07                	je     800420d7d2 <sys_page_map+0x140>
		return -E_INVAL;	
  800420d7cb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d7d0:	eb 2b                	jmp    800420d7fd <sys_page_map+0x16b>

	
	result = page_insert(env_store_dst->env_pml4e,pp,dstva,perm);
  800420d7d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d7d6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d7dd:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420d7e0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420d7e4:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420d7e8:	48 89 c7             	mov    %rax,%rdi
  800420d7eb:	48 b8 c5 37 20 04 80 	movabs $0x80042037c5,%rax
  800420d7f2:	00 00 00 
  800420d7f5:	ff d0                	callq  *%rax
  800420d7f7:	89 45 fc             	mov    %eax,-0x4(%rbp)
	
	return result;
  800420d7fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_page_map not implemented");
}
  800420d7fd:	c9                   	leaveq 
  800420d7fe:	c3                   	retq   

000000800420d7ff <sys_page_unmap>:
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.

static int
sys_page_unmap(envid_t envid, void *va)
{
  800420d7ff:	55                   	push   %rbp
  800420d800:	48 89 e5             	mov    %rsp,%rbp
  800420d803:	48 83 ec 20          	sub    $0x20,%rsp
  800420d807:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d80a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Hint: This function is a wrapper around page_remove().
	
	// LAB 4: Your code here.
	struct Env* env;
	if(envid2env(envid, &env,1) != 0)
  800420d80e:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  800420d812:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d815:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d81a:	48 89 ce             	mov    %rcx,%rsi
  800420d81d:	89 c7                	mov    %eax,%edi
  800420d81f:	48 b8 64 78 20 04 80 	movabs $0x8004207864,%rax
  800420d826:	00 00 00 
  800420d829:	ff d0                	callq  *%rax
  800420d82b:	85 c0                	test   %eax,%eax
  800420d82d:	74 07                	je     800420d836 <sys_page_unmap+0x37>
	{
		return -E_BAD_ENV;
  800420d82f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d834:	eb 55                	jmp    800420d88b <sys_page_unmap+0x8c>
	}
	if(va == NULL || (uint64_t)va >= UTOP || (uint64_t)va  % PGSIZE != 0)
  800420d836:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420d83b:	74 21                	je     800420d85e <sys_page_unmap+0x5f>
  800420d83d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d841:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d848:	00 00 00 
  800420d84b:	48 39 c2             	cmp    %rax,%rdx
  800420d84e:	77 0e                	ja     800420d85e <sys_page_unmap+0x5f>
  800420d850:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d854:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d859:	48 85 c0             	test   %rax,%rax
  800420d85c:	74 07                	je     800420d865 <sys_page_unmap+0x66>
	{
		return -E_INVAL;
  800420d85e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d863:	eb 26                	jmp    800420d88b <sys_page_unmap+0x8c>
	}
	page_remove(env->env_pml4e, va);
  800420d865:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d869:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d870:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d874:	48 89 d6             	mov    %rdx,%rsi
  800420d877:	48 89 c7             	mov    %rax,%rdi
  800420d87a:	48 b8 bc 39 20 04 80 	movabs $0x80042039bc,%rax
  800420d881:	00 00 00 
  800420d884:	ff d0                	callq  *%rax
	return 0;
  800420d886:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_page_unmap not implemented");
}
  800420d88b:	c9                   	leaveq 
  800420d88c:	c3                   	retq   

000000800420d88d <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420d88d:	55                   	push   %rbp
  800420d88e:	48 89 e5             	mov    %rsp,%rbp
  800420d891:	48 83 ec 40          	sub    $0x40,%rsp
  800420d895:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420d898:	89 75 d8             	mov    %esi,-0x28(%rbp)
  800420d89b:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420d89f:	89 4d cc             	mov    %ecx,-0x34(%rbp)
	// LAB 4: Your code here.
	struct Env* dstenv;
	struct Env* srcenv;
	pte_t* pte_store;
	int srcperm;
	perm|= PTE_P;
  800420d8a2:	83 4d cc 01          	orl    $0x1,-0x34(%rbp)
	if(envid2env(envid, &dstenv,0) != 0)
  800420d8a6:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d8aa:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420d8ad:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d8b2:	48 89 ce             	mov    %rcx,%rsi
  800420d8b5:	89 c7                	mov    %eax,%edi
  800420d8b7:	48 b8 64 78 20 04 80 	movabs $0x8004207864,%rax
  800420d8be:	00 00 00 
  800420d8c1:	ff d0                	callq  *%rax
  800420d8c3:	85 c0                	test   %eax,%eax
  800420d8c5:	74 0a                	je     800420d8d1 <sys_ipc_try_send+0x44>
		return -E_BAD_ENV;
  800420d8c7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d8cc:	e9 19 02 00 00       	jmpq   800420daea <sys_ipc_try_send+0x25d>

	if(envid2env(0, &srcenv,0) != 0)
  800420d8d1:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420d8d5:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d8da:	48 89 c6             	mov    %rax,%rsi
  800420d8dd:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d8e2:	48 b8 64 78 20 04 80 	movabs $0x8004207864,%rax
  800420d8e9:	00 00 00 
  800420d8ec:	ff d0                	callq  *%rax
  800420d8ee:	85 c0                	test   %eax,%eax
  800420d8f0:	74 0a                	je     800420d8fc <sys_ipc_try_send+0x6f>
		return -E_BAD_ENV;
  800420d8f2:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d8f7:	e9 ee 01 00 00       	jmpq   800420daea <sys_ipc_try_send+0x25d>
	
	if(!dstenv->env_ipc_recving)
  800420d8fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d900:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420d907:	83 f0 01             	xor    $0x1,%eax
  800420d90a:	84 c0                	test   %al,%al
  800420d90c:	74 0a                	je     800420d918 <sys_ipc_try_send+0x8b>
		return -E_IPC_NOT_RECV;
  800420d90e:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420d913:	e9 d2 01 00 00       	jmpq   800420daea <sys_ipc_try_send+0x25d>

	if(!page_lookup(srcenv->env_pml4e,srcva,&pte_store))
  800420d918:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d91c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d923:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  800420d927:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420d92b:	48 89 ce             	mov    %rcx,%rsi
  800420d92e:	48 89 c7             	mov    %rax,%rdi
  800420d931:	48 b8 22 39 20 04 80 	movabs $0x8004203922,%rax
  800420d938:	00 00 00 
  800420d93b:	ff d0                	callq  *%rax
  800420d93d:	48 85 c0             	test   %rax,%rax
  800420d940:	75 1a                	jne    800420d95c <sys_ipc_try_send+0xcf>
		if(srcva <(void*)UTOP)
  800420d942:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d949:	00 00 00 
  800420d94c:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420d950:	77 0a                	ja     800420d95c <sys_ipc_try_send+0xcf>
			return -E_INVAL;
  800420d952:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d957:	e9 8e 01 00 00       	jmpq   800420daea <sys_ipc_try_send+0x25d>
	srcperm = *pte_store&PTE_SYSCALL;
  800420d95c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d960:	48 8b 00             	mov    (%rax),%rax
  800420d963:	25 07 0e 00 00       	and    $0xe07,%eax
  800420d968:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(srcva <(void*)UTOP)
  800420d96b:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d972:	00 00 00 
  800420d975:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420d979:	77 23                	ja     800420d99e <sys_ipc_try_send+0x111>
		if((((uint64_t)srcva)%PGSIZE!=0) || ((srcperm & (PTE_U | PTE_P))!=(PTE_U | PTE_P)))
  800420d97b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d97f:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d984:	48 85 c0             	test   %rax,%rax
  800420d987:	75 0b                	jne    800420d994 <sys_ipc_try_send+0x107>
  800420d989:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d98c:	83 e0 05             	and    $0x5,%eax
  800420d98f:	83 f8 05             	cmp    $0x5,%eax
  800420d992:	74 0a                	je     800420d99e <sys_ipc_try_send+0x111>
			return -E_INVAL;
  800420d994:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d999:	e9 4c 01 00 00       	jmpq   800420daea <sys_ipc_try_send+0x25d>
	if((srcva <(void*)UTOP) && ((perm & PTE_W) !=0) &&(((srcperm& PTE_W) == 0)))
  800420d99e:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d9a5:	00 00 00 
  800420d9a8:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420d9ac:	77 1e                	ja     800420d9cc <sys_ipc_try_send+0x13f>
  800420d9ae:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420d9b1:	83 e0 02             	and    $0x2,%eax
  800420d9b4:	85 c0                	test   %eax,%eax
  800420d9b6:	74 14                	je     800420d9cc <sys_ipc_try_send+0x13f>
  800420d9b8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d9bb:	83 e0 02             	and    $0x2,%eax
  800420d9be:	85 c0                	test   %eax,%eax
  800420d9c0:	75 0a                	jne    800420d9cc <sys_ipc_try_send+0x13f>
		return -E_INVAL;
  800420d9c2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d9c7:	e9 1e 01 00 00       	jmpq   800420daea <sys_ipc_try_send+0x25d>

	if(envid == curenv->env_id)
  800420d9cc:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420d9d3:	00 00 00 
  800420d9d6:	ff d0                	callq  *%rax
  800420d9d8:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420d9df:	00 00 00 
  800420d9e2:	48 98                	cltq   
  800420d9e4:	48 c1 e0 03          	shl    $0x3,%rax
  800420d9e8:	48 89 c2             	mov    %rax,%rdx
  800420d9eb:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d9ef:	48 29 c2             	sub    %rax,%rdx
  800420d9f2:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d9f6:	48 83 c0 08          	add    $0x8,%rax
  800420d9fa:	48 8b 00             	mov    (%rax),%rax
  800420d9fd:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420da03:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  800420da06:	75 2a                	jne    800420da32 <sys_ipc_try_send+0x1a5>
		panic("what the hell. how can this be????");
  800420da08:	48 ba 30 87 21 04 80 	movabs $0x8004218730,%rdx
  800420da0f:	00 00 00 
  800420da12:	be 90 01 00 00       	mov    $0x190,%esi
  800420da17:	48 bf 53 87 21 04 80 	movabs $0x8004218753,%rdi
  800420da1e:	00 00 00 
  800420da21:	b8 00 00 00 00       	mov    $0x0,%eax
  800420da26:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  800420da2d:	00 00 00 
  800420da30:	ff d1                	callq  *%rcx

	dstenv->env_ipc_recving = 0;
  800420da32:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da36:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
	dstenv->env_ipc_from = srcenv->env_id;
  800420da3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da41:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da45:	8b 92 c8 00 00 00    	mov    0xc8(%rdx),%edx
  800420da4b:	89 90 0c 01 00 00    	mov    %edx,0x10c(%rax)
	dstenv->env_ipc_value = value;
  800420da51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da55:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420da58:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
	//cprintf("dstenv -> envID is:[%d]\n",dstenv->env_id);
	if(srcva <(void*)UTOP && dstenv->env_ipc_dstva <(void*)UTOP){
  800420da5e:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420da65:	00 00 00 
  800420da68:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420da6c:	77 69                	ja     800420dad7 <sys_ipc_try_send+0x24a>
  800420da6e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da72:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420da79:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420da80:	00 00 00 
  800420da83:	48 39 c2             	cmp    %rax,%rdx
  800420da86:	77 4f                	ja     800420dad7 <sys_ipc_try_send+0x24a>
		dstenv->env_ipc_perm = perm;
  800420da88:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da8c:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420da8f:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
		if(0< sys_page_map(srcenv->env_id,srcva,dstenv->env_id,dstenv->env_ipc_dstva,perm))
  800420da95:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420da98:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da9c:	48 8b 88 00 01 00 00 	mov    0x100(%rax),%rcx
  800420daa3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420daa7:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420daad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dab1:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420dab7:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420dabb:	41 89 f8             	mov    %edi,%r8d
  800420dabe:	89 c7                	mov    %eax,%edi
  800420dac0:	48 b8 92 d6 20 04 80 	movabs $0x800420d692,%rax
  800420dac7:	00 00 00 
  800420daca:	ff d0                	callq  *%rax
  800420dacc:	85 c0                	test   %eax,%eax
  800420dace:	7e 07                	jle    800420dad7 <sys_ipc_try_send+0x24a>
			return -E_NO_MEM;
  800420dad0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420dad5:	eb 13                	jmp    800420daea <sys_ipc_try_send+0x25d>
	}
	dstenv->env_status = ENV_RUNNABLE;
  800420dad7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dadb:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420dae2:	00 00 00 
	return 0;
  800420dae5:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_ipc_try_send not implemented");
}
  800420daea:	c9                   	leaveq 
  800420daeb:	c3                   	retq   

000000800420daec <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420daec:	55                   	push   %rbp
  800420daed:	48 89 e5             	mov    %rsp,%rbp
  800420daf0:	48 83 ec 20          	sub    $0x20,%rsp
  800420daf4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// LAB 4: Your code here.
	struct Env* env;
	if(envid2env(0, &env,0) != 0)
  800420daf8:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  800420dafc:	ba 00 00 00 00       	mov    $0x0,%edx
  800420db01:	48 89 c6             	mov    %rax,%rsi
  800420db04:	bf 00 00 00 00       	mov    $0x0,%edi
  800420db09:	48 b8 64 78 20 04 80 	movabs $0x8004207864,%rax
  800420db10:	00 00 00 
  800420db13:	ff d0                	callq  *%rax
  800420db15:	85 c0                	test   %eax,%eax
  800420db17:	74 07                	je     800420db20 <sys_ipc_recv+0x34>
	{
		return -E_BAD_ENV;
  800420db19:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420db1e:	eb 7a                	jmp    800420db9a <sys_ipc_recv+0xae>
	}
	if(dstva <(void*)UTOP && (uint64_t)dstva%PGSIZE!=0)
  800420db20:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420db27:	00 00 00 
  800420db2a:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420db2e:	77 15                	ja     800420db45 <sys_ipc_recv+0x59>
  800420db30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420db34:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420db39:	48 85 c0             	test   %rax,%rax
  800420db3c:	74 07                	je     800420db45 <sys_ipc_recv+0x59>
		return -E_INVAL;
  800420db3e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420db43:	eb 55                	jmp    800420db9a <sys_ipc_recv+0xae>
	if(dstva <(void*)UTOP)
  800420db45:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420db4c:	00 00 00 
  800420db4f:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420db53:	77 0f                	ja     800420db64 <sys_ipc_recv+0x78>
		env->env_ipc_dstva = dstva;
  800420db55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420db59:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420db5d:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)

	env->env_ipc_recving = 1;
  800420db64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420db68:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)

	env->env_status = ENV_NOT_RUNNABLE;
  800420db6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420db73:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420db7a:	00 00 00 
	env->env_tf.tf_regs.reg_rax = 0;
  800420db7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420db81:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420db88:	00 
	sys_yield();
  800420db89:	48 b8 64 d3 20 04 80 	movabs $0x800420d364,%rax
  800420db90:	00 00 00 
  800420db93:	ff d0                	callq  *%rax
	
	//panic("sys_ipc_recv not implemented");
	return 0;
  800420db95:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420db9a:	c9                   	leaveq 
  800420db9b:	c3                   	retq   

000000800420db9c <syscall>:

// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420db9c:	55                   	push   %rbp
  800420db9d:	48 89 e5             	mov    %rsp,%rbp
  800420dba0:	48 83 ec 40          	sub    $0x40,%rsp
  800420dba4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420dba8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420dbac:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420dbb0:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420dbb4:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  800420dbb8:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.

	//panic("syscall not implemented");
	int64_t result = -E_NO_SYS;
  800420dbbc:	48 c7 45 f8 f9 ff ff 	movq   $0xfffffffffffffff9,-0x8(%rbp)
  800420dbc3:	ff 

	switch (syscallno) 
  800420dbc4:	48 83 7d e8 0d       	cmpq   $0xd,-0x18(%rbp)
  800420dbc9:	0f 87 ca 01 00 00    	ja     800420dd99 <syscall+0x1fd>
  800420dbcf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dbd3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420dbda:	00 
  800420dbdb:	48 b8 68 87 21 04 80 	movabs $0x8004218768,%rax
  800420dbe2:	00 00 00 
  800420dbe5:	48 01 d0             	add    %rdx,%rax
  800420dbe8:	48 8b 00             	mov    (%rax),%rax
  800420dbeb:	ff e0                	jmpq   *%rax
	{
		case SYS_cputs:
			sys_cputs((const char *)a1, a2);
  800420dbed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dbf1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420dbf5:	48 89 d6             	mov    %rdx,%rsi
  800420dbf8:	48 89 c7             	mov    %rax,%rdi
  800420dbfb:	48 b8 40 d2 20 04 80 	movabs $0x800420d240,%rax
  800420dc02:	00 00 00 
  800420dc05:	ff d0                	callq  *%rax
			result = 0;
  800420dc07:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420dc0e:	00 
			break;
  800420dc0f:	e9 8e 01 00 00       	jmpq   800420dda2 <syscall+0x206>
		case SYS_cgetc:
			result = sys_cgetc();
  800420dc14:	48 b8 c5 d2 20 04 80 	movabs $0x800420d2c5,%rax
  800420dc1b:	00 00 00 
  800420dc1e:	ff d0                	callq  *%rax
  800420dc20:	48 98                	cltq   
  800420dc22:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420dc26:	e9 77 01 00 00       	jmpq   800420dda2 <syscall+0x206>
		case SYS_getenvid:
			result = sys_getenvid();
  800420dc2b:	48 b8 d7 d2 20 04 80 	movabs $0x800420d2d7,%rax
  800420dc32:	00 00 00 
  800420dc35:	ff d0                	callq  *%rax
  800420dc37:	48 98                	cltq   
  800420dc39:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420dc3d:	e9 60 01 00 00       	jmpq   800420dda2 <syscall+0x206>
		case SYS_env_destroy:
			result = sys_env_destroy(a1);
  800420dc42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dc46:	89 c7                	mov    %eax,%edi
  800420dc48:	48 b8 14 d3 20 04 80 	movabs $0x800420d314,%rax
  800420dc4f:	00 00 00 
  800420dc52:	ff d0                	callq  *%rax
  800420dc54:	48 98                	cltq   
  800420dc56:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420dc5a:	e9 43 01 00 00       	jmpq   800420dda2 <syscall+0x206>
		case SYS_yield:
			sys_yield();
  800420dc5f:	48 b8 64 d3 20 04 80 	movabs $0x800420d364,%rax
  800420dc66:	00 00 00 
  800420dc69:	ff d0                	callq  *%rax
			result = 0;
  800420dc6b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420dc72:	00 
			break;
  800420dc73:	e9 2a 01 00 00       	jmpq   800420dda2 <syscall+0x206>
		case SYS_exofork:
			return sys_exofork();
  800420dc78:	48 b8 74 d3 20 04 80 	movabs $0x800420d374,%rax
  800420dc7f:	00 00 00 
  800420dc82:	ff d0                	callq  *%rax
  800420dc84:	48 98                	cltq   
  800420dc86:	e9 1b 01 00 00       	jmpq   800420dda6 <syscall+0x20a>
			break;
		case SYS_env_set_status:
			return sys_env_set_status(a1, a2);
  800420dc8b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dc8f:	89 c2                	mov    %eax,%edx
  800420dc91:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dc95:	89 d6                	mov    %edx,%esi
  800420dc97:	89 c7                	mov    %eax,%edi
  800420dc99:	48 b8 52 d4 20 04 80 	movabs $0x800420d452,%rax
  800420dca0:	00 00 00 
  800420dca3:	ff d0                	callq  *%rax
  800420dca5:	48 98                	cltq   
  800420dca7:	e9 fa 00 00 00       	jmpq   800420dda6 <syscall+0x20a>
			break;
		case SYS_env_set_pgfault_upcall:
			return sys_env_set_pgfault_upcall(a1, (void*)a2);
  800420dcac:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420dcb0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dcb4:	48 89 d6             	mov    %rdx,%rsi
  800420dcb7:	89 c7                	mov    %eax,%edi
  800420dcb9:	48 b8 50 d5 20 04 80 	movabs $0x800420d550,%rax
  800420dcc0:	00 00 00 
  800420dcc3:	ff d0                	callq  *%rax
  800420dcc5:	48 98                	cltq   
  800420dcc7:	e9 da 00 00 00       	jmpq   800420dda6 <syscall+0x20a>
			break;
		case SYS_ipc_try_send:
			return sys_ipc_try_send(a1, a2, (void*)a3, a4);
  800420dccc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420dcd0:	89 c1                	mov    %eax,%ecx
  800420dcd2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420dcd6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dcda:	89 c6                	mov    %eax,%esi
  800420dcdc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dce0:	89 c7                	mov    %eax,%edi
  800420dce2:	48 b8 8d d8 20 04 80 	movabs $0x800420d88d,%rax
  800420dce9:	00 00 00 
  800420dcec:	ff d0                	callq  *%rax
  800420dcee:	48 98                	cltq   
  800420dcf0:	e9 b1 00 00 00       	jmpq   800420dda6 <syscall+0x20a>
			break;
		case SYS_ipc_recv:
			return sys_ipc_recv((void*)a1);
  800420dcf5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dcf9:	48 89 c7             	mov    %rax,%rdi
  800420dcfc:	48 b8 ec da 20 04 80 	movabs $0x800420daec,%rax
  800420dd03:	00 00 00 
  800420dd06:	ff d0                	callq  *%rax
  800420dd08:	48 98                	cltq   
  800420dd0a:	e9 97 00 00 00       	jmpq   800420dda6 <syscall+0x20a>
			break;
		case SYS_page_alloc:
			return sys_page_alloc(a1, (void*)a2, a3);
  800420dd0f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dd13:	89 c2                	mov    %eax,%edx
  800420dd15:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420dd19:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dd1d:	48 89 ce             	mov    %rcx,%rsi
  800420dd20:	89 c7                	mov    %eax,%edi
  800420dd22:	48 b8 a7 d5 20 04 80 	movabs $0x800420d5a7,%rax
  800420dd29:	00 00 00 
  800420dd2c:	ff d0                	callq  *%rax
  800420dd2e:	48 98                	cltq   
  800420dd30:	eb 74                	jmp    800420dda6 <syscall+0x20a>
			break;	
		case SYS_page_map:
			return sys_page_map(a1, (void*)a2, a3, (void*)a4, a5);
  800420dd32:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420dd36:	89 c7                	mov    %eax,%edi
  800420dd38:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800420dd3c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dd40:	89 c2                	mov    %eax,%edx
  800420dd42:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420dd46:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dd4a:	41 89 f8             	mov    %edi,%r8d
  800420dd4d:	89 c7                	mov    %eax,%edi
  800420dd4f:	48 b8 92 d6 20 04 80 	movabs $0x800420d692,%rax
  800420dd56:	00 00 00 
  800420dd59:	ff d0                	callq  *%rax
  800420dd5b:	48 98                	cltq   
  800420dd5d:	eb 47                	jmp    800420dda6 <syscall+0x20a>
			break;
		case SYS_page_unmap:
			return sys_page_unmap(a1, (void*)a2);
  800420dd5f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420dd63:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dd67:	48 89 d6             	mov    %rdx,%rsi
  800420dd6a:	89 c7                	mov    %eax,%edi
  800420dd6c:	48 b8 ff d7 20 04 80 	movabs $0x800420d7ff,%rax
  800420dd73:	00 00 00 
  800420dd76:	ff d0                	callq  *%rax
  800420dd78:	48 98                	cltq   
  800420dd7a:	eb 2a                	jmp    800420dda6 <syscall+0x20a>
			break;
		case SYS_env_set_trapframe:
			return sys_env_set_trapframe(a1, (struct Trapframe *)a2);
  800420dd7c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420dd80:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dd84:	48 89 d6             	mov    %rdx,%rsi
  800420dd87:	89 c7                	mov    %eax,%edi
  800420dd89:	48 b8 b7 d4 20 04 80 	movabs $0x800420d4b7,%rax
  800420dd90:	00 00 00 
  800420dd93:	ff d0                	callq  *%rax
  800420dd95:	48 98                	cltq   
  800420dd97:	eb 0d                	jmp    800420dda6 <syscall+0x20a>
		default:		
			return -E_NO_SYS;
  800420dd99:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
  800420dda0:	eb 04                	jmp    800420dda6 <syscall+0x20a>
	}
	return result;	
  800420dda2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420dda6:	c9                   	leaveq 
  800420dda7:	c3                   	retq   

000000800420dda8 <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420dda8:	55                   	push   %rbp
  800420dda9:	48 89 e5             	mov    %rsp,%rbp
  800420ddac:	48 81 ec f0 61 00 00 	sub    $0x61f0,%rsp
  800420ddb3:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420ddba:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420ddc1:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420ddc8:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420ddcf:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420ddd6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420ddda:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420dde1:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420dde8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420ddec:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420ddf3:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420ddfa:	48 89 d1             	mov    %rdx,%rcx
  800420ddfd:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420de02:	48 89 ce             	mov    %rcx,%rsi
  800420de05:	48 89 c7             	mov    %rax,%rdi
  800420de08:	48 b8 48 fa 20 04 80 	movabs $0x800420fa48,%rax
  800420de0f:	00 00 00 
  800420de12:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420de14:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420de1b:	00 
	uint64_t ret_offset=0;
  800420de1c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420de23:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420de24:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420de2b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420de2f:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420de33:	74 0a                	je     800420de3f <list_func_die+0x97>
		return 0;
  800420de35:	b8 00 00 00 00       	mov    $0x0,%eax
  800420de3a:	e9 cd 06 00 00       	jmpq   800420e50c <list_func_die+0x764>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420de3f:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420de46:	ba 38 00 00 00       	mov    $0x38,%edx
  800420de4b:	be 00 00 00 00       	mov    $0x0,%esi
  800420de50:	48 89 c7             	mov    %rax,%rdi
  800420de53:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  800420de5a:	00 00 00 
  800420de5d:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420de5f:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420de66:	be 11 00 00 00       	mov    $0x11,%esi
  800420de6b:	48 89 c7             	mov    %rax,%rdi
  800420de6e:	48 b8 db 17 21 04 80 	movabs $0x80042117db,%rax
  800420de75:	00 00 00 
  800420de78:	ff d0                	callq  *%rax
  800420de7a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420de7e:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420de85:	be 12 00 00 00       	mov    $0x12,%esi
  800420de8a:	48 89 c7             	mov    %rax,%rdi
  800420de8d:	48 b8 db 17 21 04 80 	movabs $0x80042117db,%rax
  800420de94:	00 00 00 
  800420de97:	ff d0                	callq  *%rax
  800420de99:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420de9d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420dea2:	0f 84 5f 06 00 00    	je     800420e507 <list_func_die+0x75f>
  800420dea8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420deac:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420deb0:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420deb7:	0f 83 4a 06 00 00    	jae    800420e507 <list_func_die+0x75f>
  800420debd:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420dec2:	0f 84 3f 06 00 00    	je     800420e507 <list_func_die+0x75f>
  800420dec8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420decc:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ded0:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420ded7:	0f 86 2a 06 00 00    	jbe    800420e507 <list_func_die+0x75f>
	{
		info->rip_file = die->cu_die->die_name;
  800420dedd:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420dee4:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420deeb:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420def2:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420def9:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420defc:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420df03:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420df0a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420df11:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420df15:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420df1c:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420df23:	48 89 c7             	mov    %rax,%rdi
  800420df26:	48 b8 a1 f5 20 04 80 	movabs $0x800420f5a1,%rax
  800420df2d:	00 00 00 
  800420df30:	ff d0                	callq  *%rax
  800420df32:	48 8b 95 58 9e ff ff 	mov    -0x61a8(%rbp),%rdx
  800420df39:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420df3c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420df40:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420df44:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420df4b:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420df4f:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420df56:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420df5d:	48 85 c0             	test   %rax,%rax
  800420df60:	75 35                	jne    800420df97 <list_func_die+0x1ef>
  800420df62:	48 b9 00 8b 21 04 80 	movabs $0x8004218b00,%rcx
  800420df69:	00 00 00 
  800420df6c:	48 ba 0c 8b 21 04 80 	movabs $0x8004218b0c,%rdx
  800420df73:	00 00 00 
  800420df76:	be 90 00 00 00       	mov    $0x90,%esi
  800420df7b:	48 bf 21 8b 21 04 80 	movabs $0x8004218b21,%rdi
  800420df82:	00 00 00 
  800420df85:	b8 00 00 00 00       	mov    $0x0,%eax
  800420df8a:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420df91:	00 00 00 
  800420df94:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420df97:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420df9e:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420dfa5:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420dfac:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420dfb3:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420dfb8:	48 89 c7             	mov    %rax,%rdi
  800420dfbb:	48 b8 d2 4d 21 04 80 	movabs $0x8004214dd2,%rax
  800420dfc2:	00 00 00 
  800420dfc5:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420dfc7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420dfce:	89 c2                	mov    %eax,%edx
  800420dfd0:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420dfd7:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420dfda:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420dfe1:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420dfe8:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420dfef:	00 00 00 
  800420dff2:	48 8b 00             	mov    (%rax),%rax
  800420dff5:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420dffc:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420e003:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420e007:	48 89 c7             	mov    %rax,%rdi
  800420e00a:	48 b8 b2 1a 21 04 80 	movabs $0x8004211ab2,%rax
  800420e011:	00 00 00 
  800420e014:	ff d0                	callq  *%rax
  800420e016:	83 f8 04             	cmp    $0x4,%eax
  800420e019:	0f 84 e1 04 00 00    	je     800420e500 <list_func_die+0x758>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420e01f:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420e026:	48 83 f8 05          	cmp    $0x5,%rax
  800420e02a:	74 05                	je     800420e031 <list_func_die+0x289>
				goto last;
  800420e02c:	e9 cf 04 00 00       	jmpq   800420e500 <list_func_die+0x758>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420e031:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e038:	be 49 00 00 00       	mov    $0x49,%esi
  800420e03d:	48 89 c7             	mov    %rax,%rdi
  800420e040:	48 b8 db 17 21 04 80 	movabs $0x80042117db,%rax
  800420e047:	00 00 00 
  800420e04a:	ff d0                	callq  *%rax
  800420e04c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420e050:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e055:	0f 84 d7 00 00 00    	je     800420e132 <list_func_die+0x38a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420e05b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e05f:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420e063:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e067:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e06b:	48 01 d0             	add    %rdx,%rax
  800420e06e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420e072:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e079:	00 00 00 
  800420e07c:	48 8b 08             	mov    (%rax),%rcx
  800420e07f:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420e086:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420e08a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e08e:	48 8b 38             	mov    (%rax),%rdi
  800420e091:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420e095:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420e099:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420e09e:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420e0a2:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420e0a7:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420e0ab:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420e0b0:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420e0b4:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420e0b9:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420e0bd:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420e0c2:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420e0c6:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420e0cb:	48 89 cf             	mov    %rcx,%rdi
  800420e0ce:	48 b8 d8 16 21 04 80 	movabs $0x80042116d8,%rax
  800420e0d5:	00 00 00 
  800420e0d8:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420e0da:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e0e1:	be 0b 00 00 00       	mov    $0xb,%esi
  800420e0e6:	48 89 c7             	mov    %rax,%rdi
  800420e0e9:	48 b8 db 17 21 04 80 	movabs $0x80042117db,%rax
  800420e0f0:	00 00 00 
  800420e0f3:	ff d0                	callq  *%rax
  800420e0f5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420e0f9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e0fe:	74 0e                	je     800420e10e <list_func_die+0x366>
				{
					ret_val = attr->u[0].u64;
  800420e100:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e104:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e108:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e10c:	eb 24                	jmp    800420e132 <list_func_die+0x38a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420e10e:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e115:	be 49 00 00 00       	mov    $0x49,%esi
  800420e11a:	48 89 c7             	mov    %rax,%rdi
  800420e11d:	48 b8 db 17 21 04 80 	movabs $0x80042117db,%rax
  800420e124:	00 00 00 
  800420e127:	ff d0                	callq  *%rax
  800420e129:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420e12d:	e9 1e ff ff ff       	jmpq   800420e050 <list_func_die+0x2a8>
				}
			}

			ret_offset = 0;
  800420e132:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420e139:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420e13a:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e141:	be 02 00 00 00       	mov    $0x2,%esi
  800420e146:	48 89 c7             	mov    %rax,%rdi
  800420e149:	48 b8 db 17 21 04 80 	movabs $0x80042117db,%rax
  800420e150:	00 00 00 
  800420e153:	ff d0                	callq  *%rax
  800420e155:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420e159:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e15e:	0f 84 a2 00 00 00    	je     800420e206 <list_func_die+0x45e>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420e164:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e168:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420e16c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420e170:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e174:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420e178:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420e17c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e180:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420e184:	48 83 f8 03          	cmp    $0x3,%rax
  800420e188:	72 7c                	jb     800420e206 <list_func_die+0x45e>
  800420e18a:	48 83 f8 04          	cmp    $0x4,%rax
  800420e18e:	76 06                	jbe    800420e196 <list_func_die+0x3ee>
  800420e190:	48 83 f8 0a          	cmp    $0xa,%rax
  800420e194:	75 70                	jne    800420e206 <list_func_die+0x45e>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420e196:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420e19d:	00 
						atom = *(loc_ptr++);
  800420e19e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e1a2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e1a6:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420e1aa:	0f b6 00             	movzbl (%rax),%eax
  800420e1ad:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420e1b0:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420e1b5:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420e1b9:	75 4a                	jne    800420e205 <list_func_die+0x45d>
							uint8_t *p = loc_ptr;
  800420e1bb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e1bf:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420e1c6:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420e1cd:	48 89 c7             	mov    %rax,%rdi
  800420e1d0:	48 b8 37 04 21 04 80 	movabs $0x8004210437,%rax
  800420e1d7:	00 00 00 
  800420e1da:	ff d0                	callq  *%rax
  800420e1dc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420e1e0:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420e1e7:	48 89 c2             	mov    %rax,%rdx
  800420e1ea:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e1ee:	48 29 c2             	sub    %rax,%rdx
  800420e1f1:	48 89 d0             	mov    %rdx,%rax
  800420e1f4:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420e1f8:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420e1ff:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420e203:	eb 00                	jmp    800420e205 <list_func_die+0x45d>
  800420e205:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420e206:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e20d:	8b 48 28             	mov    0x28(%rax),%ecx
  800420e210:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e214:	89 c2                	mov    %eax,%edx
  800420e216:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e21d:	48 63 c9             	movslq %ecx,%rcx
  800420e220:	48 83 c1 08          	add    $0x8,%rcx
  800420e224:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420e228:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e22f:	8b 50 28             	mov    0x28(%rax),%edx
  800420e232:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e239:	48 63 d2             	movslq %edx,%rdx
  800420e23c:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420e240:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e244:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420e249:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e250:	8b 40 28             	mov    0x28(%rax),%eax
  800420e253:	8d 50 01             	lea    0x1(%rax),%edx
  800420e256:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e25d:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420e260:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e267:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420e26e:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e273:	48 89 ce             	mov    %rcx,%rsi
  800420e276:	48 89 c7             	mov    %rax,%rdi
  800420e279:	48 b8 48 fa 20 04 80 	movabs $0x800420fa48,%rax
  800420e280:	00 00 00 
  800420e283:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420e285:	e9 40 02 00 00       	jmpq   800420e4ca <list_func_die+0x722>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420e28a:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420e291:	48 83 f8 05          	cmp    $0x5,%rax
  800420e295:	74 05                	je     800420e29c <list_func_die+0x4f4>
					break;
  800420e297:	e9 64 02 00 00       	jmpq   800420e500 <list_func_die+0x758>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420e29c:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e2a3:	be 49 00 00 00       	mov    $0x49,%esi
  800420e2a8:	48 89 c7             	mov    %rax,%rdi
  800420e2ab:	48 b8 db 17 21 04 80 	movabs $0x80042117db,%rax
  800420e2b2:	00 00 00 
  800420e2b5:	ff d0                	callq  *%rax
  800420e2b7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420e2bb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e2c0:	0f 84 b1 00 00 00    	je     800420e377 <list_func_die+0x5cf>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420e2c6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e2ca:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420e2ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e2d2:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e2d6:	48 01 d0             	add    %rdx,%rax
  800420e2d9:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420e2dd:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e2e4:	00 00 00 
  800420e2e7:	48 8b 08             	mov    (%rax),%rcx
  800420e2ea:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420e2f1:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420e2f5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e2f9:	48 8b 38             	mov    (%rax),%rdi
  800420e2fc:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420e300:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420e304:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420e309:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420e30d:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420e312:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420e316:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420e31b:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420e31f:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420e324:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420e328:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420e32d:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420e331:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420e336:	48 89 cf             	mov    %rcx,%rdi
  800420e339:	48 b8 d8 16 21 04 80 	movabs $0x80042116d8,%rax
  800420e340:	00 00 00 
  800420e343:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420e345:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e34c:	be 0b 00 00 00       	mov    $0xb,%esi
  800420e351:	48 89 c7             	mov    %rax,%rdi
  800420e354:	48 b8 db 17 21 04 80 	movabs $0x80042117db,%rax
  800420e35b:	00 00 00 
  800420e35e:	ff d0                	callq  *%rax
  800420e360:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420e364:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e369:	74 0c                	je     800420e377 <list_func_die+0x5cf>
					{
						ret_val = attr->u[0].u64;
  800420e36b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e36f:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e373:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420e377:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420e37e:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420e37f:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e386:	be 02 00 00 00       	mov    $0x2,%esi
  800420e38b:	48 89 c7             	mov    %rax,%rdi
  800420e38e:	48 b8 db 17 21 04 80 	movabs $0x80042117db,%rax
  800420e395:	00 00 00 
  800420e398:	ff d0                	callq  *%rax
  800420e39a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420e39e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e3a3:	0f 84 a2 00 00 00    	je     800420e44b <list_func_die+0x6a3>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420e3a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e3ad:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420e3b1:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420e3b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e3b9:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420e3bd:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420e3c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e3c5:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420e3c9:	48 83 f8 03          	cmp    $0x3,%rax
  800420e3cd:	72 7c                	jb     800420e44b <list_func_die+0x6a3>
  800420e3cf:	48 83 f8 04          	cmp    $0x4,%rax
  800420e3d3:	76 06                	jbe    800420e3db <list_func_die+0x633>
  800420e3d5:	48 83 f8 0a          	cmp    $0xa,%rax
  800420e3d9:	75 70                	jne    800420e44b <list_func_die+0x6a3>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420e3db:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420e3e2:	00 
							atom = *(loc_ptr++);
  800420e3e3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e3e7:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e3eb:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e3ef:	0f b6 00             	movzbl (%rax),%eax
  800420e3f2:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420e3f5:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420e3fa:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420e3fe:	75 4a                	jne    800420e44a <list_func_die+0x6a2>
								uint8_t *p = loc_ptr;
  800420e400:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e404:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420e40b:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420e412:	48 89 c7             	mov    %rax,%rdi
  800420e415:	48 b8 37 04 21 04 80 	movabs $0x8004210437,%rax
  800420e41c:	00 00 00 
  800420e41f:	ff d0                	callq  *%rax
  800420e421:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420e425:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420e42c:	48 89 c2             	mov    %rax,%rdx
  800420e42f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e433:	48 29 c2             	sub    %rax,%rdx
  800420e436:	48 89 d0             	mov    %rdx,%rax
  800420e439:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420e43d:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420e444:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420e448:	eb 00                	jmp    800420e44a <list_func_die+0x6a2>
  800420e44a:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420e44b:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e452:	8b 48 28             	mov    0x28(%rax),%ecx
  800420e455:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e459:	89 c2                	mov    %eax,%edx
  800420e45b:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e462:	48 63 c9             	movslq %ecx,%rcx
  800420e465:	48 83 c1 08          	add    $0x8,%rcx
  800420e469:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420e46d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e474:	8b 50 28             	mov    0x28(%rax),%edx
  800420e477:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e47e:	48 63 d2             	movslq %edx,%rdx
  800420e481:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420e485:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e489:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420e48e:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e495:	8b 40 28             	mov    0x28(%rax),%eax
  800420e498:	8d 50 01             	lea    0x1(%rax),%edx
  800420e49b:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e4a2:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420e4a5:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e4ac:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420e4b3:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e4b8:	48 89 ce             	mov    %rcx,%rsi
  800420e4bb:	48 89 c7             	mov    %rax,%rdi
  800420e4be:	48 b8 48 fa 20 04 80 	movabs $0x800420fa48,%rax
  800420e4c5:	00 00 00 
  800420e4c8:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420e4ca:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e4d1:	00 00 00 
  800420e4d4:	48 8b 00             	mov    (%rax),%rax
  800420e4d7:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420e4db:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420e4e2:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420e4e9:	48 89 c7             	mov    %rax,%rdi
  800420e4ec:	48 b8 6e 18 21 04 80 	movabs $0x800421186e,%rax
  800420e4f3:	00 00 00 
  800420e4f6:	ff d0                	callq  *%rax
  800420e4f8:	85 c0                	test   %eax,%eax
  800420e4fa:	0f 84 8a fd ff ff    	je     800420e28a <list_func_die+0x4e2>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420e500:	b8 01 00 00 00       	mov    $0x1,%eax
  800420e505:	eb 05                	jmp    800420e50c <list_func_die+0x764>
	}

	return 0;
  800420e507:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e50c:	c9                   	leaveq 
  800420e50d:	c3                   	retq   

000000800420e50e <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420e50e:	55                   	push   %rbp
  800420e50f:	48 89 e5             	mov    %rsp,%rbp
  800420e512:	53                   	push   %rbx
  800420e513:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420e51a:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420e521:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420e528:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420e52f:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420e530:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420e537:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420e53b:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e542:	48 bb 2f 8b 21 04 80 	movabs $0x8004218b2f,%rbx
  800420e549:	00 00 00 
  800420e54c:	48 89 18             	mov    %rbx,(%rax)
	info->rip_line = 0;
  800420e54f:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e556:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420e55d:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e564:	48 bb 2f 8b 21 04 80 	movabs $0x8004218b2f,%rbx
  800420e56b:	00 00 00 
  800420e56e:	48 89 58 10          	mov    %rbx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420e572:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e579:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420e580:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e587:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420e58e:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420e592:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e599:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420e5a0:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420e5a7:	00 00 00 
  800420e5aa:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420e5b1:	76 13                	jbe    800420e5c6 <debuginfo_rip+0xb8>
		elf = (void *)0x10000 + KERNBASE;
  800420e5b3:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420e5ba:	00 00 00 
  800420e5bd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420e5c1:	e9 08 01 00 00       	jmpq   800420e6ce <debuginfo_rip+0x1c0>
	} else {
		if(curenv != lastenv) {
  800420e5c6:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420e5cd:	00 00 00 
  800420e5d0:	ff d0                	callq  *%rax
  800420e5d2:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420e5d9:	00 00 00 
  800420e5dc:	48 98                	cltq   
  800420e5de:	48 c1 e0 03          	shl    $0x3,%rax
  800420e5e2:	48 89 c2             	mov    %rax,%rdx
  800420e5e5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e5e9:	48 29 c2             	sub    %rax,%rdx
  800420e5ec:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e5f0:	48 83 c0 08          	add    $0x8,%rax
  800420e5f4:	48 8b 10             	mov    (%rax),%rdx
  800420e5f7:	48 b8 18 13 4a 04 80 	movabs $0x80044a1318,%rax
  800420e5fe:	00 00 00 
  800420e601:	48 8b 00             	mov    (%rax),%rax
  800420e604:	48 39 c2             	cmp    %rax,%rdx
  800420e607:	0f 84 85 00 00 00    	je     800420e692 <debuginfo_rip+0x184>
			find_debug_sections((uintptr_t)curenv->elf);
  800420e60d:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420e614:	00 00 00 
  800420e617:	ff d0                	callq  *%rax
  800420e619:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420e620:	00 00 00 
  800420e623:	48 98                	cltq   
  800420e625:	48 c1 e0 03          	shl    $0x3,%rax
  800420e629:	48 89 c2             	mov    %rax,%rdx
  800420e62c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e630:	48 29 c2             	sub    %rax,%rdx
  800420e633:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e637:	48 83 c0 08          	add    $0x8,%rax
  800420e63b:	48 8b 00             	mov    (%rax),%rax
  800420e63e:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420e645:	48 89 c7             	mov    %rax,%rdi
  800420e648:	48 b8 cd 4f 21 04 80 	movabs $0x8004214fcd,%rax
  800420e64f:	00 00 00 
  800420e652:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420e654:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420e65b:	00 00 00 
  800420e65e:	ff d0                	callq  *%rax
  800420e660:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420e667:	00 00 00 
  800420e66a:	48 98                	cltq   
  800420e66c:	48 c1 e0 03          	shl    $0x3,%rax
  800420e670:	48 89 c2             	mov    %rax,%rdx
  800420e673:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e677:	48 29 c2             	sub    %rax,%rdx
  800420e67a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e67e:	48 83 c0 08          	add    $0x8,%rax
  800420e682:	48 8b 10             	mov    (%rax),%rdx
  800420e685:	48 b8 18 13 4a 04 80 	movabs $0x80044a1318,%rax
  800420e68c:	00 00 00 
  800420e68f:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420e692:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  800420e699:	00 00 00 
  800420e69c:	ff d0                	callq  *%rax
  800420e69e:	48 b9 20 30 4a 04 80 	movabs $0x80044a3020,%rcx
  800420e6a5:	00 00 00 
  800420e6a8:	48 98                	cltq   
  800420e6aa:	48 c1 e0 03          	shl    $0x3,%rax
  800420e6ae:	48 89 c2             	mov    %rax,%rdx
  800420e6b1:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e6b5:	48 29 c2             	sub    %rax,%rdx
  800420e6b8:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e6bc:	48 83 c0 08          	add    $0x8,%rax
  800420e6c0:	48 8b 00             	mov    (%rax),%rax
  800420e6c3:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420e6ca:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}
    
    
	_dwarf_init(dbg, elf);
  800420e6ce:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e6d5:	00 00 00 
  800420e6d8:	48 8b 00             	mov    (%rax),%rax
  800420e6db:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e6df:	48 89 d6             	mov    %rdx,%rsi
  800420e6e2:	48 89 c7             	mov    %rax,%rdi
  800420e6e5:	48 b8 e6 06 21 04 80 	movabs $0x80042106e6,%rax
  800420e6ec:	00 00 00 
  800420e6ef:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420e6f1:	48 bf 39 8b 21 04 80 	movabs $0x8004218b39,%rdi
  800420e6f8:	00 00 00 
  800420e6fb:	48 b8 4d 4f 21 04 80 	movabs $0x8004214f4d,%rax
  800420e702:	00 00 00 
  800420e705:	ff d0                	callq  *%rax
  800420e707:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420e70b:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e712:	00 00 00 
  800420e715:	48 8b 00             	mov    (%rax),%rax
  800420e718:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e71c:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420e720:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420e724:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e72b:	00 00 00 
  800420e72e:	48 8b 00             	mov    (%rax),%rax
  800420e731:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e735:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420e739:	48 89 50 10          	mov    %rdx,0x10(%rax)
    
	assert(dbg->dbg_info_size);
  800420e73d:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e744:	00 00 00 
  800420e747:	48 8b 00             	mov    (%rax),%rax
  800420e74a:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420e74e:	48 85 c0             	test   %rax,%rax
  800420e751:	75 35                	jne    800420e788 <debuginfo_rip+0x27a>
  800420e753:	48 b9 45 8b 21 04 80 	movabs $0x8004218b45,%rcx
  800420e75a:	00 00 00 
  800420e75d:	48 ba 0c 8b 21 04 80 	movabs $0x8004218b0c,%rdx
  800420e764:	00 00 00 
  800420e767:	be 38 01 00 00       	mov    $0x138,%esi
  800420e76c:	48 bf 21 8b 21 04 80 	movabs $0x8004218b21,%rdi
  800420e773:	00 00 00 
  800420e776:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e77b:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800420e782:	00 00 00 
  800420e785:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
  800420e788:	e9 6f 01 00 00       	jmpq   800420e8fc <debuginfo_rip+0x3ee>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420e78d:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e794:	00 00 00 
  800420e797:	48 8b 00             	mov    (%rax),%rax
  800420e79a:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420e79e:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420e7a5:	be 00 00 00 00       	mov    $0x0,%esi
  800420e7aa:	48 89 c7             	mov    %rax,%rdi
  800420e7ad:	48 b8 6e 18 21 04 80 	movabs $0x800421186e,%rax
  800420e7b4:	00 00 00 
  800420e7b7:	ff d0                	callq  *%rax
  800420e7b9:	83 f8 04             	cmp    $0x4,%eax
  800420e7bc:	75 05                	jne    800420e7c3 <debuginfo_rip+0x2b5>
		{
			continue;
  800420e7be:	e9 39 01 00 00       	jmpq   800420e8fc <debuginfo_rip+0x3ee>
		}	
		cudie.cu_header = &cu;
  800420e7c3:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420e7c7:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
		cudie.cu_die = NULL;
  800420e7ce:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420e7d5:	00 00 00 00 
	    
		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420e7d9:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e7e0:	00 00 00 
  800420e7e3:	48 8b 00             	mov    (%rax),%rax
  800420e7e6:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420e7ed:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420e7f4:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420e7f8:	48 89 c7             	mov    %rax,%rdi
  800420e7fb:	48 b8 b2 1a 21 04 80 	movabs $0x8004211ab2,%rax
  800420e802:	00 00 00 
  800420e805:	ff d0                	callq  *%rax
  800420e807:	83 f8 04             	cmp    $0x4,%eax
  800420e80a:	75 05                	jne    800420e811 <debuginfo_rip+0x303>
		{
			continue;
  800420e80c:	e9 eb 00 00 00       	jmpq   800420e8fc <debuginfo_rip+0x3ee>
		}	
		die.cu_header = &cu;
  800420e811:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420e815:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		die.cu_die = &cudie;
  800420e81c:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420e823:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420e82a:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420e831:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420e838:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e83f:	48 89 ce             	mov    %rcx,%rsi
  800420e842:	48 89 c7             	mov    %rax,%rdi
  800420e845:	48 b8 a8 dd 20 04 80 	movabs $0x800420dda8,%rax
  800420e84c:	00 00 00 
  800420e84f:	ff d0                	callq  *%rax
  800420e851:	85 c0                	test   %eax,%eax
  800420e853:	74 30                	je     800420e885 <debuginfo_rip+0x377>
				goto find_done;
  800420e855:	90                   	nop
    
	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420e856:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e85d:	00 00 00 
  800420e860:	48 8b 00             	mov    (%rax),%rax
  800420e863:	be 00 00 00 00       	mov    $0x0,%esi
  800420e868:	48 89 c7             	mov    %rax,%rdi
  800420e86b:	48 b8 5a 41 21 04 80 	movabs $0x800421415a,%rax
  800420e872:	00 00 00 
  800420e875:	ff d0                	callq  *%rax
  800420e877:	83 f8 01             	cmp    $0x1,%eax
  800420e87a:	0f 85 bb 00 00 00    	jne    800420e93b <debuginfo_rip+0x42d>
  800420e880:	e9 ac 00 00 00       	jmpq   800420e931 <debuginfo_rip+0x423>
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420e885:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e88c:	00 00 00 
  800420e88f:	48 8b 00             	mov    (%rax),%rax
  800420e892:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420e896:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420e89d:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420e8a4:	48 89 c7             	mov    %rax,%rdi
  800420e8a7:	48 b8 6e 18 21 04 80 	movabs $0x800421186e,%rax
  800420e8ae:	00 00 00 
  800420e8b1:	ff d0                	callq  *%rax
  800420e8b3:	85 c0                	test   %eax,%eax
  800420e8b5:	79 02                	jns    800420e8b9 <debuginfo_rip+0x3ab>
				break; 
  800420e8b7:	eb 43                	jmp    800420e8fc <debuginfo_rip+0x3ee>
			die = die2;
  800420e8b9:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420e8c0:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420e8c7:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e8cc:	48 89 ce             	mov    %rcx,%rsi
  800420e8cf:	48 89 c7             	mov    %rax,%rdi
  800420e8d2:	48 b8 48 fa 20 04 80 	movabs $0x800420fa48,%rax
  800420e8d9:	00 00 00 
  800420e8dc:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420e8de:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420e8e2:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
			die.cu_die = &cudie;
  800420e8e9:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420e8f0:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		}
  800420e8f7:	e9 2e ff ff ff       	jmpq   800420e82a <debuginfo_rip+0x31c>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;
    
	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420e8fc:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e903:	00 00 00 
  800420e906:	48 8b 00             	mov    (%rax),%rax
  800420e909:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420e90d:	48 89 d6             	mov    %rdx,%rsi
  800420e910:	48 89 c7             	mov    %rax,%rdi
  800420e913:	48 b8 c8 07 21 04 80 	movabs $0x80042107c8,%rax
  800420e91a:	00 00 00 
  800420e91d:	ff d0                	callq  *%rax
  800420e91f:	85 c0                	test   %eax,%eax
  800420e921:	0f 84 66 fe ff ff    	je     800420e78d <debuginfo_rip+0x27f>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}
    
	return -1;
  800420e927:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420e92c:	e9 a0 00 00 00       	jmpq   800420e9d1 <debuginfo_rip+0x4c3>

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
		return -1;
  800420e931:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420e936:	e9 96 00 00 00       	jmpq   800420e9d1 <debuginfo_rip+0x4c3>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420e93b:	48 b8 a0 c6 22 04 80 	movabs $0x800422c6a0,%rax
  800420e942:	00 00 00 
  800420e945:	48 8b 08             	mov    (%rax),%rcx
  800420e948:	48 b8 98 c6 22 04 80 	movabs $0x800422c698,%rax
  800420e94f:	00 00 00 
  800420e952:	48 8b 10             	mov    (%rax),%rdx
  800420e955:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e95c:	00 00 00 
  800420e95f:	48 8b 00             	mov    (%rax),%rax
  800420e962:	48 8b b5 38 6e ff ff 	mov    -0x91c8(%rbp),%rsi
  800420e969:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420e96f:	48 89 c7             	mov    %rax,%rdi
  800420e972:	48 b8 f3 1c 21 04 80 	movabs $0x8004211cf3,%rax
  800420e979:	00 00 00 
  800420e97c:	ff d0                	callq  *%rax
  800420e97e:	85 c0                	test   %eax,%eax
  800420e980:	75 4a                	jne    800420e9cc <debuginfo_rip+0x4be>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr, &info->reg_table,
  800420e982:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e989:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420e990:	48 b8 98 c6 22 04 80 	movabs $0x800422c698,%rax
  800420e997:	00 00 00 
  800420e99a:	48 8b 30             	mov    (%rax),%rsi
  800420e99d:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800420e9a4:	00 00 00 
  800420e9a7:	48 8b 00             	mov    (%rax),%rax
  800420e9aa:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420e9b1:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420e9b7:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420e9bd:	48 89 c7             	mov    %rax,%rdi
  800420e9c0:	48 b8 ff 2f 21 04 80 	movabs $0x8004212fff,%rax
  800420e9c7:	00 00 00 
  800420e9ca:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420e9cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e9d1:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420e9d8:	5b                   	pop    %rbx
  800420e9d9:	5d                   	pop    %rbp
  800420e9da:	c3                   	retq   

000000800420e9db <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420e9db:	55                   	push   %rbp
  800420e9dc:	48 89 e5             	mov    %rsp,%rbp
  800420e9df:	53                   	push   %rbx
  800420e9e0:	48 83 ec 38          	sub    $0x38,%rsp
  800420e9e4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e9e8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e9ec:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420e9f0:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420e9f3:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420e9f7:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420e9fb:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420e9fe:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420ea02:	77 3b                	ja     800420ea3f <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420ea04:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420ea07:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420ea0b:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420ea0e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ea12:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ea17:	48 f7 f3             	div    %rbx
  800420ea1a:	48 89 c2             	mov    %rax,%rdx
  800420ea1d:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420ea20:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ea23:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420ea27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea2b:	41 89 f9             	mov    %edi,%r9d
  800420ea2e:	48 89 c7             	mov    %rax,%rdi
  800420ea31:	48 b8 db e9 20 04 80 	movabs $0x800420e9db,%rax
  800420ea38:	00 00 00 
  800420ea3b:	ff d0                	callq  *%rax
  800420ea3d:	eb 1e                	jmp    800420ea5d <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420ea3f:	eb 12                	jmp    800420ea53 <printnum+0x78>
			putch(padc, putdat);
  800420ea41:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420ea45:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420ea48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea4c:	48 89 ce             	mov    %rcx,%rsi
  800420ea4f:	89 d7                	mov    %edx,%edi
  800420ea51:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420ea53:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420ea57:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420ea5b:	7f e4                	jg     800420ea41 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420ea5d:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ea60:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ea64:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ea69:	48 f7 f1             	div    %rcx
  800420ea6c:	48 89 d0             	mov    %rdx,%rax
  800420ea6f:	48 ba 28 8d 21 04 80 	movabs $0x8004218d28,%rdx
  800420ea76:	00 00 00 
  800420ea79:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420ea7d:	0f be d0             	movsbl %al,%edx
  800420ea80:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420ea84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea88:	48 89 ce             	mov    %rcx,%rsi
  800420ea8b:	89 d7                	mov    %edx,%edi
  800420ea8d:	ff d0                	callq  *%rax
}
  800420ea8f:	48 83 c4 38          	add    $0x38,%rsp
  800420ea93:	5b                   	pop    %rbx
  800420ea94:	5d                   	pop    %rbp
  800420ea95:	c3                   	retq   

000000800420ea96 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420ea96:	55                   	push   %rbp
  800420ea97:	48 89 e5             	mov    %rsp,%rbp
  800420ea9a:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ea9e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eaa2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420eaa5:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420eaa9:	7e 52                	jle    800420eafd <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420eaab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eaaf:	8b 00                	mov    (%rax),%eax
  800420eab1:	83 f8 30             	cmp    $0x30,%eax
  800420eab4:	73 24                	jae    800420eada <getuint+0x44>
  800420eab6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eaba:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420eabe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eac2:	8b 00                	mov    (%rax),%eax
  800420eac4:	89 c0                	mov    %eax,%eax
  800420eac6:	48 01 d0             	add    %rdx,%rax
  800420eac9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eacd:	8b 12                	mov    (%rdx),%edx
  800420eacf:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ead2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ead6:	89 0a                	mov    %ecx,(%rdx)
  800420ead8:	eb 17                	jmp    800420eaf1 <getuint+0x5b>
  800420eada:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eade:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420eae2:	48 89 d0             	mov    %rdx,%rax
  800420eae5:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420eae9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eaed:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420eaf1:	48 8b 00             	mov    (%rax),%rax
  800420eaf4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420eaf8:	e9 a3 00 00 00       	jmpq   800420eba0 <getuint+0x10a>
	else if (lflag)
  800420eafd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420eb01:	74 4f                	je     800420eb52 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420eb03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb07:	8b 00                	mov    (%rax),%eax
  800420eb09:	83 f8 30             	cmp    $0x30,%eax
  800420eb0c:	73 24                	jae    800420eb32 <getuint+0x9c>
  800420eb0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb12:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420eb16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb1a:	8b 00                	mov    (%rax),%eax
  800420eb1c:	89 c0                	mov    %eax,%eax
  800420eb1e:	48 01 d0             	add    %rdx,%rax
  800420eb21:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eb25:	8b 12                	mov    (%rdx),%edx
  800420eb27:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420eb2a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eb2e:	89 0a                	mov    %ecx,(%rdx)
  800420eb30:	eb 17                	jmp    800420eb49 <getuint+0xb3>
  800420eb32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb36:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420eb3a:	48 89 d0             	mov    %rdx,%rax
  800420eb3d:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420eb41:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eb45:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420eb49:	48 8b 00             	mov    (%rax),%rax
  800420eb4c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420eb50:	eb 4e                	jmp    800420eba0 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420eb52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb56:	8b 00                	mov    (%rax),%eax
  800420eb58:	83 f8 30             	cmp    $0x30,%eax
  800420eb5b:	73 24                	jae    800420eb81 <getuint+0xeb>
  800420eb5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb61:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420eb65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb69:	8b 00                	mov    (%rax),%eax
  800420eb6b:	89 c0                	mov    %eax,%eax
  800420eb6d:	48 01 d0             	add    %rdx,%rax
  800420eb70:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eb74:	8b 12                	mov    (%rdx),%edx
  800420eb76:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420eb79:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eb7d:	89 0a                	mov    %ecx,(%rdx)
  800420eb7f:	eb 17                	jmp    800420eb98 <getuint+0x102>
  800420eb81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb85:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420eb89:	48 89 d0             	mov    %rdx,%rax
  800420eb8c:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420eb90:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eb94:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420eb98:	8b 00                	mov    (%rax),%eax
  800420eb9a:	89 c0                	mov    %eax,%eax
  800420eb9c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420eba0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420eba4:	c9                   	leaveq 
  800420eba5:	c3                   	retq   

000000800420eba6 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420eba6:	55                   	push   %rbp
  800420eba7:	48 89 e5             	mov    %rsp,%rbp
  800420ebaa:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ebae:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ebb2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420ebb5:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420ebb9:	7e 52                	jle    800420ec0d <getint+0x67>
		x=va_arg(*ap, long long);
  800420ebbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebbf:	8b 00                	mov    (%rax),%eax
  800420ebc1:	83 f8 30             	cmp    $0x30,%eax
  800420ebc4:	73 24                	jae    800420ebea <getint+0x44>
  800420ebc6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebca:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ebce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebd2:	8b 00                	mov    (%rax),%eax
  800420ebd4:	89 c0                	mov    %eax,%eax
  800420ebd6:	48 01 d0             	add    %rdx,%rax
  800420ebd9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ebdd:	8b 12                	mov    (%rdx),%edx
  800420ebdf:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ebe2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ebe6:	89 0a                	mov    %ecx,(%rdx)
  800420ebe8:	eb 17                	jmp    800420ec01 <getint+0x5b>
  800420ebea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebee:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ebf2:	48 89 d0             	mov    %rdx,%rax
  800420ebf5:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ebf9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ebfd:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ec01:	48 8b 00             	mov    (%rax),%rax
  800420ec04:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ec08:	e9 a3 00 00 00       	jmpq   800420ecb0 <getint+0x10a>
	else if (lflag)
  800420ec0d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420ec11:	74 4f                	je     800420ec62 <getint+0xbc>
		x=va_arg(*ap, long);
  800420ec13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec17:	8b 00                	mov    (%rax),%eax
  800420ec19:	83 f8 30             	cmp    $0x30,%eax
  800420ec1c:	73 24                	jae    800420ec42 <getint+0x9c>
  800420ec1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec22:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ec26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec2a:	8b 00                	mov    (%rax),%eax
  800420ec2c:	89 c0                	mov    %eax,%eax
  800420ec2e:	48 01 d0             	add    %rdx,%rax
  800420ec31:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec35:	8b 12                	mov    (%rdx),%edx
  800420ec37:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ec3a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec3e:	89 0a                	mov    %ecx,(%rdx)
  800420ec40:	eb 17                	jmp    800420ec59 <getint+0xb3>
  800420ec42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec46:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ec4a:	48 89 d0             	mov    %rdx,%rax
  800420ec4d:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ec51:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec55:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ec59:	48 8b 00             	mov    (%rax),%rax
  800420ec5c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ec60:	eb 4e                	jmp    800420ecb0 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420ec62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec66:	8b 00                	mov    (%rax),%eax
  800420ec68:	83 f8 30             	cmp    $0x30,%eax
  800420ec6b:	73 24                	jae    800420ec91 <getint+0xeb>
  800420ec6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec71:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ec75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec79:	8b 00                	mov    (%rax),%eax
  800420ec7b:	89 c0                	mov    %eax,%eax
  800420ec7d:	48 01 d0             	add    %rdx,%rax
  800420ec80:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec84:	8b 12                	mov    (%rdx),%edx
  800420ec86:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ec89:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec8d:	89 0a                	mov    %ecx,(%rdx)
  800420ec8f:	eb 17                	jmp    800420eca8 <getint+0x102>
  800420ec91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec95:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ec99:	48 89 d0             	mov    %rdx,%rax
  800420ec9c:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420eca0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eca4:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420eca8:	8b 00                	mov    (%rax),%eax
  800420ecaa:	48 98                	cltq   
  800420ecac:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420ecb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ecb4:	c9                   	leaveq 
  800420ecb5:	c3                   	retq   

000000800420ecb6 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420ecb6:	55                   	push   %rbp
  800420ecb7:	48 89 e5             	mov    %rsp,%rbp
  800420ecba:	41 54                	push   %r12
  800420ecbc:	53                   	push   %rbx
  800420ecbd:	48 83 ec 60          	sub    $0x60,%rsp
  800420ecc1:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420ecc5:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420ecc9:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420eccd:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420ecd1:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420ecd5:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420ecd9:	48 8b 0a             	mov    (%rdx),%rcx
  800420ecdc:	48 89 08             	mov    %rcx,(%rax)
  800420ecdf:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420ece3:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420ece7:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420eceb:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420ecef:	eb 17                	jmp    800420ed08 <vprintfmt+0x52>
			if (ch == '\0')
  800420ecf1:	85 db                	test   %ebx,%ebx
  800420ecf3:	0f 84 cc 04 00 00    	je     800420f1c5 <vprintfmt+0x50f>
				return;
			putch(ch, putdat);
  800420ecf9:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420ecfd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ed01:	48 89 d6             	mov    %rdx,%rsi
  800420ed04:	89 df                	mov    %ebx,%edi
  800420ed06:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420ed08:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ed0c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ed10:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420ed14:	0f b6 00             	movzbl (%rax),%eax
  800420ed17:	0f b6 d8             	movzbl %al,%ebx
  800420ed1a:	83 fb 25             	cmp    $0x25,%ebx
  800420ed1d:	75 d2                	jne    800420ecf1 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420ed1f:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420ed23:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420ed2a:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420ed31:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420ed38:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420ed3f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ed43:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ed47:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420ed4b:	0f b6 00             	movzbl (%rax),%eax
  800420ed4e:	0f b6 d8             	movzbl %al,%ebx
  800420ed51:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420ed54:	83 f8 55             	cmp    $0x55,%eax
  800420ed57:	0f 87 34 04 00 00    	ja     800420f191 <vprintfmt+0x4db>
  800420ed5d:	89 c0                	mov    %eax,%eax
  800420ed5f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ed66:	00 
  800420ed67:	48 b8 50 8d 21 04 80 	movabs $0x8004218d50,%rax
  800420ed6e:	00 00 00 
  800420ed71:	48 01 d0             	add    %rdx,%rax
  800420ed74:	48 8b 00             	mov    (%rax),%rax
  800420ed77:	ff e0                	jmpq   *%rax

		// flag to pad on the right
		case '-':
			padc = '-';
  800420ed79:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420ed7d:	eb c0                	jmp    800420ed3f <vprintfmt+0x89>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420ed7f:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420ed83:	eb ba                	jmp    800420ed3f <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420ed85:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420ed8c:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420ed8f:	89 d0                	mov    %edx,%eax
  800420ed91:	c1 e0 02             	shl    $0x2,%eax
  800420ed94:	01 d0                	add    %edx,%eax
  800420ed96:	01 c0                	add    %eax,%eax
  800420ed98:	01 d8                	add    %ebx,%eax
  800420ed9a:	83 e8 30             	sub    $0x30,%eax
  800420ed9d:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420eda0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420eda4:	0f b6 00             	movzbl (%rax),%eax
  800420eda7:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420edaa:	83 fb 2f             	cmp    $0x2f,%ebx
  800420edad:	7e 0c                	jle    800420edbb <vprintfmt+0x105>
  800420edaf:	83 fb 39             	cmp    $0x39,%ebx
  800420edb2:	7f 07                	jg     800420edbb <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420edb4:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420edb9:	eb d1                	jmp    800420ed8c <vprintfmt+0xd6>
			goto process_precision;
  800420edbb:	eb 58                	jmp    800420ee15 <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  800420edbd:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420edc0:	83 f8 30             	cmp    $0x30,%eax
  800420edc3:	73 17                	jae    800420eddc <vprintfmt+0x126>
  800420edc5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420edc9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420edcc:	89 c0                	mov    %eax,%eax
  800420edce:	48 01 d0             	add    %rdx,%rax
  800420edd1:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420edd4:	83 c2 08             	add    $0x8,%edx
  800420edd7:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420edda:	eb 0f                	jmp    800420edeb <vprintfmt+0x135>
  800420eddc:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420ede0:	48 89 d0             	mov    %rdx,%rax
  800420ede3:	48 83 c2 08          	add    $0x8,%rdx
  800420ede7:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420edeb:	8b 00                	mov    (%rax),%eax
  800420eded:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420edf0:	eb 23                	jmp    800420ee15 <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  800420edf2:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420edf6:	79 0c                	jns    800420ee04 <vprintfmt+0x14e>
				width = 0;
  800420edf8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420edff:	e9 3b ff ff ff       	jmpq   800420ed3f <vprintfmt+0x89>
  800420ee04:	e9 36 ff ff ff       	jmpq   800420ed3f <vprintfmt+0x89>

		case '#':
			altflag = 1;
  800420ee09:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420ee10:	e9 2a ff ff ff       	jmpq   800420ed3f <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  800420ee15:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420ee19:	79 12                	jns    800420ee2d <vprintfmt+0x177>
				width = precision, precision = -1;
  800420ee1b:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420ee1e:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420ee21:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420ee28:	e9 12 ff ff ff       	jmpq   800420ed3f <vprintfmt+0x89>
  800420ee2d:	e9 0d ff ff ff       	jmpq   800420ed3f <vprintfmt+0x89>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420ee32:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420ee36:	e9 04 ff ff ff       	jmpq   800420ed3f <vprintfmt+0x89>

		// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420ee3b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ee3e:	83 f8 30             	cmp    $0x30,%eax
  800420ee41:	73 17                	jae    800420ee5a <vprintfmt+0x1a4>
  800420ee43:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ee47:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ee4a:	89 c0                	mov    %eax,%eax
  800420ee4c:	48 01 d0             	add    %rdx,%rax
  800420ee4f:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420ee52:	83 c2 08             	add    $0x8,%edx
  800420ee55:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420ee58:	eb 0f                	jmp    800420ee69 <vprintfmt+0x1b3>
  800420ee5a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420ee5e:	48 89 d0             	mov    %rdx,%rax
  800420ee61:	48 83 c2 08          	add    $0x8,%rdx
  800420ee65:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420ee69:	8b 10                	mov    (%rax),%edx
  800420ee6b:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420ee6f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ee73:	48 89 ce             	mov    %rcx,%rsi
  800420ee76:	89 d7                	mov    %edx,%edi
  800420ee78:	ff d0                	callq  *%rax
			break;
  800420ee7a:	e9 40 03 00 00       	jmpq   800420f1bf <vprintfmt+0x509>

		// error message
		case 'e':
			err = va_arg(aq, int);
  800420ee7f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ee82:	83 f8 30             	cmp    $0x30,%eax
  800420ee85:	73 17                	jae    800420ee9e <vprintfmt+0x1e8>
  800420ee87:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ee8b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ee8e:	89 c0                	mov    %eax,%eax
  800420ee90:	48 01 d0             	add    %rdx,%rax
  800420ee93:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420ee96:	83 c2 08             	add    $0x8,%edx
  800420ee99:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420ee9c:	eb 0f                	jmp    800420eead <vprintfmt+0x1f7>
  800420ee9e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420eea2:	48 89 d0             	mov    %rdx,%rax
  800420eea5:	48 83 c2 08          	add    $0x8,%rdx
  800420eea9:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420eead:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420eeaf:	85 db                	test   %ebx,%ebx
  800420eeb1:	79 02                	jns    800420eeb5 <vprintfmt+0x1ff>
				err = -err;
  800420eeb3:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420eeb5:	83 fb 10             	cmp    $0x10,%ebx
  800420eeb8:	7f 16                	jg     800420eed0 <vprintfmt+0x21a>
  800420eeba:	48 b8 a0 8c 21 04 80 	movabs $0x8004218ca0,%rax
  800420eec1:	00 00 00 
  800420eec4:	48 63 d3             	movslq %ebx,%rdx
  800420eec7:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420eecb:	4d 85 e4             	test   %r12,%r12
  800420eece:	75 2e                	jne    800420eefe <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  800420eed0:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420eed4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420eed8:	89 d9                	mov    %ebx,%ecx
  800420eeda:	48 ba 39 8d 21 04 80 	movabs $0x8004218d39,%rdx
  800420eee1:	00 00 00 
  800420eee4:	48 89 c7             	mov    %rax,%rdi
  800420eee7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eeec:	49 b8 ce f1 20 04 80 	movabs $0x800420f1ce,%r8
  800420eef3:	00 00 00 
  800420eef6:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420eef9:	e9 c1 02 00 00       	jmpq   800420f1bf <vprintfmt+0x509>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420eefe:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420ef02:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ef06:	4c 89 e1             	mov    %r12,%rcx
  800420ef09:	48 ba 42 8d 21 04 80 	movabs $0x8004218d42,%rdx
  800420ef10:	00 00 00 
  800420ef13:	48 89 c7             	mov    %rax,%rdi
  800420ef16:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ef1b:	49 b8 ce f1 20 04 80 	movabs $0x800420f1ce,%r8
  800420ef22:	00 00 00 
  800420ef25:	41 ff d0             	callq  *%r8
			break;
  800420ef28:	e9 92 02 00 00       	jmpq   800420f1bf <vprintfmt+0x509>

		// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420ef2d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ef30:	83 f8 30             	cmp    $0x30,%eax
  800420ef33:	73 17                	jae    800420ef4c <vprintfmt+0x296>
  800420ef35:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ef39:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ef3c:	89 c0                	mov    %eax,%eax
  800420ef3e:	48 01 d0             	add    %rdx,%rax
  800420ef41:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420ef44:	83 c2 08             	add    $0x8,%edx
  800420ef47:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420ef4a:	eb 0f                	jmp    800420ef5b <vprintfmt+0x2a5>
  800420ef4c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420ef50:	48 89 d0             	mov    %rdx,%rax
  800420ef53:	48 83 c2 08          	add    $0x8,%rdx
  800420ef57:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420ef5b:	4c 8b 20             	mov    (%rax),%r12
  800420ef5e:	4d 85 e4             	test   %r12,%r12
  800420ef61:	75 0a                	jne    800420ef6d <vprintfmt+0x2b7>
				p = "(null)";
  800420ef63:	49 bc 45 8d 21 04 80 	movabs $0x8004218d45,%r12
  800420ef6a:	00 00 00 
			if (width > 0 && padc != '-')
  800420ef6d:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420ef71:	7e 3f                	jle    800420efb2 <vprintfmt+0x2fc>
  800420ef73:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420ef77:	74 39                	je     800420efb2 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420ef79:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420ef7c:	48 98                	cltq   
  800420ef7e:	48 89 c6             	mov    %rax,%rsi
  800420ef81:	4c 89 e7             	mov    %r12,%rdi
  800420ef84:	48 b8 cf f5 20 04 80 	movabs $0x800420f5cf,%rax
  800420ef8b:	00 00 00 
  800420ef8e:	ff d0                	callq  *%rax
  800420ef90:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420ef93:	eb 17                	jmp    800420efac <vprintfmt+0x2f6>
					putch(padc, putdat);
  800420ef95:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420ef99:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420ef9d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420efa1:	48 89 ce             	mov    %rcx,%rsi
  800420efa4:	89 d7                	mov    %edx,%edi
  800420efa6:	ff d0                	callq  *%rax
		// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420efa8:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420efac:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420efb0:	7f e3                	jg     800420ef95 <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420efb2:	eb 37                	jmp    800420efeb <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  800420efb4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420efb8:	74 1e                	je     800420efd8 <vprintfmt+0x322>
  800420efba:	83 fb 1f             	cmp    $0x1f,%ebx
  800420efbd:	7e 05                	jle    800420efc4 <vprintfmt+0x30e>
  800420efbf:	83 fb 7e             	cmp    $0x7e,%ebx
  800420efc2:	7e 14                	jle    800420efd8 <vprintfmt+0x322>
					putch('?', putdat);
  800420efc4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420efc8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420efcc:	48 89 d6             	mov    %rdx,%rsi
  800420efcf:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420efd4:	ff d0                	callq  *%rax
  800420efd6:	eb 0f                	jmp    800420efe7 <vprintfmt+0x331>
				else
					putch(ch, putdat);
  800420efd8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420efdc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420efe0:	48 89 d6             	mov    %rdx,%rsi
  800420efe3:	89 df                	mov    %ebx,%edi
  800420efe5:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420efe7:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420efeb:	4c 89 e0             	mov    %r12,%rax
  800420efee:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420eff2:	0f b6 00             	movzbl (%rax),%eax
  800420eff5:	0f be d8             	movsbl %al,%ebx
  800420eff8:	85 db                	test   %ebx,%ebx
  800420effa:	74 10                	je     800420f00c <vprintfmt+0x356>
  800420effc:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420f000:	78 b2                	js     800420efb4 <vprintfmt+0x2fe>
  800420f002:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420f006:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420f00a:	79 a8                	jns    800420efb4 <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420f00c:	eb 16                	jmp    800420f024 <vprintfmt+0x36e>
				putch(' ', putdat);
  800420f00e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f012:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f016:	48 89 d6             	mov    %rdx,%rsi
  800420f019:	bf 20 00 00 00       	mov    $0x20,%edi
  800420f01e:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420f020:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f024:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f028:	7f e4                	jg     800420f00e <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  800420f02a:	e9 90 01 00 00       	jmpq   800420f1bf <vprintfmt+0x509>

		// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420f02f:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f033:	be 03 00 00 00       	mov    $0x3,%esi
  800420f038:	48 89 c7             	mov    %rax,%rdi
  800420f03b:	48 b8 a6 eb 20 04 80 	movabs $0x800420eba6,%rax
  800420f042:	00 00 00 
  800420f045:	ff d0                	callq  *%rax
  800420f047:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420f04b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f04f:	48 85 c0             	test   %rax,%rax
  800420f052:	79 1d                	jns    800420f071 <vprintfmt+0x3bb>
				putch('-', putdat);
  800420f054:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f058:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f05c:	48 89 d6             	mov    %rdx,%rsi
  800420f05f:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420f064:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420f066:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f06a:	48 f7 d8             	neg    %rax
  800420f06d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420f071:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420f078:	e9 d5 00 00 00       	jmpq   800420f152 <vprintfmt+0x49c>

		// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420f07d:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f081:	be 03 00 00 00       	mov    $0x3,%esi
  800420f086:	48 89 c7             	mov    %rax,%rdi
  800420f089:	48 b8 96 ea 20 04 80 	movabs $0x800420ea96,%rax
  800420f090:	00 00 00 
  800420f093:	ff d0                	callq  *%rax
  800420f095:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420f099:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420f0a0:	e9 ad 00 00 00       	jmpq   800420f152 <vprintfmt+0x49c>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getint(&aq, lflag);
  800420f0a5:	8b 55 e0             	mov    -0x20(%rbp),%edx
  800420f0a8:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f0ac:	89 d6                	mov    %edx,%esi
  800420f0ae:	48 89 c7             	mov    %rax,%rdi
  800420f0b1:	48 b8 a6 eb 20 04 80 	movabs $0x800420eba6,%rax
  800420f0b8:	00 00 00 
  800420f0bb:	ff d0                	callq  *%rax
  800420f0bd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  800420f0c1:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  800420f0c8:	e9 85 00 00 00       	jmpq   800420f152 <vprintfmt+0x49c>


		// pointer
		case 'p':
			putch('0', putdat);
  800420f0cd:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f0d1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f0d5:	48 89 d6             	mov    %rdx,%rsi
  800420f0d8:	bf 30 00 00 00       	mov    $0x30,%edi
  800420f0dd:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420f0df:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f0e3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f0e7:	48 89 d6             	mov    %rdx,%rsi
  800420f0ea:	bf 78 00 00 00       	mov    $0x78,%edi
  800420f0ef:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420f0f1:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f0f4:	83 f8 30             	cmp    $0x30,%eax
  800420f0f7:	73 17                	jae    800420f110 <vprintfmt+0x45a>
  800420f0f9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f0fd:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f100:	89 c0                	mov    %eax,%eax
  800420f102:	48 01 d0             	add    %rdx,%rax
  800420f105:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f108:	83 c2 08             	add    $0x8,%edx
  800420f10b:	89 55 b8             	mov    %edx,-0x48(%rbp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420f10e:	eb 0f                	jmp    800420f11f <vprintfmt+0x469>
				(uintptr_t) va_arg(aq, void *);
  800420f110:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f114:	48 89 d0             	mov    %rdx,%rax
  800420f117:	48 83 c2 08          	add    $0x8,%rdx
  800420f11b:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f11f:	48 8b 00             	mov    (%rax),%rax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420f122:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420f126:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420f12d:	eb 23                	jmp    800420f152 <vprintfmt+0x49c>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420f12f:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f133:	be 03 00 00 00       	mov    $0x3,%esi
  800420f138:	48 89 c7             	mov    %rax,%rdi
  800420f13b:	48 b8 96 ea 20 04 80 	movabs $0x800420ea96,%rax
  800420f142:	00 00 00 
  800420f145:	ff d0                	callq  *%rax
  800420f147:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420f14b:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420f152:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420f157:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420f15a:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420f15d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f161:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f165:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f169:	45 89 c1             	mov    %r8d,%r9d
  800420f16c:	41 89 f8             	mov    %edi,%r8d
  800420f16f:	48 89 c7             	mov    %rax,%rdi
  800420f172:	48 b8 db e9 20 04 80 	movabs $0x800420e9db,%rax
  800420f179:	00 00 00 
  800420f17c:	ff d0                	callq  *%rax
			break;
  800420f17e:	eb 3f                	jmp    800420f1bf <vprintfmt+0x509>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420f180:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f184:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f188:	48 89 d6             	mov    %rdx,%rsi
  800420f18b:	89 df                	mov    %ebx,%edi
  800420f18d:	ff d0                	callq  *%rax
			break;
  800420f18f:	eb 2e                	jmp    800420f1bf <vprintfmt+0x509>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420f191:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f195:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f199:	48 89 d6             	mov    %rdx,%rsi
  800420f19c:	bf 25 00 00 00       	mov    $0x25,%edi
  800420f1a1:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420f1a3:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420f1a8:	eb 05                	jmp    800420f1af <vprintfmt+0x4f9>
  800420f1aa:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420f1af:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f1b3:	48 83 e8 01          	sub    $0x1,%rax
  800420f1b7:	0f b6 00             	movzbl (%rax),%eax
  800420f1ba:	3c 25                	cmp    $0x25,%al
  800420f1bc:	75 ec                	jne    800420f1aa <vprintfmt+0x4f4>
				/* do nothing */;
			break;
  800420f1be:	90                   	nop
		}
	}
  800420f1bf:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420f1c0:	e9 43 fb ff ff       	jmpq   800420ed08 <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
    va_end(aq);
}
  800420f1c5:	48 83 c4 60          	add    $0x60,%rsp
  800420f1c9:	5b                   	pop    %rbx
  800420f1ca:	41 5c                	pop    %r12
  800420f1cc:	5d                   	pop    %rbp
  800420f1cd:	c3                   	retq   

000000800420f1ce <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420f1ce:	55                   	push   %rbp
  800420f1cf:	48 89 e5             	mov    %rsp,%rbp
  800420f1d2:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420f1d9:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420f1e0:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420f1e7:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420f1ee:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420f1f5:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420f1fc:	84 c0                	test   %al,%al
  800420f1fe:	74 20                	je     800420f220 <printfmt+0x52>
  800420f200:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420f204:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420f208:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420f20c:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420f210:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420f214:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420f218:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420f21c:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420f220:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420f227:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420f22e:	00 00 00 
  800420f231:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420f238:	00 00 00 
  800420f23b:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420f23f:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420f246:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f24d:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420f254:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420f25b:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420f262:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420f269:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420f270:	48 89 c7             	mov    %rax,%rdi
  800420f273:	48 b8 b6 ec 20 04 80 	movabs $0x800420ecb6,%rax
  800420f27a:	00 00 00 
  800420f27d:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420f27f:	c9                   	leaveq 
  800420f280:	c3                   	retq   

000000800420f281 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420f281:	55                   	push   %rbp
  800420f282:	48 89 e5             	mov    %rsp,%rbp
  800420f285:	48 83 ec 10          	sub    $0x10,%rsp
  800420f289:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420f28c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420f290:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f294:	8b 40 10             	mov    0x10(%rax),%eax
  800420f297:	8d 50 01             	lea    0x1(%rax),%edx
  800420f29a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f29e:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420f2a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2a5:	48 8b 10             	mov    (%rax),%rdx
  800420f2a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2ac:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f2b0:	48 39 c2             	cmp    %rax,%rdx
  800420f2b3:	73 17                	jae    800420f2cc <sprintputch+0x4b>
		*b->buf++ = ch;
  800420f2b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2b9:	48 8b 00             	mov    (%rax),%rax
  800420f2bc:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420f2c0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f2c4:	48 89 0a             	mov    %rcx,(%rdx)
  800420f2c7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420f2ca:	88 10                	mov    %dl,(%rax)
}
  800420f2cc:	c9                   	leaveq 
  800420f2cd:	c3                   	retq   

000000800420f2ce <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420f2ce:	55                   	push   %rbp
  800420f2cf:	48 89 e5             	mov    %rsp,%rbp
  800420f2d2:	48 83 ec 50          	sub    $0x50,%rsp
  800420f2d6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420f2da:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420f2dd:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420f2e1:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420f2e5:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420f2e9:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420f2ed:	48 8b 0a             	mov    (%rdx),%rcx
  800420f2f0:	48 89 08             	mov    %rcx,(%rax)
  800420f2f3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420f2f7:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420f2fb:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420f2ff:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420f303:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f307:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420f30b:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420f30e:	48 98                	cltq   
  800420f310:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420f314:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f318:	48 01 d0             	add    %rdx,%rax
  800420f31b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420f31f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420f326:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420f32b:	74 06                	je     800420f333 <vsnprintf+0x65>
  800420f32d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420f331:	7f 07                	jg     800420f33a <vsnprintf+0x6c>
		return -E_INVAL;
  800420f333:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420f338:	eb 2f                	jmp    800420f369 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420f33a:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420f33e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420f342:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420f346:	48 89 c6             	mov    %rax,%rsi
  800420f349:	48 bf 81 f2 20 04 80 	movabs $0x800420f281,%rdi
  800420f350:	00 00 00 
  800420f353:	48 b8 b6 ec 20 04 80 	movabs $0x800420ecb6,%rax
  800420f35a:	00 00 00 
  800420f35d:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420f35f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f363:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420f366:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420f369:	c9                   	leaveq 
  800420f36a:	c3                   	retq   

000000800420f36b <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420f36b:	55                   	push   %rbp
  800420f36c:	48 89 e5             	mov    %rsp,%rbp
  800420f36f:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420f376:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420f37d:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420f383:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420f38a:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420f391:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420f398:	84 c0                	test   %al,%al
  800420f39a:	74 20                	je     800420f3bc <snprintf+0x51>
  800420f39c:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420f3a0:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420f3a4:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420f3a8:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420f3ac:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420f3b0:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420f3b4:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420f3b8:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420f3bc:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420f3c3:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420f3ca:	00 00 00 
  800420f3cd:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420f3d4:	00 00 00 
  800420f3d7:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420f3db:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420f3e2:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f3e9:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420f3f0:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420f3f7:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420f3fe:	48 8b 0a             	mov    (%rdx),%rcx
  800420f401:	48 89 08             	mov    %rcx,(%rax)
  800420f404:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420f408:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420f40c:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420f410:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420f414:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420f41b:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420f422:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420f428:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420f42f:	48 89 c7             	mov    %rax,%rdi
  800420f432:	48 b8 ce f2 20 04 80 	movabs $0x800420f2ce,%rax
  800420f439:	00 00 00 
  800420f43c:	ff d0                	callq  *%rax
  800420f43e:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420f444:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420f44a:	c9                   	leaveq 
  800420f44b:	c3                   	retq   

000000800420f44c <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420f44c:	55                   	push   %rbp
  800420f44d:	48 89 e5             	mov    %rsp,%rbp
  800420f450:	48 83 ec 20          	sub    $0x20,%rsp
  800420f454:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

#if JOS_KERNEL
	if (prompt != NULL)
  800420f458:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f45d:	74 22                	je     800420f481 <readline+0x35>
		cprintf("%s", prompt);
  800420f45f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f463:	48 89 c6             	mov    %rax,%rsi
  800420f466:	48 bf 00 90 21 04 80 	movabs $0x8004219000,%rdi
  800420f46d:	00 00 00 
  800420f470:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f475:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420f47c:	00 00 00 
  800420f47f:	ff d2                	callq  *%rdx
#else
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif

	i = 0;
  800420f481:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420f488:	bf 00 00 00 00       	mov    $0x0,%edi
  800420f48d:	48 b8 90 12 20 04 80 	movabs $0x8004201290,%rax
  800420f494:	00 00 00 
  800420f497:	ff d0                	callq  *%rax
  800420f499:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420f49c:	48 b8 6e 12 20 04 80 	movabs $0x800420126e,%rax
  800420f4a3:	00 00 00 
  800420f4a6:	ff d0                	callq  *%rax
  800420f4a8:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420f4ab:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420f4af:	79 30                	jns    800420f4e1 <readline+0x95>
			if (c != -E_EOF)
  800420f4b1:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800420f4b5:	74 20                	je     800420f4d7 <readline+0x8b>
				cprintf("read error: %e\n", c);
  800420f4b7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f4ba:	89 c6                	mov    %eax,%esi
  800420f4bc:	48 bf 03 90 21 04 80 	movabs $0x8004219003,%rdi
  800420f4c3:	00 00 00 
  800420f4c6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f4cb:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800420f4d2:	00 00 00 
  800420f4d5:	ff d2                	callq  *%rdx
			return NULL;
  800420f4d7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f4dc:	e9 be 00 00 00       	jmpq   800420f59f <readline+0x153>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420f4e1:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420f4e5:	74 06                	je     800420f4ed <readline+0xa1>
  800420f4e7:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420f4eb:	75 26                	jne    800420f513 <readline+0xc7>
  800420f4ed:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f4f1:	7e 20                	jle    800420f513 <readline+0xc7>
			if (echoing)
  800420f4f3:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f4f7:	74 11                	je     800420f50a <readline+0xbe>
				cputchar('\b');
  800420f4f9:	bf 08 00 00 00       	mov    $0x8,%edi
  800420f4fe:	48 b8 50 12 20 04 80 	movabs $0x8004201250,%rax
  800420f505:	00 00 00 
  800420f508:	ff d0                	callq  *%rax
			i--;
  800420f50a:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420f50e:	e9 87 00 00 00       	jmpq   800420f59a <readline+0x14e>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420f513:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f517:	7e 3f                	jle    800420f558 <readline+0x10c>
  800420f519:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420f520:	7f 36                	jg     800420f558 <readline+0x10c>
			if (echoing)
  800420f522:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f526:	74 11                	je     800420f539 <readline+0xed>
				cputchar(c);
  800420f528:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f52b:	89 c7                	mov    %eax,%edi
  800420f52d:	48 b8 50 12 20 04 80 	movabs $0x8004201250,%rax
  800420f534:	00 00 00 
  800420f537:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420f539:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f53c:	8d 50 01             	lea    0x1(%rax),%edx
  800420f53f:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420f542:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420f545:	89 d1                	mov    %edx,%ecx
  800420f547:	48 ba 20 13 4a 04 80 	movabs $0x80044a1320,%rdx
  800420f54e:	00 00 00 
  800420f551:	48 98                	cltq   
  800420f553:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420f556:	eb 42                	jmp    800420f59a <readline+0x14e>
		} else if (c == '\n' || c == '\r') {
  800420f558:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420f55c:	74 06                	je     800420f564 <readline+0x118>
  800420f55e:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420f562:	75 36                	jne    800420f59a <readline+0x14e>
			if (echoing)
  800420f564:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f568:	74 11                	je     800420f57b <readline+0x12f>
				cputchar('\n');
  800420f56a:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420f56f:	48 b8 50 12 20 04 80 	movabs $0x8004201250,%rax
  800420f576:	00 00 00 
  800420f579:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420f57b:	48 ba 20 13 4a 04 80 	movabs $0x80044a1320,%rdx
  800420f582:	00 00 00 
  800420f585:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f588:	48 98                	cltq   
  800420f58a:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420f58e:	48 b8 20 13 4a 04 80 	movabs $0x80044a1320,%rax
  800420f595:	00 00 00 
  800420f598:	eb 05                	jmp    800420f59f <readline+0x153>
		}
	}
  800420f59a:	e9 fd fe ff ff       	jmpq   800420f49c <readline+0x50>
}
  800420f59f:	c9                   	leaveq 
  800420f5a0:	c3                   	retq   

000000800420f5a1 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420f5a1:	55                   	push   %rbp
  800420f5a2:	48 89 e5             	mov    %rsp,%rbp
  800420f5a5:	48 83 ec 18          	sub    $0x18,%rsp
  800420f5a9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420f5ad:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f5b4:	eb 09                	jmp    800420f5bf <strlen+0x1e>
		n++;
  800420f5b6:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420f5ba:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420f5bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5c3:	0f b6 00             	movzbl (%rax),%eax
  800420f5c6:	84 c0                	test   %al,%al
  800420f5c8:	75 ec                	jne    800420f5b6 <strlen+0x15>
		n++;
	return n;
  800420f5ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420f5cd:	c9                   	leaveq 
  800420f5ce:	c3                   	retq   

000000800420f5cf <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420f5cf:	55                   	push   %rbp
  800420f5d0:	48 89 e5             	mov    %rsp,%rbp
  800420f5d3:	48 83 ec 20          	sub    $0x20,%rsp
  800420f5d7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f5db:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420f5df:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f5e6:	eb 0e                	jmp    800420f5f6 <strnlen+0x27>
		n++;
  800420f5e8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420f5ec:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420f5f1:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420f5f6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420f5fb:	74 0b                	je     800420f608 <strnlen+0x39>
  800420f5fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f601:	0f b6 00             	movzbl (%rax),%eax
  800420f604:	84 c0                	test   %al,%al
  800420f606:	75 e0                	jne    800420f5e8 <strnlen+0x19>
		n++;
	return n;
  800420f608:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420f60b:	c9                   	leaveq 
  800420f60c:	c3                   	retq   

000000800420f60d <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420f60d:	55                   	push   %rbp
  800420f60e:	48 89 e5             	mov    %rsp,%rbp
  800420f611:	48 83 ec 20          	sub    $0x20,%rsp
  800420f615:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f619:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420f61d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f621:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420f625:	90                   	nop
  800420f626:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f62a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f62e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f632:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f636:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420f63a:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420f63e:	0f b6 12             	movzbl (%rdx),%edx
  800420f641:	88 10                	mov    %dl,(%rax)
  800420f643:	0f b6 00             	movzbl (%rax),%eax
  800420f646:	84 c0                	test   %al,%al
  800420f648:	75 dc                	jne    800420f626 <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420f64a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f64e:	c9                   	leaveq 
  800420f64f:	c3                   	retq   

000000800420f650 <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420f650:	55                   	push   %rbp
  800420f651:	48 89 e5             	mov    %rsp,%rbp
  800420f654:	48 83 ec 20          	sub    $0x20,%rsp
  800420f658:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f65c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420f660:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f664:	48 89 c7             	mov    %rax,%rdi
  800420f667:	48 b8 a1 f5 20 04 80 	movabs $0x800420f5a1,%rax
  800420f66e:	00 00 00 
  800420f671:	ff d0                	callq  *%rax
  800420f673:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420f676:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f679:	48 63 d0             	movslq %eax,%rdx
  800420f67c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f680:	48 01 c2             	add    %rax,%rdx
  800420f683:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f687:	48 89 c6             	mov    %rax,%rsi
  800420f68a:	48 89 d7             	mov    %rdx,%rdi
  800420f68d:	48 b8 0d f6 20 04 80 	movabs $0x800420f60d,%rax
  800420f694:	00 00 00 
  800420f697:	ff d0                	callq  *%rax
	return dst;
  800420f699:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420f69d:	c9                   	leaveq 
  800420f69e:	c3                   	retq   

000000800420f69f <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420f69f:	55                   	push   %rbp
  800420f6a0:	48 89 e5             	mov    %rsp,%rbp
  800420f6a3:	48 83 ec 28          	sub    $0x28,%rsp
  800420f6a7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f6ab:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f6af:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420f6b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6b7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420f6bb:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f6c2:	00 
  800420f6c3:	eb 2a                	jmp    800420f6ef <strncpy+0x50>
		*dst++ = *src;
  800420f6c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6c9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f6cd:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f6d1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f6d5:	0f b6 12             	movzbl (%rdx),%edx
  800420f6d8:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420f6da:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f6de:	0f b6 00             	movzbl (%rax),%eax
  800420f6e1:	84 c0                	test   %al,%al
  800420f6e3:	74 05                	je     800420f6ea <strncpy+0x4b>
			src++;
  800420f6e5:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420f6ea:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f6ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f6f3:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420f6f7:	72 cc                	jb     800420f6c5 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420f6f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f6fd:	c9                   	leaveq 
  800420f6fe:	c3                   	retq   

000000800420f6ff <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420f6ff:	55                   	push   %rbp
  800420f700:	48 89 e5             	mov    %rsp,%rbp
  800420f703:	48 83 ec 28          	sub    $0x28,%rsp
  800420f707:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f70b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f70f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420f713:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f717:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420f71b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420f720:	74 3d                	je     800420f75f <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420f722:	eb 1d                	jmp    800420f741 <strlcpy+0x42>
			*dst++ = *src++;
  800420f724:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f728:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f72c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f730:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f734:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420f738:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420f73c:	0f b6 12             	movzbl (%rdx),%edx
  800420f73f:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420f741:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420f746:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420f74b:	74 0b                	je     800420f758 <strlcpy+0x59>
  800420f74d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f751:	0f b6 00             	movzbl (%rax),%eax
  800420f754:	84 c0                	test   %al,%al
  800420f756:	75 cc                	jne    800420f724 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420f758:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f75c:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420f75f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f763:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f767:	48 29 c2             	sub    %rax,%rdx
  800420f76a:	48 89 d0             	mov    %rdx,%rax
}
  800420f76d:	c9                   	leaveq 
  800420f76e:	c3                   	retq   

000000800420f76f <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420f76f:	55                   	push   %rbp
  800420f770:	48 89 e5             	mov    %rsp,%rbp
  800420f773:	48 83 ec 10          	sub    $0x10,%rsp
  800420f777:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f77b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420f77f:	eb 0a                	jmp    800420f78b <strcmp+0x1c>
		p++, q++;
  800420f781:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f786:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420f78b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f78f:	0f b6 00             	movzbl (%rax),%eax
  800420f792:	84 c0                	test   %al,%al
  800420f794:	74 12                	je     800420f7a8 <strcmp+0x39>
  800420f796:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f79a:	0f b6 10             	movzbl (%rax),%edx
  800420f79d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f7a1:	0f b6 00             	movzbl (%rax),%eax
  800420f7a4:	38 c2                	cmp    %al,%dl
  800420f7a6:	74 d9                	je     800420f781 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420f7a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f7ac:	0f b6 00             	movzbl (%rax),%eax
  800420f7af:	0f b6 d0             	movzbl %al,%edx
  800420f7b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f7b6:	0f b6 00             	movzbl (%rax),%eax
  800420f7b9:	0f b6 c0             	movzbl %al,%eax
  800420f7bc:	29 c2                	sub    %eax,%edx
  800420f7be:	89 d0                	mov    %edx,%eax
}
  800420f7c0:	c9                   	leaveq 
  800420f7c1:	c3                   	retq   

000000800420f7c2 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420f7c2:	55                   	push   %rbp
  800420f7c3:	48 89 e5             	mov    %rsp,%rbp
  800420f7c6:	48 83 ec 18          	sub    $0x18,%rsp
  800420f7ca:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f7ce:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420f7d2:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420f7d6:	eb 0f                	jmp    800420f7e7 <strncmp+0x25>
		n--, p++, q++;
  800420f7d8:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420f7dd:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f7e2:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420f7e7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f7ec:	74 1d                	je     800420f80b <strncmp+0x49>
  800420f7ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f7f2:	0f b6 00             	movzbl (%rax),%eax
  800420f7f5:	84 c0                	test   %al,%al
  800420f7f7:	74 12                	je     800420f80b <strncmp+0x49>
  800420f7f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f7fd:	0f b6 10             	movzbl (%rax),%edx
  800420f800:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f804:	0f b6 00             	movzbl (%rax),%eax
  800420f807:	38 c2                	cmp    %al,%dl
  800420f809:	74 cd                	je     800420f7d8 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420f80b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f810:	75 07                	jne    800420f819 <strncmp+0x57>
		return 0;
  800420f812:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f817:	eb 18                	jmp    800420f831 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420f819:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f81d:	0f b6 00             	movzbl (%rax),%eax
  800420f820:	0f b6 d0             	movzbl %al,%edx
  800420f823:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f827:	0f b6 00             	movzbl (%rax),%eax
  800420f82a:	0f b6 c0             	movzbl %al,%eax
  800420f82d:	29 c2                	sub    %eax,%edx
  800420f82f:	89 d0                	mov    %edx,%eax
}
  800420f831:	c9                   	leaveq 
  800420f832:	c3                   	retq   

000000800420f833 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420f833:	55                   	push   %rbp
  800420f834:	48 89 e5             	mov    %rsp,%rbp
  800420f837:	48 83 ec 0c          	sub    $0xc,%rsp
  800420f83b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f83f:	89 f0                	mov    %esi,%eax
  800420f841:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420f844:	eb 17                	jmp    800420f85d <strchr+0x2a>
		if (*s == c)
  800420f846:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f84a:	0f b6 00             	movzbl (%rax),%eax
  800420f84d:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420f850:	75 06                	jne    800420f858 <strchr+0x25>
			return (char *) s;
  800420f852:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f856:	eb 15                	jmp    800420f86d <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420f858:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f85d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f861:	0f b6 00             	movzbl (%rax),%eax
  800420f864:	84 c0                	test   %al,%al
  800420f866:	75 de                	jne    800420f846 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420f868:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f86d:	c9                   	leaveq 
  800420f86e:	c3                   	retq   

000000800420f86f <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420f86f:	55                   	push   %rbp
  800420f870:	48 89 e5             	mov    %rsp,%rbp
  800420f873:	48 83 ec 0c          	sub    $0xc,%rsp
  800420f877:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f87b:	89 f0                	mov    %esi,%eax
  800420f87d:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420f880:	eb 13                	jmp    800420f895 <strfind+0x26>
		if (*s == c)
  800420f882:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f886:	0f b6 00             	movzbl (%rax),%eax
  800420f889:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420f88c:	75 02                	jne    800420f890 <strfind+0x21>
			break;
  800420f88e:	eb 10                	jmp    800420f8a0 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420f890:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f895:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f899:	0f b6 00             	movzbl (%rax),%eax
  800420f89c:	84 c0                	test   %al,%al
  800420f89e:	75 e2                	jne    800420f882 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  800420f8a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f8a4:	c9                   	leaveq 
  800420f8a5:	c3                   	retq   

000000800420f8a6 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420f8a6:	55                   	push   %rbp
  800420f8a7:	48 89 e5             	mov    %rsp,%rbp
  800420f8aa:	48 83 ec 18          	sub    $0x18,%rsp
  800420f8ae:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f8b2:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420f8b5:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420f8b9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f8be:	75 06                	jne    800420f8c6 <memset+0x20>
		return v;
  800420f8c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f8c4:	eb 69                	jmp    800420f92f <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420f8c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f8ca:	83 e0 03             	and    $0x3,%eax
  800420f8cd:	48 85 c0             	test   %rax,%rax
  800420f8d0:	75 48                	jne    800420f91a <memset+0x74>
  800420f8d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8d6:	83 e0 03             	and    $0x3,%eax
  800420f8d9:	48 85 c0             	test   %rax,%rax
  800420f8dc:	75 3c                	jne    800420f91a <memset+0x74>
		c &= 0xFF;
  800420f8de:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420f8e5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f8e8:	c1 e0 18             	shl    $0x18,%eax
  800420f8eb:	89 c2                	mov    %eax,%edx
  800420f8ed:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f8f0:	c1 e0 10             	shl    $0x10,%eax
  800420f8f3:	09 c2                	or     %eax,%edx
  800420f8f5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f8f8:	c1 e0 08             	shl    $0x8,%eax
  800420f8fb:	09 d0                	or     %edx,%eax
  800420f8fd:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  800420f900:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f904:	48 c1 e8 02          	shr    $0x2,%rax
  800420f908:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420f90b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420f90f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f912:	48 89 d7             	mov    %rdx,%rdi
  800420f915:	fc                   	cld    
  800420f916:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420f918:	eb 11                	jmp    800420f92b <memset+0x85>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420f91a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420f91e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f921:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f925:	48 89 d7             	mov    %rdx,%rdi
  800420f928:	fc                   	cld    
  800420f929:	f3 aa                	rep stos %al,%es:(%rdi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
  800420f92b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f92f:	c9                   	leaveq 
  800420f930:	c3                   	retq   

000000800420f931 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420f931:	55                   	push   %rbp
  800420f932:	48 89 e5             	mov    %rsp,%rbp
  800420f935:	48 83 ec 28          	sub    $0x28,%rsp
  800420f939:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f93d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f941:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420f945:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f949:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420f94d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f951:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420f955:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f959:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420f95d:	0f 83 88 00 00 00    	jae    800420f9eb <memmove+0xba>
  800420f963:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f967:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420f96b:	48 01 d0             	add    %rdx,%rax
  800420f96e:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420f972:	76 77                	jbe    800420f9eb <memmove+0xba>
		s += n;
  800420f974:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f978:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420f97c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f980:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420f984:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f988:	83 e0 03             	and    $0x3,%eax
  800420f98b:	48 85 c0             	test   %rax,%rax
  800420f98e:	75 3b                	jne    800420f9cb <memmove+0x9a>
  800420f990:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f994:	83 e0 03             	and    $0x3,%eax
  800420f997:	48 85 c0             	test   %rax,%rax
  800420f99a:	75 2f                	jne    800420f9cb <memmove+0x9a>
  800420f99c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f9a0:	83 e0 03             	and    $0x3,%eax
  800420f9a3:	48 85 c0             	test   %rax,%rax
  800420f9a6:	75 23                	jne    800420f9cb <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420f9a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f9ac:	48 83 e8 04          	sub    $0x4,%rax
  800420f9b0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420f9b4:	48 83 ea 04          	sub    $0x4,%rdx
  800420f9b8:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420f9bc:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420f9c0:	48 89 c7             	mov    %rax,%rdi
  800420f9c3:	48 89 d6             	mov    %rdx,%rsi
  800420f9c6:	fd                   	std    
  800420f9c7:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420f9c9:	eb 1d                	jmp    800420f9e8 <memmove+0xb7>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420f9cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f9cf:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420f9d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f9d7:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420f9db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f9df:	48 89 d7             	mov    %rdx,%rdi
  800420f9e2:	48 89 c1             	mov    %rax,%rcx
  800420f9e5:	fd                   	std    
  800420f9e6:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420f9e8:	fc                   	cld    
  800420f9e9:	eb 57                	jmp    800420fa42 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420f9eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f9ef:	83 e0 03             	and    $0x3,%eax
  800420f9f2:	48 85 c0             	test   %rax,%rax
  800420f9f5:	75 36                	jne    800420fa2d <memmove+0xfc>
  800420f9f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f9fb:	83 e0 03             	and    $0x3,%eax
  800420f9fe:	48 85 c0             	test   %rax,%rax
  800420fa01:	75 2a                	jne    800420fa2d <memmove+0xfc>
  800420fa03:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa07:	83 e0 03             	and    $0x3,%eax
  800420fa0a:	48 85 c0             	test   %rax,%rax
  800420fa0d:	75 1e                	jne    800420fa2d <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420fa0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa13:	48 c1 e8 02          	shr    $0x2,%rax
  800420fa17:	48 89 c1             	mov    %rax,%rcx
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420fa1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fa1e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fa22:	48 89 c7             	mov    %rax,%rdi
  800420fa25:	48 89 d6             	mov    %rdx,%rsi
  800420fa28:	fc                   	cld    
  800420fa29:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420fa2b:	eb 15                	jmp    800420fa42 <memmove+0x111>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420fa2d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fa31:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fa35:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420fa39:	48 89 c7             	mov    %rax,%rdi
  800420fa3c:	48 89 d6             	mov    %rdx,%rsi
  800420fa3f:	fc                   	cld    
  800420fa40:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420fa42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420fa46:	c9                   	leaveq 
  800420fa47:	c3                   	retq   

000000800420fa48 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420fa48:	55                   	push   %rbp
  800420fa49:	48 89 e5             	mov    %rsp,%rbp
  800420fa4c:	48 83 ec 18          	sub    $0x18,%rsp
  800420fa50:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fa54:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420fa58:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420fa5c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fa60:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420fa64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa68:	48 89 ce             	mov    %rcx,%rsi
  800420fa6b:	48 89 c7             	mov    %rax,%rdi
  800420fa6e:	48 b8 31 f9 20 04 80 	movabs $0x800420f931,%rax
  800420fa75:	00 00 00 
  800420fa78:	ff d0                	callq  *%rax
}
  800420fa7a:	c9                   	leaveq 
  800420fa7b:	c3                   	retq   

000000800420fa7c <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420fa7c:	55                   	push   %rbp
  800420fa7d:	48 89 e5             	mov    %rsp,%rbp
  800420fa80:	48 83 ec 28          	sub    $0x28,%rsp
  800420fa84:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fa88:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fa8c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420fa90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa94:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420fa98:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fa9c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420faa0:	eb 36                	jmp    800420fad8 <memcmp+0x5c>
		if (*s1 != *s2)
  800420faa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420faa6:	0f b6 10             	movzbl (%rax),%edx
  800420faa9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420faad:	0f b6 00             	movzbl (%rax),%eax
  800420fab0:	38 c2                	cmp    %al,%dl
  800420fab2:	74 1a                	je     800420face <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420fab4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fab8:	0f b6 00             	movzbl (%rax),%eax
  800420fabb:	0f b6 d0             	movzbl %al,%edx
  800420fabe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fac2:	0f b6 00             	movzbl (%rax),%eax
  800420fac5:	0f b6 c0             	movzbl %al,%eax
  800420fac8:	29 c2                	sub    %eax,%edx
  800420faca:	89 d0                	mov    %edx,%eax
  800420facc:	eb 20                	jmp    800420faee <memcmp+0x72>
		s1++, s2++;
  800420face:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420fad3:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420fad8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fadc:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420fae0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420fae4:	48 85 c0             	test   %rax,%rax
  800420fae7:	75 b9                	jne    800420faa2 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420fae9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420faee:	c9                   	leaveq 
  800420faef:	c3                   	retq   

000000800420faf0 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420faf0:	55                   	push   %rbp
  800420faf1:	48 89 e5             	mov    %rsp,%rbp
  800420faf4:	48 83 ec 28          	sub    $0x28,%rsp
  800420faf8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fafc:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420faff:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420fb03:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb07:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fb0b:	48 01 d0             	add    %rdx,%rax
  800420fb0e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420fb12:	eb 15                	jmp    800420fb29 <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420fb14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb18:	0f b6 10             	movzbl (%rax),%edx
  800420fb1b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420fb1e:	38 c2                	cmp    %al,%dl
  800420fb20:	75 02                	jne    800420fb24 <memfind+0x34>
			break;
  800420fb22:	eb 0f                	jmp    800420fb33 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420fb24:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420fb29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb2d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420fb31:	72 e1                	jb     800420fb14 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  800420fb33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420fb37:	c9                   	leaveq 
  800420fb38:	c3                   	retq   

000000800420fb39 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420fb39:	55                   	push   %rbp
  800420fb3a:	48 89 e5             	mov    %rsp,%rbp
  800420fb3d:	48 83 ec 34          	sub    $0x34,%rsp
  800420fb41:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420fb45:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420fb49:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420fb4c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420fb53:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420fb5a:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420fb5b:	eb 05                	jmp    800420fb62 <strtol+0x29>
		s++;
  800420fb5d:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420fb62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb66:	0f b6 00             	movzbl (%rax),%eax
  800420fb69:	3c 20                	cmp    $0x20,%al
  800420fb6b:	74 f0                	je     800420fb5d <strtol+0x24>
  800420fb6d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb71:	0f b6 00             	movzbl (%rax),%eax
  800420fb74:	3c 09                	cmp    $0x9,%al
  800420fb76:	74 e5                	je     800420fb5d <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420fb78:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb7c:	0f b6 00             	movzbl (%rax),%eax
  800420fb7f:	3c 2b                	cmp    $0x2b,%al
  800420fb81:	75 07                	jne    800420fb8a <strtol+0x51>
		s++;
  800420fb83:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fb88:	eb 17                	jmp    800420fba1 <strtol+0x68>
	else if (*s == '-')
  800420fb8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb8e:	0f b6 00             	movzbl (%rax),%eax
  800420fb91:	3c 2d                	cmp    $0x2d,%al
  800420fb93:	75 0c                	jne    800420fba1 <strtol+0x68>
		s++, neg = 1;
  800420fb95:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fb9a:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420fba1:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fba5:	74 06                	je     800420fbad <strtol+0x74>
  800420fba7:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420fbab:	75 28                	jne    800420fbd5 <strtol+0x9c>
  800420fbad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fbb1:	0f b6 00             	movzbl (%rax),%eax
  800420fbb4:	3c 30                	cmp    $0x30,%al
  800420fbb6:	75 1d                	jne    800420fbd5 <strtol+0x9c>
  800420fbb8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fbbc:	48 83 c0 01          	add    $0x1,%rax
  800420fbc0:	0f b6 00             	movzbl (%rax),%eax
  800420fbc3:	3c 78                	cmp    $0x78,%al
  800420fbc5:	75 0e                	jne    800420fbd5 <strtol+0x9c>
		s += 2, base = 16;
  800420fbc7:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420fbcc:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420fbd3:	eb 2c                	jmp    800420fc01 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420fbd5:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fbd9:	75 19                	jne    800420fbf4 <strtol+0xbb>
  800420fbdb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fbdf:	0f b6 00             	movzbl (%rax),%eax
  800420fbe2:	3c 30                	cmp    $0x30,%al
  800420fbe4:	75 0e                	jne    800420fbf4 <strtol+0xbb>
		s++, base = 8;
  800420fbe6:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fbeb:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420fbf2:	eb 0d                	jmp    800420fc01 <strtol+0xc8>
	else if (base == 0)
  800420fbf4:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fbf8:	75 07                	jne    800420fc01 <strtol+0xc8>
		base = 10;
  800420fbfa:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420fc01:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc05:	0f b6 00             	movzbl (%rax),%eax
  800420fc08:	3c 2f                	cmp    $0x2f,%al
  800420fc0a:	7e 1d                	jle    800420fc29 <strtol+0xf0>
  800420fc0c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc10:	0f b6 00             	movzbl (%rax),%eax
  800420fc13:	3c 39                	cmp    $0x39,%al
  800420fc15:	7f 12                	jg     800420fc29 <strtol+0xf0>
			dig = *s - '0';
  800420fc17:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc1b:	0f b6 00             	movzbl (%rax),%eax
  800420fc1e:	0f be c0             	movsbl %al,%eax
  800420fc21:	83 e8 30             	sub    $0x30,%eax
  800420fc24:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420fc27:	eb 4e                	jmp    800420fc77 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420fc29:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc2d:	0f b6 00             	movzbl (%rax),%eax
  800420fc30:	3c 60                	cmp    $0x60,%al
  800420fc32:	7e 1d                	jle    800420fc51 <strtol+0x118>
  800420fc34:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc38:	0f b6 00             	movzbl (%rax),%eax
  800420fc3b:	3c 7a                	cmp    $0x7a,%al
  800420fc3d:	7f 12                	jg     800420fc51 <strtol+0x118>
			dig = *s - 'a' + 10;
  800420fc3f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc43:	0f b6 00             	movzbl (%rax),%eax
  800420fc46:	0f be c0             	movsbl %al,%eax
  800420fc49:	83 e8 57             	sub    $0x57,%eax
  800420fc4c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420fc4f:	eb 26                	jmp    800420fc77 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420fc51:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc55:	0f b6 00             	movzbl (%rax),%eax
  800420fc58:	3c 40                	cmp    $0x40,%al
  800420fc5a:	7e 48                	jle    800420fca4 <strtol+0x16b>
  800420fc5c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc60:	0f b6 00             	movzbl (%rax),%eax
  800420fc63:	3c 5a                	cmp    $0x5a,%al
  800420fc65:	7f 3d                	jg     800420fca4 <strtol+0x16b>
			dig = *s - 'A' + 10;
  800420fc67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc6b:	0f b6 00             	movzbl (%rax),%eax
  800420fc6e:	0f be c0             	movsbl %al,%eax
  800420fc71:	83 e8 37             	sub    $0x37,%eax
  800420fc74:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420fc77:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420fc7a:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420fc7d:	7c 02                	jl     800420fc81 <strtol+0x148>
			break;
  800420fc7f:	eb 23                	jmp    800420fca4 <strtol+0x16b>
		s++, val = (val * base) + dig;
  800420fc81:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fc86:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420fc89:	48 98                	cltq   
  800420fc8b:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420fc90:	48 89 c2             	mov    %rax,%rdx
  800420fc93:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420fc96:	48 98                	cltq   
  800420fc98:	48 01 d0             	add    %rdx,%rax
  800420fc9b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420fc9f:	e9 5d ff ff ff       	jmpq   800420fc01 <strtol+0xc8>

	if (endptr)
  800420fca4:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420fca9:	74 0b                	je     800420fcb6 <strtol+0x17d>
		*endptr = (char *) s;
  800420fcab:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fcaf:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420fcb3:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420fcb6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420fcba:	74 09                	je     800420fcc5 <strtol+0x18c>
  800420fcbc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fcc0:	48 f7 d8             	neg    %rax
  800420fcc3:	eb 04                	jmp    800420fcc9 <strtol+0x190>
  800420fcc5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420fcc9:	c9                   	leaveq 
  800420fcca:	c3                   	retq   

000000800420fccb <strstr>:

char * strstr(const char *in, const char *str)
{
  800420fccb:	55                   	push   %rbp
  800420fccc:	48 89 e5             	mov    %rsp,%rbp
  800420fccf:	48 83 ec 30          	sub    $0x30,%rsp
  800420fcd3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420fcd7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    char c;
    size_t len;

    c = *str++;
  800420fcdb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fcdf:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fce3:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420fce7:	0f b6 00             	movzbl (%rax),%eax
  800420fcea:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (!c)
  800420fced:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420fcf1:	75 06                	jne    800420fcf9 <strstr+0x2e>
        return (char *) in;	// Trivial empty string case
  800420fcf3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fcf7:	eb 6b                	jmp    800420fd64 <strstr+0x99>

    len = strlen(str);
  800420fcf9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fcfd:	48 89 c7             	mov    %rax,%rdi
  800420fd00:	48 b8 a1 f5 20 04 80 	movabs $0x800420f5a1,%rax
  800420fd07:	00 00 00 
  800420fd0a:	ff d0                	callq  *%rax
  800420fd0c:	48 98                	cltq   
  800420fd0e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    do {
        char sc;

        do {
            sc = *in++;
  800420fd12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd16:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fd1a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420fd1e:	0f b6 00             	movzbl (%rax),%eax
  800420fd21:	88 45 ef             	mov    %al,-0x11(%rbp)
            if (!sc)
  800420fd24:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420fd28:	75 07                	jne    800420fd31 <strstr+0x66>
                return (char *) 0;
  800420fd2a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fd2f:	eb 33                	jmp    800420fd64 <strstr+0x99>
        } while (sc != c);
  800420fd31:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420fd35:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420fd38:	75 d8                	jne    800420fd12 <strstr+0x47>
    } while (strncmp(in, str, len) != 0);
  800420fd3a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fd3e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420fd42:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd46:	48 89 ce             	mov    %rcx,%rsi
  800420fd49:	48 89 c7             	mov    %rax,%rdi
  800420fd4c:	48 b8 c2 f7 20 04 80 	movabs $0x800420f7c2,%rax
  800420fd53:	00 00 00 
  800420fd56:	ff d0                	callq  *%rax
  800420fd58:	85 c0                	test   %eax,%eax
  800420fd5a:	75 b6                	jne    800420fd12 <strstr+0x47>

    return (char *) (in - 1);
  800420fd5c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd60:	48 83 e8 01          	sub    $0x1,%rax
}
  800420fd64:	c9                   	leaveq 
  800420fd65:	c3                   	retq   

000000800420fd66 <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420fd66:	55                   	push   %rbp
  800420fd67:	48 89 e5             	mov    %rsp,%rbp
  800420fd6a:	48 83 ec 24          	sub    $0x24,%rsp
  800420fd6e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fd72:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fd76:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420fd79:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fd7d:	48 8b 10             	mov    (%rax),%rdx
  800420fd80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd84:	48 01 d0             	add    %rdx,%rax
  800420fd87:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420fd8b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420fd92:	00 
	switch (bytes_to_read) {
  800420fd93:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420fd96:	83 f8 02             	cmp    $0x2,%eax
  800420fd99:	0f 84 ab 00 00 00    	je     800420fe4a <_dwarf_read_lsb+0xe4>
  800420fd9f:	83 f8 02             	cmp    $0x2,%eax
  800420fda2:	7f 0e                	jg     800420fdb2 <_dwarf_read_lsb+0x4c>
  800420fda4:	83 f8 01             	cmp    $0x1,%eax
  800420fda7:	0f 84 b3 00 00 00    	je     800420fe60 <_dwarf_read_lsb+0xfa>
  800420fdad:	e9 d9 00 00 00       	jmpq   800420fe8b <_dwarf_read_lsb+0x125>
  800420fdb2:	83 f8 04             	cmp    $0x4,%eax
  800420fdb5:	74 65                	je     800420fe1c <_dwarf_read_lsb+0xb6>
  800420fdb7:	83 f8 08             	cmp    $0x8,%eax
  800420fdba:	0f 85 cb 00 00 00    	jne    800420fe8b <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420fdc0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fdc4:	48 83 c0 04          	add    $0x4,%rax
  800420fdc8:	0f b6 00             	movzbl (%rax),%eax
  800420fdcb:	0f b6 c0             	movzbl %al,%eax
  800420fdce:	48 c1 e0 20          	shl    $0x20,%rax
  800420fdd2:	48 89 c2             	mov    %rax,%rdx
  800420fdd5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fdd9:	48 83 c0 05          	add    $0x5,%rax
  800420fddd:	0f b6 00             	movzbl (%rax),%eax
  800420fde0:	0f b6 c0             	movzbl %al,%eax
  800420fde3:	48 c1 e0 28          	shl    $0x28,%rax
  800420fde7:	48 09 d0             	or     %rdx,%rax
  800420fdea:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420fdee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fdf2:	48 83 c0 06          	add    $0x6,%rax
  800420fdf6:	0f b6 00             	movzbl (%rax),%eax
  800420fdf9:	0f b6 c0             	movzbl %al,%eax
  800420fdfc:	48 c1 e0 30          	shl    $0x30,%rax
  800420fe00:	48 89 c2             	mov    %rax,%rdx
  800420fe03:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fe07:	48 83 c0 07          	add    $0x7,%rax
  800420fe0b:	0f b6 00             	movzbl (%rax),%eax
  800420fe0e:	0f b6 c0             	movzbl %al,%eax
  800420fe11:	48 c1 e0 38          	shl    $0x38,%rax
  800420fe15:	48 09 d0             	or     %rdx,%rax
  800420fe18:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420fe1c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fe20:	48 83 c0 02          	add    $0x2,%rax
  800420fe24:	0f b6 00             	movzbl (%rax),%eax
  800420fe27:	0f b6 c0             	movzbl %al,%eax
  800420fe2a:	48 c1 e0 10          	shl    $0x10,%rax
  800420fe2e:	48 89 c2             	mov    %rax,%rdx
  800420fe31:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fe35:	48 83 c0 03          	add    $0x3,%rax
  800420fe39:	0f b6 00             	movzbl (%rax),%eax
  800420fe3c:	0f b6 c0             	movzbl %al,%eax
  800420fe3f:	48 c1 e0 18          	shl    $0x18,%rax
  800420fe43:	48 09 d0             	or     %rdx,%rax
  800420fe46:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420fe4a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fe4e:	48 83 c0 01          	add    $0x1,%rax
  800420fe52:	0f b6 00             	movzbl (%rax),%eax
  800420fe55:	0f b6 c0             	movzbl %al,%eax
  800420fe58:	48 c1 e0 08          	shl    $0x8,%rax
  800420fe5c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420fe60:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fe64:	0f b6 00             	movzbl (%rax),%eax
  800420fe67:	0f b6 c0             	movzbl %al,%eax
  800420fe6a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420fe6e:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800420fe6f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe73:	48 8b 10             	mov    (%rax),%rdx
  800420fe76:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420fe79:	48 98                	cltq   
  800420fe7b:	48 01 c2             	add    %rax,%rdx
  800420fe7e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe82:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420fe85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fe89:	eb 05                	jmp    800420fe90 <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420fe8b:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800420fe90:	c9                   	leaveq 
  800420fe91:	c3                   	retq   

000000800420fe92 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800420fe92:	55                   	push   %rbp
  800420fe93:	48 89 e5             	mov    %rsp,%rbp
  800420fe96:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420fe9a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fe9e:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420fea1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fea5:	48 8b 00             	mov    (%rax),%rax
  800420fea8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420feac:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420feb3:	00 
	switch (bytes_to_read) {
  800420feb4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420feb7:	83 f8 02             	cmp    $0x2,%eax
  800420feba:	0f 84 ab 00 00 00    	je     800420ff6b <_dwarf_decode_lsb+0xd9>
  800420fec0:	83 f8 02             	cmp    $0x2,%eax
  800420fec3:	7f 0e                	jg     800420fed3 <_dwarf_decode_lsb+0x41>
  800420fec5:	83 f8 01             	cmp    $0x1,%eax
  800420fec8:	0f 84 b3 00 00 00    	je     800420ff81 <_dwarf_decode_lsb+0xef>
  800420fece:	e9 d9 00 00 00       	jmpq   800420ffac <_dwarf_decode_lsb+0x11a>
  800420fed3:	83 f8 04             	cmp    $0x4,%eax
  800420fed6:	74 65                	je     800420ff3d <_dwarf_decode_lsb+0xab>
  800420fed8:	83 f8 08             	cmp    $0x8,%eax
  800420fedb:	0f 85 cb 00 00 00    	jne    800420ffac <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420fee1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fee5:	48 83 c0 04          	add    $0x4,%rax
  800420fee9:	0f b6 00             	movzbl (%rax),%eax
  800420feec:	0f b6 c0             	movzbl %al,%eax
  800420feef:	48 c1 e0 20          	shl    $0x20,%rax
  800420fef3:	48 89 c2             	mov    %rax,%rdx
  800420fef6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fefa:	48 83 c0 05          	add    $0x5,%rax
  800420fefe:	0f b6 00             	movzbl (%rax),%eax
  800420ff01:	0f b6 c0             	movzbl %al,%eax
  800420ff04:	48 c1 e0 28          	shl    $0x28,%rax
  800420ff08:	48 09 d0             	or     %rdx,%rax
  800420ff0b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420ff0f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff13:	48 83 c0 06          	add    $0x6,%rax
  800420ff17:	0f b6 00             	movzbl (%rax),%eax
  800420ff1a:	0f b6 c0             	movzbl %al,%eax
  800420ff1d:	48 c1 e0 30          	shl    $0x30,%rax
  800420ff21:	48 89 c2             	mov    %rax,%rdx
  800420ff24:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff28:	48 83 c0 07          	add    $0x7,%rax
  800420ff2c:	0f b6 00             	movzbl (%rax),%eax
  800420ff2f:	0f b6 c0             	movzbl %al,%eax
  800420ff32:	48 c1 e0 38          	shl    $0x38,%rax
  800420ff36:	48 09 d0             	or     %rdx,%rax
  800420ff39:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420ff3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff41:	48 83 c0 02          	add    $0x2,%rax
  800420ff45:	0f b6 00             	movzbl (%rax),%eax
  800420ff48:	0f b6 c0             	movzbl %al,%eax
  800420ff4b:	48 c1 e0 10          	shl    $0x10,%rax
  800420ff4f:	48 89 c2             	mov    %rax,%rdx
  800420ff52:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff56:	48 83 c0 03          	add    $0x3,%rax
  800420ff5a:	0f b6 00             	movzbl (%rax),%eax
  800420ff5d:	0f b6 c0             	movzbl %al,%eax
  800420ff60:	48 c1 e0 18          	shl    $0x18,%rax
  800420ff64:	48 09 d0             	or     %rdx,%rax
  800420ff67:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420ff6b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff6f:	48 83 c0 01          	add    $0x1,%rax
  800420ff73:	0f b6 00             	movzbl (%rax),%eax
  800420ff76:	0f b6 c0             	movzbl %al,%eax
  800420ff79:	48 c1 e0 08          	shl    $0x8,%rax
  800420ff7d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420ff81:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff85:	0f b6 00             	movzbl (%rax),%eax
  800420ff88:	0f b6 c0             	movzbl %al,%eax
  800420ff8b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420ff8f:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800420ff90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff94:	48 8b 10             	mov    (%rax),%rdx
  800420ff97:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420ff9a:	48 98                	cltq   
  800420ff9c:	48 01 c2             	add    %rax,%rdx
  800420ff9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ffa3:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420ffa6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ffaa:	eb 05                	jmp    800420ffb1 <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420ffac:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  800420ffb1:	c9                   	leaveq 
  800420ffb2:	c3                   	retq   

000000800420ffb3 <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420ffb3:	55                   	push   %rbp
  800420ffb4:	48 89 e5             	mov    %rsp,%rbp
  800420ffb7:	48 83 ec 24          	sub    $0x24,%rsp
  800420ffbb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ffbf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ffc3:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420ffc6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ffca:	48 8b 10             	mov    (%rax),%rdx
  800420ffcd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ffd1:	48 01 d0             	add    %rdx,%rax
  800420ffd4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  800420ffd8:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420ffdb:	83 f8 02             	cmp    $0x2,%eax
  800420ffde:	74 35                	je     8004210015 <_dwarf_read_msb+0x62>
  800420ffe0:	83 f8 02             	cmp    $0x2,%eax
  800420ffe3:	7f 0a                	jg     800420ffef <_dwarf_read_msb+0x3c>
  800420ffe5:	83 f8 01             	cmp    $0x1,%eax
  800420ffe8:	74 18                	je     8004210002 <_dwarf_read_msb+0x4f>
  800420ffea:	e9 53 01 00 00       	jmpq   8004210142 <_dwarf_read_msb+0x18f>
  800420ffef:	83 f8 04             	cmp    $0x4,%eax
  800420fff2:	74 49                	je     800421003d <_dwarf_read_msb+0x8a>
  800420fff4:	83 f8 08             	cmp    $0x8,%eax
  800420fff7:	0f 84 96 00 00 00    	je     8004210093 <_dwarf_read_msb+0xe0>
  800420fffd:	e9 40 01 00 00       	jmpq   8004210142 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  8004210002:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210006:	0f b6 00             	movzbl (%rax),%eax
  8004210009:	0f b6 c0             	movzbl %al,%eax
  800421000c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210010:	e9 34 01 00 00       	jmpq   8004210149 <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  8004210015:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210019:	48 83 c0 01          	add    $0x1,%rax
  800421001d:	0f b6 00             	movzbl (%rax),%eax
  8004210020:	0f b6 d0             	movzbl %al,%edx
  8004210023:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210027:	0f b6 00             	movzbl (%rax),%eax
  800421002a:	0f b6 c0             	movzbl %al,%eax
  800421002d:	48 c1 e0 08          	shl    $0x8,%rax
  8004210031:	48 09 d0             	or     %rdx,%rax
  8004210034:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210038:	e9 0c 01 00 00       	jmpq   8004210149 <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800421003d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210041:	48 83 c0 03          	add    $0x3,%rax
  8004210045:	0f b6 00             	movzbl (%rax),%eax
  8004210048:	0f b6 c0             	movzbl %al,%eax
  800421004b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421004f:	48 83 c2 02          	add    $0x2,%rdx
  8004210053:	0f b6 12             	movzbl (%rdx),%edx
  8004210056:	0f b6 d2             	movzbl %dl,%edx
  8004210059:	48 c1 e2 08          	shl    $0x8,%rdx
  800421005d:	48 09 d0             	or     %rdx,%rax
  8004210060:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  8004210064:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210068:	48 83 c0 01          	add    $0x1,%rax
  800421006c:	0f b6 00             	movzbl (%rax),%eax
  800421006f:	0f b6 c0             	movzbl %al,%eax
  8004210072:	48 c1 e0 10          	shl    $0x10,%rax
  8004210076:	48 89 c2             	mov    %rax,%rdx
  8004210079:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421007d:	0f b6 00             	movzbl (%rax),%eax
  8004210080:	0f b6 c0             	movzbl %al,%eax
  8004210083:	48 c1 e0 18          	shl    $0x18,%rax
  8004210087:	48 09 d0             	or     %rdx,%rax
  800421008a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421008e:	e9 b6 00 00 00       	jmpq   8004210149 <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004210093:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210097:	48 83 c0 07          	add    $0x7,%rax
  800421009b:	0f b6 00             	movzbl (%rax),%eax
  800421009e:	0f b6 c0             	movzbl %al,%eax
  80042100a1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042100a5:	48 83 c2 06          	add    $0x6,%rdx
  80042100a9:	0f b6 12             	movzbl (%rdx),%edx
  80042100ac:	0f b6 d2             	movzbl %dl,%edx
  80042100af:	48 c1 e2 08          	shl    $0x8,%rdx
  80042100b3:	48 09 d0             	or     %rdx,%rax
  80042100b6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  80042100ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100be:	48 83 c0 05          	add    $0x5,%rax
  80042100c2:	0f b6 00             	movzbl (%rax),%eax
  80042100c5:	0f b6 c0             	movzbl %al,%eax
  80042100c8:	48 c1 e0 10          	shl    $0x10,%rax
  80042100cc:	48 89 c2             	mov    %rax,%rdx
  80042100cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100d3:	48 83 c0 04          	add    $0x4,%rax
  80042100d7:	0f b6 00             	movzbl (%rax),%eax
  80042100da:	0f b6 c0             	movzbl %al,%eax
  80042100dd:	48 c1 e0 18          	shl    $0x18,%rax
  80042100e1:	48 09 d0             	or     %rdx,%rax
  80042100e4:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  80042100e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100ec:	48 83 c0 03          	add    $0x3,%rax
  80042100f0:	0f b6 00             	movzbl (%rax),%eax
  80042100f3:	0f b6 c0             	movzbl %al,%eax
  80042100f6:	48 c1 e0 20          	shl    $0x20,%rax
  80042100fa:	48 89 c2             	mov    %rax,%rdx
  80042100fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210101:	48 83 c0 02          	add    $0x2,%rax
  8004210105:	0f b6 00             	movzbl (%rax),%eax
  8004210108:	0f b6 c0             	movzbl %al,%eax
  800421010b:	48 c1 e0 28          	shl    $0x28,%rax
  800421010f:	48 09 d0             	or     %rdx,%rax
  8004210112:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  8004210116:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421011a:	48 83 c0 01          	add    $0x1,%rax
  800421011e:	0f b6 00             	movzbl (%rax),%eax
  8004210121:	0f b6 c0             	movzbl %al,%eax
  8004210124:	48 c1 e0 30          	shl    $0x30,%rax
  8004210128:	48 89 c2             	mov    %rax,%rdx
  800421012b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421012f:	0f b6 00             	movzbl (%rax),%eax
  8004210132:	0f b6 c0             	movzbl %al,%eax
  8004210135:	48 c1 e0 38          	shl    $0x38,%rax
  8004210139:	48 09 d0             	or     %rdx,%rax
  800421013c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210140:	eb 07                	jmp    8004210149 <_dwarf_read_msb+0x196>
	default:
		return (0);
  8004210142:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210147:	eb 1a                	jmp    8004210163 <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  8004210149:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421014d:	48 8b 10             	mov    (%rax),%rdx
  8004210150:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210153:	48 98                	cltq   
  8004210155:	48 01 c2             	add    %rax,%rdx
  8004210158:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421015c:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421015f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210163:	c9                   	leaveq 
  8004210164:	c3                   	retq   

0000008004210165 <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  8004210165:	55                   	push   %rbp
  8004210166:	48 89 e5             	mov    %rsp,%rbp
  8004210169:	48 83 ec 1c          	sub    $0x1c,%rsp
  800421016d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210171:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  8004210174:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210178:	48 8b 00             	mov    (%rax),%rax
  800421017b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800421017f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210186:	00 
	switch (bytes_to_read) {
  8004210187:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421018a:	83 f8 02             	cmp    $0x2,%eax
  800421018d:	74 35                	je     80042101c4 <_dwarf_decode_msb+0x5f>
  800421018f:	83 f8 02             	cmp    $0x2,%eax
  8004210192:	7f 0a                	jg     800421019e <_dwarf_decode_msb+0x39>
  8004210194:	83 f8 01             	cmp    $0x1,%eax
  8004210197:	74 18                	je     80042101b1 <_dwarf_decode_msb+0x4c>
  8004210199:	e9 53 01 00 00       	jmpq   80042102f1 <_dwarf_decode_msb+0x18c>
  800421019e:	83 f8 04             	cmp    $0x4,%eax
  80042101a1:	74 49                	je     80042101ec <_dwarf_decode_msb+0x87>
  80042101a3:	83 f8 08             	cmp    $0x8,%eax
  80042101a6:	0f 84 96 00 00 00    	je     8004210242 <_dwarf_decode_msb+0xdd>
  80042101ac:	e9 40 01 00 00       	jmpq   80042102f1 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  80042101b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101b5:	0f b6 00             	movzbl (%rax),%eax
  80042101b8:	0f b6 c0             	movzbl %al,%eax
  80042101bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042101bf:	e9 34 01 00 00       	jmpq   80042102f8 <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  80042101c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101c8:	48 83 c0 01          	add    $0x1,%rax
  80042101cc:	0f b6 00             	movzbl (%rax),%eax
  80042101cf:	0f b6 d0             	movzbl %al,%edx
  80042101d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101d6:	0f b6 00             	movzbl (%rax),%eax
  80042101d9:	0f b6 c0             	movzbl %al,%eax
  80042101dc:	48 c1 e0 08          	shl    $0x8,%rax
  80042101e0:	48 09 d0             	or     %rdx,%rax
  80042101e3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042101e7:	e9 0c 01 00 00       	jmpq   80042102f8 <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  80042101ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101f0:	48 83 c0 03          	add    $0x3,%rax
  80042101f4:	0f b6 00             	movzbl (%rax),%eax
  80042101f7:	0f b6 c0             	movzbl %al,%eax
  80042101fa:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042101fe:	48 83 c2 02          	add    $0x2,%rdx
  8004210202:	0f b6 12             	movzbl (%rdx),%edx
  8004210205:	0f b6 d2             	movzbl %dl,%edx
  8004210208:	48 c1 e2 08          	shl    $0x8,%rdx
  800421020c:	48 09 d0             	or     %rdx,%rax
  800421020f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  8004210213:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210217:	48 83 c0 01          	add    $0x1,%rax
  800421021b:	0f b6 00             	movzbl (%rax),%eax
  800421021e:	0f b6 c0             	movzbl %al,%eax
  8004210221:	48 c1 e0 10          	shl    $0x10,%rax
  8004210225:	48 89 c2             	mov    %rax,%rdx
  8004210228:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421022c:	0f b6 00             	movzbl (%rax),%eax
  800421022f:	0f b6 c0             	movzbl %al,%eax
  8004210232:	48 c1 e0 18          	shl    $0x18,%rax
  8004210236:	48 09 d0             	or     %rdx,%rax
  8004210239:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421023d:	e9 b6 00 00 00       	jmpq   80042102f8 <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004210242:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210246:	48 83 c0 07          	add    $0x7,%rax
  800421024a:	0f b6 00             	movzbl (%rax),%eax
  800421024d:	0f b6 c0             	movzbl %al,%eax
  8004210250:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210254:	48 83 c2 06          	add    $0x6,%rdx
  8004210258:	0f b6 12             	movzbl (%rdx),%edx
  800421025b:	0f b6 d2             	movzbl %dl,%edx
  800421025e:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210262:	48 09 d0             	or     %rdx,%rax
  8004210265:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  8004210269:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421026d:	48 83 c0 05          	add    $0x5,%rax
  8004210271:	0f b6 00             	movzbl (%rax),%eax
  8004210274:	0f b6 c0             	movzbl %al,%eax
  8004210277:	48 c1 e0 10          	shl    $0x10,%rax
  800421027b:	48 89 c2             	mov    %rax,%rdx
  800421027e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210282:	48 83 c0 04          	add    $0x4,%rax
  8004210286:	0f b6 00             	movzbl (%rax),%eax
  8004210289:	0f b6 c0             	movzbl %al,%eax
  800421028c:	48 c1 e0 18          	shl    $0x18,%rax
  8004210290:	48 09 d0             	or     %rdx,%rax
  8004210293:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  8004210297:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421029b:	48 83 c0 03          	add    $0x3,%rax
  800421029f:	0f b6 00             	movzbl (%rax),%eax
  80042102a2:	0f b6 c0             	movzbl %al,%eax
  80042102a5:	48 c1 e0 20          	shl    $0x20,%rax
  80042102a9:	48 89 c2             	mov    %rax,%rdx
  80042102ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102b0:	48 83 c0 02          	add    $0x2,%rax
  80042102b4:	0f b6 00             	movzbl (%rax),%eax
  80042102b7:	0f b6 c0             	movzbl %al,%eax
  80042102ba:	48 c1 e0 28          	shl    $0x28,%rax
  80042102be:	48 09 d0             	or     %rdx,%rax
  80042102c1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  80042102c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102c9:	48 83 c0 01          	add    $0x1,%rax
  80042102cd:	0f b6 00             	movzbl (%rax),%eax
  80042102d0:	0f b6 c0             	movzbl %al,%eax
  80042102d3:	48 c1 e0 30          	shl    $0x30,%rax
  80042102d7:	48 89 c2             	mov    %rax,%rdx
  80042102da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102de:	0f b6 00             	movzbl (%rax),%eax
  80042102e1:	0f b6 c0             	movzbl %al,%eax
  80042102e4:	48 c1 e0 38          	shl    $0x38,%rax
  80042102e8:	48 09 d0             	or     %rdx,%rax
  80042102eb:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  80042102ef:	eb 07                	jmp    80042102f8 <_dwarf_decode_msb+0x193>
	default:
		return (0);
  80042102f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042102f6:	eb 1a                	jmp    8004210312 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  80042102f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102fc:	48 8b 10             	mov    (%rax),%rdx
  80042102ff:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210302:	48 98                	cltq   
  8004210304:	48 01 c2             	add    %rax,%rdx
  8004210307:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421030b:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421030e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210312:	c9                   	leaveq 
  8004210313:	c3                   	retq   

0000008004210314 <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  8004210314:	55                   	push   %rbp
  8004210315:	48 89 e5             	mov    %rsp,%rbp
  8004210318:	48 83 ec 30          	sub    $0x30,%rsp
  800421031c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210320:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  8004210324:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421032b:	00 
	uint8_t b;
	int shift = 0;
  800421032c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004210333:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210337:	48 8b 10             	mov    (%rax),%rdx
  800421033a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421033e:	48 01 d0             	add    %rdx,%rax
  8004210341:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004210345:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210349:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421034d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210351:	0f b6 00             	movzbl (%rax),%eax
  8004210354:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210357:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421035b:	83 e0 7f             	and    $0x7f,%eax
  800421035e:	89 c2                	mov    %eax,%edx
  8004210360:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210363:	89 c1                	mov    %eax,%ecx
  8004210365:	d3 e2                	shl    %cl,%edx
  8004210367:	89 d0                	mov    %edx,%eax
  8004210369:	48 98                	cltq   
  800421036b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800421036f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210373:	48 8b 00             	mov    (%rax),%rax
  8004210376:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421037a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421037e:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004210381:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004210385:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210389:	84 c0                	test   %al,%al
  800421038b:	78 b8                	js     8004210345 <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  800421038d:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004210391:	7f 1f                	jg     80042103b2 <_dwarf_read_sleb128+0x9e>
  8004210393:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210397:	83 e0 40             	and    $0x40,%eax
  800421039a:	85 c0                	test   %eax,%eax
  800421039c:	74 14                	je     80042103b2 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  800421039e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042103a1:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80042103a6:	89 c1                	mov    %eax,%ecx
  80042103a8:	d3 e2                	shl    %cl,%edx
  80042103aa:	89 d0                	mov    %edx,%eax
  80042103ac:	48 98                	cltq   
  80042103ae:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  80042103b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042103b6:	c9                   	leaveq 
  80042103b7:	c3                   	retq   

00000080042103b8 <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  80042103b8:	55                   	push   %rbp
  80042103b9:	48 89 e5             	mov    %rsp,%rbp
  80042103bc:	48 83 ec 30          	sub    $0x30,%rsp
  80042103c0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042103c4:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  80042103c8:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042103cf:	00 
	uint8_t b;
	int shift = 0;
  80042103d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  80042103d7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042103db:	48 8b 10             	mov    (%rax),%rdx
  80042103de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042103e2:	48 01 d0             	add    %rdx,%rax
  80042103e5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  80042103e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103ed:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042103f1:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042103f5:	0f b6 00             	movzbl (%rax),%eax
  80042103f8:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  80042103fb:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042103ff:	83 e0 7f             	and    $0x7f,%eax
  8004210402:	89 c2                	mov    %eax,%edx
  8004210404:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210407:	89 c1                	mov    %eax,%ecx
  8004210409:	d3 e2                	shl    %cl,%edx
  800421040b:	89 d0                	mov    %edx,%eax
  800421040d:	48 98                	cltq   
  800421040f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  8004210413:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210417:	48 8b 00             	mov    (%rax),%rax
  800421041a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421041e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210422:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004210425:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004210429:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421042d:	84 c0                	test   %al,%al
  800421042f:	78 b8                	js     80042103e9 <_dwarf_read_uleb128+0x31>

	return (ret);
  8004210431:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210435:	c9                   	leaveq 
  8004210436:	c3                   	retq   

0000008004210437 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  8004210437:	55                   	push   %rbp
  8004210438:	48 89 e5             	mov    %rsp,%rbp
  800421043b:	48 83 ec 28          	sub    $0x28,%rsp
  800421043f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  8004210443:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421044a:	00 
	uint8_t b;
	int shift = 0;
  800421044b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  8004210452:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210456:	48 8b 00             	mov    (%rax),%rax
  8004210459:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800421045d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210461:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210465:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210469:	0f b6 00             	movzbl (%rax),%eax
  800421046c:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800421046f:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210473:	83 e0 7f             	and    $0x7f,%eax
  8004210476:	89 c2                	mov    %eax,%edx
  8004210478:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421047b:	89 c1                	mov    %eax,%ecx
  800421047d:	d3 e2                	shl    %cl,%edx
  800421047f:	89 d0                	mov    %edx,%eax
  8004210481:	48 98                	cltq   
  8004210483:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  8004210487:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800421048b:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421048f:	84 c0                	test   %al,%al
  8004210491:	78 ca                	js     800421045d <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  8004210493:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004210497:	7f 1f                	jg     80042104b8 <_dwarf_decode_sleb128+0x81>
  8004210499:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421049d:	83 e0 40             	and    $0x40,%eax
  80042104a0:	85 c0                	test   %eax,%eax
  80042104a2:	74 14                	je     80042104b8 <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  80042104a4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042104a7:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80042104ac:	89 c1                	mov    %eax,%ecx
  80042104ae:	d3 e2                	shl    %cl,%edx
  80042104b0:	89 d0                	mov    %edx,%eax
  80042104b2:	48 98                	cltq   
  80042104b4:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  80042104b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042104bc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042104c0:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042104c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042104c7:	c9                   	leaveq 
  80042104c8:	c3                   	retq   

00000080042104c9 <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  80042104c9:	55                   	push   %rbp
  80042104ca:	48 89 e5             	mov    %rsp,%rbp
  80042104cd:	48 83 ec 28          	sub    $0x28,%rsp
  80042104d1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  80042104d5:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042104dc:	00 
	uint8_t b;
	int shift = 0;
  80042104dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  80042104e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042104e8:	48 8b 00             	mov    (%rax),%rax
  80042104eb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  80042104ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104f3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042104f7:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042104fb:	0f b6 00             	movzbl (%rax),%eax
  80042104fe:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210501:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210505:	83 e0 7f             	and    $0x7f,%eax
  8004210508:	89 c2                	mov    %eax,%edx
  800421050a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421050d:	89 c1                	mov    %eax,%ecx
  800421050f:	d3 e2                	shl    %cl,%edx
  8004210511:	89 d0                	mov    %edx,%eax
  8004210513:	48 98                	cltq   
  8004210515:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  8004210519:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800421051d:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210521:	84 c0                	test   %al,%al
  8004210523:	78 ca                	js     80042104ef <_dwarf_decode_uleb128+0x26>

	*dp = src;
  8004210525:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210529:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421052d:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210530:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210534:	c9                   	leaveq 
  8004210535:	c3                   	retq   

0000008004210536 <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  8004210536:	55                   	push   %rbp
  8004210537:	48 89 e5             	mov    %rsp,%rbp
  800421053a:	48 83 ec 28          	sub    $0x28,%rsp
  800421053e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210542:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210546:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  800421054a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421054e:	48 8b 10             	mov    (%rax),%rdx
  8004210551:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210555:	48 01 d0             	add    %rdx,%rax
  8004210558:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421055c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210560:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  8004210564:	eb 17                	jmp    800421057d <_dwarf_read_string+0x47>
		src++;
  8004210566:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  800421056b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421056f:	48 8b 00             	mov    (%rax),%rax
  8004210572:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210576:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421057a:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  800421057d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210581:	0f b6 00             	movzbl (%rax),%eax
  8004210584:	84 c0                	test   %al,%al
  8004210586:	74 0d                	je     8004210595 <_dwarf_read_string+0x5f>
  8004210588:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421058c:	48 8b 00             	mov    (%rax),%rax
  800421058f:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004210593:	72 d1                	jb     8004210566 <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  8004210595:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210599:	0f b6 00             	movzbl (%rax),%eax
  800421059c:	84 c0                	test   %al,%al
  800421059e:	75 1f                	jne    80042105bf <_dwarf_read_string+0x89>
  80042105a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042105a4:	48 8b 00             	mov    (%rax),%rax
  80042105a7:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042105ab:	73 12                	jae    80042105bf <_dwarf_read_string+0x89>
		(*offsetp)++;
  80042105ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042105b1:	48 8b 00             	mov    (%rax),%rax
  80042105b4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042105b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042105bc:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042105bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042105c3:	c9                   	leaveq 
  80042105c4:	c3                   	retq   

00000080042105c5 <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  80042105c5:	55                   	push   %rbp
  80042105c6:	48 89 e5             	mov    %rsp,%rbp
  80042105c9:	48 83 ec 28          	sub    $0x28,%rsp
  80042105cd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042105d1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042105d5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  80042105d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042105dd:	48 8b 10             	mov    (%rax),%rdx
  80042105e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042105e4:	48 01 d0             	add    %rdx,%rax
  80042105e7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042105eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042105ef:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  80042105f3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042105f7:	48 8b 10             	mov    (%rax),%rdx
  80042105fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042105fe:	48 01 c2             	add    %rax,%rdx
  8004210601:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210605:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210608:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800421060c:	c9                   	leaveq 
  800421060d:	c3                   	retq   

000000800421060e <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  800421060e:	55                   	push   %rbp
  800421060f:	48 89 e5             	mov    %rsp,%rbp
  8004210612:	48 83 ec 20          	sub    $0x20,%rsp
  8004210616:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Elf *e;

    e = (Elf *)obj;
  800421061a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421061e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    assert(e != NULL);
  8004210622:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210627:	75 35                	jne    800421065e <_dwarf_elf_get_byte_order+0x50>
  8004210629:	48 b9 18 90 21 04 80 	movabs $0x8004219018,%rcx
  8004210630:	00 00 00 
  8004210633:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  800421063a:	00 00 00 
  800421063d:	be 29 01 00 00       	mov    $0x129,%esi
  8004210642:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  8004210649:	00 00 00 
  800421064c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210651:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004210658:	00 00 00 
  800421065b:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
    switch (e->e_ident[EI_DATA]) {
  800421065e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210662:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  8004210666:	0f b6 c0             	movzbl %al,%eax
  8004210669:	83 f8 02             	cmp    $0x2,%eax
  800421066c:	75 07                	jne    8004210675 <_dwarf_elf_get_byte_order+0x67>
    case ELFDATA2MSB:
        return (DW_OBJECT_MSB);
  800421066e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210673:	eb 05                	jmp    800421067a <_dwarf_elf_get_byte_order+0x6c>

    case ELFDATA2LSB:
    case ELFDATANONE:
    default:
        return (DW_OBJECT_LSB);
  8004210675:	b8 01 00 00 00       	mov    $0x1,%eax
    }
}
  800421067a:	c9                   	leaveq 
  800421067b:	c3                   	retq   

000000800421067c <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  800421067c:	55                   	push   %rbp
  800421067d:	48 89 e5             	mov    %rsp,%rbp
  8004210680:	48 83 ec 20          	sub    $0x20,%rsp
  8004210684:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Elf *e;

    e = (Elf *) obj;
  8004210688:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421068c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    assert(e != NULL);
  8004210690:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210695:	75 35                	jne    80042106cc <_dwarf_elf_get_pointer_size+0x50>
  8004210697:	48 b9 18 90 21 04 80 	movabs $0x8004219018,%rcx
  800421069e:	00 00 00 
  80042106a1:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  80042106a8:	00 00 00 
  80042106ab:	be 3f 01 00 00       	mov    $0x13f,%esi
  80042106b0:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  80042106b7:	00 00 00 
  80042106ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042106bf:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042106c6:	00 00 00 
  80042106c9:	41 ff d0             	callq  *%r8

    if (e->e_ident[4] == ELFCLASS32)
  80042106cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042106d0:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  80042106d4:	3c 01                	cmp    $0x1,%al
  80042106d6:	75 07                	jne    80042106df <_dwarf_elf_get_pointer_size+0x63>
        return (4);
  80042106d8:	b8 04 00 00 00       	mov    $0x4,%eax
  80042106dd:	eb 05                	jmp    80042106e4 <_dwarf_elf_get_pointer_size+0x68>
    else
        return (8);
  80042106df:	b8 08 00 00 00       	mov    $0x8,%eax
}
  80042106e4:	c9                   	leaveq 
  80042106e5:	c3                   	retq   

00000080042106e6 <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  80042106e6:	55                   	push   %rbp
  80042106e7:	48 89 e5             	mov    %rsp,%rbp
  80042106ea:	53                   	push   %rbx
  80042106eb:	48 83 ec 18          	sub    $0x18,%rsp
  80042106ef:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042106f3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  80042106f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042106fb:	ba 60 00 00 00       	mov    $0x60,%edx
  8004210700:	be 00 00 00 00       	mov    $0x0,%esi
  8004210705:	48 89 c7             	mov    %rax,%rdi
  8004210708:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  800421070f:	00 00 00 
  8004210712:	ff d0                	callq  *%rax
    dbg->curr_off_dbginfo = 0;
  8004210714:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210718:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    dbg->dbg_info_size = 0;
  800421071f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210723:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800421072a:	00 
    dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  800421072b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421072f:	48 89 c7             	mov    %rax,%rdi
  8004210732:	48 b8 7c 06 21 04 80 	movabs $0x800421067c,%rax
  8004210739:	00 00 00 
  800421073c:	ff d0                	callq  *%rax
  800421073e:	0f b6 d0             	movzbl %al,%edx
  8004210741:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210745:	89 50 28             	mov    %edx,0x28(%rax)

    if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  8004210748:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421074c:	48 89 c7             	mov    %rax,%rdi
  800421074f:	48 b8 0e 06 21 04 80 	movabs $0x800421060e,%rax
  8004210756:	00 00 00 
  8004210759:	ff d0                	callq  *%rax
  800421075b:	85 c0                	test   %eax,%eax
  800421075d:	75 26                	jne    8004210785 <_dwarf_init+0x9f>
        dbg->read = _dwarf_read_msb;
  800421075f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210763:	48 b9 b3 ff 20 04 80 	movabs $0x800420ffb3,%rcx
  800421076a:	00 00 00 
  800421076d:	48 89 48 18          	mov    %rcx,0x18(%rax)
        dbg->decode = _dwarf_decode_msb;
  8004210771:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210775:	48 bb 65 01 21 04 80 	movabs $0x8004210165,%rbx
  800421077c:	00 00 00 
  800421077f:	48 89 58 20          	mov    %rbx,0x20(%rax)
  8004210783:	eb 24                	jmp    80042107a9 <_dwarf_init+0xc3>
    } else {
        dbg->read = _dwarf_read_lsb;
  8004210785:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210789:	48 b9 66 fd 20 04 80 	movabs $0x800420fd66,%rcx
  8004210790:	00 00 00 
  8004210793:	48 89 48 18          	mov    %rcx,0x18(%rax)
        dbg->decode = _dwarf_decode_lsb;
  8004210797:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421079b:	48 be 92 fe 20 04 80 	movabs $0x800420fe92,%rsi
  80042107a2:	00 00 00 
  80042107a5:	48 89 70 20          	mov    %rsi,0x20(%rax)
    }
   _dwarf_frame_params_init(dbg);
  80042107a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107ad:	48 89 c7             	mov    %rax,%rdi
  80042107b0:	48 b8 b3 1c 21 04 80 	movabs $0x8004211cb3,%rax
  80042107b7:	00 00 00 
  80042107ba:	ff d0                	callq  *%rax
   return 0;
  80042107bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042107c1:	48 83 c4 18          	add    $0x18,%rsp
  80042107c5:	5b                   	pop    %rbx
  80042107c6:	5d                   	pop    %rbp
  80042107c7:	c3                   	retq   

00000080042107c8 <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  80042107c8:	55                   	push   %rbp
  80042107c9:	48 89 e5             	mov    %rsp,%rbp
  80042107cc:	48 83 ec 20          	sub    $0x20,%rsp
  80042107d0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042107d4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    uint32_t length;
    uint64_t offset;
    uint8_t dwarf_size;

    if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  80042107d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107dc:	48 8b 10             	mov    (%rax),%rdx
  80042107df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107e3:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042107e7:	48 39 c2             	cmp    %rax,%rdx
  80042107ea:	76 0a                	jbe    80042107f6 <_get_next_cu+0x2e>
        return -1;
  80042107ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042107f1:	e9 6b 01 00 00       	jmpq   8004210961 <_get_next_cu+0x199>

    offset = dbg->curr_off_dbginfo;
  80042107f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107fa:	48 8b 00             	mov    (%rax),%rax
  80042107fd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  8004210801:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210805:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210809:	48 89 50 30          	mov    %rdx,0x30(%rax)

    length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  800421080d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210811:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210815:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210819:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800421081d:	48 89 d1             	mov    %rdx,%rcx
  8004210820:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210824:	ba 04 00 00 00       	mov    $0x4,%edx
  8004210829:	48 89 cf             	mov    %rcx,%rdi
  800421082c:	ff d0                	callq  *%rax
  800421082e:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (length == 0xffffffff) {
  8004210831:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004210835:	75 2a                	jne    8004210861 <_get_next_cu+0x99>
        length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  8004210837:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421083b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421083f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210843:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210847:	48 89 d1             	mov    %rdx,%rcx
  800421084a:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800421084e:	ba 08 00 00 00       	mov    $0x8,%edx
  8004210853:	48 89 cf             	mov    %rcx,%rdi
  8004210856:	ff d0                	callq  *%rax
  8004210858:	89 45 fc             	mov    %eax,-0x4(%rbp)
        dwarf_size = 8;
  800421085b:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  800421085f:	eb 04                	jmp    8004210865 <_get_next_cu+0x9d>
    } else {
        dwarf_size = 4;
  8004210861:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
    }

    cu->cu_dwarf_size = dwarf_size;
  8004210865:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210869:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800421086d:	88 50 19             	mov    %dl,0x19(%rax)
	if (length > ds->ds_size - offset) {
		return (DW_DLE_CU_LENGTH_ERROR);
	}*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  8004210870:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004210873:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210877:	48 01 c2             	add    %rax,%rdx
  800421087a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421087e:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  8004210881:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210885:	48 8b 10             	mov    (%rax),%rdx
  8004210888:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421088c:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  8004210890:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004210893:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210897:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  800421089a:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  800421089e:	75 07                	jne    80042108a7 <_get_next_cu+0xdf>
  80042108a0:	b8 04 00 00 00       	mov    $0x4,%eax
  80042108a5:	eb 05                	jmp    80042108ac <_get_next_cu+0xe4>
  80042108a7:	b8 0c 00 00 00       	mov    $0xc,%eax
  80042108ac:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042108b0:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  80042108b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108b7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042108bb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042108bf:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80042108c3:	48 89 d1             	mov    %rdx,%rcx
  80042108c6:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  80042108ca:	ba 02 00 00 00       	mov    $0x2,%edx
  80042108cf:	48 89 cf             	mov    %rcx,%rdi
  80042108d2:	ff d0                	callq  *%rax
  80042108d4:	89 c2                	mov    %eax,%edx
  80042108d6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042108da:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  80042108de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108e2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042108e6:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  80042108ea:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042108ee:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  80042108f2:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  80042108f6:	48 89 cf             	mov    %rcx,%rdi
  80042108f9:	ff d0                	callq  *%rax
  80042108fb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042108ff:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  8004210903:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210907:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421090b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421090f:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210913:	48 89 d1             	mov    %rdx,%rcx
  8004210916:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800421091a:	ba 01 00 00 00       	mov    $0x1,%edx
  800421091f:	48 89 cf             	mov    %rcx,%rdi
  8004210922:	ff d0                	callq  *%rax
  8004210924:	89 c2                	mov    %eax,%edx
  8004210926:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421092a:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  800421092d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210931:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210935:	66 83 f8 01          	cmp    $0x1,%ax
  8004210939:	76 0e                	jbe    8004210949 <_get_next_cu+0x181>
  800421093b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421093f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210943:	66 83 f8 04          	cmp    $0x4,%ax
  8004210947:	76 07                	jbe    8004210950 <_get_next_cu+0x188>
		return -1;
  8004210949:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421094e:	eb 11                	jmp    8004210961 <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  8004210950:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210954:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210958:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  800421095c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210961:	c9                   	leaveq 
  8004210962:	c3                   	retq   

0000008004210963 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  8004210963:	55                   	push   %rbp
  8004210964:	48 89 e5             	mov    %rsp,%rbp
    cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  8004210967:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  800421096b:	0f b6 c8             	movzbl %al,%ecx
  800421096e:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  8004210972:	0f b7 d0             	movzwl %ax,%edx
  8004210975:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8004210979:	48 89 c6             	mov    %rax,%rsi
  800421097c:	48 bf 4a 90 21 04 80 	movabs $0x800421904a,%rdi
  8004210983:	00 00 00 
  8004210986:	b8 00 00 00 00       	mov    $0x0,%eax
  800421098b:	49 b8 99 8d 20 04 80 	movabs $0x8004208d99,%r8
  8004210992:	00 00 00 
  8004210995:	41 ff d0             	callq  *%r8
}
  8004210998:	5d                   	pop    %rbp
  8004210999:	c3                   	retq   

000000800421099a <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  800421099a:	55                   	push   %rbp
  800421099b:	48 89 e5             	mov    %rsp,%rbp
  800421099e:	48 83 ec 60          	sub    $0x60,%rsp
  80042109a2:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042109a6:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  80042109aa:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  80042109ae:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    uint64_t tag;
    uint8_t children;
    uint64_t abbr_addr;
    int ret;

    assert(abp != NULL);
  80042109b2:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  80042109b7:	75 35                	jne    80042109ee <_dwarf_abbrev_parse+0x54>
  80042109b9:	48 b9 59 90 21 04 80 	movabs $0x8004219059,%rcx
  80042109c0:	00 00 00 
  80042109c3:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  80042109ca:	00 00 00 
  80042109cd:	be a4 01 00 00       	mov    $0x1a4,%esi
  80042109d2:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  80042109d9:	00 00 00 
  80042109dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042109e1:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042109e8:	00 00 00 
  80042109eb:	41 ff d0             	callq  *%r8
    assert(ds != NULL);
  80042109ee:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  80042109f3:	75 35                	jne    8004210a2a <_dwarf_abbrev_parse+0x90>
  80042109f5:	48 b9 65 90 21 04 80 	movabs $0x8004219065,%rcx
  80042109fc:	00 00 00 
  80042109ff:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  8004210a06:	00 00 00 
  8004210a09:	be a5 01 00 00       	mov    $0x1a5,%esi
  8004210a0e:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  8004210a15:	00 00 00 
  8004210a18:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210a1d:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004210a24:	00 00 00 
  8004210a27:	41 ff d0             	callq  *%r8

    if (*offset >= ds->ds_size)
  8004210a2a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210a2e:	48 8b 10             	mov    (%rax),%rdx
  8004210a31:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210a35:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210a39:	48 39 c2             	cmp    %rax,%rdx
  8004210a3c:	72 0a                	jb     8004210a48 <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  8004210a3e:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210a43:	e9 d3 01 00 00       	jmpq   8004210c1b <_dwarf_abbrev_parse+0x281>

    aboff = *offset;
  8004210a48:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210a4c:	48 8b 00             	mov    (%rax),%rax
  8004210a4f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  8004210a53:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210a57:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210a5b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210a5f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a63:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210a67:	48 89 d6             	mov    %rdx,%rsi
  8004210a6a:	48 89 c7             	mov    %rax,%rdi
  8004210a6d:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  8004210a74:	00 00 00 
  8004210a77:	ff d0                	callq  *%rax
  8004210a79:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    if (entry == 0) {
  8004210a7d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210a82:	75 15                	jne    8004210a99 <_dwarf_abbrev_parse+0xff>
        /* Last entry. */
        //Need to make connection from below function
        abp->ab_entry = 0;
  8004210a84:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210a88:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        return DW_DLE_NONE;
  8004210a8f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210a94:	e9 82 01 00 00       	jmpq   8004210c1b <_dwarf_abbrev_parse+0x281>
    }

    tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210a99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a9d:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210aa1:	48 89 d6             	mov    %rdx,%rsi
  8004210aa4:	48 89 c7             	mov    %rax,%rdi
  8004210aa7:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  8004210aae:	00 00 00 
  8004210ab1:	ff d0                	callq  *%rax
  8004210ab3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  8004210ab7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210abb:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210abf:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004210ac3:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004210ac7:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210acc:	48 89 cf             	mov    %rcx,%rdi
  8004210acf:	ff d0                	callq  *%rax
  8004210ad1:	88 45 df             	mov    %al,-0x21(%rbp)

    abp->ab_entry    = entry;
  8004210ad4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210ad8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210adc:	48 89 10             	mov    %rdx,(%rax)
    abp->ab_tag      = tag;
  8004210adf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210ae3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210ae7:	48 89 50 08          	mov    %rdx,0x8(%rax)
    abp->ab_children = children;
  8004210aeb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210aef:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  8004210af3:	88 50 10             	mov    %dl,0x10(%rax)
    abp->ab_offset   = aboff;
  8004210af6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210afa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210afe:	48 89 50 18          	mov    %rdx,0x18(%rax)
    abp->ab_length   = 0;    /* fill in later. */
  8004210b02:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210b06:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  8004210b0d:	00 
    abp->ab_atnum    = 0;
  8004210b0e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210b12:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  8004210b19:	00 

    /* Parse attribute definitions. */
    do {
        adoff = *offset;
  8004210b1a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210b1e:	48 8b 00             	mov    (%rax),%rax
  8004210b21:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210b25:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b29:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210b2d:	48 89 d6             	mov    %rdx,%rsi
  8004210b30:	48 89 c7             	mov    %rax,%rdi
  8004210b33:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  8004210b3a:	00 00 00 
  8004210b3d:	ff d0                	callq  *%rax
  8004210b3f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210b43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b47:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210b4b:	48 89 d6             	mov    %rdx,%rsi
  8004210b4e:	48 89 c7             	mov    %rax,%rdi
  8004210b51:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  8004210b58:	00 00 00 
  8004210b5b:	ff d0                	callq  *%rax
  8004210b5d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        if (attr != 0)
  8004210b61:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210b66:	0f 84 89 00 00 00    	je     8004210bf5 <_dwarf_abbrev_parse+0x25b>
        {
            /* Initialise the attribute definition structure. */
            abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  8004210b6c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210b70:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210b74:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210b78:	48 89 d0             	mov    %rdx,%rax
  8004210b7b:	48 01 c0             	add    %rax,%rax
  8004210b7e:	48 01 d0             	add    %rdx,%rax
  8004210b81:	48 c1 e0 03          	shl    $0x3,%rax
  8004210b85:	48 01 c8             	add    %rcx,%rax
  8004210b88:	48 8d 50 30          	lea    0x30(%rax),%rdx
  8004210b8c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210b90:	48 89 02             	mov    %rax,(%rdx)
            abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  8004210b93:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210b97:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210b9b:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210b9f:	48 89 d0             	mov    %rdx,%rax
  8004210ba2:	48 01 c0             	add    %rax,%rax
  8004210ba5:	48 01 d0             	add    %rdx,%rax
  8004210ba8:	48 c1 e0 03          	shl    $0x3,%rax
  8004210bac:	48 01 c8             	add    %rcx,%rax
  8004210baf:	48 8d 50 38          	lea    0x38(%rax),%rdx
  8004210bb3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210bb7:	48 89 02             	mov    %rax,(%rdx)
            abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  8004210bba:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210bbe:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210bc2:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210bc6:	48 89 d0             	mov    %rdx,%rax
  8004210bc9:	48 01 c0             	add    %rax,%rax
  8004210bcc:	48 01 d0             	add    %rdx,%rax
  8004210bcf:	48 c1 e0 03          	shl    $0x3,%rax
  8004210bd3:	48 01 c8             	add    %rcx,%rax
  8004210bd6:	48 8d 50 40          	lea    0x40(%rax),%rdx
  8004210bda:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210bde:	48 89 02             	mov    %rax,(%rdx)
            abp->ab_atnum++;
  8004210be1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210be5:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210be9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210bed:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210bf1:	48 89 50 28          	mov    %rdx,0x28(%rax)
        }
    } while (attr != 0);
  8004210bf5:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210bfa:	0f 85 1a ff ff ff    	jne    8004210b1a <_dwarf_abbrev_parse+0x180>

    //(*abp)->ab_length = *offset - aboff;
    abp->ab_length = (uint64_t)(*offset - aboff);
  8004210c00:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210c04:	48 8b 00             	mov    (%rax),%rax
  8004210c07:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004210c0b:	48 89 c2             	mov    %rax,%rdx
  8004210c0e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210c12:	48 89 50 20          	mov    %rdx,0x20(%rax)

    return DW_DLV_OK;
  8004210c16:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210c1b:	c9                   	leaveq 
  8004210c1c:	c3                   	retq   

0000008004210c1d <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  8004210c1d:	55                   	push   %rbp
  8004210c1e:	48 89 e5             	mov    %rsp,%rbp
  8004210c21:	48 83 ec 70          	sub    $0x70,%rsp
  8004210c25:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210c29:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210c2d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    Dwarf_Section *ds;
    uint64_t offset;
    int ret;

    if (entry == 0)
  8004210c31:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210c36:	75 0a                	jne    8004210c42 <_dwarf_abbrev_find+0x25>
    {
		return (DW_DLE_NO_ENTRY);
  8004210c38:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210c3d:	e9 0a 01 00 00       	jmpq   8004210d4c <_dwarf_abbrev_find+0x12f>
    }

    /* Load and search the abbrev table. */
    ds = _dwarf_find_section(".debug_abbrev");
  8004210c42:	48 bf 70 90 21 04 80 	movabs $0x8004219070,%rdi
  8004210c49:	00 00 00 
  8004210c4c:	48 b8 4d 4f 21 04 80 	movabs $0x8004214f4d,%rax
  8004210c53:	00 00 00 
  8004210c56:	ff d0                	callq  *%rax
  8004210c58:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    assert(ds != NULL);
  8004210c5c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210c61:	75 35                	jne    8004210c98 <_dwarf_abbrev_find+0x7b>
  8004210c63:	48 b9 65 90 21 04 80 	movabs $0x8004219065,%rcx
  8004210c6a:	00 00 00 
  8004210c6d:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  8004210c74:	00 00 00 
  8004210c77:	be e5 01 00 00       	mov    $0x1e5,%esi
  8004210c7c:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  8004210c83:	00 00 00 
  8004210c86:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c8b:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004210c92:	00 00 00 
  8004210c95:	41 ff d0             	callq  *%r8

    //TODO: We are starting offset from 0, however libdwarf logic
    //      is keeping a counter for current offset. Ok. let use
    //      that. I relent, but this will be done in Phase 2. :)
    //offset = 0; //cu->cu_abbrev_offset_cur;
    offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  8004210c98:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210c9c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    while (offset < ds->ds_size) {
  8004210ca0:	e9 8d 00 00 00       	jmpq   8004210d32 <_dwarf_abbrev_find+0x115>
        ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  8004210ca5:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004210ca9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210cad:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  8004210cb1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210cb5:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004210cb9:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210cbd:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  8004210cc1:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004210cc6:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  8004210cca:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004210ccf:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  8004210cd3:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004210cd8:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  8004210cdc:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004210ce1:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  8004210ce5:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004210cea:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  8004210cee:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  8004210cf3:	48 89 c7             	mov    %rax,%rdi
  8004210cf6:	48 b8 9a 09 21 04 80 	movabs $0x800421099a,%rax
  8004210cfd:	00 00 00 
  8004210d00:	ff d0                	callq  *%rax
  8004210d02:	89 45 f4             	mov    %eax,-0xc(%rbp)
        if (ret != DW_DLE_NONE)
  8004210d05:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004210d09:	74 05                	je     8004210d10 <_dwarf_abbrev_find+0xf3>
            return (ret);
  8004210d0b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210d0e:	eb 3c                	jmp    8004210d4c <_dwarf_abbrev_find+0x12f>
        if (abp->ab_entry == entry) {
  8004210d10:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210d14:	48 8b 00             	mov    (%rax),%rax
  8004210d17:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004210d1b:	75 07                	jne    8004210d24 <_dwarf_abbrev_find+0x107>
            //cu->cu_abbrev_offset_cur = offset;
            return DW_DLE_NONE;
  8004210d1d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210d22:	eb 28                	jmp    8004210d4c <_dwarf_abbrev_find+0x12f>
        }
        if (abp->ab_entry == 0) {
  8004210d24:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210d28:	48 8b 00             	mov    (%rax),%rax
  8004210d2b:	48 85 c0             	test   %rax,%rax
  8004210d2e:	75 02                	jne    8004210d32 <_dwarf_abbrev_find+0x115>
            //cu->cu_abbrev_offset_cur = offset;
            //cu->cu_abbrev_loaded = 1;
            break;
  8004210d30:	eb 15                	jmp    8004210d47 <_dwarf_abbrev_find+0x12a>
    //TODO: We are starting offset from 0, however libdwarf logic
    //      is keeping a counter for current offset. Ok. let use
    //      that. I relent, but this will be done in Phase 2. :)
    //offset = 0; //cu->cu_abbrev_offset_cur;
    offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
    while (offset < ds->ds_size) {
  8004210d32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210d36:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210d3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d3e:	48 39 c2             	cmp    %rax,%rdx
  8004210d41:	0f 87 5e ff ff ff    	ja     8004210ca5 <_dwarf_abbrev_find+0x88>
            //cu->cu_abbrev_loaded = 1;
            break;
        }
    }

    return DW_DLE_NO_ENTRY;
  8004210d47:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004210d4c:	c9                   	leaveq 
  8004210d4d:	c3                   	retq   

0000008004210d4e <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
    uint64_t form, int indirect)
{
  8004210d4e:	55                   	push   %rbp
  8004210d4f:	48 89 e5             	mov    %rsp,%rbp
  8004210d52:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  8004210d59:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004210d60:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004210d67:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004210d6e:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  8004210d75:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  8004210d7c:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
    struct _Dwarf_Attribute atref;
    Dwarf_Section *str;
    int ret;
    Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  8004210d83:	48 bf 7e 90 21 04 80 	movabs $0x800421907e,%rdi
  8004210d8a:	00 00 00 
  8004210d8d:	48 b8 4d 4f 21 04 80 	movabs $0x8004214f4d,%rax
  8004210d94:	00 00 00 
  8004210d97:	ff d0                	callq  *%rax
  8004210d99:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  8004210d9d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210da1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210da5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    uint8_t dwarf_size = cu->cu_dwarf_size;
  8004210da9:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004210db0:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004210db4:	88 45 e7             	mov    %al,-0x19(%rbp)

    ret = DW_DLE_NONE;
  8004210db7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    memset(&atref, 0, sizeof(atref));
  8004210dbe:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004210dc5:	ba 60 00 00 00       	mov    $0x60,%edx
  8004210dca:	be 00 00 00 00       	mov    $0x0,%esi
  8004210dcf:	48 89 c7             	mov    %rax,%rdi
  8004210dd2:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004210dd9:	00 00 00 
  8004210ddc:	ff d0                	callq  *%rax
    atref.at_die = ret_die;
  8004210dde:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004210de5:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    atref.at_attrib = ad->ad_attrib;
  8004210dec:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004210df3:	48 8b 00             	mov    (%rax),%rax
  8004210df6:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    atref.at_form = ad->ad_form;
  8004210dfa:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004210e01:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210e05:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    atref.at_indirect = indirect;
  8004210e09:	8b 45 10             	mov    0x10(%rbp),%eax
  8004210e0c:	89 45 90             	mov    %eax,-0x70(%rbp)
    atref.at_ld = NULL;
  8004210e0f:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004210e16:	00 

    switch (form) {
  8004210e17:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  8004210e1e:	20 
  8004210e1f:	0f 87 82 04 00 00    	ja     80042112a7 <_dwarf_attr_init+0x559>
  8004210e25:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004210e2c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004210e33:	00 
  8004210e34:	48 b8 a8 90 21 04 80 	movabs $0x80042190a8,%rax
  8004210e3b:	00 00 00 
  8004210e3e:	48 01 d0             	add    %rdx,%rax
  8004210e41:	48 8b 00             	mov    (%rax),%rax
  8004210e44:	ff e0                	jmpq   *%rax
    case DW_FORM_addr:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004210e46:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210e4d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210e51:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004210e58:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004210e5c:	0f b6 d2             	movzbl %dl,%edx
  8004210e5f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210e66:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210e6a:	48 89 cf             	mov    %rcx,%rdi
  8004210e6d:	ff d0                	callq  *%rax
  8004210e6f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004210e73:	e9 37 04 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_block:
    case DW_FORM_exprloc:
        atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004210e78:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004210e7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210e83:	48 89 d6             	mov    %rdx,%rsi
  8004210e86:	48 89 c7             	mov    %rax,%rdi
  8004210e89:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  8004210e90:	00 00 00 
  8004210e93:	ff d0                	callq  *%rax
  8004210e95:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004210e99:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210e9d:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210ea4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ea8:	48 89 ce             	mov    %rcx,%rsi
  8004210eab:	48 89 c7             	mov    %rax,%rdi
  8004210eae:	48 b8 c5 05 21 04 80 	movabs $0x80042105c5,%rax
  8004210eb5:	00 00 00 
  8004210eb8:	ff d0                	callq  *%rax
  8004210eba:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  8004210ebe:	e9 ec 03 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_block1:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004210ec3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210eca:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210ece:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210ed5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210ed9:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210ede:	48 89 cf             	mov    %rcx,%rdi
  8004210ee1:	ff d0                	callq  *%rax
  8004210ee3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004210ee7:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210eeb:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210ef2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ef6:	48 89 ce             	mov    %rcx,%rsi
  8004210ef9:	48 89 c7             	mov    %rax,%rdi
  8004210efc:	48 b8 c5 05 21 04 80 	movabs $0x80042105c5,%rax
  8004210f03:	00 00 00 
  8004210f06:	ff d0                	callq  *%rax
  8004210f08:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  8004210f0c:	e9 9e 03 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_block2:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  8004210f11:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210f18:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210f1c:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210f23:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210f27:	ba 02 00 00 00       	mov    $0x2,%edx
  8004210f2c:	48 89 cf             	mov    %rcx,%rdi
  8004210f2f:	ff d0                	callq  *%rax
  8004210f31:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004210f35:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210f39:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210f40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f44:	48 89 ce             	mov    %rcx,%rsi
  8004210f47:	48 89 c7             	mov    %rax,%rdi
  8004210f4a:	48 b8 c5 05 21 04 80 	movabs $0x80042105c5,%rax
  8004210f51:	00 00 00 
  8004210f54:	ff d0                	callq  *%rax
  8004210f56:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  8004210f5a:	e9 50 03 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
   case DW_FORM_block4:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004210f5f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210f66:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210f6a:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210f71:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210f75:	ba 04 00 00 00       	mov    $0x4,%edx
  8004210f7a:	48 89 cf             	mov    %rcx,%rdi
  8004210f7d:	ff d0                	callq  *%rax
  8004210f7f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004210f83:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210f87:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210f8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f92:	48 89 ce             	mov    %rcx,%rsi
  8004210f95:	48 89 c7             	mov    %rax,%rdi
  8004210f98:	48 b8 c5 05 21 04 80 	movabs $0x80042105c5,%rax
  8004210f9f:	00 00 00 
  8004210fa2:	ff d0                	callq  *%rax
  8004210fa4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  8004210fa8:	e9 02 03 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_data1:
    case DW_FORM_flag:
    case DW_FORM_ref1:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004210fad:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210fb4:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210fb8:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210fbf:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210fc3:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210fc8:	48 89 cf             	mov    %rcx,%rdi
  8004210fcb:	ff d0                	callq  *%rax
  8004210fcd:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004210fd1:	e9 d9 02 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_data2:
    case DW_FORM_ref2:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  8004210fd6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210fdd:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210fe1:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210fe8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210fec:	ba 02 00 00 00       	mov    $0x2,%edx
  8004210ff1:	48 89 cf             	mov    %rcx,%rdi
  8004210ff4:	ff d0                	callq  *%rax
  8004210ff6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004210ffa:	e9 b0 02 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_data4:
    case DW_FORM_ref4:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004210fff:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211006:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421100a:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211011:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211015:	ba 04 00 00 00       	mov    $0x4,%edx
  800421101a:	48 89 cf             	mov    %rcx,%rdi
  800421101d:	ff d0                	callq  *%rax
  800421101f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004211023:	e9 87 02 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_data8:
    case DW_FORM_ref8:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  8004211028:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421102f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211033:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421103a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421103e:	ba 08 00 00 00       	mov    $0x8,%edx
  8004211043:	48 89 cf             	mov    %rcx,%rdi
  8004211046:	ff d0                	callq  *%rax
  8004211048:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800421104c:	e9 5e 02 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_indirect:
        form = _dwarf_read_uleb128(ds_data, offsetp);
  8004211051:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211058:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421105c:	48 89 d6             	mov    %rdx,%rsi
  800421105f:	48 89 c7             	mov    %rax,%rdi
  8004211062:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  8004211069:	00 00 00 
  800421106c:	ff d0                	callq  *%rax
  800421106e:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
        return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  8004211075:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  800421107c:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  8004211083:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800421108a:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004211091:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211098:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421109f:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  80042110a6:	4d 89 c1             	mov    %r8,%r9
  80042110a9:	49 89 f8             	mov    %rdi,%r8
  80042110ac:	48 89 c7             	mov    %rax,%rdi
  80042110af:	48 b8 4e 0d 21 04 80 	movabs $0x8004210d4e,%rax
  80042110b6:	00 00 00 
  80042110b9:	ff d0                	callq  *%rax
  80042110bb:	e9 1d 03 00 00       	jmpq   80042113dd <_dwarf_attr_init+0x68f>
    case DW_FORM_ref_addr:
        if (cu->version == 2)
  80042110c0:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042110c7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042110cb:	66 83 f8 02          	cmp    $0x2,%ax
  80042110cf:	75 2f                	jne    8004211100 <_dwarf_attr_init+0x3b2>
            atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  80042110d1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042110d8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042110dc:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  80042110e3:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  80042110e7:	0f b6 d2             	movzbl %dl,%edx
  80042110ea:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042110f1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042110f5:	48 89 cf             	mov    %rcx,%rdi
  80042110f8:	ff d0                	callq  *%rax
  80042110fa:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042110fe:	eb 39                	jmp    8004211139 <_dwarf_attr_init+0x3eb>
        else if (cu->version == 3)
  8004211100:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004211107:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421110b:	66 83 f8 03          	cmp    $0x3,%ax
  800421110f:	75 28                	jne    8004211139 <_dwarf_attr_init+0x3eb>
            atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004211111:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211118:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421111c:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004211120:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211127:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421112b:	48 89 cf             	mov    %rcx,%rdi
  800421112e:	ff d0                	callq  *%rax
  8004211130:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004211134:	e9 76 01 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
  8004211139:	e9 71 01 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_ref_udata:
    case DW_FORM_udata:
        atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800421113e:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211145:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211149:	48 89 d6             	mov    %rdx,%rsi
  800421114c:	48 89 c7             	mov    %rax,%rdi
  800421114f:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  8004211156:	00 00 00 
  8004211159:	ff d0                	callq  *%rax
  800421115b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800421115f:	e9 4b 01 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_sdata:
        atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  8004211164:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421116b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421116f:	48 89 d6             	mov    %rdx,%rsi
  8004211172:	48 89 c7             	mov    %rax,%rdi
  8004211175:	48 b8 14 03 21 04 80 	movabs $0x8004210314,%rax
  800421117c:	00 00 00 
  800421117f:	ff d0                	callq  *%rax
  8004211181:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  8004211185:	e9 25 01 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_sec_offset:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800421118a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211191:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211195:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004211199:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042111a0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042111a4:	48 89 cf             	mov    %rcx,%rdi
  80042111a7:	ff d0                	callq  *%rax
  80042111a9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  80042111ad:	e9 fd 00 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_string:
        atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  80042111b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042111b6:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80042111ba:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042111c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042111c5:	48 89 ce             	mov    %rcx,%rsi
  80042111c8:	48 89 c7             	mov    %rax,%rdi
  80042111cb:	48 b8 36 05 21 04 80 	movabs $0x8004210536,%rax
  80042111d2:	00 00 00 
  80042111d5:	ff d0                	callq  *%rax
  80042111d7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  80042111db:	e9 cf 00 00 00       	jmpq   80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_strp:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042111e0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042111e7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042111eb:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042111ef:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042111f6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042111fa:	48 89 cf             	mov    %rcx,%rdi
  80042111fd:	ff d0                	callq  *%rax
  80042111ff:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        str = _dwarf_find_section(".debug_str");
  8004211203:	48 bf 8a 90 21 04 80 	movabs $0x800421908a,%rdi
  800421120a:	00 00 00 
  800421120d:	48 b8 4d 4f 21 04 80 	movabs $0x8004214f4d,%rax
  8004211214:	00 00 00 
  8004211217:	ff d0                	callq  *%rax
  8004211219:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        assert(str != NULL);
  800421121d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211222:	75 35                	jne    8004211259 <_dwarf_attr_init+0x50b>
  8004211224:	48 b9 95 90 21 04 80 	movabs $0x8004219095,%rcx
  800421122b:	00 00 00 
  800421122e:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  8004211235:	00 00 00 
  8004211238:	be 51 02 00 00       	mov    $0x251,%esi
  800421123d:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  8004211244:	00 00 00 
  8004211247:	b8 00 00 00 00       	mov    $0x0,%eax
  800421124c:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004211253:	00 00 00 
  8004211256:	41 ff d0             	callq  *%r8
        //atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
        atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  8004211259:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421125d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211261:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211265:	48 01 d0             	add    %rdx,%rax
  8004211268:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  800421126c:	eb 41                	jmp    80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_ref_sig8:
        atref.u[0].u64 = 8;
  800421126e:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  8004211275:	00 
        atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  8004211276:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421127a:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211281:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211285:	48 89 ce             	mov    %rcx,%rsi
  8004211288:	48 89 c7             	mov    %rax,%rdi
  800421128b:	48 b8 c5 05 21 04 80 	movabs $0x80042105c5,%rax
  8004211292:	00 00 00 
  8004211295:	ff d0                	callq  *%rax
  8004211297:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  800421129b:	eb 12                	jmp    80042112af <_dwarf_attr_init+0x561>
    case DW_FORM_flag_present:
        /* This form has no value encoded in the DIE. */
        atref.u[0].u64 = 1;
  800421129d:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  80042112a4:	00 
        break;
  80042112a5:	eb 08                	jmp    80042112af <_dwarf_attr_init+0x561>
    default:
        //DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
        ret = DW_DLE_ATTR_FORM_BAD;
  80042112a7:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
        break;
  80042112ae:	90                   	nop
    }

    if (ret == DW_DLE_NONE) {
  80042112af:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042112b3:	0f 85 21 01 00 00    	jne    80042113da <_dwarf_attr_init+0x68c>
        if (form == DW_FORM_block || form == DW_FORM_block1 ||
  80042112b9:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  80042112c0:	09 
  80042112c1:	74 1e                	je     80042112e1 <_dwarf_attr_init+0x593>
  80042112c3:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  80042112ca:	0a 
  80042112cb:	74 14                	je     80042112e1 <_dwarf_attr_init+0x593>
  80042112cd:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  80042112d4:	03 
  80042112d5:	74 0a                	je     80042112e1 <_dwarf_attr_init+0x593>
            form == DW_FORM_block2 || form == DW_FORM_block4) {
  80042112d7:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  80042112de:	04 
  80042112df:	75 10                	jne    80042112f1 <_dwarf_attr_init+0x5a3>
            atref.at_block.bl_len = atref.u[0].u64;
  80042112e1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042112e5:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
            atref.at_block.bl_data = atref.u[1].u8p;
  80042112e9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042112ed:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        }
        //ret = _dwarf_attr_add(die, &atref, NULL, error);
        if (atref.at_attrib == DW_AT_name) {
  80042112f1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042112f5:	48 83 f8 03          	cmp    $0x3,%rax
  80042112f9:	75 39                	jne    8004211334 <_dwarf_attr_init+0x5e6>
                switch (atref.at_form) {
  80042112fb:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042112ff:	48 83 f8 08          	cmp    $0x8,%rax
  8004211303:	74 1c                	je     8004211321 <_dwarf_attr_init+0x5d3>
  8004211305:	48 83 f8 0e          	cmp    $0xe,%rax
  8004211309:	74 02                	je     800421130d <_dwarf_attr_init+0x5bf>
                    break;
                case DW_FORM_string:
                    ret_die->die_name = atref.u[0].s;
                    break;
                default:
                    break;
  800421130b:	eb 27                	jmp    8004211334 <_dwarf_attr_init+0x5e6>
        }
        //ret = _dwarf_attr_add(die, &atref, NULL, error);
        if (atref.at_attrib == DW_AT_name) {
                switch (atref.at_form) {
                case DW_FORM_strp:
                    ret_die->die_name = atref.u[1].s;
  800421130d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211311:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211318:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
                    break;
  800421131f:	eb 13                	jmp    8004211334 <_dwarf_attr_init+0x5e6>
                case DW_FORM_string:
                    ret_die->die_name = atref.u[0].s;
  8004211321:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211325:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800421132c:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
                    break;
  8004211333:	90                   	nop
                default:
                    break;
                }
        }
        ret_die->die_attr[ret_die->die_attr_count++] = atref;
  8004211334:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800421133b:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004211342:	8d 48 01             	lea    0x1(%rax),%ecx
  8004211345:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  800421134c:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  8004211352:	0f b6 c0             	movzbl %al,%eax
  8004211355:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800421135c:	48 63 d0             	movslq %eax,%rdx
  800421135f:	48 89 d0             	mov    %rdx,%rax
  8004211362:	48 01 c0             	add    %rax,%rax
  8004211365:	48 01 d0             	add    %rdx,%rax
  8004211368:	48 c1 e0 05          	shl    $0x5,%rax
  800421136c:	48 01 c8             	add    %rcx,%rax
  800421136f:	48 05 70 03 00 00    	add    $0x370,%rax
  8004211375:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421137c:	48 89 10             	mov    %rdx,(%rax)
  800421137f:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004211386:	48 89 50 08          	mov    %rdx,0x8(%rax)
  800421138a:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800421138e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004211392:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004211396:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421139a:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800421139e:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042113a2:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042113a6:	48 89 50 28          	mov    %rdx,0x28(%rax)
  80042113aa:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042113ae:	48 89 50 30          	mov    %rdx,0x30(%rax)
  80042113b2:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042113b6:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80042113ba:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042113be:	48 89 50 40          	mov    %rdx,0x40(%rax)
  80042113c2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042113c6:	48 89 50 48          	mov    %rdx,0x48(%rax)
  80042113ca:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042113ce:	48 89 50 50          	mov    %rdx,0x50(%rax)
  80042113d2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042113d6:	48 89 50 58          	mov    %rdx,0x58(%rax)
    }

    return (ret);
  80042113da:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042113dd:	c9                   	leaveq 
  80042113de:	c3                   	retq   

00000080042113df <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  80042113df:	55                   	push   %rbp
  80042113e0:	48 89 e5             	mov    %rsp,%rbp
  80042113e3:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  80042113ea:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  80042113f1:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  80042113f8:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  80042113ff:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
    uint64_t abnum;
    uint64_t die_offset;
    int ret, level;
    int i;

    assert(dbg);
  8004211405:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  800421140c:	00 
  800421140d:	75 35                	jne    8004211444 <dwarf_search_die_within_cu+0x65>
  800421140f:	48 b9 b0 91 21 04 80 	movabs $0x80042191b0,%rcx
  8004211416:	00 00 00 
  8004211419:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  8004211420:	00 00 00 
  8004211423:	be 86 02 00 00       	mov    $0x286,%esi
  8004211428:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  800421142f:	00 00 00 
  8004211432:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211437:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800421143e:	00 00 00 
  8004211441:	41 ff d0             	callq  *%r8
    //assert(cu);
    assert(ret_die);
  8004211444:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  800421144b:	00 
  800421144c:	75 35                	jne    8004211483 <dwarf_search_die_within_cu+0xa4>
  800421144e:	48 b9 b4 91 21 04 80 	movabs $0x80042191b4,%rcx
  8004211455:	00 00 00 
  8004211458:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  800421145f:	00 00 00 
  8004211462:	be 88 02 00 00       	mov    $0x288,%esi
  8004211467:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  800421146e:	00 00 00 
  8004211471:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211476:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800421147d:	00 00 00 
  8004211480:	41 ff d0             	callq  *%r8

    level = 1;
  8004211483:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

    while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  800421148a:	e9 17 02 00 00       	jmpq   80042116a6 <dwarf_search_die_within_cu+0x2c7>

        die_offset = offset;
  800421148f:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004211496:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

        abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  800421149a:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042114a1:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042114a5:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  80042114ac:	48 89 d6             	mov    %rdx,%rsi
  80042114af:	48 89 c7             	mov    %rax,%rdi
  80042114b2:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  80042114b9:	00 00 00 
  80042114bc:	ff d0                	callq  *%rax
  80042114be:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

        if (abnum == 0) {
  80042114c2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042114c7:	75 22                	jne    80042114eb <dwarf_search_die_within_cu+0x10c>
            if (level == 0 || !search_sibling) {
  80042114c9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042114cd:	74 09                	je     80042114d8 <dwarf_search_die_within_cu+0xf9>
  80042114cf:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  80042114d6:	75 0a                	jne    80042114e2 <dwarf_search_die_within_cu+0x103>
                //No more entry
                return (DW_DLE_NO_ENTRY);
  80042114d8:	b8 04 00 00 00       	mov    $0x4,%eax
  80042114dd:	e9 f4 01 00 00       	jmpq   80042116d6 <dwarf_search_die_within_cu+0x2f7>
            }
            /*
             * Return to previous DIE level.
             */
            level--;
  80042114e2:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
            continue;
  80042114e6:	e9 bb 01 00 00       	jmpq   80042116a6 <dwarf_search_die_within_cu+0x2c7>
        }

        if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  80042114eb:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  80042114f2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042114f6:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042114fd:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8004211501:	48 89 34 24          	mov    %rsi,(%rsp)
  8004211505:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  8004211509:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  800421150e:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  8004211512:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  8004211517:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  800421151b:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  8004211520:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  8004211524:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  8004211529:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  800421152d:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  8004211532:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  8004211536:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  800421153b:	48 89 ce             	mov    %rcx,%rsi
  800421153e:	48 89 c7             	mov    %rax,%rdi
  8004211541:	48 b8 1d 0c 21 04 80 	movabs $0x8004210c1d,%rax
  8004211548:	00 00 00 
  800421154b:	ff d0                	callq  *%rax
  800421154d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004211550:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211554:	74 08                	je     800421155e <dwarf_search_die_within_cu+0x17f>
            return (ret);
  8004211556:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211559:	e9 78 01 00 00       	jmpq   80042116d6 <dwarf_search_die_within_cu+0x2f7>
        ret_die->die_offset = die_offset;
  800421155e:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211565:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211569:	48 89 10             	mov    %rdx,(%rax)
        ret_die->die_abnum  = abnum;
  800421156c:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211573:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211577:	48 89 50 10          	mov    %rdx,0x10(%rax)
        ret_die->die_ab  = ab;
  800421157b:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211582:	48 8d 78 20          	lea    0x20(%rax),%rdi
  8004211586:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  800421158d:	b8 66 00 00 00       	mov    $0x66,%eax
  8004211592:	48 89 d6             	mov    %rdx,%rsi
  8004211595:	48 89 c1             	mov    %rax,%rcx
  8004211598:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
        ret_die->die_attr_count = 0;
  800421159b:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042115a2:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
        ret_die->die_tag = ab.ab_tag;
  80042115a9:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  80042115b0:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042115b7:	48 89 50 18          	mov    %rdx,0x18(%rax)
        //ret_die->die_cu  = cu;
        //ret_die->die_dbg = cu->cu_dbg;

        for(i=0; i < ab.ab_atnum; i++)
  80042115bb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042115c2:	e9 8e 00 00 00       	jmpq   8004211655 <dwarf_search_die_within_cu+0x276>
        {
            if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  80042115c7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042115ca:	48 63 d0             	movslq %eax,%rdx
  80042115cd:	48 89 d0             	mov    %rdx,%rax
  80042115d0:	48 01 c0             	add    %rax,%rax
  80042115d3:	48 01 d0             	add    %rdx,%rax
  80042115d6:	48 c1 e0 03          	shl    $0x3,%rax
  80042115da:	48 01 e8             	add    %rbp,%rax
  80042115dd:	48 2d 18 03 00 00    	sub    $0x318,%rax
  80042115e3:	48 8b 08             	mov    (%rax),%rcx
  80042115e6:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  80042115ed:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042115f0:	48 63 d0             	movslq %eax,%rdx
  80042115f3:	48 89 d0             	mov    %rdx,%rax
  80042115f6:	48 01 c0             	add    %rax,%rax
  80042115f9:	48 01 d0             	add    %rdx,%rax
  80042115fc:	48 c1 e0 03          	shl    $0x3,%rax
  8004211600:	48 83 c0 30          	add    $0x30,%rax
  8004211604:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  8004211608:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  800421160f:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  8004211616:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800421161d:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  8004211624:	49 89 c9             	mov    %rcx,%r9
  8004211627:	49 89 f8             	mov    %rdi,%r8
  800421162a:	48 89 d1             	mov    %rdx,%rcx
  800421162d:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  8004211631:	48 89 c7             	mov    %rax,%rdi
  8004211634:	48 b8 4e 0d 21 04 80 	movabs $0x8004210d4e,%rax
  800421163b:	00 00 00 
  800421163e:	ff d0                	callq  *%rax
  8004211640:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004211643:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211647:	74 08                	je     8004211651 <dwarf_search_die_within_cu+0x272>
                return (ret);
  8004211649:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421164c:	e9 85 00 00 00       	jmpq   80042116d6 <dwarf_search_die_within_cu+0x2f7>
        ret_die->die_attr_count = 0;
        ret_die->die_tag = ab.ab_tag;
        //ret_die->die_cu  = cu;
        //ret_die->die_dbg = cu->cu_dbg;

        for(i=0; i < ab.ab_atnum; i++)
  8004211651:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004211655:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004211658:	48 63 d0             	movslq %eax,%rdx
  800421165b:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004211662:	48 39 c2             	cmp    %rax,%rdx
  8004211665:	0f 82 5c ff ff ff    	jb     80042115c7 <dwarf_search_die_within_cu+0x1e8>
        {
            if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
                return (ret);
        }

        ret_die->die_next_off = offset;
  800421166b:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  8004211672:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211679:	48 89 50 08          	mov    %rdx,0x8(%rax)
        if (search_sibling && level > 0) {
  800421167d:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004211684:	74 19                	je     800421169f <dwarf_search_die_within_cu+0x2c0>
  8004211686:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421168a:	7e 13                	jle    800421169f <dwarf_search_die_within_cu+0x2c0>
            //dwarf_dealloc(dbg, die, DW_DLA_DIE);
            if (ab.ab_children == DW_CHILDREN_yes) {
  800421168c:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  8004211693:	3c 01                	cmp    $0x1,%al
  8004211695:	75 06                	jne    800421169d <dwarf_search_die_within_cu+0x2be>
                /* Advance to next DIE level. */
                level++;
  8004211697:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        ret_die->die_next_off = offset;
        if (search_sibling && level > 0) {
            //dwarf_dealloc(dbg, die, DW_DLA_DIE);
            if (ab.ab_children == DW_CHILDREN_yes) {
  800421169b:	eb 09                	jmp    80042116a6 <dwarf_search_die_within_cu+0x2c7>
  800421169d:	eb 07                	jmp    80042116a6 <dwarf_search_die_within_cu+0x2c7>
                /* Advance to next DIE level. */
                level++;
            }
        } else {
            //*ret_die = die;
            return (DW_DLE_NONE);
  800421169f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042116a4:	eb 30                	jmp    80042116d6 <dwarf_search_die_within_cu+0x2f7>
    //assert(cu);
    assert(ret_die);

    level = 1;

    while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  80042116a6:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  80042116aa:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042116b1:	48 39 c2             	cmp    %rax,%rdx
  80042116b4:	76 1b                	jbe    80042116d1 <dwarf_search_die_within_cu+0x2f2>
  80042116b6:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042116bd:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042116c1:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042116c8:	48 39 c2             	cmp    %rax,%rdx
  80042116cb:	0f 87 be fd ff ff    	ja     800421148f <dwarf_search_die_within_cu+0xb0>
            //*ret_die = die;
            return (DW_DLE_NONE);
        }
    }

    return (DW_DLE_NO_ENTRY);
  80042116d1:	b8 04 00 00 00       	mov    $0x4,%eax
}
  80042116d6:	c9                   	leaveq 
  80042116d7:	c3                   	retq   

00000080042116d8 <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  80042116d8:	55                   	push   %rbp
  80042116d9:	48 89 e5             	mov    %rsp,%rbp
  80042116dc:	48 83 ec 60          	sub    $0x60,%rsp
  80042116e0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042116e4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042116e8:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    int ret;

    assert(dbg);
  80042116ec:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042116f1:	75 35                	jne    8004211728 <dwarf_offdie+0x50>
  80042116f3:	48 b9 b0 91 21 04 80 	movabs $0x80042191b0,%rcx
  80042116fa:	00 00 00 
  80042116fd:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  8004211704:	00 00 00 
  8004211707:	be c4 02 00 00       	mov    $0x2c4,%esi
  800421170c:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  8004211713:	00 00 00 
  8004211716:	b8 00 00 00 00       	mov    $0x0,%eax
  800421171b:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004211722:	00 00 00 
  8004211725:	41 ff d0             	callq  *%r8
    assert(ret_die);
  8004211728:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421172d:	75 35                	jne    8004211764 <dwarf_offdie+0x8c>
  800421172f:	48 b9 b4 91 21 04 80 	movabs $0x80042191b4,%rcx
  8004211736:	00 00 00 
  8004211739:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  8004211740:	00 00 00 
  8004211743:	be c5 02 00 00       	mov    $0x2c5,%esi
  8004211748:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  800421174f:	00 00 00 
  8004211752:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211757:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800421175e:	00 00 00 
  8004211761:	41 ff d0             	callq  *%r8

    /* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004211764:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004211768:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421176c:	76 66                	jbe    80042117d4 <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  800421176e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211772:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004211776:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421177a:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  800421177e:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004211782:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  8004211786:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800421178b:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  800421178f:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004211794:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004211798:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  800421179d:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  80042117a1:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  80042117a6:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  80042117aa:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  80042117af:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  80042117b3:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  80042117b8:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042117bd:	48 89 c7             	mov    %rax,%rdi
  80042117c0:	48 b8 df 13 21 04 80 	movabs $0x80042113df,%rax
  80042117c7:	00 00 00 
  80042117ca:	ff d0                	callq  *%rax
  80042117cc:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  80042117cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042117d2:	eb 05                	jmp    80042117d9 <dwarf_offdie+0x101>
	}

    /*TODO: Search other CU*/
    return DW_DLV_OK;
  80042117d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042117d9:	c9                   	leaveq 
  80042117da:	c3                   	retq   

00000080042117db <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  80042117db:	55                   	push   %rbp
  80042117dc:	48 89 e5             	mov    %rsp,%rbp
  80042117df:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042117e3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042117e7:	89 f0                	mov    %esi,%eax
  80042117e9:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
    Dwarf_Attribute *myat = NULL;
  80042117ed:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042117f4:	00 
    int i;
    
    for(i=0; i < die->die_attr_count; i++)
  80042117f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042117fc:	eb 57                	jmp    8004211855 <_dwarf_attr_find+0x7a>
    {
        if (die->die_attr[i].at_attrib == attr)
  80042117fe:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211802:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211805:	48 63 d0             	movslq %eax,%rdx
  8004211808:	48 89 d0             	mov    %rdx,%rax
  800421180b:	48 01 c0             	add    %rax,%rax
  800421180e:	48 01 d0             	add    %rdx,%rax
  8004211811:	48 c1 e0 05          	shl    $0x5,%rax
  8004211815:	48 01 c8             	add    %rcx,%rax
  8004211818:	48 05 80 03 00 00    	add    $0x380,%rax
  800421181e:	48 8b 10             	mov    (%rax),%rdx
  8004211821:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  8004211825:	48 39 c2             	cmp    %rax,%rdx
  8004211828:	75 27                	jne    8004211851 <_dwarf_attr_find+0x76>
        {
            myat = &(die->die_attr[i]);
  800421182a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421182d:	48 63 d0             	movslq %eax,%rdx
  8004211830:	48 89 d0             	mov    %rdx,%rax
  8004211833:	48 01 c0             	add    %rax,%rax
  8004211836:	48 01 d0             	add    %rdx,%rax
  8004211839:	48 c1 e0 05          	shl    $0x5,%rax
  800421183d:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004211844:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211848:	48 01 d0             	add    %rdx,%rax
  800421184b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            break;
  800421184f:	eb 17                	jmp    8004211868 <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
    Dwarf_Attribute *myat = NULL;
    int i;
    
    for(i=0; i < die->die_attr_count; i++)
  8004211851:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004211855:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211859:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004211860:	0f b6 c0             	movzbl %al,%eax
  8004211863:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004211866:	7f 96                	jg     80042117fe <_dwarf_attr_find+0x23>
            myat = &(die->die_attr[i]);
            break;
        }
    }

    return myat;
  8004211868:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421186c:	c9                   	leaveq 
  800421186d:	c3                   	retq   

000000800421186e <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
    Dwarf_CU *cu)
{
  800421186e:	55                   	push   %rbp
  800421186f:	48 89 e5             	mov    %rsp,%rbp
  8004211872:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004211876:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421187a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421187e:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211882:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    Dwarf_Attribute *at;
    uint64_t offset;
    int ret, search_sibling;

    assert(dbg);
  8004211886:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421188b:	75 35                	jne    80042118c2 <dwarf_siblingof+0x54>
  800421188d:	48 b9 b0 91 21 04 80 	movabs $0x80042191b0,%rcx
  8004211894:	00 00 00 
  8004211897:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  800421189e:	00 00 00 
  80042118a1:	be ec 02 00 00       	mov    $0x2ec,%esi
  80042118a6:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  80042118ad:	00 00 00 
  80042118b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042118b5:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042118bc:	00 00 00 
  80042118bf:	41 ff d0             	callq  *%r8
    assert(ret_die);
  80042118c2:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042118c7:	75 35                	jne    80042118fe <dwarf_siblingof+0x90>
  80042118c9:	48 b9 b4 91 21 04 80 	movabs $0x80042191b4,%rcx
  80042118d0:	00 00 00 
  80042118d3:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  80042118da:	00 00 00 
  80042118dd:	be ed 02 00 00       	mov    $0x2ed,%esi
  80042118e2:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  80042118e9:	00 00 00 
  80042118ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042118f1:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042118f8:	00 00 00 
  80042118fb:	41 ff d0             	callq  *%r8
    assert(cu);
  80042118fe:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004211903:	75 35                	jne    800421193a <dwarf_siblingof+0xcc>
  8004211905:	48 b9 bc 91 21 04 80 	movabs $0x80042191bc,%rcx
  800421190c:	00 00 00 
  800421190f:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  8004211916:	00 00 00 
  8004211919:	be ee 02 00 00       	mov    $0x2ee,%esi
  800421191e:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  8004211925:	00 00 00 
  8004211928:	b8 00 00 00 00       	mov    $0x0,%eax
  800421192d:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004211934:	00 00 00 
  8004211937:	41 ff d0             	callq  *%r8

    /* Application requests the first DIE in this CU. */
    if (die == NULL)
  800421193a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421193f:	75 65                	jne    80042119a6 <dwarf_siblingof+0x138>
        return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  8004211941:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211945:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004211949:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421194d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004211951:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211955:	48 8b 38             	mov    (%rax),%rdi
  8004211958:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421195c:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004211960:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004211965:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8004211969:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800421196e:	48 8b 78 18          	mov    0x18(%rax),%rdi
  8004211972:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004211977:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800421197b:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004211980:	48 8b 78 28          	mov    0x28(%rax),%rdi
  8004211984:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004211989:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421198d:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211992:	48 89 cf             	mov    %rcx,%rdi
  8004211995:	48 b8 d8 16 21 04 80 	movabs $0x80042116d8,%rax
  800421199c:	00 00 00 
  800421199f:	ff d0                	callq  *%rax
  80042119a1:	e9 0a 01 00 00       	jmpq   8004211ab0 <dwarf_siblingof+0x242>

    /*
     * If the DIE doesn't have any children, its sibling sits next
     * right to it.
     */
    search_sibling = 0;
  80042119a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    if (die->die_ab.ab_children == DW_CHILDREN_no)
  80042119ad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042119b1:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  80042119b5:	84 c0                	test   %al,%al
  80042119b7:	75 0e                	jne    80042119c7 <dwarf_siblingof+0x159>
        offset = die->die_next_off;
  80042119b9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042119bd:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042119c1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042119c5:	eb 6b                	jmp    8004211a32 <dwarf_siblingof+0x1c4>
    else {
        /*
         * Look for DW_AT_sibling attribute for the offset of
         * its sibling.
         */
        if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  80042119c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042119cb:	be 01 00 00 00       	mov    $0x1,%esi
  80042119d0:	48 89 c7             	mov    %rax,%rdi
  80042119d3:	48 b8 db 17 21 04 80 	movabs $0x80042117db,%rax
  80042119da:	00 00 00 
  80042119dd:	ff d0                	callq  *%rax
  80042119df:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042119e3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042119e8:	74 35                	je     8004211a1f <dwarf_siblingof+0x1b1>
            if (at->at_form != DW_FORM_ref_addr)
  80042119ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042119ee:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042119f2:	48 83 f8 10          	cmp    $0x10,%rax
  80042119f6:	74 19                	je     8004211a11 <dwarf_siblingof+0x1a3>
                offset = at->u[0].u64 + cu->cu_offset;
  80042119f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042119fc:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004211a00:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211a04:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211a08:	48 01 d0             	add    %rdx,%rax
  8004211a0b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211a0f:	eb 21                	jmp    8004211a32 <dwarf_siblingof+0x1c4>
            else
                offset = at->u[0].u64;
  8004211a11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a15:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211a19:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211a1d:	eb 13                	jmp    8004211a32 <dwarf_siblingof+0x1c4>
        } else {
            offset = die->die_next_off;
  8004211a1f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211a23:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211a27:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            search_sibling = 1;
  8004211a2b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
        }
    }

    ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  8004211a32:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004211a35:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211a39:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004211a3d:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8004211a41:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211a45:	4c 8b 00             	mov    (%rax),%r8
  8004211a48:	4c 89 04 24          	mov    %r8,(%rsp)
  8004211a4c:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004211a50:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004211a55:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004211a59:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004211a5e:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211a62:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004211a67:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004211a6b:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  8004211a70:	4c 8b 40 28          	mov    0x28(%rax),%r8
  8004211a74:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  8004211a79:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211a7d:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211a82:	48 b8 df 13 21 04 80 	movabs $0x80042113df,%rax
  8004211a89:	00 00 00 
  8004211a8c:	ff d0                	callq  *%rax
  8004211a8e:	89 45 e4             	mov    %eax,-0x1c(%rbp)


    if (ret == DW_DLE_NO_ENTRY) {
  8004211a91:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  8004211a95:	75 07                	jne    8004211a9e <dwarf_siblingof+0x230>
        return (DW_DLV_NO_ENTRY);
  8004211a97:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211a9c:	eb 12                	jmp    8004211ab0 <dwarf_siblingof+0x242>
    } else if (ret != DW_DLE_NONE)
  8004211a9e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211aa2:	74 07                	je     8004211aab <dwarf_siblingof+0x23d>
        return (DW_DLV_ERROR);
  8004211aa4:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211aa9:	eb 05                	jmp    8004211ab0 <dwarf_siblingof+0x242>


    return (DW_DLV_OK);
  8004211aab:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211ab0:	c9                   	leaveq 
  8004211ab1:	c3                   	retq   

0000008004211ab2 <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  8004211ab2:	55                   	push   %rbp
  8004211ab3:	48 89 e5             	mov    %rsp,%rbp
  8004211ab6:	48 83 ec 70          	sub    $0x70,%rsp
  8004211aba:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211abe:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211ac2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211ac6:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    int ret;

    assert(die);
  8004211aca:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211acf:	75 35                	jne    8004211b06 <dwarf_child+0x54>
  8004211ad1:	48 b9 bf 91 21 04 80 	movabs $0x80042191bf,%rcx
  8004211ad8:	00 00 00 
  8004211adb:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  8004211ae2:	00 00 00 
  8004211ae5:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004211aea:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  8004211af1:	00 00 00 
  8004211af4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211af9:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004211b00:	00 00 00 
  8004211b03:	41 ff d0             	callq  *%r8
    assert(ret_die);
  8004211b06:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211b0b:	75 35                	jne    8004211b42 <dwarf_child+0x90>
  8004211b0d:	48 b9 b4 91 21 04 80 	movabs $0x80042191b4,%rcx
  8004211b14:	00 00 00 
  8004211b17:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  8004211b1e:	00 00 00 
  8004211b21:	be 1d 03 00 00       	mov    $0x31d,%esi
  8004211b26:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  8004211b2d:	00 00 00 
  8004211b30:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211b35:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004211b3c:	00 00 00 
  8004211b3f:	41 ff d0             	callq  *%r8
    assert(dbg);
  8004211b42:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211b47:	75 35                	jne    8004211b7e <dwarf_child+0xcc>
  8004211b49:	48 b9 b0 91 21 04 80 	movabs $0x80042191b0,%rcx
  8004211b50:	00 00 00 
  8004211b53:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  8004211b5a:	00 00 00 
  8004211b5d:	be 1e 03 00 00       	mov    $0x31e,%esi
  8004211b62:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  8004211b69:	00 00 00 
  8004211b6c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211b71:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004211b78:	00 00 00 
  8004211b7b:	41 ff d0             	callq  *%r8
    assert(cu);
  8004211b7e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004211b83:	75 35                	jne    8004211bba <dwarf_child+0x108>
  8004211b85:	48 b9 bc 91 21 04 80 	movabs $0x80042191bc,%rcx
  8004211b8c:	00 00 00 
  8004211b8f:	48 ba 22 90 21 04 80 	movabs $0x8004219022,%rdx
  8004211b96:	00 00 00 
  8004211b99:	be 1f 03 00 00       	mov    $0x31f,%esi
  8004211b9e:	48 bf 37 90 21 04 80 	movabs $0x8004219037,%rdi
  8004211ba5:	00 00 00 
  8004211ba8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211bad:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004211bb4:	00 00 00 
  8004211bb7:	41 ff d0             	callq  *%r8

    if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004211bba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211bbe:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004211bc2:	84 c0                	test   %al,%al
  8004211bc4:	75 0a                	jne    8004211bd0 <dwarf_child+0x11e>
        return (DW_DLE_NO_ENTRY);
  8004211bc6:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211bcb:	e9 84 00 00 00       	jmpq   8004211c54 <dwarf_child+0x1a2>

    ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  8004211bd0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211bd4:	48 8b 70 08          	mov    0x8(%rax),%rsi
  8004211bd8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211bdc:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8004211be0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211be4:	48 8b 08             	mov    (%rax),%rcx
  8004211be7:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004211beb:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004211bef:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004211bf4:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004211bf8:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004211bfd:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004211c01:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004211c06:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211c0a:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004211c0f:	48 8b 48 28          	mov    0x28(%rax),%rcx
  8004211c13:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004211c18:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211c1c:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211c21:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004211c26:	48 b8 df 13 21 04 80 	movabs $0x80042113df,%rax
  8004211c2d:	00 00 00 
  8004211c30:	ff d0                	callq  *%rax
  8004211c32:	89 45 fc             	mov    %eax,-0x4(%rbp)

    if (ret == DW_DLE_NO_ENTRY) {
  8004211c35:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004211c39:	75 07                	jne    8004211c42 <dwarf_child+0x190>
        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004211c3b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211c40:	eb 12                	jmp    8004211c54 <dwarf_child+0x1a2>
    } else if (ret != DW_DLE_NONE)
  8004211c42:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211c46:	74 07                	je     8004211c4f <dwarf_child+0x19d>
        return (DW_DLV_ERROR);
  8004211c48:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211c4d:	eb 05                	jmp    8004211c54 <dwarf_child+0x1a2>

    return (DW_DLV_OK);
  8004211c4f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211c54:	c9                   	leaveq 
  8004211c55:	c3                   	retq   

0000008004211c56 <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004211c56:	55                   	push   %rbp
  8004211c57:	48 89 e5             	mov    %rsp,%rbp
  8004211c5a:	48 83 ec 20          	sub    $0x20,%rsp
  8004211c5e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  8004211c62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c66:	48 8b 00             	mov    (%rax),%rax
  8004211c69:	48 89 c7             	mov    %rax,%rdi
  8004211c6c:	48 b8 4d 4f 21 04 80 	movabs $0x8004214f4d,%rax
  8004211c73:	00 00 00 
  8004211c76:	ff d0                	callq  *%rax
  8004211c78:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  8004211c7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211c80:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211c84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c88:	48 89 50 08          	mov    %rdx,0x8(%rax)
    ds->ds_addr = secthdr->ds_addr;
  8004211c8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211c90:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211c94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c98:	48 89 50 10          	mov    %rdx,0x10(%rax)
    ds->ds_size = secthdr->ds_size;
  8004211c9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211ca0:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211ca4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ca8:	48 89 50 18          	mov    %rdx,0x18(%rax)
    return 0;
  8004211cac:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211cb1:	c9                   	leaveq 
  8004211cb2:	c3                   	retq   

0000008004211cb3 <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  8004211cb3:	55                   	push   %rbp
  8004211cb4:	48 89 e5             	mov    %rsp,%rbp
  8004211cb7:	48 83 ec 08          	sub    $0x8,%rsp
  8004211cbb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
        /* Initialise call frame related parameters. */
        dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  8004211cbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211cc3:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
        dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  8004211cc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211ccd:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
        dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  8004211cd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211cd7:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
        dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004211cdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211ce1:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
        dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  8004211ce7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211ceb:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  8004211cf1:	c9                   	leaveq 
  8004211cf2:	c3                   	retq   

0000008004211cf3 <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
    Dwarf_Fde ret_fde, Dwarf_Cie cie,
    Dwarf_Error *error)
{
  8004211cf3:	55                   	push   %rbp
  8004211cf4:	48 89 e5             	mov    %rsp,%rbp
  8004211cf7:	48 83 ec 40          	sub    $0x40,%rsp
  8004211cfb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211cff:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211d03:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211d07:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004211d0b:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
        Dwarf_Fde fde = ret_fde;
  8004211d0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211d13:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        memset(fde, 0, sizeof(struct _Dwarf_Fde));
  8004211d17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211d1b:	ba 80 00 00 00       	mov    $0x80,%edx
  8004211d20:	be 00 00 00 00       	mov    $0x0,%esi
  8004211d25:	48 89 c7             	mov    %rax,%rdi
  8004211d28:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004211d2f:	00 00 00 
  8004211d32:	ff d0                	callq  *%rax
        fde->fde_cie = cie;
  8004211d34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211d38:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211d3c:	48 89 50 08          	mov    %rdx,0x8(%rax)

        if (ret_fde == NULL)
  8004211d40:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211d45:	75 07                	jne    8004211d4e <dwarf_get_fde_at_pc+0x5b>
                return (DW_DLV_ERROR);
  8004211d47:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211d4c:	eb 75                	jmp    8004211dc3 <dwarf_get_fde_at_pc+0xd0>

        while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  8004211d4e:	eb 59                	jmp    8004211da9 <dwarf_get_fde_at_pc+0xb6>
                if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  8004211d50:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004211d54:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211d58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d5c:	be 01 00 00 00       	mov    $0x1,%esi
  8004211d61:	48 89 c7             	mov    %rax,%rdi
  8004211d64:	48 b8 03 3f 21 04 80 	movabs $0x8004213f03,%rax
  8004211d6b:	00 00 00 
  8004211d6e:	ff d0                	callq  *%rax
  8004211d70:	85 c0                	test   %eax,%eax
  8004211d72:	79 07                	jns    8004211d7b <dwarf_get_fde_at_pc+0x88>
                        return DW_DLV_NO_ENTRY;
  8004211d74:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211d79:	eb 48                	jmp    8004211dc3 <dwarf_get_fde_at_pc+0xd0>
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004211d7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211d7f:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211d83:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211d87:	77 20                	ja     8004211da9 <dwarf_get_fde_at_pc+0xb6>
  8004211d89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211d8d:	48 8b 50 30          	mov    0x30(%rax),%rdx
                    fde->fde_adrange)
  8004211d91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211d95:	48 8b 40 38          	mov    0x38(%rax),%rax
                return (DW_DLV_ERROR);

        while(dbg->curr_off_eh < dbg->dbg_eh_size) {
                if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
                        return DW_DLV_NO_ENTRY;
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004211d99:	48 01 d0             	add    %rdx,%rax
  8004211d9c:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211da0:	76 07                	jbe    8004211da9 <dwarf_get_fde_at_pc+0xb6>
                    fde->fde_adrange)
                        return (DW_DLV_OK);
  8004211da2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211da7:	eb 1a                	jmp    8004211dc3 <dwarf_get_fde_at_pc+0xd0>
        fde->fde_cie = cie;

        if (ret_fde == NULL)
                return (DW_DLV_ERROR);

        while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  8004211da9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211dad:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004211db1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211db5:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004211db9:	48 39 c2             	cmp    %rax,%rdx
  8004211dbc:	72 92                	jb     8004211d50 <dwarf_get_fde_at_pc+0x5d>
                    fde->fde_adrange)
                        return (DW_DLV_OK);
        }

        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004211dbe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8004211dc3:	c9                   	leaveq 
  8004211dc4:	c3                   	retq   

0000008004211dc5 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
    Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  8004211dc5:	55                   	push   %rbp
  8004211dc6:	48 89 e5             	mov    %rsp,%rbp
  8004211dc9:	53                   	push   %rbx
  8004211dca:	48 83 ec 38          	sub    $0x38,%rsp
  8004211dce:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211dd2:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211dd6:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211dda:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
        int i;

        assert(dest != NULL);
  8004211dde:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211de3:	75 35                	jne    8004211e1a <_dwarf_frame_regtable_copy+0x55>
  8004211de5:	48 b9 d2 91 21 04 80 	movabs $0x80042191d2,%rcx
  8004211dec:	00 00 00 
  8004211def:	48 ba df 91 21 04 80 	movabs $0x80042191df,%rdx
  8004211df6:	00 00 00 
  8004211df9:	be 55 00 00 00       	mov    $0x55,%esi
  8004211dfe:	48 bf f4 91 21 04 80 	movabs $0x80042191f4,%rdi
  8004211e05:	00 00 00 
  8004211e08:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211e0d:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004211e14:	00 00 00 
  8004211e17:	41 ff d0             	callq  *%r8
        assert(src != NULL);
  8004211e1a:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211e1f:	75 35                	jne    8004211e56 <_dwarf_frame_regtable_copy+0x91>
  8004211e21:	48 b9 0a 92 21 04 80 	movabs $0x800421920a,%rcx
  8004211e28:	00 00 00 
  8004211e2b:	48 ba df 91 21 04 80 	movabs $0x80042191df,%rdx
  8004211e32:	00 00 00 
  8004211e35:	be 56 00 00 00       	mov    $0x56,%esi
  8004211e3a:	48 bf f4 91 21 04 80 	movabs $0x80042191f4,%rdi
  8004211e41:	00 00 00 
  8004211e44:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211e49:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004211e50:	00 00 00 
  8004211e53:	41 ff d0             	callq  *%r8

        if (*dest == NULL) {
  8004211e56:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211e5a:	48 8b 00             	mov    (%rax),%rax
  8004211e5d:	48 85 c0             	test   %rax,%rax
  8004211e60:	75 39                	jne    8004211e9b <_dwarf_frame_regtable_copy+0xd6>
                *dest = &global_rt_table_shadow;
  8004211e62:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211e66:	48 bb 60 17 4a 04 80 	movabs $0x80044a1760,%rbx
  8004211e6d:	00 00 00 
  8004211e70:	48 89 18             	mov    %rbx,(%rax)
                (*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  8004211e73:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211e77:	48 8b 00             	mov    (%rax),%rax
  8004211e7a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211e7e:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  8004211e82:	66 89 50 18          	mov    %dx,0x18(%rax)
                (*dest)->rt3_rules = global_rules_shadow;
  8004211e86:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211e8a:	48 8b 00             	mov    (%rax),%rax
  8004211e8d:	48 bb 20 19 4a 04 80 	movabs $0x80044a1920,%rbx
  8004211e94:	00 00 00 
  8004211e97:	48 89 58 20          	mov    %rbx,0x20(%rax)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  8004211e9b:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004211e9f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211ea3:	48 8b 00             	mov    (%rax),%rax
  8004211ea6:	ba 18 00 00 00       	mov    $0x18,%edx
  8004211eab:	48 89 ce             	mov    %rcx,%rsi
  8004211eae:	48 89 c7             	mov    %rax,%rdi
  8004211eb1:	48 b8 48 fa 20 04 80 	movabs $0x800420fa48,%rax
  8004211eb8:	00 00 00 
  8004211ebb:	ff d0                	callq  *%rax
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004211ebd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004211ec4:	eb 5a                	jmp    8004211f20 <_dwarf_frame_regtable_copy+0x15b>
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  8004211ec6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211eca:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211ece:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211ed1:	48 63 d0             	movslq %eax,%rdx
  8004211ed4:	48 89 d0             	mov    %rdx,%rax
  8004211ed7:	48 01 c0             	add    %rax,%rax
  8004211eda:	48 01 d0             	add    %rdx,%rax
  8004211edd:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ee1:	48 01 c1             	add    %rax,%rcx
  8004211ee4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211ee8:	48 8b 00             	mov    (%rax),%rax
  8004211eeb:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211eef:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211ef2:	48 63 d0             	movslq %eax,%rdx
  8004211ef5:	48 89 d0             	mov    %rdx,%rax
  8004211ef8:	48 01 c0             	add    %rax,%rax
  8004211efb:	48 01 d0             	add    %rdx,%rax
  8004211efe:	48 c1 e0 03          	shl    $0x3,%rax
  8004211f02:	48 01 f0             	add    %rsi,%rax
  8004211f05:	ba 18 00 00 00       	mov    $0x18,%edx
  8004211f0a:	48 89 ce             	mov    %rcx,%rsi
  8004211f0d:	48 89 c7             	mov    %rax,%rdi
  8004211f10:	48 b8 48 fa 20 04 80 	movabs $0x800420fa48,%rax
  8004211f17:	00 00 00 
  8004211f1a:	ff d0                	callq  *%rax

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
             i < src->rt3_reg_table_size; i++)
  8004211f1c:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004211f20:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211f24:	48 8b 00             	mov    (%rax),%rax
  8004211f27:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211f2b:	0f b7 c0             	movzwl %ax,%eax
  8004211f2e:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004211f31:	7e 10                	jle    8004211f43 <_dwarf_frame_regtable_copy+0x17e>
             i < src->rt3_reg_table_size; i++)
  8004211f33:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211f37:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211f3b:	0f b7 c0             	movzwl %ax,%eax
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004211f3e:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004211f41:	7f 83                	jg     8004211ec6 <_dwarf_frame_regtable_copy+0x101>
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
                    sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  8004211f43:	eb 32                	jmp    8004211f77 <_dwarf_frame_regtable_copy+0x1b2>
                (*dest)->rt3_rules[i].dw_regnum =
  8004211f45:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211f49:	48 8b 00             	mov    (%rax),%rax
  8004211f4c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211f50:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211f53:	48 63 d0             	movslq %eax,%rdx
  8004211f56:	48 89 d0             	mov    %rdx,%rax
  8004211f59:	48 01 c0             	add    %rax,%rax
  8004211f5c:	48 01 d0             	add    %rdx,%rax
  8004211f5f:	48 c1 e0 03          	shl    $0x3,%rax
  8004211f63:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
                    dbg->dbg_frame_undefined_value;
  8004211f67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211f6b:	0f b7 40 50          	movzwl 0x50(%rax),%eax
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
                    sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
                (*dest)->rt3_rules[i].dw_regnum =
  8004211f6f:	66 89 42 02          	mov    %ax,0x2(%rdx)
        for (i = 0; i < (*dest)->rt3_reg_table_size &&
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
                    sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  8004211f73:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004211f77:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211f7b:	48 8b 00             	mov    (%rax),%rax
  8004211f7e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211f82:	0f b7 c0             	movzwl %ax,%eax
  8004211f85:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004211f88:	7f bb                	jg     8004211f45 <_dwarf_frame_regtable_copy+0x180>
                (*dest)->rt3_rules[i].dw_regnum =
                    dbg->dbg_frame_undefined_value;

        return (DW_DLE_NONE);
  8004211f8a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211f8f:	48 83 c4 38          	add    $0x38,%rsp
  8004211f93:	5b                   	pop    %rbx
  8004211f94:	5d                   	pop    %rbp
  8004211f95:	c3                   	retq   

0000008004211f96 <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
    Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
    Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004211f96:	55                   	push   %rbp
  8004211f97:	48 89 e5             	mov    %rsp,%rbp
  8004211f9a:	53                   	push   %rbx
  8004211f9b:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  8004211fa2:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004211fa6:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004211faa:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004211fae:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004211fb2:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  8004211fb9:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
                        ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
                        goto program_done;                              \
                }                                                       \
        } while(0)

        ret = DW_DLE_NONE;
  8004211fc0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
        init_rt = saved_rt = NULL;
  8004211fc7:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004211fce:	00 
  8004211fcf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211fd3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        *row_pc = pc;
  8004211fd7:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211fdb:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211fdf:	48 89 10             	mov    %rdx,(%rax)

        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  8004211fe2:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004211fe6:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004211fea:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  8004211fee:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211ff2:	48 89 c7             	mov    %rax,%rdi
  8004211ff5:	48 b8 c5 1d 21 04 80 	movabs $0x8004211dc5,%rax
  8004211ffc:	00 00 00 
  8004211fff:	ff d0                	callq  *%rax
        p = insts;
  8004212001:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004212005:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        pe = p + len;
  8004212009:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421200d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212011:	48 01 d0             	add    %rdx,%rax
  8004212014:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

        while (p < pe) {
  8004212018:	e9 3a 0d 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                if (*p == DW_CFA_nop) {
  800421201d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212021:	0f b6 00             	movzbl (%rax),%eax
  8004212024:	84 c0                	test   %al,%al
  8004212026:	75 11                	jne    8004212039 <_dwarf_frame_run_inst+0xa3>
                        p++;
  8004212028:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421202c:	48 83 c0 01          	add    $0x1,%rax
  8004212030:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        continue;
  8004212034:	e9 1e 0d 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                }

                high2 = *p & 0xc0;
  8004212039:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421203d:	0f b6 00             	movzbl (%rax),%eax
  8004212040:	83 e0 c0             	and    $0xffffffc0,%eax
  8004212043:	88 45 df             	mov    %al,-0x21(%rbp)
                low6 = *p & 0x3f;
  8004212046:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421204a:	0f b6 00             	movzbl (%rax),%eax
  800421204d:	83 e0 3f             	and    $0x3f,%eax
  8004212050:	88 45 de             	mov    %al,-0x22(%rbp)
                p++;
  8004212053:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212057:	48 83 c0 01          	add    $0x1,%rax
  800421205b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

                if (high2 > 0) {
  800421205f:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  8004212063:	0f 84 a1 01 00 00    	je     800421220a <_dwarf_frame_run_inst+0x274>
                        switch (high2) {
  8004212069:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800421206d:	3d 80 00 00 00       	cmp    $0x80,%eax
  8004212072:	74 38                	je     80042120ac <_dwarf_frame_run_inst+0x116>
  8004212074:	3d c0 00 00 00       	cmp    $0xc0,%eax
  8004212079:	0f 84 01 01 00 00    	je     8004212180 <_dwarf_frame_run_inst+0x1ea>
  800421207f:	83 f8 40             	cmp    $0x40,%eax
  8004212082:	0f 85 71 01 00 00    	jne    80042121f9 <_dwarf_frame_run_inst+0x263>
                        case DW_CFA_advance_loc:
                                pc += low6 * caf;
  8004212088:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  800421208c:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212093:	ff 
  8004212094:	48 01 45 10          	add    %rax,0x10(%rbp)
                                if (pc_req < pc)
  8004212098:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421209c:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042120a0:	73 05                	jae    80042120a7 <_dwarf_frame_run_inst+0x111>
                                        goto program_done;
  80042120a2:	e9 be 0c 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                                break;
  80042120a7:	e9 59 01 00 00       	jmpq   8004212205 <_dwarf_frame_run_inst+0x26f>
                        case DW_CFA_offset:
                                *row_pc = pc;
  80042120ac:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042120b0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042120b4:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  80042120b7:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042120bb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042120bf:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042120c3:	66 39 c2             	cmp    %ax,%dx
  80042120c6:	72 0c                	jb     80042120d4 <_dwarf_frame_run_inst+0x13e>
  80042120c8:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042120cf:	e9 91 0c 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                                RL[low6].dw_offset_relevant = 1;
  80042120d4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042120d8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042120dc:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042120e0:	48 89 d0             	mov    %rdx,%rax
  80042120e3:	48 01 c0             	add    %rax,%rax
  80042120e6:	48 01 d0             	add    %rdx,%rax
  80042120e9:	48 c1 e0 03          	shl    $0x3,%rax
  80042120ed:	48 01 c8             	add    %rcx,%rax
  80042120f0:	c6 00 01             	movb   $0x1,(%rax)
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
  80042120f3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042120f7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042120fb:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042120ff:	48 89 d0             	mov    %rdx,%rax
  8004212102:	48 01 c0             	add    %rax,%rax
  8004212105:	48 01 d0             	add    %rdx,%rax
  8004212108:	48 c1 e0 03          	shl    $0x3,%rax
  800421210c:	48 01 c8             	add    %rcx,%rax
  800421210f:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212113:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212117:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421211b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421211f:	48 89 d0             	mov    %rdx,%rax
  8004212122:	48 01 c0             	add    %rax,%rax
  8004212125:	48 01 d0             	add    %rdx,%rax
  8004212128:	48 c1 e0 03          	shl    $0x3,%rax
  800421212c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212130:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212134:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212138:	66 89 42 02          	mov    %ax,0x2(%rdx)
                                RL[low6].dw_offset_or_block_len =
  800421213c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212140:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212144:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212148:	48 89 d0             	mov    %rdx,%rax
  800421214b:	48 01 c0             	add    %rax,%rax
  800421214e:	48 01 d0             	add    %rdx,%rax
  8004212151:	48 c1 e0 03          	shl    $0x3,%rax
  8004212155:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
                                    _dwarf_decode_uleb128(&p) * daf;
  8004212159:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421215d:	48 89 c7             	mov    %rax,%rdi
  8004212160:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004212167:	00 00 00 
  800421216a:	ff d0                	callq  *%rax
  800421216c:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212173:	48 0f af c2          	imul   %rdx,%rax
                                *row_pc = pc;
                                CHECK_TABLE_SIZE(low6);
                                RL[low6].dw_offset_relevant = 1;
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
                                RL[low6].dw_offset_or_block_len =
  8004212177:	48 89 43 08          	mov    %rax,0x8(%rbx)
                                    _dwarf_decode_uleb128(&p) * daf;
                                break;
  800421217b:	e9 85 00 00 00       	jmpq   8004212205 <_dwarf_frame_run_inst+0x26f>
                        case DW_CFA_restore:
                                *row_pc = pc;
  8004212180:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212184:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212188:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  800421218b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421218f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212193:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212197:	66 39 c2             	cmp    %ax,%dx
  800421219a:	72 0c                	jb     80042121a8 <_dwarf_frame_run_inst+0x212>
  800421219c:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042121a3:	e9 bd 0b 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                                memcpy(&RL[low6], &INITRL[low6],
  80042121a8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042121ac:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042121b0:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042121b4:	48 89 d0             	mov    %rdx,%rax
  80042121b7:	48 01 c0             	add    %rax,%rax
  80042121ba:	48 01 d0             	add    %rdx,%rax
  80042121bd:	48 c1 e0 03          	shl    $0x3,%rax
  80042121c1:	48 01 c1             	add    %rax,%rcx
  80042121c4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042121c8:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042121cc:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042121d0:	48 89 d0             	mov    %rdx,%rax
  80042121d3:	48 01 c0             	add    %rax,%rax
  80042121d6:	48 01 d0             	add    %rdx,%rax
  80042121d9:	48 c1 e0 03          	shl    $0x3,%rax
  80042121dd:	48 01 f0             	add    %rsi,%rax
  80042121e0:	ba 18 00 00 00       	mov    $0x18,%edx
  80042121e5:	48 89 ce             	mov    %rcx,%rsi
  80042121e8:	48 89 c7             	mov    %rax,%rdi
  80042121eb:	48 b8 48 fa 20 04 80 	movabs $0x800420fa48,%rax
  80042121f2:	00 00 00 
  80042121f5:	ff d0                	callq  *%rax
                                    sizeof(Dwarf_Regtable_Entry3));
                                break;
  80042121f7:	eb 0c                	jmp    8004212205 <_dwarf_frame_run_inst+0x26f>
                        default:
                                DWARF_SET_ERROR(dbg, error,
                                    DW_DLE_FRAME_INSTR_EXEC_ERROR);
                                ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  80042121f9:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                                goto program_done;
  8004212200:	e9 60 0b 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        }

                        continue;
  8004212205:	e9 4d 0b 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                }

                switch (low6) {
  800421220a:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  800421220e:	83 f8 16             	cmp    $0x16,%eax
  8004212211:	0f 87 37 0b 00 00    	ja     8004212d4e <_dwarf_frame_run_inst+0xdb8>
  8004212217:	89 c0                	mov    %eax,%eax
  8004212219:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004212220:	00 
  8004212221:	48 b8 18 92 21 04 80 	movabs $0x8004219218,%rax
  8004212228:	00 00 00 
  800421222b:	48 01 d0             	add    %rdx,%rax
  800421222e:	48 8b 00             	mov    (%rax),%rax
  8004212231:	ff e0                	jmpq   *%rax
                case DW_CFA_set_loc:
                        pc = dbg->decode(&p, dbg->dbg_pointer_size);
  8004212233:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212237:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421223b:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421223f:	8b 4a 28             	mov    0x28(%rdx),%ecx
  8004212242:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212246:	89 ce                	mov    %ecx,%esi
  8004212248:	48 89 d7             	mov    %rdx,%rdi
  800421224b:	ff d0                	callq  *%rax
  800421224d:	48 89 45 10          	mov    %rax,0x10(%rbp)
                        if (pc_req < pc)
  8004212251:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212255:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212259:	73 05                	jae    8004212260 <_dwarf_frame_run_inst+0x2ca>
                                goto program_done;
  800421225b:	e9 05 0b 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        break;
  8004212260:	e9 f2 0a 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc1:
                        pc += dbg->decode(&p, 1) * caf;
  8004212265:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212269:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421226d:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212271:	be 01 00 00 00       	mov    $0x1,%esi
  8004212276:	48 89 d7             	mov    %rdx,%rdi
  8004212279:	ff d0                	callq  *%rax
  800421227b:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212282:	ff 
  8004212283:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  8004212287:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421228b:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421228f:	73 05                	jae    8004212296 <_dwarf_frame_run_inst+0x300>
                                goto program_done;
  8004212291:	e9 cf 0a 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        break;
  8004212296:	e9 bc 0a 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc2:
                        pc += dbg->decode(&p, 2) * caf;
  800421229b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421229f:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042122a3:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042122a7:	be 02 00 00 00       	mov    $0x2,%esi
  80042122ac:	48 89 d7             	mov    %rdx,%rdi
  80042122af:	ff d0                	callq  *%rax
  80042122b1:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042122b8:	ff 
  80042122b9:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  80042122bd:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042122c1:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042122c5:	73 05                	jae    80042122cc <_dwarf_frame_run_inst+0x336>
                                goto program_done;
  80042122c7:	e9 99 0a 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        break;
  80042122cc:	e9 86 0a 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc4:
                        pc += dbg->decode(&p, 4) * caf;
  80042122d1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042122d5:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042122d9:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042122dd:	be 04 00 00 00       	mov    $0x4,%esi
  80042122e2:	48 89 d7             	mov    %rdx,%rdi
  80042122e5:	ff d0                	callq  *%rax
  80042122e7:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042122ee:	ff 
  80042122ef:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  80042122f3:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042122f7:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042122fb:	73 05                	jae    8004212302 <_dwarf_frame_run_inst+0x36c>
                                goto program_done;
  80042122fd:	e9 63 0a 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        break;
  8004212302:	e9 50 0a 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_offset_extended:
                        *row_pc = pc;
  8004212307:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421230b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421230f:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212312:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212316:	48 89 c7             	mov    %rax,%rdi
  8004212319:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004212320:	00 00 00 
  8004212323:	ff d0                	callq  *%rax
  8004212325:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004212329:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421232d:	48 89 c7             	mov    %rax,%rdi
  8004212330:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004212337:	00 00 00 
  800421233a:	ff d0                	callq  *%rax
  800421233c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212340:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212344:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212348:	0f b7 c0             	movzwl %ax,%eax
  800421234b:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421234f:	77 0c                	ja     800421235d <_dwarf_frame_run_inst+0x3c7>
  8004212351:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212358:	e9 08 0a 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  800421235d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212361:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212365:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212369:	48 89 d0             	mov    %rdx,%rax
  800421236c:	48 01 c0             	add    %rax,%rax
  800421236f:	48 01 d0             	add    %rdx,%rax
  8004212372:	48 c1 e0 03          	shl    $0x3,%rax
  8004212376:	48 01 c8             	add    %rcx,%rax
  8004212379:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  800421237c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212380:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212384:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212388:	48 89 d0             	mov    %rdx,%rax
  800421238b:	48 01 c0             	add    %rax,%rax
  800421238e:	48 01 d0             	add    %rdx,%rax
  8004212391:	48 c1 e0 03          	shl    $0x3,%rax
  8004212395:	48 01 c8             	add    %rcx,%rax
  8004212398:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800421239c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042123a0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042123a4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042123a8:	48 89 d0             	mov    %rdx,%rax
  80042123ab:	48 01 c0             	add    %rax,%rax
  80042123ae:	48 01 d0             	add    %rdx,%rax
  80042123b1:	48 c1 e0 03          	shl    $0x3,%rax
  80042123b5:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042123b9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042123bd:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042123c1:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  80042123c5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042123c9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042123cd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042123d1:	48 89 d0             	mov    %rdx,%rax
  80042123d4:	48 01 c0             	add    %rax,%rax
  80042123d7:	48 01 d0             	add    %rdx,%rax
  80042123da:	48 c1 e0 03          	shl    $0x3,%rax
  80042123de:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042123e2:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042123e9:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  80042123ee:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  80042123f2:	e9 60 09 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_restore_extended:
                        *row_pc = pc;
  80042123f7:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042123fb:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042123ff:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212402:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212406:	48 89 c7             	mov    %rax,%rdi
  8004212409:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004212410:	00 00 00 
  8004212413:	ff d0                	callq  *%rax
  8004212415:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212419:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421241d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212421:	0f b7 c0             	movzwl %ax,%eax
  8004212424:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212428:	77 0c                	ja     8004212436 <_dwarf_frame_run_inst+0x4a0>
  800421242a:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212431:	e9 2f 09 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        memcpy(&RL[reg], &INITRL[reg],
  8004212436:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421243a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421243e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212442:	48 89 d0             	mov    %rdx,%rax
  8004212445:	48 01 c0             	add    %rax,%rax
  8004212448:	48 01 d0             	add    %rdx,%rax
  800421244b:	48 c1 e0 03          	shl    $0x3,%rax
  800421244f:	48 01 c1             	add    %rax,%rcx
  8004212452:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212456:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421245a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421245e:	48 89 d0             	mov    %rdx,%rax
  8004212461:	48 01 c0             	add    %rax,%rax
  8004212464:	48 01 d0             	add    %rdx,%rax
  8004212467:	48 c1 e0 03          	shl    $0x3,%rax
  800421246b:	48 01 f0             	add    %rsi,%rax
  800421246e:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212473:	48 89 ce             	mov    %rcx,%rsi
  8004212476:	48 89 c7             	mov    %rax,%rdi
  8004212479:	48 b8 48 fa 20 04 80 	movabs $0x800420fa48,%rax
  8004212480:	00 00 00 
  8004212483:	ff d0                	callq  *%rax
                        sizeof(Dwarf_Regtable_Entry3));
                        break;
  8004212485:	e9 cd 08 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_undefined:
                        *row_pc = pc;
  800421248a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421248e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212492:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212495:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212499:	48 89 c7             	mov    %rax,%rdi
  800421249c:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  80042124a3:	00 00 00 
  80042124a6:	ff d0                	callq  *%rax
  80042124a8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042124ac:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042124b0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042124b4:	0f b7 c0             	movzwl %ax,%eax
  80042124b7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042124bb:	77 0c                	ja     80042124c9 <_dwarf_frame_run_inst+0x533>
  80042124bd:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042124c4:	e9 9c 08 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  80042124c9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042124cd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042124d1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042124d5:	48 89 d0             	mov    %rdx,%rax
  80042124d8:	48 01 c0             	add    %rax,%rax
  80042124db:	48 01 d0             	add    %rdx,%rax
  80042124de:	48 c1 e0 03          	shl    $0x3,%rax
  80042124e2:	48 01 c8             	add    %rcx,%rax
  80042124e5:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  80042124e8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042124ec:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042124f0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042124f4:	48 89 d0             	mov    %rdx,%rax
  80042124f7:	48 01 c0             	add    %rax,%rax
  80042124fa:	48 01 d0             	add    %rdx,%rax
  80042124fd:	48 c1 e0 03          	shl    $0x3,%rax
  8004212501:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212505:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212509:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  800421250d:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  8004212511:	e9 41 08 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_same_value:
                        reg = _dwarf_decode_uleb128(&p);
  8004212516:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421251a:	48 89 c7             	mov    %rax,%rdi
  800421251d:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004212524:	00 00 00 
  8004212527:	ff d0                	callq  *%rax
  8004212529:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  800421252d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212531:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212535:	0f b7 c0             	movzwl %ax,%eax
  8004212538:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421253c:	77 0c                	ja     800421254a <_dwarf_frame_run_inst+0x5b4>
  800421253e:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212545:	e9 1b 08 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  800421254a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421254e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212552:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212556:	48 89 d0             	mov    %rdx,%rax
  8004212559:	48 01 c0             	add    %rax,%rax
  800421255c:	48 01 d0             	add    %rdx,%rax
  800421255f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212563:	48 01 c8             	add    %rcx,%rax
  8004212566:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  8004212569:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421256d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212571:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212575:	48 89 d0             	mov    %rdx,%rax
  8004212578:	48 01 c0             	add    %rax,%rax
  800421257b:	48 01 d0             	add    %rdx,%rax
  800421257e:	48 c1 e0 03          	shl    $0x3,%rax
  8004212582:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212586:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421258a:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  800421258e:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  8004212592:	e9 c0 07 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_register:
                        *row_pc = pc;
  8004212597:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421259b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421259f:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042125a2:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042125a6:	48 89 c7             	mov    %rax,%rdi
  80042125a9:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  80042125b0:	00 00 00 
  80042125b3:	ff d0                	callq  *%rax
  80042125b5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        reg2 = _dwarf_decode_uleb128(&p);
  80042125b9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042125bd:	48 89 c7             	mov    %rax,%rdi
  80042125c0:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  80042125c7:	00 00 00 
  80042125ca:	ff d0                	callq  *%rax
  80042125cc:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042125d0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042125d4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042125d8:	0f b7 c0             	movzwl %ax,%eax
  80042125db:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042125df:	77 0c                	ja     80042125ed <_dwarf_frame_run_inst+0x657>
  80042125e1:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042125e8:	e9 78 07 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  80042125ed:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042125f1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042125f5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042125f9:	48 89 d0             	mov    %rdx,%rax
  80042125fc:	48 01 c0             	add    %rax,%rax
  80042125ff:	48 01 d0             	add    %rdx,%rax
  8004212602:	48 c1 e0 03          	shl    $0x3,%rax
  8004212606:	48 01 c8             	add    %rcx,%rax
  8004212609:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = reg2;
  800421260c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212610:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212614:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212618:	48 89 d0             	mov    %rdx,%rax
  800421261b:	48 01 c0             	add    %rax,%rax
  800421261e:	48 01 d0             	add    %rdx,%rax
  8004212621:	48 c1 e0 03          	shl    $0x3,%rax
  8004212625:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212629:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421262d:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  8004212631:	e9 21 07 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_remember_state:
                        _dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  8004212636:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800421263a:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421263e:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  8004212642:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212646:	48 89 c7             	mov    %rax,%rdi
  8004212649:	48 b8 c5 1d 21 04 80 	movabs $0x8004211dc5,%rax
  8004212650:	00 00 00 
  8004212653:	ff d0                	callq  *%rax
                        break;
  8004212655:	e9 fd 06 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_restore_state:
                        *row_pc = pc;
  800421265a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421265e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212662:	48 89 10             	mov    %rdx,(%rax)
                        _dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004212665:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004212669:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421266d:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  8004212671:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212675:	48 89 c7             	mov    %rax,%rdi
  8004212678:	48 b8 c5 1d 21 04 80 	movabs $0x8004211dc5,%rax
  800421267f:	00 00 00 
  8004212682:	ff d0                	callq  *%rax
                        break;
  8004212684:	e9 ce 06 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa:
                        *row_pc = pc;
  8004212689:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421268d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212691:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212694:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212698:	48 89 c7             	mov    %rax,%rdi
  800421269b:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  80042126a2:	00 00 00 
  80042126a5:	ff d0                	callq  *%rax
  80042126a7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  80042126ab:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042126af:	48 89 c7             	mov    %rax,%rdi
  80042126b2:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  80042126b9:	00 00 00 
  80042126bc:	ff d0                	callq  *%rax
  80042126be:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  80042126c2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042126c6:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  80042126c9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042126cd:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  80042126d1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042126d5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042126d9:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  80042126dd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042126e1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042126e5:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  80042126e9:	e9 69 06 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_register:
                        *row_pc = pc;
  80042126ee:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042126f2:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042126f6:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042126f9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042126fd:	48 89 c7             	mov    %rax,%rdi
  8004212700:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004212707:	00 00 00 
  800421270a:	ff d0                	callq  *%rax
  800421270c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CFA.dw_regnum = reg;
  8004212710:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212714:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212718:	66 89 50 02          	mov    %dx,0x2(%rax)
                         * Note that DW_CFA_def_cfa_register change the CFA
                         * rule register while keep the old offset. So we
                         * should not touch the CFA.dw_offset_relevant flag
                         * here.
                         */
                        break;
  800421271c:	e9 36 06 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_offset:
                        *row_pc = pc;
  8004212721:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212725:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212729:	48 89 10             	mov    %rdx,(%rax)
                        uoff = _dwarf_decode_uleb128(&p);
  800421272c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212730:	48 89 c7             	mov    %rax,%rdi
  8004212733:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  800421273a:	00 00 00 
  800421273d:	ff d0                	callq  *%rax
  800421273f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004212743:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212747:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  800421274a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421274e:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  8004212752:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212756:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421275a:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  800421275e:	e9 f4 05 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_expression:
                        *row_pc = pc;
  8004212763:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212767:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421276b:	48 89 10             	mov    %rdx,(%rax)
                        CFA.dw_offset_relevant = 0;
  800421276e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212772:	c6 00 00             	movb   $0x0,(%rax)
                        CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004212775:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212779:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  800421277d:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8004212781:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212785:	48 89 c7             	mov    %rax,%rdi
  8004212788:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  800421278f:	00 00 00 
  8004212792:	ff d0                	callq  *%rax
  8004212794:	48 89 43 08          	mov    %rax,0x8(%rbx)
                        CFA.dw_block_ptr = p;
  8004212798:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421279c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042127a0:	48 89 50 10          	mov    %rdx,0x10(%rax)
                        p += CFA.dw_offset_or_block_len;
  80042127a4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042127a8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127ac:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042127b0:	48 01 d0             	add    %rdx,%rax
  80042127b3:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  80042127b7:	e9 9b 05 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_expression:
                        *row_pc = pc;
  80042127bc:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042127c0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042127c4:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042127c7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042127cb:	48 89 c7             	mov    %rax,%rdi
  80042127ce:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  80042127d5:	00 00 00 
  80042127d8:	ff d0                	callq  *%rax
  80042127da:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042127de:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127e2:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042127e6:	0f b7 c0             	movzwl %ax,%eax
  80042127e9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042127ed:	77 0c                	ja     80042127fb <_dwarf_frame_run_inst+0x865>
  80042127ef:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042127f6:	e9 6a 05 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  80042127fb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127ff:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212803:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212807:	48 89 d0             	mov    %rdx,%rax
  800421280a:	48 01 c0             	add    %rax,%rax
  800421280d:	48 01 d0             	add    %rdx,%rax
  8004212810:	48 c1 e0 03          	shl    $0x3,%rax
  8004212814:	48 01 c8             	add    %rcx,%rax
  8004212817:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  800421281a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421281e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212822:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212826:	48 89 d0             	mov    %rdx,%rax
  8004212829:	48 01 c0             	add    %rax,%rax
  800421282c:	48 01 d0             	add    %rdx,%rax
  800421282f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212833:	48 01 c8             	add    %rcx,%rax
  8004212836:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  800421283a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421283e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212842:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212846:	48 89 d0             	mov    %rdx,%rax
  8004212849:	48 01 c0             	add    %rax,%rax
  800421284c:	48 01 d0             	add    %rdx,%rax
  800421284f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212853:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
                            _dwarf_decode_uleb128(&p);
  8004212857:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421285b:	48 89 c7             	mov    %rax,%rdi
  800421285e:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004212865:	00 00 00 
  8004212868:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  800421286a:	48 89 43 08          	mov    %rax,0x8(%rbx)
                            _dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  800421286e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212872:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212876:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421287a:	48 89 d0             	mov    %rdx,%rax
  800421287d:	48 01 c0             	add    %rax,%rax
  8004212880:	48 01 d0             	add    %rdx,%rax
  8004212883:	48 c1 e0 03          	shl    $0x3,%rax
  8004212887:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421288b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421288f:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  8004212893:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004212897:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421289b:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421289f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042128a3:	48 89 d0             	mov    %rdx,%rax
  80042128a6:	48 01 c0             	add    %rax,%rax
  80042128a9:	48 01 d0             	add    %rdx,%rax
  80042128ac:	48 c1 e0 03          	shl    $0x3,%rax
  80042128b0:	48 01 f0             	add    %rsi,%rax
  80042128b3:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042128b7:	48 01 c8             	add    %rcx,%rax
  80042128ba:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  80042128be:	e9 94 04 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_offset_extended_sf:
                        *row_pc = pc;
  80042128c3:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042128c7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042128cb:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042128ce:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042128d2:	48 89 c7             	mov    %rax,%rdi
  80042128d5:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  80042128dc:	00 00 00 
  80042128df:	ff d0                	callq  *%rax
  80042128e1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  80042128e5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042128e9:	48 89 c7             	mov    %rax,%rdi
  80042128ec:	48 b8 37 04 21 04 80 	movabs $0x8004210437,%rax
  80042128f3:	00 00 00 
  80042128f6:	ff d0                	callq  *%rax
  80042128f8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042128fc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212900:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212904:	0f b7 c0             	movzwl %ax,%eax
  8004212907:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421290b:	77 0c                	ja     8004212919 <_dwarf_frame_run_inst+0x983>
  800421290d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212914:	e9 4c 04 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004212919:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421291d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212921:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212925:	48 89 d0             	mov    %rdx,%rax
  8004212928:	48 01 c0             	add    %rax,%rax
  800421292b:	48 01 d0             	add    %rdx,%rax
  800421292e:	48 c1 e0 03          	shl    $0x3,%rax
  8004212932:	48 01 c8             	add    %rcx,%rax
  8004212935:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004212938:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421293c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212940:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212944:	48 89 d0             	mov    %rdx,%rax
  8004212947:	48 01 c0             	add    %rax,%rax
  800421294a:	48 01 d0             	add    %rdx,%rax
  800421294d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212951:	48 01 c8             	add    %rcx,%rax
  8004212954:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212958:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421295c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212960:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212964:	48 89 d0             	mov    %rdx,%rax
  8004212967:	48 01 c0             	add    %rax,%rax
  800421296a:	48 01 d0             	add    %rdx,%rax
  800421296d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212971:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212975:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212979:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800421297d:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004212981:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212985:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212989:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421298d:	48 89 d0             	mov    %rdx,%rax
  8004212990:	48 01 c0             	add    %rax,%rax
  8004212993:	48 01 d0             	add    %rdx,%rax
  8004212996:	48 c1 e0 03          	shl    $0x3,%rax
  800421299a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421299e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042129a5:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  80042129aa:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  80042129ae:	e9 a4 03 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_sf:
                        *row_pc = pc;
  80042129b3:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042129b7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042129bb:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042129be:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042129c2:	48 89 c7             	mov    %rax,%rdi
  80042129c5:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  80042129cc:	00 00 00 
  80042129cf:	ff d0                	callq  *%rax
  80042129d1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  80042129d5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042129d9:	48 89 c7             	mov    %rax,%rdi
  80042129dc:	48 b8 37 04 21 04 80 	movabs $0x8004210437,%rax
  80042129e3:	00 00 00 
  80042129e6:	ff d0                	callq  *%rax
  80042129e8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  80042129ec:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042129f0:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  80042129f3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042129f7:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  80042129fb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042129ff:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a03:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004212a07:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a0b:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212a12:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004212a17:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004212a1b:	e9 37 03 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_offset_sf:
                        *row_pc = pc;
  8004212a20:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212a24:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212a28:	48 89 10             	mov    %rdx,(%rax)
                        soff = _dwarf_decode_sleb128(&p);
  8004212a2b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212a2f:	48 89 c7             	mov    %rax,%rdi
  8004212a32:	48 b8 37 04 21 04 80 	movabs $0x8004210437,%rax
  8004212a39:	00 00 00 
  8004212a3c:	ff d0                	callq  *%rax
  8004212a3e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004212a42:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a46:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212a49:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a4d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004212a51:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a55:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212a5c:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004212a61:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004212a65:	e9 ed 02 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_offset:
                        *row_pc = pc;
  8004212a6a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212a6e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212a72:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212a75:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212a79:	48 89 c7             	mov    %rax,%rdi
  8004212a7c:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004212a83:	00 00 00 
  8004212a86:	ff d0                	callq  *%rax
  8004212a88:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004212a8c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212a90:	48 89 c7             	mov    %rax,%rdi
  8004212a93:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004212a9a:	00 00 00 
  8004212a9d:	ff d0                	callq  *%rax
  8004212a9f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212aa3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212aa7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212aab:	0f b7 c0             	movzwl %ax,%eax
  8004212aae:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212ab2:	77 0c                	ja     8004212ac0 <_dwarf_frame_run_inst+0xb2a>
  8004212ab4:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212abb:	e9 a5 02 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004212ac0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ac4:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212ac8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212acc:	48 89 d0             	mov    %rdx,%rax
  8004212acf:	48 01 c0             	add    %rax,%rax
  8004212ad2:	48 01 d0             	add    %rdx,%rax
  8004212ad5:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ad9:	48 01 c8             	add    %rcx,%rax
  8004212adc:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004212adf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ae3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212ae7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212aeb:	48 89 d0             	mov    %rdx,%rax
  8004212aee:	48 01 c0             	add    %rax,%rax
  8004212af1:	48 01 d0             	add    %rdx,%rax
  8004212af4:	48 c1 e0 03          	shl    $0x3,%rax
  8004212af8:	48 01 c8             	add    %rcx,%rax
  8004212afb:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212aff:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b03:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212b07:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212b0b:	48 89 d0             	mov    %rdx,%rax
  8004212b0e:	48 01 c0             	add    %rax,%rax
  8004212b11:	48 01 d0             	add    %rdx,%rax
  8004212b14:	48 c1 e0 03          	shl    $0x3,%rax
  8004212b18:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212b1c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212b20:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212b24:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  8004212b28:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b2c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212b30:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212b34:	48 89 d0             	mov    %rdx,%rax
  8004212b37:	48 01 c0             	add    %rax,%rax
  8004212b3a:	48 01 d0             	add    %rdx,%rax
  8004212b3d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212b41:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212b45:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212b4c:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004212b51:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004212b55:	e9 fd 01 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_offset_sf:
                        *row_pc = pc;
  8004212b5a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212b5e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212b62:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212b65:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212b69:	48 89 c7             	mov    %rax,%rdi
  8004212b6c:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004212b73:	00 00 00 
  8004212b76:	ff d0                	callq  *%rax
  8004212b78:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004212b7c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212b80:	48 89 c7             	mov    %rax,%rdi
  8004212b83:	48 b8 37 04 21 04 80 	movabs $0x8004210437,%rax
  8004212b8a:	00 00 00 
  8004212b8d:	ff d0                	callq  *%rax
  8004212b8f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212b93:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b97:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212b9b:	0f b7 c0             	movzwl %ax,%eax
  8004212b9e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212ba2:	77 0c                	ja     8004212bb0 <_dwarf_frame_run_inst+0xc1a>
  8004212ba4:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212bab:	e9 b5 01 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004212bb0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bb4:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212bb8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212bbc:	48 89 d0             	mov    %rdx,%rax
  8004212bbf:	48 01 c0             	add    %rax,%rax
  8004212bc2:	48 01 d0             	add    %rdx,%rax
  8004212bc5:	48 c1 e0 03          	shl    $0x3,%rax
  8004212bc9:	48 01 c8             	add    %rcx,%rax
  8004212bcc:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004212bcf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bd3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212bd7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212bdb:	48 89 d0             	mov    %rdx,%rax
  8004212bde:	48 01 c0             	add    %rax,%rax
  8004212be1:	48 01 d0             	add    %rdx,%rax
  8004212be4:	48 c1 e0 03          	shl    $0x3,%rax
  8004212be8:	48 01 c8             	add    %rcx,%rax
  8004212beb:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212bef:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bf3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212bf7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212bfb:	48 89 d0             	mov    %rdx,%rax
  8004212bfe:	48 01 c0             	add    %rax,%rax
  8004212c01:	48 01 d0             	add    %rdx,%rax
  8004212c04:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c08:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212c0c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212c10:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212c14:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004212c18:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c1c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c20:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212c24:	48 89 d0             	mov    %rdx,%rax
  8004212c27:	48 01 c0             	add    %rax,%rax
  8004212c2a:	48 01 d0             	add    %rdx,%rax
  8004212c2d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c31:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212c35:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212c3c:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004212c41:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004212c45:	e9 0d 01 00 00       	jmpq   8004212d57 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_expression:
                        *row_pc = pc;
  8004212c4a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212c4e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212c52:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212c55:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212c59:	48 89 c7             	mov    %rax,%rdi
  8004212c5c:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004212c63:	00 00 00 
  8004212c66:	ff d0                	callq  *%rax
  8004212c68:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212c6c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c70:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212c74:	0f b7 c0             	movzwl %ax,%eax
  8004212c77:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212c7b:	77 0c                	ja     8004212c89 <_dwarf_frame_run_inst+0xcf3>
  8004212c7d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212c84:	e9 dc 00 00 00       	jmpq   8004212d65 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004212c89:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c8d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c91:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212c95:	48 89 d0             	mov    %rdx,%rax
  8004212c98:	48 01 c0             	add    %rax,%rax
  8004212c9b:	48 01 d0             	add    %rdx,%rax
  8004212c9e:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ca2:	48 01 c8             	add    %rcx,%rax
  8004212ca5:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  8004212ca8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cac:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cb0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212cb4:	48 89 d0             	mov    %rdx,%rax
  8004212cb7:	48 01 c0             	add    %rax,%rax
  8004212cba:	48 01 d0             	add    %rdx,%rax
  8004212cbd:	48 c1 e0 03          	shl    $0x3,%rax
  8004212cc1:	48 01 c8             	add    %rcx,%rax
  8004212cc4:	c6 40 01 03          	movb   $0x3,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  8004212cc8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ccc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cd0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212cd4:	48 89 d0             	mov    %rdx,%rax
  8004212cd7:	48 01 c0             	add    %rax,%rax
  8004212cda:	48 01 d0             	add    %rdx,%rax
  8004212cdd:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ce1:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
                            _dwarf_decode_uleb128(&p);
  8004212ce5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212ce9:	48 89 c7             	mov    %rax,%rdi
  8004212cec:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004212cf3:	00 00 00 
  8004212cf6:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  8004212cf8:	48 89 43 08          	mov    %rax,0x8(%rbx)
                            _dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  8004212cfc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d00:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212d04:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d08:	48 89 d0             	mov    %rdx,%rax
  8004212d0b:	48 01 c0             	add    %rax,%rax
  8004212d0e:	48 01 d0             	add    %rdx,%rax
  8004212d11:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d15:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212d19:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212d1d:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  8004212d21:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004212d25:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d29:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212d2d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d31:	48 89 d0             	mov    %rdx,%rax
  8004212d34:	48 01 c0             	add    %rax,%rax
  8004212d37:	48 01 d0             	add    %rdx,%rax
  8004212d3a:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d3e:	48 01 f0             	add    %rsi,%rax
  8004212d41:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212d45:	48 01 c8             	add    %rcx,%rax
  8004212d48:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  8004212d4c:	eb 09                	jmp    8004212d57 <_dwarf_frame_run_inst+0xdc1>
                default:
                        DWARF_SET_ERROR(dbg, error,
                            DW_DLE_FRAME_INSTR_EXEC_ERROR);
                        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004212d4e:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                        goto program_done;
  8004212d55:	eb 0e                	jmp    8004212d65 <_dwarf_frame_run_inst+0xdcf>
        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
        p = insts;
        pe = p + len;

        while (p < pe) {
  8004212d57:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212d5b:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212d5f:	0f 82 b8 f2 ff ff    	jb     800421201d <_dwarf_frame_run_inst+0x87>
                        goto program_done;
                }
        }

program_done:
        return (ret);
  8004212d65:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004212d68:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  8004212d6f:	5b                   	pop    %rbx
  8004212d70:	5d                   	pop    %rbp
  8004212d71:	c3                   	retq   

0000008004212d72 <_dwarf_frame_get_internal_table>:

int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
    Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt, Dwarf_Addr *ret_row_pc,
    Dwarf_Error *error)
{
  8004212d72:	55                   	push   %rbp
  8004212d73:	48 89 e5             	mov    %rsp,%rbp
  8004212d76:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004212d7a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212d7e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212d82:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212d86:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004212d8a:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  8004212d8e:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
        Dwarf_Cie cie;
        Dwarf_Regtable3 *rt;
        Dwarf_Addr row_pc;
        int i, ret;

        assert(ret_rt != NULL);
  8004212d92:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004212d97:	75 35                	jne    8004212dce <_dwarf_frame_get_internal_table+0x5c>
  8004212d99:	48 b9 d0 92 21 04 80 	movabs $0x80042192d0,%rcx
  8004212da0:	00 00 00 
  8004212da3:	48 ba df 91 21 04 80 	movabs $0x80042191df,%rdx
  8004212daa:	00 00 00 
  8004212dad:	be 80 01 00 00       	mov    $0x180,%esi
  8004212db2:	48 bf f4 91 21 04 80 	movabs $0x80042191f4,%rdi
  8004212db9:	00 00 00 
  8004212dbc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212dc1:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004212dc8:	00 00 00 
  8004212dcb:	41 ff d0             	callq  *%r8

        //dbg = fde->fde_dbg;
        assert(dbg != NULL);
  8004212dce:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004212dd3:	75 35                	jne    8004212e0a <_dwarf_frame_get_internal_table+0x98>
  8004212dd5:	48 b9 df 92 21 04 80 	movabs $0x80042192df,%rcx
  8004212ddc:	00 00 00 
  8004212ddf:	48 ba df 91 21 04 80 	movabs $0x80042191df,%rdx
  8004212de6:	00 00 00 
  8004212de9:	be 83 01 00 00       	mov    $0x183,%esi
  8004212dee:	48 bf f4 91 21 04 80 	movabs $0x80042191f4,%rdi
  8004212df5:	00 00 00 
  8004212df8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212dfd:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004212e04:	00 00 00 
  8004212e07:	41 ff d0             	callq  *%r8

        rt = dbg->dbg_internal_reg_table;
  8004212e0a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e0e:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212e12:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

        /* Clear the content of regtable from previous run. */
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  8004212e16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212e1a:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212e1f:	be 00 00 00 00       	mov    $0x0,%esi
  8004212e24:	48 89 c7             	mov    %rax,%rdi
  8004212e27:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004212e2e:	00 00 00 
  8004212e31:	ff d0                	callq  *%rax
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  8004212e33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212e37:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212e3b:	0f b7 d0             	movzwl %ax,%edx
  8004212e3e:	48 89 d0             	mov    %rdx,%rax
  8004212e41:	48 01 c0             	add    %rax,%rax
  8004212e44:	48 01 d0             	add    %rdx,%rax
  8004212e47:	48 c1 e0 03          	shl    $0x3,%rax
  8004212e4b:	48 89 c2             	mov    %rax,%rdx
  8004212e4e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212e52:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212e56:	be 00 00 00 00       	mov    $0x0,%esi
  8004212e5b:	48 89 c7             	mov    %rax,%rdi
  8004212e5e:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004212e65:	00 00 00 
  8004212e68:	ff d0                	callq  *%rax
            sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004212e6a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004212e71:	eb 2f                	jmp    8004212ea2 <_dwarf_frame_get_internal_table+0x130>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  8004212e73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212e77:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212e7b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212e7e:	48 63 d0             	movslq %eax,%rdx
  8004212e81:	48 89 d0             	mov    %rdx,%rax
  8004212e84:	48 01 c0             	add    %rax,%rax
  8004212e87:	48 01 d0             	add    %rdx,%rax
  8004212e8a:	48 c1 e0 03          	shl    $0x3,%rax
  8004212e8e:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212e92:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e96:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  8004212e9a:	66 89 42 02          	mov    %ax,0x2(%rdx)
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
            sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004212e9e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004212ea2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212ea6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212eaa:	0f b7 c0             	movzwl %ax,%eax
  8004212ead:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004212eb0:	7f c1                	jg     8004212e73 <_dwarf_frame_get_internal_table+0x101>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
  8004212eb2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212eb6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212eba:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        assert(cie != NULL);
  8004212ebe:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212ec3:	75 35                	jne    8004212efa <_dwarf_frame_get_internal_table+0x188>
  8004212ec5:	48 b9 eb 92 21 04 80 	movabs $0x80042192eb,%rcx
  8004212ecc:	00 00 00 
  8004212ecf:	48 ba df 91 21 04 80 	movabs $0x80042191df,%rdx
  8004212ed6:	00 00 00 
  8004212ed9:	be 92 01 00 00       	mov    $0x192,%esi
  8004212ede:	48 bf f4 91 21 04 80 	movabs $0x80042191f4,%rdi
  8004212ee5:	00 00 00 
  8004212ee8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212eed:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004212ef4:	00 00 00 
  8004212ef7:	41 ff d0             	callq  *%r8
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004212efa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212efe:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004212f02:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f06:	4c 8b 40 38          	mov    0x38(%rax),%r8
  8004212f0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f0e:	48 8b 48 70          	mov    0x70(%rax),%rcx
  8004212f12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f16:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004212f1a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004212f1e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f22:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8004212f26:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004212f2b:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  8004212f2f:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004212f34:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  8004212f3b:	ff ff 
  8004212f3d:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8004212f44:	00 
  8004212f45:	48 89 c7             	mov    %rax,%rdi
  8004212f48:	48 b8 96 1f 21 04 80 	movabs $0x8004211f96,%rax
  8004212f4f:	00 00 00 
  8004212f52:	ff d0                	callq  *%rax
  8004212f54:	89 45 e4             	mov    %eax,-0x1c(%rbp)
            cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
            &row_pc, error);
        if (ret != DW_DLE_NONE)
  8004212f57:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212f5b:	74 08                	je     8004212f65 <_dwarf_frame_get_internal_table+0x1f3>
                return (ret);
  8004212f5d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212f60:	e9 98 00 00 00       	jmpq   8004212ffd <_dwarf_frame_get_internal_table+0x28b>
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
  8004212f65:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212f69:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004212f6d:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004212f71:	77 6f                	ja     8004212fe2 <_dwarf_frame_get_internal_table+0x270>
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004212f73:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212f77:	48 8b 78 30          	mov    0x30(%rax),%rdi
  8004212f7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f7f:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004212f83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f87:	4c 8b 50 38          	mov    0x38(%rax),%r10
  8004212f8b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212f8f:	48 8b 48 58          	mov    0x58(%rax),%rcx
  8004212f93:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212f97:	48 8b 50 50          	mov    0x50(%rax),%rdx
  8004212f9b:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004212f9f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212fa3:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  8004212fa7:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004212fac:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  8004212fb0:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004212fb5:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  8004212fb9:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004212fbe:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212fc2:	4d 89 d0             	mov    %r10,%r8
  8004212fc5:	48 89 c7             	mov    %rax,%rdi
  8004212fc8:	48 b8 96 1f 21 04 80 	movabs $0x8004211f96,%rax
  8004212fcf:	00 00 00 
  8004212fd2:	ff d0                	callq  *%rax
  8004212fd4:	89 45 e4             	mov    %eax,-0x1c(%rbp)
                    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
                    fde->fde_initloc, pc_req, &row_pc, error);
                if (ret != DW_DLE_NONE)
  8004212fd7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212fdb:	74 05                	je     8004212fe2 <_dwarf_frame_get_internal_table+0x270>
                        return (ret);
  8004212fdd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212fe0:	eb 1b                	jmp    8004212ffd <_dwarf_frame_get_internal_table+0x28b>
        }

        *ret_rt = rt;
  8004212fe2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212fe6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004212fea:	48 89 10             	mov    %rdx,(%rax)
        *ret_row_pc = row_pc;
  8004212fed:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004212ff1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212ff5:	48 89 10             	mov    %rdx,(%rax)

        return (DW_DLE_NONE);
  8004212ff8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212ffd:	c9                   	leaveq 
  8004212ffe:	c3                   	retq   

0000008004212fff <dwarf_get_fde_info_for_all_regs>:

int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
    Dwarf_Addr pc_requested, Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
    Dwarf_Error *error)
{
  8004212fff:	55                   	push   %rbp
  8004213000:	48 89 e5             	mov    %rsp,%rbp
  8004213003:	48 83 ec 50          	sub    $0x50,%rsp
  8004213007:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421300b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421300f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004213013:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004213017:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  800421301b:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
        Dwarf_Regtable3 *rt;
        Dwarf_Addr pc;
        Dwarf_Half cfa;
        int i, ret;

        if (fde == NULL || reg_table == NULL) {
  800421301f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004213024:	74 07                	je     800421302d <dwarf_get_fde_info_for_all_regs+0x2e>
  8004213026:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800421302b:	75 0a                	jne    8004213037 <dwarf_get_fde_info_for_all_regs+0x38>
                DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
                return (DW_DLV_ERROR);
  800421302d:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213032:	e9 eb 02 00 00       	jmpq   8004213322 <dwarf_get_fde_info_for_all_regs+0x323>
        }

        assert(dbg != NULL);
  8004213037:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421303c:	75 35                	jne    8004213073 <dwarf_get_fde_info_for_all_regs+0x74>
  800421303e:	48 b9 df 92 21 04 80 	movabs $0x80042192df,%rcx
  8004213045:	00 00 00 
  8004213048:	48 ba df 91 21 04 80 	movabs $0x80042191df,%rdx
  800421304f:	00 00 00 
  8004213052:	be b8 01 00 00       	mov    $0x1b8,%esi
  8004213057:	48 bf f4 91 21 04 80 	movabs $0x80042191f4,%rdi
  800421305e:	00 00 00 
  8004213061:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213066:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800421306d:	00 00 00 
  8004213070:	41 ff d0             	callq  *%r8

        if (pc_requested < fde->fde_initloc ||
  8004213073:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213077:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421307b:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800421307f:	77 19                	ja     800421309a <dwarf_get_fde_info_for_all_regs+0x9b>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  8004213081:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213085:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004213089:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421308d:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213091:	48 01 d0             	add    %rdx,%rax
                return (DW_DLV_ERROR);
        }

        assert(dbg != NULL);

        if (pc_requested < fde->fde_initloc ||
  8004213094:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004213098:	77 0a                	ja     80042130a4 <dwarf_get_fde_info_for_all_regs+0xa5>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
                DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
                return (DW_DLV_ERROR);
  800421309a:	b8 01 00 00 00       	mov    $0x1,%eax
  800421309f:	e9 7e 02 00 00       	jmpq   8004213322 <dwarf_get_fde_info_for_all_regs+0x323>
        }

        ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  80042130a4:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  80042130a8:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  80042130ac:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  80042130b0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042130b4:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042130b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042130bc:	4d 89 c1             	mov    %r8,%r9
  80042130bf:	49 89 f8             	mov    %rdi,%r8
  80042130c2:	48 89 c7             	mov    %rax,%rdi
  80042130c5:	48 b8 72 2d 21 04 80 	movabs $0x8004212d72,%rax
  80042130cc:	00 00 00 
  80042130cf:	ff d0                	callq  *%rax
  80042130d1:	89 45 f8             	mov    %eax,-0x8(%rbp)
                                              error);
        if (ret != DW_DLE_NONE)
  80042130d4:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042130d8:	74 0a                	je     80042130e4 <dwarf_get_fde_info_for_all_regs+0xe5>
                return (DW_DLV_ERROR);
  80042130da:	b8 01 00 00 00       	mov    $0x1,%eax
  80042130df:	e9 3e 02 00 00       	jmpq   8004213322 <dwarf_get_fde_info_for_all_regs+0x323>
        /*
         * Copy the CFA rule to the column intended for holding the CFA,
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
  80042130e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042130e8:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042130ec:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
        if (cfa < DW_REG_TABLE_SIZE) {
  80042130f0:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  80042130f5:	0f 87 b1 00 00 00    	ja     80042131ac <dwarf_get_fde_info_for_all_regs+0x1ad>
                reg_table->rules[cfa].dw_offset_relevant =
  80042130fb:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
                    CFA.dw_offset_relevant;
  80042130ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213103:	0f b6 00             	movzbl (%rax),%eax
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
        if (cfa < DW_REG_TABLE_SIZE) {
                reg_table->rules[cfa].dw_offset_relevant =
  8004213106:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421310a:	48 63 c9             	movslq %ecx,%rcx
  800421310d:	48 83 c1 01          	add    $0x1,%rcx
  8004213111:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213115:	48 01 ca             	add    %rcx,%rdx
  8004213118:	88 02                	mov    %al,(%rdx)
                    CFA.dw_offset_relevant;
                reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  800421311a:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421311e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213122:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8004213126:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421312a:	48 63 c9             	movslq %ecx,%rcx
  800421312d:	48 83 c1 01          	add    $0x1,%rcx
  8004213131:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213135:	48 01 ca             	add    %rcx,%rdx
  8004213138:	88 42 01             	mov    %al,0x1(%rdx)
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  800421313b:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421313f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213143:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004213147:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421314b:	48 63 c9             	movslq %ecx,%rcx
  800421314e:	48 83 c1 01          	add    $0x1,%rcx
  8004213152:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213156:	48 01 ca             	add    %rcx,%rdx
  8004213159:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  800421315d:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004213161:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213165:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213169:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421316d:	48 63 c9             	movslq %ecx,%rcx
  8004213170:	48 83 c1 01          	add    $0x1,%rcx
  8004213174:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213178:	48 01 ca             	add    %rcx,%rdx
  800421317b:	48 83 c2 08          	add    $0x8,%rdx
  800421317f:	48 89 02             	mov    %rax,(%rdx)
                reg_table->cfa_rule = reg_table->rules[cfa];
  8004213182:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004213186:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800421318a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421318e:	48 63 d2             	movslq %edx,%rdx
  8004213191:	48 83 c2 01          	add    $0x1,%rdx
  8004213195:	48 c1 e2 04          	shl    $0x4,%rdx
  8004213199:	48 01 d0             	add    %rdx,%rax
  800421319c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042131a0:	48 8b 00             	mov    (%rax),%rax
  80042131a3:	48 89 01             	mov    %rax,(%rcx)
  80042131a6:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  80042131aa:	eb 3c                	jmp    80042131e8 <dwarf_get_fde_info_for_all_regs+0x1e9>
        } else {
                reg_table->cfa_rule.dw_offset_relevant =
                    CFA.dw_offset_relevant;
  80042131ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131b0:	0f b6 10             	movzbl (%rax),%edx
                reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
                reg_table->cfa_rule = reg_table->rules[cfa];
        } else {
                reg_table->cfa_rule.dw_offset_relevant =
  80042131b3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042131b7:	88 10                	mov    %dl,(%rax)
                    CFA.dw_offset_relevant;
                reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  80042131b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131bd:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  80042131c1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042131c5:	88 50 01             	mov    %dl,0x1(%rax)
                reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  80042131c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131cc:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  80042131d0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042131d4:	66 89 50 02          	mov    %dx,0x2(%rax)
                reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  80042131d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131dc:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042131e0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042131e4:	48 89 50 08          	mov    %rdx,0x8(%rax)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042131e8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042131ef:	e9 fd 00 00 00       	jmpq   80042132f1 <dwarf_get_fde_info_for_all_regs+0x2f2>
             i++) {

                /* Do not overwrite CFA column */
                if (i == cfa)
  80042131f4:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80042131f8:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042131fb:	75 05                	jne    8004213202 <dwarf_get_fde_info_for_all_regs+0x203>
                        continue;
  80042131fd:	e9 eb 00 00 00       	jmpq   80042132ed <dwarf_get_fde_info_for_all_regs+0x2ee>

                reg_table->rules[i].dw_offset_relevant =
                    rt->rt3_rules[i].dw_offset_relevant;
  8004213202:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213206:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421320a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421320d:	48 63 d0             	movslq %eax,%rdx
  8004213210:	48 89 d0             	mov    %rdx,%rax
  8004213213:	48 01 c0             	add    %rax,%rax
  8004213216:	48 01 d0             	add    %rdx,%rax
  8004213219:	48 c1 e0 03          	shl    $0x3,%rax
  800421321d:	48 01 c8             	add    %rcx,%rax
  8004213220:	0f b6 00             	movzbl (%rax),%eax

                /* Do not overwrite CFA column */
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
  8004213223:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213227:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421322a:	48 63 c9             	movslq %ecx,%rcx
  800421322d:	48 83 c1 01          	add    $0x1,%rcx
  8004213231:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213235:	48 01 ca             	add    %rcx,%rdx
  8004213238:	88 02                	mov    %al,(%rdx)
                    rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
                    rt->rt3_rules[i].dw_value_type;
  800421323a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421323e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213242:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213245:	48 63 d0             	movslq %eax,%rdx
  8004213248:	48 89 d0             	mov    %rdx,%rax
  800421324b:	48 01 c0             	add    %rax,%rax
  800421324e:	48 01 d0             	add    %rdx,%rax
  8004213251:	48 c1 e0 03          	shl    $0x3,%rax
  8004213255:	48 01 c8             	add    %rcx,%rax
  8004213258:	0f b6 40 01          	movzbl 0x1(%rax),%eax
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
                    rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
  800421325c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213260:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213263:	48 63 c9             	movslq %ecx,%rcx
  8004213266:	48 83 c1 01          	add    $0x1,%rcx
  800421326a:	48 c1 e1 04          	shl    $0x4,%rcx
  800421326e:	48 01 ca             	add    %rcx,%rdx
  8004213271:	88 42 01             	mov    %al,0x1(%rdx)
                    rt->rt3_rules[i].dw_value_type;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  8004213274:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213278:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421327c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421327f:	48 63 d0             	movslq %eax,%rdx
  8004213282:	48 89 d0             	mov    %rdx,%rax
  8004213285:	48 01 c0             	add    %rax,%rax
  8004213288:	48 01 d0             	add    %rdx,%rax
  800421328b:	48 c1 e0 03          	shl    $0x3,%rax
  800421328f:	48 01 c8             	add    %rcx,%rax
  8004213292:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004213296:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421329a:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421329d:	48 63 c9             	movslq %ecx,%rcx
  80042132a0:	48 83 c1 01          	add    $0x1,%rcx
  80042132a4:	48 c1 e1 04          	shl    $0x4,%rcx
  80042132a8:	48 01 ca             	add    %rcx,%rdx
  80042132ab:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[i].dw_offset =
                    rt->rt3_rules[i].dw_offset_or_block_len;
  80042132af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132b3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042132b7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042132ba:	48 63 d0             	movslq %eax,%rdx
  80042132bd:	48 89 d0             	mov    %rdx,%rax
  80042132c0:	48 01 c0             	add    %rax,%rax
  80042132c3:	48 01 d0             	add    %rdx,%rax
  80042132c6:	48 c1 e0 03          	shl    $0x3,%rax
  80042132ca:	48 01 c8             	add    %rcx,%rax
  80042132cd:	48 8b 40 08          	mov    0x8(%rax),%rax
                reg_table->rules[i].dw_offset_relevant =
                    rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
                    rt->rt3_rules[i].dw_value_type;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
  80042132d1:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042132d5:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042132d8:	48 63 c9             	movslq %ecx,%rcx
  80042132db:	48 83 c1 01          	add    $0x1,%rcx
  80042132df:	48 c1 e1 04          	shl    $0x4,%rcx
  80042132e3:	48 01 ca             	add    %rcx,%rdx
  80042132e6:	48 83 c2 08          	add    $0x8,%rdx
  80042132ea:	48 89 02             	mov    %rax,(%rdx)

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
             i++) {
  80042132ed:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042132f1:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  80042132f5:	7f 14                	jg     800421330b <dwarf_get_fde_info_for_all_regs+0x30c>
  80042132f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042132fb:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  80042132ff:	0f b7 c0             	movzwl %ax,%eax
  8004213302:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004213305:	0f 8f e9 fe ff ff    	jg     80042131f4 <dwarf_get_fde_info_for_all_regs+0x1f5>
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
                    rt->rt3_rules[i].dw_offset_or_block_len;
        }

        if (row_pc) *row_pc = pc;
  800421330b:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004213310:	74 0b                	je     800421331d <dwarf_get_fde_info_for_all_regs+0x31e>
  8004213312:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213316:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421331a:	48 89 10             	mov    %rdx,(%rax)
        return (DW_DLV_OK);
  800421331d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213322:	c9                   	leaveq 
  8004213323:	c3                   	retq   

0000008004213324 <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
    uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004213324:	55                   	push   %rbp
  8004213325:	48 89 e5             	mov    %rsp,%rbp
  8004213328:	48 83 ec 40          	sub    $0x40,%rsp
  800421332c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213330:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004213334:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004213338:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800421333c:	44 89 c0             	mov    %r8d,%eax
  800421333f:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  8004213343:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  8004213346:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  800421334a:	75 0a                	jne    8004213356 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  800421334c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213351:	e9 e6 01 00 00       	jmpq   800421353c <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  8004213356:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421335a:	83 e0 f0             	and    $0xfffffff0,%eax
  800421335d:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  8004213360:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  8004213364:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004213368:	83 f8 0c             	cmp    $0xc,%eax
  800421336b:	0f 87 72 01 00 00    	ja     80042134e3 <_dwarf_frame_read_lsb_encoded+0x1bf>
  8004213371:	89 c0                	mov    %eax,%eax
  8004213373:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421337a:	00 
  800421337b:	48 b8 f8 92 21 04 80 	movabs $0x80042192f8,%rax
  8004213382:	00 00 00 
  8004213385:	48 01 d0             	add    %rdx,%rax
  8004213388:	48 8b 00             	mov    (%rax),%rax
  800421338b:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  800421338d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213391:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213395:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213399:	8b 52 28             	mov    0x28(%rdx),%edx
  800421339c:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042133a0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042133a4:	48 89 cf             	mov    %rcx,%rdi
  80042133a7:	ff d0                	callq  *%rax
  80042133a9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042133ad:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042133b0:	e9 35 01 00 00       	jmpq   80042134ea <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  80042133b5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042133b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042133bd:	48 89 d6             	mov    %rdx,%rsi
  80042133c0:	48 89 c7             	mov    %rax,%rdi
  80042133c3:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  80042133ca:	00 00 00 
  80042133cd:	ff d0                	callq  *%rax
  80042133cf:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042133d3:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042133d6:	e9 0f 01 00 00       	jmpq   80042134ea <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  80042133db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133df:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042133e3:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042133e7:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042133eb:	ba 02 00 00 00       	mov    $0x2,%edx
  80042133f0:	48 89 cf             	mov    %rcx,%rdi
  80042133f3:	ff d0                	callq  *%rax
  80042133f5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042133f9:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042133fc:	e9 e9 00 00 00       	jmpq   80042134ea <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  8004213401:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213405:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213409:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421340d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213411:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213416:	48 89 cf             	mov    %rcx,%rdi
  8004213419:	ff d0                	callq  *%rax
  800421341b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421341f:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213422:	e9 c3 00 00 00       	jmpq   80042134ea <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  8004213427:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421342b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421342f:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213433:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213437:	ba 08 00 00 00       	mov    $0x8,%edx
  800421343c:	48 89 cf             	mov    %rcx,%rdi
  800421343f:	ff d0                	callq  *%rax
  8004213441:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213445:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213448:	e9 9d 00 00 00       	jmpq   80042134ea <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  800421344d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213451:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213455:	48 89 d6             	mov    %rdx,%rsi
  8004213458:	48 89 c7             	mov    %rax,%rdi
  800421345b:	48 b8 14 03 21 04 80 	movabs $0x8004210314,%rax
  8004213462:	00 00 00 
  8004213465:	ff d0                	callq  *%rax
  8004213467:	48 89 c2             	mov    %rax,%rdx
  800421346a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421346e:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004213471:	eb 77                	jmp    80042134ea <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  8004213473:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213477:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421347b:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421347f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213483:	ba 02 00 00 00       	mov    $0x2,%edx
  8004213488:	48 89 cf             	mov    %rcx,%rdi
  800421348b:	ff d0                	callq  *%rax
  800421348d:	48 0f bf d0          	movswq %ax,%rdx
  8004213491:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213495:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004213498:	eb 50                	jmp    80042134ea <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  800421349a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421349e:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042134a2:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042134a6:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042134aa:	ba 04 00 00 00       	mov    $0x4,%edx
  80042134af:	48 89 cf             	mov    %rcx,%rdi
  80042134b2:	ff d0                	callq  *%rax
  80042134b4:	48 63 d0             	movslq %eax,%rdx
  80042134b7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042134bb:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042134be:	eb 2a                	jmp    80042134ea <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  80042134c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042134c4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042134c8:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042134cc:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042134d0:	ba 08 00 00 00       	mov    $0x8,%edx
  80042134d5:	48 89 cf             	mov    %rcx,%rdi
  80042134d8:	ff d0                	callq  *%rax
  80042134da:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042134de:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042134e1:	eb 07                	jmp    80042134ea <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  80042134e3:	b8 14 00 00 00       	mov    $0x14,%eax
  80042134e8:	eb 52                	jmp    800421353c <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  80042134ea:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  80042134ee:	75 47                	jne    8004213537 <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  80042134f0:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042134f4:	83 f8 01             	cmp    $0x1,%eax
  80042134f7:	7c 3d                	jl     8004213536 <_dwarf_frame_read_lsb_encoded+0x212>
  80042134f9:	83 f8 04             	cmp    $0x4,%eax
  80042134fc:	7e 0a                	jle    8004213508 <_dwarf_frame_read_lsb_encoded+0x1e4>
  80042134fe:	83 e8 09             	sub    $0x9,%eax
  8004213501:	83 f8 03             	cmp    $0x3,%eax
  8004213504:	77 30                	ja     8004213536 <_dwarf_frame_read_lsb_encoded+0x212>
  8004213506:	eb 17                	jmp    800421351f <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  8004213508:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421350c:	48 8b 10             	mov    (%rax),%rdx
  800421350f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213513:	48 01 c2             	add    %rax,%rdx
  8004213516:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421351a:	48 89 10             	mov    %rdx,(%rax)
			break;
  800421351d:	eb 18                	jmp    8004213537 <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  800421351f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213523:	48 8b 10             	mov    (%rax),%rdx
  8004213526:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421352a:	48 01 c2             	add    %rax,%rdx
  800421352d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213531:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004213534:	eb 01                	jmp    8004213537 <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  8004213536:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004213537:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421353c:	c9                   	leaveq 
  800421353d:	c3                   	retq   

000000800421353e <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
    Dwarf_Error *error)
{
  800421353e:	55                   	push   %rbp
  800421353f:	48 89 e5             	mov    %rsp,%rbp
  8004213542:	48 83 ec 50          	sub    $0x50,%rsp
  8004213546:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421354a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421354e:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  8004213552:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213556:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421355a:	48 85 c0             	test   %rax,%rax
  800421355d:	74 0f                	je     800421356e <_dwarf_frame_parse_lsb_cie_augment+0x30>
  800421355f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213563:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213567:	0f b6 00             	movzbl (%rax),%eax
  800421356a:	3c 7a                	cmp    $0x7a,%al
  800421356c:	74 35                	je     80042135a3 <_dwarf_frame_parse_lsb_cie_augment+0x65>
  800421356e:	48 b9 60 93 21 04 80 	movabs $0x8004219360,%rcx
  8004213575:	00 00 00 
  8004213578:	48 ba df 91 21 04 80 	movabs $0x80042191df,%rdx
  800421357f:	00 00 00 
  8004213582:	be 43 02 00 00       	mov    $0x243,%esi
  8004213587:	48 bf f4 91 21 04 80 	movabs $0x80042191f4,%rdi
  800421358e:	00 00 00 
  8004213591:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213596:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800421359d:	00 00 00 
  80042135a0:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  80042135a3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042135a7:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042135ab:	48 83 c0 01          	add    $0x1,%rax
  80042135af:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  80042135b3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042135b7:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042135bb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  80042135bf:	e9 af 00 00 00       	jmpq   8004213673 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  80042135c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042135c8:	0f b6 00             	movzbl (%rax),%eax
  80042135cb:	0f b6 c0             	movzbl %al,%eax
  80042135ce:	83 f8 50             	cmp    $0x50,%eax
  80042135d1:	74 18                	je     80042135eb <_dwarf_frame_parse_lsb_cie_augment+0xad>
  80042135d3:	83 f8 52             	cmp    $0x52,%eax
  80042135d6:	74 77                	je     800421364f <_dwarf_frame_parse_lsb_cie_augment+0x111>
  80042135d8:	83 f8 4c             	cmp    $0x4c,%eax
  80042135db:	0f 85 86 00 00 00    	jne    8004213667 <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  80042135e1:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  80042135e6:	e9 83 00 00 00       	jmpq   800421366e <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  80042135eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042135ef:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042135f3:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  80042135f7:	0f b6 00             	movzbl (%rax),%eax
  80042135fa:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  80042135fd:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004213604:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213605:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  800421360a:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800421360e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004213612:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004213616:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421361a:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421361e:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213622:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004213628:	48 89 c7             	mov    %rax,%rdi
  800421362b:	48 b8 24 33 21 04 80 	movabs $0x8004213324,%rax
  8004213632:	00 00 00 
  8004213635:	ff d0                	callq  *%rax
  8004213637:	89 45 e8             	mov    %eax,-0x18(%rbp)
			    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  800421363a:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800421363e:	74 05                	je     8004213645 <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  8004213640:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004213643:	eb 42                	jmp    8004213687 <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  8004213645:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213649:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  800421364d:	eb 1f                	jmp    800421366e <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  800421364f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213653:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213657:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  800421365b:	0f b6 10             	movzbl (%rax),%edx
  800421365e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213662:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  8004213665:	eb 07                	jmp    800421366e <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
			    DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004213667:	b8 14 00 00 00       	mov    $0x14,%eax
  800421366c:	eb 19                	jmp    8004213687 <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  800421366e:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  8004213673:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213677:	0f b6 00             	movzbl (%rax),%eax
  800421367a:	84 c0                	test   %al,%al
  800421367c:	0f 85 42 ff ff ff    	jne    80042135c4 <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  8004213682:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213687:	c9                   	leaveq 
  8004213688:	c3                   	retq   

0000008004213689 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Unsigned *off, Dwarf_Cie ret_cie,
		     Dwarf_Error *error)
{
  8004213689:	55                   	push   %rbp
  800421368a:	48 89 e5             	mov    %rsp,%rbp
  800421368d:	48 83 ec 50          	sub    $0x50,%rsp
  8004213691:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213695:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004213699:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421369d:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  80042136a1:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042136a6:	75 35                	jne    80042136dd <_dwarf_frame_set_cie+0x54>
  80042136a8:	48 b9 95 93 21 04 80 	movabs $0x8004219395,%rcx
  80042136af:	00 00 00 
  80042136b2:	48 ba df 91 21 04 80 	movabs $0x80042191df,%rdx
  80042136b9:	00 00 00 
  80042136bc:	be 74 02 00 00       	mov    $0x274,%esi
  80042136c1:	48 bf f4 91 21 04 80 	movabs $0x80042191f4,%rdi
  80042136c8:	00 00 00 
  80042136cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042136d0:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042136d7:	00 00 00 
  80042136da:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  80042136dd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042136e1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  80042136e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042136e9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042136ed:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  80042136f0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042136f4:	48 8b 10             	mov    (%rax),%rdx
  80042136f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042136fb:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  80042136ff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213703:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213707:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421370b:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421370f:	48 89 d1             	mov    %rdx,%rcx
  8004213712:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004213716:	ba 04 00 00 00       	mov    $0x4,%edx
  800421371b:	48 89 cf             	mov    %rcx,%rdi
  800421371e:	ff d0                	callq  *%rax
  8004213720:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004213724:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213729:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421372d:	75 2e                	jne    800421375d <_dwarf_frame_set_cie+0xd4>
		dwarf_size = 8;
  800421372f:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004213736:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421373a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421373e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213742:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213746:	48 89 d1             	mov    %rdx,%rcx
  8004213749:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800421374d:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213752:	48 89 cf             	mov    %rcx,%rdi
  8004213755:	ff d0                	callq  *%rax
  8004213757:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421375b:	eb 07                	jmp    8004213764 <_dwarf_frame_set_cie+0xdb>
	} else
		dwarf_size = 4;
  800421375d:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004213764:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213768:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421376c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213770:	48 8b 00             	mov    (%rax),%rax
  8004213773:	48 29 c2             	sub    %rax,%rdx
  8004213776:	48 89 d0             	mov    %rdx,%rax
  8004213779:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800421377d:	73 0a                	jae    8004213789 <_dwarf_frame_set_cie+0x100>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  800421377f:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213784:	e9 5d 03 00 00       	jmpq   8004213ae6 <_dwarf_frame_set_cie+0x45d>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  8004213789:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421378d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213791:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213795:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213799:	48 89 d1             	mov    %rdx,%rcx
  800421379c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421379f:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042137a3:	48 89 cf             	mov    %rcx,%rdi
  80042137a6:	ff d0                	callq  *%rax
	cie->cie_length = length;
  80042137a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137ac:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042137b0:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  80042137b4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042137b8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042137bc:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042137c0:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042137c4:	48 89 d1             	mov    %rdx,%rcx
  80042137c7:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042137cb:	ba 01 00 00 00       	mov    $0x1,%edx
  80042137d0:	48 89 cf             	mov    %rcx,%rdi
  80042137d3:	ff d0                	callq  *%rax
  80042137d5:	89 c2                	mov    %eax,%edx
  80042137d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137db:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  80042137df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137e3:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  80042137e7:	66 83 f8 01          	cmp    $0x1,%ax
  80042137eb:	74 26                	je     8004213813 <_dwarf_frame_set_cie+0x18a>
  80042137ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137f1:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  80042137f5:	66 83 f8 03          	cmp    $0x3,%ax
  80042137f9:	74 18                	je     8004213813 <_dwarf_frame_set_cie+0x18a>
	    cie->cie_version != 4) {
  80042137fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137ff:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004213803:	66 83 f8 04          	cmp    $0x4,%ax
  8004213807:	74 0a                	je     8004213813 <_dwarf_frame_set_cie+0x18a>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  8004213809:	b8 16 00 00 00       	mov    $0x16,%eax
  800421380e:	e9 d3 02 00 00       	jmpq   8004213ae6 <_dwarf_frame_set_cie+0x45d>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213813:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213817:	48 8b 10             	mov    (%rax),%rdx
  800421381a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421381e:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213822:	48 01 d0             	add    %rdx,%rax
  8004213825:	48 89 c2             	mov    %rax,%rdx
  8004213828:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421382c:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004213830:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213834:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213838:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  800421383c:	90                   	nop
  800421383d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213841:	48 8b 00             	mov    (%rax),%rax
  8004213844:	48 8d 48 01          	lea    0x1(%rax),%rcx
  8004213848:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421384c:	48 89 0a             	mov    %rcx,(%rdx)
  800421384f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213853:	48 01 d0             	add    %rdx,%rax
  8004213856:	0f b6 00             	movzbl (%rax),%eax
  8004213859:	84 c0                	test   %al,%al
  800421385b:	75 e0                	jne    800421383d <_dwarf_frame_set_cie+0x1b4>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  800421385d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213861:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213865:	0f b6 00             	movzbl (%rax),%eax
  8004213868:	84 c0                	test   %al,%al
  800421386a:	74 48                	je     80042138b4 <_dwarf_frame_set_cie+0x22b>
  800421386c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213870:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213874:	0f b6 00             	movzbl (%rax),%eax
  8004213877:	3c 7a                	cmp    $0x7a,%al
  8004213879:	74 39                	je     80042138b4 <_dwarf_frame_set_cie+0x22b>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  800421387b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421387f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213883:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213887:	75 07                	jne    8004213890 <_dwarf_frame_set_cie+0x207>
  8004213889:	b8 04 00 00 00       	mov    $0x4,%eax
  800421388e:	eb 05                	jmp    8004213895 <_dwarf_frame_set_cie+0x20c>
  8004213890:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004213895:	48 01 c2             	add    %rax,%rdx
		    cie->cie_length;
  8004213898:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421389c:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  80042138a0:	48 01 c2             	add    %rax,%rdx
  80042138a3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042138a7:	48 89 10             	mov    %rdx,(%rax)
		    cie->cie_length;
		return (DW_DLE_NONE);
  80042138aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042138af:	e9 32 02 00 00       	jmpq   8004213ae6 <_dwarf_frame_set_cie+0x45d>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  80042138b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042138b8:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042138bc:	48 be 9d 93 21 04 80 	movabs $0x800421939d,%rsi
  80042138c3:	00 00 00 
  80042138c6:	48 89 c7             	mov    %rax,%rdi
  80042138c9:	48 b8 cb fc 20 04 80 	movabs $0x800420fccb,%rax
  80042138d0:	00 00 00 
  80042138d3:	ff d0                	callq  *%rax
  80042138d5:	48 85 c0             	test   %rax,%rax
  80042138d8:	74 28                	je     8004213902 <_dwarf_frame_set_cie+0x279>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  80042138da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042138de:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042138e2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042138e6:	8b 52 28             	mov    0x28(%rdx),%edx
  80042138e9:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042138ed:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  80042138f1:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042138f5:	48 89 cf             	mov    %rcx,%rdi
  80042138f8:	ff d0                	callq  *%rax
  80042138fa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042138fe:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213902:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213906:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421390a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421390e:	48 89 d6             	mov    %rdx,%rsi
  8004213911:	48 89 c7             	mov    %rax,%rdi
  8004213914:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  800421391b:	00 00 00 
  800421391e:	ff d0                	callq  *%rax
  8004213920:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213924:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213928:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421392c:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213930:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213934:	48 89 d6             	mov    %rdx,%rsi
  8004213937:	48 89 c7             	mov    %rax,%rdi
  800421393a:	48 b8 14 03 21 04 80 	movabs $0x8004210314,%rax
  8004213941:	00 00 00 
  8004213944:	ff d0                	callq  *%rax
  8004213946:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421394a:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  800421394e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213952:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004213956:	66 83 f8 01          	cmp    $0x1,%ax
  800421395a:	75 2b                	jne    8004213987 <_dwarf_frame_set_cie+0x2fe>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  800421395c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213960:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213964:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213968:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421396c:	48 89 d1             	mov    %rdx,%rcx
  800421396f:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004213973:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213978:	48 89 cf             	mov    %rcx,%rdi
  800421397b:	ff d0                	callq  *%rax
  800421397d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213981:	48 89 42 48          	mov    %rax,0x48(%rdx)
  8004213985:	eb 26                	jmp    80042139ad <_dwarf_frame_set_cie+0x324>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213987:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421398b:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421398f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213993:	48 89 d6             	mov    %rdx,%rsi
  8004213996:	48 89 c7             	mov    %rax,%rdi
  8004213999:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  80042139a0:	00 00 00 
  80042139a3:	ff d0                	callq  *%rax
  80042139a5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042139a9:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  80042139ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042139b1:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042139b5:	0f b6 00             	movzbl (%rax),%eax
  80042139b8:	3c 7a                	cmp    $0x7a,%al
  80042139ba:	0f 85 93 00 00 00    	jne    8004213a53 <_dwarf_frame_set_cie+0x3ca>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  80042139c0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042139c4:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042139c8:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042139cc:	48 89 d6             	mov    %rdx,%rsi
  80042139cf:	48 89 c7             	mov    %rax,%rdi
  80042139d2:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  80042139d9:	00 00 00 
  80042139dc:	ff d0                	callq  *%rax
  80042139de:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042139e2:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042139e6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042139ea:	48 8b 10             	mov    (%rax),%rdx
  80042139ed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042139f1:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042139f5:	48 01 d0             	add    %rdx,%rax
  80042139f8:	48 89 c2             	mov    %rax,%rdx
  80042139fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042139ff:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004213a03:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213a07:	48 8b 10             	mov    (%rax),%rdx
  8004213a0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a0e:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004213a12:	48 01 c2             	add    %rax,%rdx
  8004213a15:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213a19:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004213a1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a20:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004213a24:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004213a28:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004213a2c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a30:	48 89 ce             	mov    %rcx,%rsi
  8004213a33:	48 89 c7             	mov    %rax,%rdi
  8004213a36:	48 b8 3e 35 21 04 80 	movabs $0x800421353e,%rax
  8004213a3d:	00 00 00 
  8004213a40:	ff d0                	callq  *%rax
  8004213a42:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004213a45:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213a49:	74 08                	je     8004213a53 <_dwarf_frame_set_cie+0x3ca>
			return (ret);
  8004213a4b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213a4e:	e9 93 00 00 00       	jmpq   8004213ae6 <_dwarf_frame_set_cie+0x45d>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213a53:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213a57:	48 8b 10             	mov    (%rax),%rdx
  8004213a5a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a5e:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213a62:	48 01 d0             	add    %rdx,%rax
  8004213a65:	48 89 c2             	mov    %rax,%rdx
  8004213a68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a6c:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  8004213a70:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213a74:	75 2a                	jne    8004213aa0 <_dwarf_frame_set_cie+0x417>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004213a76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a7a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213a7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213a82:	48 01 c2             	add    %rax,%rdx
  8004213a85:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213a89:	48 8b 00             	mov    (%rax),%rax
  8004213a8c:	48 29 c2             	sub    %rax,%rdx
  8004213a8f:	48 89 d0             	mov    %rdx,%rax
  8004213a92:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004213a96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a9a:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004213a9e:	eb 28                	jmp    8004213ac8 <_dwarf_frame_set_cie+0x43f>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004213aa0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213aa4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213aa8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213aac:	48 01 c2             	add    %rax,%rdx
  8004213aaf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213ab3:	48 8b 00             	mov    (%rax),%rax
  8004213ab6:	48 29 c2             	sub    %rax,%rdx
  8004213ab9:	48 89 d0             	mov    %rdx,%rax
  8004213abc:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004213ac0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ac4:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004213ac8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213acc:	48 8b 10             	mov    (%rax),%rdx
  8004213acf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ad3:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004213ad7:	48 01 c2             	add    %rax,%rdx
  8004213ada:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213ade:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004213ae1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213ae6:	c9                   	leaveq 
  8004213ae7:	c3                   	retq   

0000008004213ae8 <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde,
    Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004213ae8:	55                   	push   %rbp
  8004213ae9:	48 89 e5             	mov    %rsp,%rbp
  8004213aec:	48 83 ec 70          	sub    $0x70,%rsp
  8004213af0:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213af4:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004213af8:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004213afc:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
  8004213aff:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  8004213b03:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  8004213b07:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213b0b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  8004213b0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b13:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213b17:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213b1a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b1e:	48 8b 10             	mov    (%rax),%rdx
  8004213b21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b25:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213b29:	48 01 d0             	add    %rdx,%rax
  8004213b2c:	48 89 c2             	mov    %rax,%rdx
  8004213b2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b33:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004213b37:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b3b:	48 8b 10             	mov    (%rax),%rdx
  8004213b3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b42:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004213b46:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b4a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213b4e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213b52:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213b56:	48 89 d1             	mov    %rdx,%rcx
  8004213b59:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213b5d:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213b62:	48 89 cf             	mov    %rcx,%rdi
  8004213b65:	ff d0                	callq  *%rax
  8004213b67:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004213b6b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213b70:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004213b74:	75 2e                	jne    8004213ba4 <_dwarf_frame_set_fde+0xbc>
		dwarf_size = 8;
  8004213b76:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004213b7d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b81:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213b85:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213b89:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213b8d:	48 89 d1             	mov    %rdx,%rcx
  8004213b90:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213b94:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213b99:	48 89 cf             	mov    %rcx,%rdi
  8004213b9c:	ff d0                	callq  *%rax
  8004213b9e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213ba2:	eb 07                	jmp    8004213bab <_dwarf_frame_set_fde+0xc3>
	} else
		dwarf_size = 4;
  8004213ba4:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004213bab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213baf:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004213bb3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213bb7:	48 8b 00             	mov    (%rax),%rax
  8004213bba:	48 29 c2             	sub    %rax,%rdx
  8004213bbd:	48 89 d0             	mov    %rdx,%rax
  8004213bc0:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213bc4:	73 0a                	jae    8004213bd0 <_dwarf_frame_set_fde+0xe8>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004213bc6:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213bcb:	e9 ca 02 00 00       	jmpq   8004213e9a <_dwarf_frame_set_fde+0x3b2>
	}

	fde->fde_length = length;
  8004213bd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213bd4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213bd8:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004213bdc:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  8004213be0:	74 5e                	je     8004213c40 <_dwarf_frame_set_fde+0x158>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004213be2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213be6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213bea:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213bee:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213bf2:	48 89 d1             	mov    %rdx,%rcx
  8004213bf5:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213bf9:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213bfe:	48 89 cf             	mov    %rcx,%rdi
  8004213c01:	ff d0                	callq  *%rax
  8004213c03:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213c07:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004213c0b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c0f:	48 8b 10             	mov    (%rax),%rdx
  8004213c12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c16:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213c1a:	48 29 c2             	sub    %rax,%rdx
  8004213c1d:	48 89 d0             	mov    %rdx,%rax
  8004213c20:	48 83 e8 04          	sub    $0x4,%rax
  8004213c24:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004213c28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c2c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213c30:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004213c34:	75 3d                	jne    8004213c73 <_dwarf_frame_set_fde+0x18b>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004213c36:	b8 13 00 00 00       	mov    $0x13,%eax
  8004213c3b:	e9 5a 02 00 00       	jmpq   8004213e9a <_dwarf_frame_set_fde+0x3b2>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  8004213c40:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213c44:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213c48:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213c4c:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213c50:	48 89 d1             	mov    %rdx,%rcx
  8004213c53:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213c56:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213c5a:	48 89 cf             	mov    %rcx,%rdi
  8004213c5d:	ff d0                	callq  *%rax
  8004213c5f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213c63:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  8004213c67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c6b:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213c6f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  8004213c73:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  8004213c77:	0f 84 c9 00 00 00    	je     8004213d46 <_dwarf_frame_set_fde+0x25e>
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, (uint8_t *)dbg->dbg_eh_offset,
		    off, cie->cie_fde_encode, dbg->dbg_eh_offset + *off, error);
  8004213c7d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213c81:	48 8b 50 38          	mov    0x38(%rax),%rdx
  8004213c85:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c89:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, (uint8_t *)dbg->dbg_eh_offset,
  8004213c8c:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
		    off, cie->cie_fde_encode, dbg->dbg_eh_offset + *off, error);
  8004213c90:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004213c94:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, (uint8_t *)dbg->dbg_eh_offset,
  8004213c98:	44 0f b6 c0          	movzbl %al,%r8d
  8004213c9c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ca0:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213ca4:	48 89 c2             	mov    %rax,%rdx
  8004213ca7:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004213cab:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004213caf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213cb3:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8004213cb7:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213cbb:	48 89 c7             	mov    %rax,%rdi
  8004213cbe:	48 b8 24 33 21 04 80 	movabs $0x8004213324,%rax
  8004213cc5:	00 00 00 
  8004213cc8:	ff d0                	callq  *%rax
  8004213cca:	89 45 dc             	mov    %eax,-0x24(%rbp)
		    off, cie->cie_fde_encode, dbg->dbg_eh_offset + *off, error);
		if (ret != DW_DLE_NONE)
  8004213ccd:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213cd1:	74 08                	je     8004213cdb <_dwarf_frame_set_fde+0x1f3>
			return (ret);
  8004213cd3:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213cd6:	e9 bf 01 00 00       	jmpq   8004213e9a <_dwarf_frame_set_fde+0x3b2>
		fde->fde_initloc = val;
  8004213cdb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213cdf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ce3:	48 89 50 30          	mov    %rdx,0x30(%rax)
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, (uint8_t *)dbg->dbg_eh_offset,
		    off, cie->cie_fde_encode, 0, error);
  8004213ce7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004213ceb:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, (uint8_t *)dbg->dbg_eh_offset,
  8004213cef:	44 0f b6 c0          	movzbl %al,%r8d
  8004213cf3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213cf7:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213cfb:	48 89 c2             	mov    %rax,%rdx
  8004213cfe:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004213d02:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004213d06:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d0a:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8004213d0e:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213d12:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004213d18:	48 89 c7             	mov    %rax,%rdi
  8004213d1b:	48 b8 24 33 21 04 80 	movabs $0x8004213324,%rax
  8004213d22:	00 00 00 
  8004213d25:	ff d0                	callq  *%rax
  8004213d27:	89 45 dc             	mov    %eax,-0x24(%rbp)
		    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  8004213d2a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213d2e:	74 08                	je     8004213d38 <_dwarf_frame_set_fde+0x250>
			return (ret);
  8004213d30:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213d33:	e9 62 01 00 00       	jmpq   8004213e9a <_dwarf_frame_set_fde+0x3b2>
		fde->fde_adrange = val;
  8004213d38:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213d3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d40:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004213d44:	eb 50                	jmp    8004213d96 <_dwarf_frame_set_fde+0x2ae>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004213d46:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d4a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213d4e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d52:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213d55:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004213d59:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004213d5d:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213d61:	48 89 cf             	mov    %rcx,%rdi
  8004213d64:	ff d0                	callq  *%rax
  8004213d66:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213d6a:	48 89 42 30          	mov    %rax,0x30(%rdx)
		    dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004213d6e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d72:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213d76:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d7a:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213d7d:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004213d81:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004213d85:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213d89:	48 89 cf             	mov    %rcx,%rdi
  8004213d8c:	ff d0                	callq  *%rax
  8004213d8e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213d92:	48 89 42 38          	mov    %rax,0x38(%rdx)
		    dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004213d96:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  8004213d9a:	74 6b                	je     8004213e07 <_dwarf_frame_set_fde+0x31f>
  8004213d9c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004213da0:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213da4:	0f b6 00             	movzbl (%rax),%eax
  8004213da7:	3c 7a                	cmp    $0x7a,%al
  8004213da9:	75 5c                	jne    8004213e07 <_dwarf_frame_set_fde+0x31f>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213dab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213daf:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213db3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213db7:	48 89 d6             	mov    %rdx,%rsi
  8004213dba:	48 89 c7             	mov    %rax,%rdi
  8004213dbd:	48 b8 b8 03 21 04 80 	movabs $0x80042103b8,%rax
  8004213dc4:	00 00 00 
  8004213dc7:	ff d0                	callq  *%rax
  8004213dc9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213dcd:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213dd1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213dd5:	48 8b 10             	mov    (%rax),%rdx
  8004213dd8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ddc:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213de0:	48 01 d0             	add    %rdx,%rax
  8004213de3:	48 89 c2             	mov    %rax,%rdx
  8004213de6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213dea:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  8004213dee:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213df2:	48 8b 10             	mov    (%rax),%rdx
  8004213df5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213df9:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004213dfd:	48 01 c2             	add    %rax,%rdx
  8004213e00:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213e04:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213e07:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213e0b:	48 8b 10             	mov    (%rax),%rdx
  8004213e0e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213e12:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213e16:	48 01 d0             	add    %rdx,%rax
  8004213e19:	48 89 c2             	mov    %rax,%rdx
  8004213e1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e20:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  8004213e24:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213e28:	75 2a                	jne    8004213e54 <_dwarf_frame_set_fde+0x36c>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  8004213e2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e2e:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213e32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213e36:	48 01 c2             	add    %rax,%rdx
  8004213e39:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213e3d:	48 8b 00             	mov    (%rax),%rax
  8004213e40:	48 29 c2             	sub    %rax,%rdx
  8004213e43:	48 89 d0             	mov    %rdx,%rax
  8004213e46:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004213e4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e4e:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004213e52:	eb 28                	jmp    8004213e7c <_dwarf_frame_set_fde+0x394>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  8004213e54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e58:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213e5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213e60:	48 01 c2             	add    %rax,%rdx
  8004213e63:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213e67:	48 8b 00             	mov    (%rax),%rax
  8004213e6a:	48 29 c2             	sub    %rax,%rdx
  8004213e6d:	48 89 d0             	mov    %rdx,%rax
  8004213e70:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004213e74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e78:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004213e7c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213e80:	48 8b 10             	mov    (%rax),%rdx
  8004213e83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e87:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004213e8b:	48 01 c2             	add    %rax,%rdx
  8004213e8e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213e92:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004213e95:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213e9a:	c9                   	leaveq 
  8004213e9b:	c3                   	retq   

0000008004213e9c <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004213e9c:	55                   	push   %rbp
  8004213e9d:	48 89 e5             	mov    %rsp,%rbp
  8004213ea0:	48 83 ec 20          	sub    $0x20,%rsp
  8004213ea4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213ea8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
        Dwarf_Regtable3 *rt = &global_rt_table;
  8004213eac:	48 b8 20 17 4a 04 80 	movabs $0x80044a1720,%rax
  8004213eb3:	00 00 00 
  8004213eb6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

        if (dbg->dbg_internal_reg_table != NULL)
  8004213eba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ebe:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004213ec2:	48 85 c0             	test   %rax,%rax
  8004213ec5:	74 07                	je     8004213ece <_dwarf_frame_interal_table_init+0x32>
                return (DW_DLE_NONE);
  8004213ec7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213ecc:	eb 33                	jmp    8004213f01 <_dwarf_frame_interal_table_init+0x65>

        rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004213ece:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ed2:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  8004213ed6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213eda:	66 89 50 18          	mov    %dx,0x18(%rax)
        rt->rt3_rules = global_rules;
  8004213ede:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213ee2:	48 b9 60 1f 4a 04 80 	movabs $0x80044a1f60,%rcx
  8004213ee9:	00 00 00 
  8004213eec:	48 89 48 20          	mov    %rcx,0x20(%rax)
        dbg->dbg_internal_reg_table = rt;
  8004213ef0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ef4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213ef8:	48 89 50 58          	mov    %rdx,0x58(%rax)

        return (DW_DLE_NONE);
  8004213efc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213f01:	c9                   	leaveq 
  8004213f02:	c3                   	retq   

0000008004213f03 <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
                    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  8004213f03:	55                   	push   %rbp
  8004213f04:	48 89 e5             	mov    %rsp,%rbp
  8004213f07:	48 83 ec 50          	sub    $0x50,%rsp
  8004213f0b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213f0f:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  8004213f12:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004213f16:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  8004213f1a:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  8004213f21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213f25:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004213f29:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (offset < dbg->dbg_eh_size) {
  8004213f2d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213f31:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004213f35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213f39:	48 39 c2             	cmp    %rax,%rdx
  8004213f3c:	0f 86 e1 01 00 00    	jbe    8004214123 <_dwarf_get_next_fde+0x220>
		entry_off = offset;
  8004213f42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213f46:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  8004213f4a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213f4e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f52:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213f56:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213f5a:	48 89 d1             	mov    %rdx,%rcx
  8004213f5d:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004213f61:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213f66:	48 89 cf             	mov    %rcx,%rdi
  8004213f69:	ff d0                	callq  *%rax
  8004213f6b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004213f6f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213f74:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004213f78:	75 2e                	jne    8004213fa8 <_dwarf_get_next_fde+0xa5>
			dwarf_size = 8;
  8004213f7a:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  8004213f81:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213f85:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f89:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213f8d:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213f91:	48 89 d1             	mov    %rdx,%rcx
  8004213f94:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004213f98:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213f9d:	48 89 cf             	mov    %rcx,%rdi
  8004213fa0:	ff d0                	callq  *%rax
  8004213fa2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213fa6:	eb 07                	jmp    8004213faf <_dwarf_get_next_fde+0xac>
		} else
			dwarf_size = 4;
  8004213fa8:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  8004213faf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213fb3:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004213fb7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213fbb:	48 29 c2             	sub    %rax,%rdx
  8004213fbe:	48 89 d0             	mov    %rdx,%rax
  8004213fc1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213fc5:	72 0d                	jb     8004213fd4 <_dwarf_get_next_fde+0xd1>
  8004213fc7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213fcc:	75 10                	jne    8004213fde <_dwarf_get_next_fde+0xdb>
  8004213fce:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004213fd2:	75 0a                	jne    8004213fde <_dwarf_get_next_fde+0xdb>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004213fd4:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213fd9:	e9 4a 01 00 00       	jmpq   8004214128 <_dwarf_get_next_fde+0x225>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  8004213fde:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004213fe2:	74 11                	je     8004213ff5 <_dwarf_get_next_fde+0xf2>
  8004213fe4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213fe9:	75 0a                	jne    8004213ff5 <_dwarf_get_next_fde+0xf2>
			return(-1);
  8004213feb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213ff0:	e9 33 01 00 00       	jmpq   8004214128 <_dwarf_get_next_fde+0x225>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  8004213ff5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ff9:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213ffd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214001:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214005:	48 89 d1             	mov    %rdx,%rcx
  8004214008:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421400b:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  800421400f:	48 89 cf             	mov    %rcx,%rdi
  8004214012:	ff d0                	callq  *%rax
  8004214014:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (eh_frame) {
  8004214018:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800421401c:	74 69                	je     8004214087 <_dwarf_get_next_fde+0x184>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  800421401e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004214023:	75 2b                	jne    8004214050 <_dwarf_get_next_fde+0x14d>
				ret = _dwarf_frame_set_cie(dbg,
  8004214025:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214029:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421402d:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004214031:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004214035:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214039:	48 89 c7             	mov    %rax,%rdi
  800421403c:	48 b8 89 36 21 04 80 	movabs $0x8004213689,%rax
  8004214043:	00 00 00 
  8004214046:	ff d0                	callq  *%rax
  8004214048:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421404b:	e9 b2 00 00 00       	jmpq   8004214102 <_dwarf_get_next_fde+0x1ff>
				    &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde,
  8004214050:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214054:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004214058:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421405c:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  8004214060:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214064:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214068:	49 89 f9             	mov    %rdi,%r9
  800421406b:	49 89 c8             	mov    %rcx,%r8
  800421406e:	b9 01 00 00 00       	mov    $0x1,%ecx
  8004214073:	48 89 c7             	mov    %rax,%rdi
  8004214076:	48 b8 e8 3a 21 04 80 	movabs $0x8004213ae8,%rax
  800421407d:	00 00 00 
  8004214080:	ff d0                	callq  *%rax
  8004214082:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004214085:	eb 7b                	jmp    8004214102 <_dwarf_get_next_fde+0x1ff>
				    &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  8004214087:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800421408b:	75 0b                	jne    8004214098 <_dwarf_get_next_fde+0x195>
  800421408d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214092:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004214096:	74 0d                	je     80042140a5 <_dwarf_get_next_fde+0x1a2>
  8004214098:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800421409c:	75 2f                	jne    80042140cd <_dwarf_get_next_fde+0x1ca>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  800421409e:	48 83 7d e8 ff       	cmpq   $0xffffffffffffffff,-0x18(%rbp)
  80042140a3:	75 28                	jne    80042140cd <_dwarf_get_next_fde+0x1ca>
				ret = _dwarf_frame_set_cie(dbg,
  80042140a5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042140a9:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042140ad:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80042140b1:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  80042140b5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042140b9:	48 89 c7             	mov    %rax,%rdi
  80042140bc:	48 b8 89 36 21 04 80 	movabs $0x8004213689,%rax
  80042140c3:	00 00 00 
  80042140c6:	ff d0                	callq  *%rax
  80042140c8:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042140cb:	eb 35                	jmp    8004214102 <_dwarf_get_next_fde+0x1ff>
				    &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde,
  80042140cd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042140d1:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042140d5:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042140d9:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  80042140dd:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042140e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042140e5:	49 89 f9             	mov    %rdi,%r9
  80042140e8:	49 89 c8             	mov    %rcx,%r8
  80042140eb:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042140f0:	48 89 c7             	mov    %rax,%rdi
  80042140f3:	48 b8 e8 3a 21 04 80 	movabs $0x8004213ae8,%rax
  80042140fa:	00 00 00 
  80042140fd:	ff d0                	callq  *%rax
  80042140ff:	89 45 f0             	mov    %eax,-0x10(%rbp)
				    &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004214102:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004214106:	74 07                	je     800421410f <_dwarf_get_next_fde+0x20c>
			return(-1);
  8004214108:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421410d:	eb 19                	jmp    8004214128 <_dwarf_get_next_fde+0x225>

		offset = entry_off;
  800421410f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214113:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		dbg->curr_off_eh = offset;
  8004214117:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421411b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421411f:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004214123:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214128:	c9                   	leaveq 
  8004214129:	c3                   	retq   

000000800421412a <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  800421412a:	55                   	push   %rbp
  800421412b:	48 89 e5             	mov    %rsp,%rbp
  800421412e:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004214132:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214136:	89 f0                	mov    %esi,%eax
  8004214138:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
        Dwarf_Half old_value;

        old_value = dbg->dbg_frame_cfa_value;
  800421413c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214140:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004214144:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
        dbg->dbg_frame_cfa_value = value;
  8004214148:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421414c:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004214150:	66 89 50 4c          	mov    %dx,0x4c(%rax)

        return (old_value);
  8004214154:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  8004214158:	c9                   	leaveq 
  8004214159:	c3                   	retq   

000000800421415a <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  800421415a:	55                   	push   %rbp
  800421415b:	48 89 e5             	mov    %rsp,%rbp
  800421415e:	48 83 ec 10          	sub    $0x10,%rsp
  8004214162:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004214166:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  800421416a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421416f:	75 0a                	jne    800421417b <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004214171:	b8 01 00 00 00       	mov    $0x1,%eax
  8004214176:	e9 85 00 00 00       	jmpq   8004214200 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  800421417b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421417f:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004214183:	48 85 c0             	test   %rax,%rax
  8004214186:	75 25                	jne    80042141ad <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  8004214188:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421418c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214190:	48 89 d6             	mov    %rdx,%rsi
  8004214193:	48 89 c7             	mov    %rax,%rdi
  8004214196:	48 b8 9c 3e 21 04 80 	movabs $0x8004213e9c,%rax
  800421419d:	00 00 00 
  80042141a0:	ff d0                	callq  *%rax
  80042141a2:	85 c0                	test   %eax,%eax
  80042141a4:	74 07                	je     80042141ad <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  80042141a6:	b8 01 00 00 00       	mov    $0x1,%eax
  80042141ab:	eb 53                	jmp    8004214200 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  80042141ad:	48 bf c0 c6 22 04 80 	movabs $0x800422c6c0,%rdi
  80042141b4:	00 00 00 
  80042141b7:	48 b8 56 1c 21 04 80 	movabs $0x8004211c56,%rax
  80042141be:	00 00 00 
  80042141c1:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  80042141c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042141c7:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80042141ce:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  80042141cf:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  80042141d6:	00 00 00 
  80042141d9:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042141dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042141e1:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  80042141e5:	48 b8 c0 c6 22 04 80 	movabs $0x800422c6c0,%rax
  80042141ec:	00 00 00 
  80042141ef:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042141f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042141f7:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  80042141fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214200:	c9                   	leaveq 
  8004214201:	c3                   	retq   

0000008004214202 <_dwarf_lineno_run_program>:


static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
    uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004214202:	55                   	push   %rbp
  8004214203:	48 89 e5             	mov    %rsp,%rbp
  8004214206:	53                   	push   %rbx
  8004214207:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  800421420e:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  8004214212:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  8004214216:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  800421421d:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  8004214224:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  800421422b:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
    uint64_t address, file, line, column, isa, opsize;
    int is_stmt, basic_block, end_sequence;
    int prologue_end, epilogue_begin;
    int ret;

	ln = &li->li_line;
  8004214232:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214236:	48 83 c0 48          	add    $0x48,%rax
  800421423a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    /*
     *   ln->ln_li     = li;             \
     * Set registers to their default values.
     */
    RESET_REGISTERS;
  800421423e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214245:	00 
  8004214246:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  800421424d:	00 
  800421424e:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004214255:	00 
  8004214256:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800421425d:	00 
  800421425e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214262:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004214266:	0f b6 c0             	movzbl %al,%eax
  8004214269:	89 45 cc             	mov    %eax,-0x34(%rbp)
  800421426c:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004214273:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  800421427a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004214281:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

    /*
     * Start line number program.
     */
    while (p < pe) {
  8004214288:	e9 0a 05 00 00       	jmpq   8004214797 <_dwarf_lineno_run_program+0x595>
        if (*p == 0) {
  800421428d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214294:	0f b6 00             	movzbl (%rax),%eax
  8004214297:	84 c0                	test   %al,%al
  8004214299:	0f 85 78 01 00 00    	jne    8004214417 <_dwarf_lineno_run_program+0x215>

            /*
             * Extended Opcodes.
             */

            p++;
  800421429f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042142a6:	48 83 c0 01          	add    $0x1,%rax
  80042142aa:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
            opsize = _dwarf_decode_uleb128(&p);
  80042142b1:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042142b8:	48 89 c7             	mov    %rax,%rdi
  80042142bb:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  80042142c2:	00 00 00 
  80042142c5:	ff d0                	callq  *%rax
  80042142c7:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
            switch (*p) {
  80042142cb:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042142d2:	0f b6 00             	movzbl (%rax),%eax
  80042142d5:	0f b6 c0             	movzbl %al,%eax
  80042142d8:	83 f8 02             	cmp    $0x2,%eax
  80042142db:	74 7a                	je     8004214357 <_dwarf_lineno_run_program+0x155>
  80042142dd:	83 f8 03             	cmp    $0x3,%eax
  80042142e0:	0f 84 b3 00 00 00    	je     8004214399 <_dwarf_lineno_run_program+0x197>
  80042142e6:	83 f8 01             	cmp    $0x1,%eax
  80042142e9:	0f 85 09 01 00 00    	jne    80042143f8 <_dwarf_lineno_run_program+0x1f6>
            case DW_LNE_end_sequence:
                p++;
  80042142ef:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042142f6:	48 83 c0 01          	add    $0x1,%rax
  80042142fa:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
                end_sequence = 1;
  8004214301:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
                RESET_REGISTERS;
  8004214308:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800421430f:	00 
  8004214310:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  8004214317:	00 
  8004214318:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  800421431f:	00 
  8004214320:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004214327:	00 
  8004214328:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421432c:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004214330:	0f b6 c0             	movzbl %al,%eax
  8004214333:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004214336:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  800421433d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004214344:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  800421434b:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
                break;
  8004214352:	e9 bb 00 00 00       	jmpq   8004214412 <_dwarf_lineno_run_program+0x210>
            case DW_LNE_set_address:
                p++;
  8004214357:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421435e:	48 83 c0 01          	add    $0x1,%rax
  8004214362:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
                address = dbg->decode(&p, cu->addr_size);
  8004214369:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  8004214370:	00 00 00 
  8004214373:	48 8b 00             	mov    (%rax),%rax
  8004214376:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421437a:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800421437e:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004214382:	0f b6 ca             	movzbl %dl,%ecx
  8004214385:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  800421438c:	89 ce                	mov    %ecx,%esi
  800421438e:	48 89 d7             	mov    %rdx,%rdi
  8004214391:	ff d0                	callq  *%rax
  8004214393:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                break;
  8004214397:	eb 79                	jmp    8004214412 <_dwarf_lineno_run_program+0x210>
            case DW_LNE_define_file:
                p++;
  8004214399:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042143a0:	48 83 c0 01          	add    $0x1,%rax
  80042143a4:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
                ret = _dwarf_lineno_add_file(li, &p, NULL,
  80042143ab:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  80042143b2:	00 00 00 
  80042143b5:	48 8b 08             	mov    (%rax),%rcx
  80042143b8:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042143bf:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  80042143c6:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042143ca:	49 89 c8             	mov    %rcx,%r8
  80042143cd:	48 89 d1             	mov    %rdx,%rcx
  80042143d0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042143d5:	48 89 c7             	mov    %rax,%rdi
  80042143d8:	48 b8 ba 47 21 04 80 	movabs $0x80042147ba,%rax
  80042143df:	00 00 00 
  80042143e2:	ff d0                	callq  *%rax
  80042143e4:	89 45 a4             	mov    %eax,-0x5c(%rbp)
                    error, dbg);
                if (ret != DW_DLE_NONE)
  80042143e7:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  80042143eb:	74 09                	je     80042143f6 <_dwarf_lineno_run_program+0x1f4>
                    goto prog_fail;
  80042143ed:	90                   	nop

    return (DW_DLE_NONE);

prog_fail:

    return (ret);
  80042143ee:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80042143f1:	e9 ba 03 00 00       	jmpq   80042147b0 <_dwarf_lineno_run_program+0x5ae>
                p++;
                ret = _dwarf_lineno_add_file(li, &p, NULL,
                    error, dbg);
                if (ret != DW_DLE_NONE)
                    goto prog_fail;
                break;
  80042143f6:	eb 1a                	jmp    8004214412 <_dwarf_lineno_run_program+0x210>
            default:
                /* Unrecognized extened opcodes. */
                p += opsize;
  80042143f8:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042143ff:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214403:	48 01 d0             	add    %rdx,%rax
  8004214406:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  800421440d:	e9 85 03 00 00       	jmpq   8004214797 <_dwarf_lineno_run_program+0x595>
  8004214412:	e9 80 03 00 00       	jmpq   8004214797 <_dwarf_lineno_run_program+0x595>
            }

        } else if (*p > 0 && *p < li->li_opbase) {
  8004214417:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421441e:	0f b6 00             	movzbl (%rax),%eax
  8004214421:	84 c0                	test   %al,%al
  8004214423:	0f 84 3c 02 00 00    	je     8004214665 <_dwarf_lineno_run_program+0x463>
  8004214429:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214430:	0f b6 10             	movzbl (%rax),%edx
  8004214433:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214437:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421443b:	38 c2                	cmp    %al,%dl
  800421443d:	0f 83 22 02 00 00    	jae    8004214665 <_dwarf_lineno_run_program+0x463>

            /*
             * Standard Opcodes.
             */

            switch (*p++) {
  8004214443:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421444a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421444e:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004214455:	0f b6 00             	movzbl (%rax),%eax
  8004214458:	0f b6 c0             	movzbl %al,%eax
  800421445b:	83 f8 0c             	cmp    $0xc,%eax
  800421445e:	0f 87 fb 01 00 00    	ja     800421465f <_dwarf_lineno_run_program+0x45d>
  8004214464:	89 c0                	mov    %eax,%eax
  8004214466:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421446d:	00 
  800421446e:	48 b8 a0 93 21 04 80 	movabs $0x80042193a0,%rax
  8004214475:	00 00 00 
  8004214478:	48 01 d0             	add    %rdx,%rax
  800421447b:	48 8b 00             	mov    (%rax),%rax
  800421447e:	ff e0                	jmpq   *%rax
            case DW_LNS_copy:
                APPEND_ROW;
  8004214480:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214487:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421448b:	73 0a                	jae    8004214497 <_dwarf_lineno_run_program+0x295>
  800421448d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214492:	e9 19 03 00 00       	jmpq   80042147b0 <_dwarf_lineno_run_program+0x5ae>
  8004214497:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421449b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421449f:	48 89 10             	mov    %rdx,(%rax)
  80042144a2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042144a6:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80042144ad:	00 
  80042144ae:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042144b2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042144b6:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042144ba:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042144be:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042144c2:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042144c6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042144ca:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042144ce:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042144d2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042144d6:	8b 55 c8             	mov    -0x38(%rbp),%edx
  80042144d9:	89 50 28             	mov    %edx,0x28(%rax)
  80042144dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042144e0:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042144e3:	89 50 2c             	mov    %edx,0x2c(%rax)
  80042144e6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042144ea:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042144ed:	89 50 30             	mov    %edx,0x30(%rax)
  80042144f0:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042144f4:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80042144fb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042144ff:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214503:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
                basic_block = 0;
  800421450a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
                prologue_end = 0;
  8004214511:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
                epilogue_begin = 0;
  8004214518:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
                break;
  800421451f:	e9 3c 01 00 00       	jmpq   8004214660 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_advance_pc:
                address += _dwarf_decode_uleb128(&p) *
  8004214524:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421452b:	48 89 c7             	mov    %rax,%rdi
  800421452e:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004214535:	00 00 00 
  8004214538:	ff d0                	callq  *%rax
                    li->li_minlen;
  800421453a:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800421453e:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
                basic_block = 0;
                prologue_end = 0;
                epilogue_begin = 0;
                break;
            case DW_LNS_advance_pc:
                address += _dwarf_decode_uleb128(&p) *
  8004214542:	0f b6 d2             	movzbl %dl,%edx
  8004214545:	48 0f af c2          	imul   %rdx,%rax
  8004214549:	48 01 45 e8          	add    %rax,-0x18(%rbp)
                    li->li_minlen;
                break;
  800421454d:	e9 0e 01 00 00       	jmpq   8004214660 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_advance_line:
                line += _dwarf_decode_sleb128(&p);
  8004214552:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004214559:	48 89 c7             	mov    %rax,%rdi
  800421455c:	48 b8 37 04 21 04 80 	movabs $0x8004210437,%rax
  8004214563:	00 00 00 
  8004214566:	ff d0                	callq  *%rax
  8004214568:	48 01 45 d8          	add    %rax,-0x28(%rbp)
                break;
  800421456c:	e9 ef 00 00 00       	jmpq   8004214660 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_file:
                file = _dwarf_decode_uleb128(&p);
  8004214571:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004214578:	48 89 c7             	mov    %rax,%rdi
  800421457b:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004214582:	00 00 00 
  8004214585:	ff d0                	callq  *%rax
  8004214587:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
                break;
  800421458b:	e9 d0 00 00 00       	jmpq   8004214660 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_column:
                column = _dwarf_decode_uleb128(&p);
  8004214590:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004214597:	48 89 c7             	mov    %rax,%rdi
  800421459a:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  80042145a1:	00 00 00 
  80042145a4:	ff d0                	callq  *%rax
  80042145a6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                break;
  80042145aa:	e9 b1 00 00 00       	jmpq   8004214660 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_negate_stmt:
                is_stmt = !is_stmt;
  80042145af:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042145b3:	0f 94 c0             	sete   %al
  80042145b6:	0f b6 c0             	movzbl %al,%eax
  80042145b9:	89 45 cc             	mov    %eax,-0x34(%rbp)
                break;
  80042145bc:	e9 9f 00 00 00       	jmpq   8004214660 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_basic_block:
                basic_block = 1;
  80042145c1:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
                break;
  80042145c8:	e9 93 00 00 00       	jmpq   8004214660 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_const_add_pc:
                address += ADDRESS(255);
  80042145cd:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042145d1:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042145d5:	0f b6 c0             	movzbl %al,%eax
  80042145d8:	ba ff 00 00 00       	mov    $0xff,%edx
  80042145dd:	89 d1                	mov    %edx,%ecx
  80042145df:	29 c1                	sub    %eax,%ecx
  80042145e1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042145e5:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042145e9:	0f b6 d8             	movzbl %al,%ebx
  80042145ec:	89 c8                	mov    %ecx,%eax
  80042145ee:	99                   	cltd   
  80042145ef:	f7 fb                	idiv   %ebx
  80042145f1:	89 c2                	mov    %eax,%edx
  80042145f3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042145f7:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80042145fb:	0f b6 c0             	movzbl %al,%eax
  80042145fe:	0f af c2             	imul   %edx,%eax
  8004214601:	48 98                	cltq   
  8004214603:	48 01 45 e8          	add    %rax,-0x18(%rbp)
                break;
  8004214607:	eb 57                	jmp    8004214660 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_fixed_advance_pc:
                address += dbg->decode(&p, 2);
  8004214609:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  8004214610:	00 00 00 
  8004214613:	48 8b 00             	mov    (%rax),%rax
  8004214616:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421461a:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004214621:	be 02 00 00 00       	mov    $0x2,%esi
  8004214626:	48 89 d7             	mov    %rdx,%rdi
  8004214629:	ff d0                	callq  *%rax
  800421462b:	48 01 45 e8          	add    %rax,-0x18(%rbp)
                break;
  800421462f:	eb 2f                	jmp    8004214660 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_prologue_end:
                prologue_end = 1;
  8004214631:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
                break;
  8004214638:	eb 26                	jmp    8004214660 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_epilogue_begin:
                epilogue_begin = 1;
  800421463a:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
                break;
  8004214641:	eb 1d                	jmp    8004214660 <_dwarf_lineno_run_program+0x45e>
            case DW_LNS_set_isa:
                isa = _dwarf_decode_uleb128(&p);
  8004214643:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421464a:	48 89 c7             	mov    %rax,%rdi
  800421464d:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004214654:	00 00 00 
  8004214657:	ff d0                	callq  *%rax
  8004214659:	48 89 45 98          	mov    %rax,-0x68(%rbp)
                break;
  800421465d:	eb 01                	jmp    8004214660 <_dwarf_lineno_run_program+0x45e>
            default:
                /* Unrecognized extened opcodes. What to do? */
                break;
  800421465f:	90                   	nop
            }

        } else {
  8004214660:	e9 32 01 00 00       	jmpq   8004214797 <_dwarf_lineno_run_program+0x595>

            /*
             * Special Opcodes.
             */

            line += LINE(*p);
  8004214665:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214669:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  800421466d:	0f be c8             	movsbl %al,%ecx
  8004214670:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214677:	0f b6 00             	movzbl (%rax),%eax
  800421467a:	0f b6 d0             	movzbl %al,%edx
  800421467d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214681:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214685:	0f b6 c0             	movzbl %al,%eax
  8004214688:	29 c2                	sub    %eax,%edx
  800421468a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421468e:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004214692:	0f b6 f0             	movzbl %al,%esi
  8004214695:	89 d0                	mov    %edx,%eax
  8004214697:	99                   	cltd   
  8004214698:	f7 fe                	idiv   %esi
  800421469a:	89 d0                	mov    %edx,%eax
  800421469c:	01 c8                	add    %ecx,%eax
  800421469e:	48 98                	cltq   
  80042146a0:	48 01 45 d8          	add    %rax,-0x28(%rbp)
            address += ADDRESS(*p);
  80042146a4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042146ab:	0f b6 00             	movzbl (%rax),%eax
  80042146ae:	0f b6 d0             	movzbl %al,%edx
  80042146b1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042146b5:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042146b9:	0f b6 c0             	movzbl %al,%eax
  80042146bc:	89 d1                	mov    %edx,%ecx
  80042146be:	29 c1                	sub    %eax,%ecx
  80042146c0:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042146c4:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042146c8:	0f b6 d8             	movzbl %al,%ebx
  80042146cb:	89 c8                	mov    %ecx,%eax
  80042146cd:	99                   	cltd   
  80042146ce:	f7 fb                	idiv   %ebx
  80042146d0:	89 c2                	mov    %eax,%edx
  80042146d2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042146d6:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80042146da:	0f b6 c0             	movzbl %al,%eax
  80042146dd:	0f af c2             	imul   %edx,%eax
  80042146e0:	48 98                	cltq   
  80042146e2:	48 01 45 e8          	add    %rax,-0x18(%rbp)
            APPEND_ROW;
  80042146e6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042146ed:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042146f1:	73 0a                	jae    80042146fd <_dwarf_lineno_run_program+0x4fb>
  80042146f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042146f8:	e9 b3 00 00 00       	jmpq   80042147b0 <_dwarf_lineno_run_program+0x5ae>
  80042146fd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214701:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214705:	48 89 10             	mov    %rdx,(%rax)
  8004214708:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421470c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004214713:	00 
  8004214714:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214718:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421471c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004214720:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214724:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214728:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421472c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214730:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214734:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004214738:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421473c:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800421473f:	89 50 28             	mov    %edx,0x28(%rax)
  8004214742:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214746:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004214749:	89 50 2c             	mov    %edx,0x2c(%rax)
  800421474c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214750:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004214753:	89 50 30             	mov    %edx,0x30(%rax)
  8004214756:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421475a:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004214761:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214765:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214769:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
            basic_block = 0;
  8004214770:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
            prologue_end = 0;
  8004214777:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
            epilogue_begin = 0;
  800421477e:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
            p++;
  8004214785:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421478c:	48 83 c0 01          	add    $0x1,%rax
  8004214790:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    RESET_REGISTERS;

    /*
     * Start line number program.
     */
    while (p < pe) {
  8004214797:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421479e:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  80042147a5:	0f 82 e2 fa ff ff    	jb     800421428d <_dwarf_lineno_run_program+0x8b>
            epilogue_begin = 0;
            p++;
        }
    }

    return (DW_DLE_NONE);
  80042147ab:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  80042147b0:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  80042147b7:	5b                   	pop    %rbx
  80042147b8:	5d                   	pop    %rbp
  80042147b9:	c3                   	retq   

00000080042147ba <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
    Dwarf_Error *error, Dwarf_Debug dbg)
{
  80042147ba:	55                   	push   %rbp
  80042147bb:	48 89 e5             	mov    %rsp,%rbp
  80042147be:	53                   	push   %rbx
  80042147bf:	48 83 ec 48          	sub    $0x48,%rsp
  80042147c3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042147c7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042147cb:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042147cf:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  80042147d3:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
    char *fname;
    //const char *dirname;
    uint8_t *src;
    int slen;

    src = *p;
  80042147d7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042147db:	48 8b 00             	mov    (%rax),%rax
  80042147de:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
        return (DW_DLE_MEMORY);
    }
*/  
    //lf->lf_fullpath = NULL;
    fname = (char *) src;
  80042147e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042147e6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    src += strlen(fname) + 1;
  80042147ea:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  80042147ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042147f2:	48 89 c7             	mov    %rax,%rdi
  80042147f5:	48 b8 a1 f5 20 04 80 	movabs $0x800420f5a1,%rax
  80042147fc:	00 00 00 
  80042147ff:	ff d0                	callq  *%rax
  8004214801:	48 98                	cltq   
  8004214803:	48 83 c0 01          	add    $0x1,%rax
  8004214807:	48 01 d8             	add    %rbx,%rax
  800421480a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    _dwarf_decode_uleb128(&src);
  800421480e:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214812:	48 89 c7             	mov    %rax,%rdi
  8004214815:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  800421481c:	00 00 00 
  800421481f:	ff d0                	callq  *%rax
            snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
                lf->lf_fname);
        }
    }
*/
    _dwarf_decode_uleb128(&src);
  8004214821:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214825:	48 89 c7             	mov    %rax,%rdi
  8004214828:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  800421482f:	00 00 00 
  8004214832:	ff d0                	callq  *%rax
    _dwarf_decode_uleb128(&src);
  8004214834:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214838:	48 89 c7             	mov    %rax,%rdi
  800421483b:	48 b8 c9 04 21 04 80 	movabs $0x80042104c9,%rax
  8004214842:	00 00 00 
  8004214845:	ff d0                	callq  *%rax
    //STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
    //li->li_lflen++;

    *p = src;
  8004214847:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421484b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421484f:	48 89 10             	mov    %rdx,(%rax)

    return (DW_DLE_NONE);
  8004214852:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214857:	48 83 c4 48          	add    $0x48,%rsp
  800421485b:	5b                   	pop    %rbx
  800421485c:	5d                   	pop    %rbp
  800421485d:	c3                   	retq   

000000800421485e <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  800421485e:	55                   	push   %rbp
  800421485f:	48 89 e5             	mov    %rsp,%rbp
  8004214862:	53                   	push   %rbx
  8004214863:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  800421486a:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004214871:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  8004214878:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  800421487f:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004214886:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
    Dwarf_Section myds = {.ds_name = ".debug_line"};
  800421488d:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004214894:	00 
  8004214895:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  800421489c:	00 
  800421489d:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  80042148a4:	00 
  80042148a5:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80042148ac:	00 
  80042148ad:	48 b8 08 94 21 04 80 	movabs $0x8004219408,%rax
  80042148b4:	00 00 00 
  80042148b7:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  80042148bb:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  80042148bf:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    //Dwarf_LineFile lf, tlf;
    uint64_t length, hdroff, endoff;
    uint8_t *p;
    int dwarf_size, i, ret;
            
    cu = die->cu_header;
  80042148c3:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042148ca:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  80042148d1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    assert(cu != NULL); 
  80042148d5:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042148da:	75 35                	jne    8004214911 <_dwarf_lineno_init+0xb3>
  80042148dc:	48 b9 14 94 21 04 80 	movabs $0x8004219414,%rcx
  80042148e3:	00 00 00 
  80042148e6:	48 ba 1f 94 21 04 80 	movabs $0x800421941f,%rdx
  80042148ed:	00 00 00 
  80042148f0:	be 17 01 00 00       	mov    $0x117,%esi
  80042148f5:	48 bf 34 94 21 04 80 	movabs $0x8004219434,%rdi
  80042148fc:	00 00 00 
  80042148ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214904:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800421490b:	00 00 00 
  800421490e:	41 ff d0             	callq  *%r8
    assert(dbg != NULL);
  8004214911:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  8004214918:	00 00 00 
  800421491b:	48 8b 00             	mov    (%rax),%rax
  800421491e:	48 85 c0             	test   %rax,%rax
  8004214921:	75 35                	jne    8004214958 <_dwarf_lineno_init+0xfa>
  8004214923:	48 b9 4b 94 21 04 80 	movabs $0x800421944b,%rcx
  800421492a:	00 00 00 
  800421492d:	48 ba 1f 94 21 04 80 	movabs $0x800421941f,%rdx
  8004214934:	00 00 00 
  8004214937:	be 18 01 00 00       	mov    $0x118,%esi
  800421493c:	48 bf 34 94 21 04 80 	movabs $0x8004219434,%rdi
  8004214943:	00 00 00 
  8004214946:	b8 00 00 00 00       	mov    $0x0,%eax
  800421494b:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004214952:	00 00 00 
  8004214955:	41 ff d0             	callq  *%r8

    if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004214958:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421495c:	48 89 c7             	mov    %rax,%rdi
  800421495f:	48 b8 56 1c 21 04 80 	movabs $0x8004211c56,%rax
  8004214966:	00 00 00 
  8004214969:	ff d0                	callq  *%rax
  800421496b:	85 c0                	test   %eax,%eax
  800421496d:	74 0a                	je     8004214979 <_dwarf_lineno_init+0x11b>
        return (DW_DLE_NONE);
  800421496f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214974:	e9 4f 04 00 00       	jmpq   8004214dc8 <_dwarf_lineno_init+0x56a>

	li = linfo;
  8004214979:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004214980:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
            break;
        }
    }
     */

    length = dbg->read(ds->ds_data, &offset, 4);
  8004214984:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  800421498b:	00 00 00 
  800421498e:	48 8b 00             	mov    (%rax),%rax
  8004214991:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214995:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214999:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800421499d:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042149a4:	ba 04 00 00 00       	mov    $0x4,%edx
  80042149a9:	48 89 cf             	mov    %rcx,%rdi
  80042149ac:	ff d0                	callq  *%rax
  80042149ae:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (length == 0xffffffff) {
  80042149b2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042149b7:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042149bb:	75 37                	jne    80042149f4 <_dwarf_lineno_init+0x196>
        dwarf_size = 8;
  80042149bd:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
        length = dbg->read(ds->ds_data, &offset, 8);
  80042149c4:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  80042149cb:	00 00 00 
  80042149ce:	48 8b 00             	mov    (%rax),%rax
  80042149d1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042149d5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042149d9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042149dd:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042149e4:	ba 08 00 00 00       	mov    $0x8,%edx
  80042149e9:	48 89 cf             	mov    %rcx,%rdi
  80042149ec:	ff d0                	callq  *%rax
  80042149ee:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042149f2:	eb 07                	jmp    80042149fb <_dwarf_lineno_init+0x19d>
    } else
        dwarf_size = 4;
  80042149f4:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

    if (length > ds->ds_size - offset) {
  80042149fb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042149ff:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214a03:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214a0a:	48 29 c2             	sub    %rax,%rdx
  8004214a0d:	48 89 d0             	mov    %rdx,%rax
  8004214a10:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004214a14:	73 0a                	jae    8004214a20 <_dwarf_lineno_init+0x1c2>
        DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
        return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004214a16:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004214a1b:	e9 a8 03 00 00       	jmpq   8004214dc8 <_dwarf_lineno_init+0x56a>
    }
    /*
     * Read in line number program header.
     */
    li->li_length = length;
  8004214a20:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214a24:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214a28:	48 89 10             	mov    %rdx,(%rax)
    endoff = offset + length;
  8004214a2b:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004214a32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a36:	48 01 d0             	add    %rdx,%rax
  8004214a39:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004214a3d:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  8004214a44:	00 00 00 
  8004214a47:	48 8b 00             	mov    (%rax),%rax
  8004214a4a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214a4e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214a52:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214a56:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214a5d:	ba 02 00 00 00       	mov    $0x2,%edx
  8004214a62:	48 89 cf             	mov    %rcx,%rdi
  8004214a65:	ff d0                	callq  *%rax
  8004214a67:	89 c2                	mov    %eax,%edx
  8004214a69:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214a6d:	66 89 50 08          	mov    %dx,0x8(%rax)
    li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004214a71:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  8004214a78:	00 00 00 
  8004214a7b:	48 8b 00             	mov    (%rax),%rax
  8004214a7e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214a82:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214a86:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214a8a:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004214a8d:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214a94:	48 89 cf             	mov    %rcx,%rdi
  8004214a97:	ff d0                	callq  *%rax
  8004214a99:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214a9d:	48 89 42 10          	mov    %rax,0x10(%rdx)
    hdroff = offset;
  8004214aa1:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214aa8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004214aac:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  8004214ab3:	00 00 00 
  8004214ab6:	48 8b 00             	mov    (%rax),%rax
  8004214ab9:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214abd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214ac1:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214ac5:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214acc:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214ad1:	48 89 cf             	mov    %rcx,%rdi
  8004214ad4:	ff d0                	callq  *%rax
  8004214ad6:	89 c2                	mov    %eax,%edx
  8004214ad8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214adc:	88 50 18             	mov    %dl,0x18(%rax)
    li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004214adf:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  8004214ae6:	00 00 00 
  8004214ae9:	48 8b 00             	mov    (%rax),%rax
  8004214aec:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214af0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214af4:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214af8:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214aff:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214b04:	48 89 cf             	mov    %rcx,%rdi
  8004214b07:	ff d0                	callq  *%rax
  8004214b09:	89 c2                	mov    %eax,%edx
  8004214b0b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214b0f:	88 50 19             	mov    %dl,0x19(%rax)
    li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004214b12:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  8004214b19:	00 00 00 
  8004214b1c:	48 8b 00             	mov    (%rax),%rax
  8004214b1f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214b23:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214b27:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214b2b:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214b32:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214b37:	48 89 cf             	mov    %rcx,%rdi
  8004214b3a:	ff d0                	callq  *%rax
  8004214b3c:	89 c2                	mov    %eax,%edx
  8004214b3e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214b42:	88 50 1a             	mov    %dl,0x1a(%rax)
    li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  8004214b45:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  8004214b4c:	00 00 00 
  8004214b4f:	48 8b 00             	mov    (%rax),%rax
  8004214b52:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214b56:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214b5a:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214b5e:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214b65:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214b6a:	48 89 cf             	mov    %rcx,%rdi
  8004214b6d:	ff d0                	callq  *%rax
  8004214b6f:	89 c2                	mov    %eax,%edx
  8004214b71:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214b75:	88 50 1b             	mov    %dl,0x1b(%rax)
    li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  8004214b78:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  8004214b7f:	00 00 00 
  8004214b82:	48 8b 00             	mov    (%rax),%rax
  8004214b85:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214b89:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214b8d:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214b91:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214b98:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214b9d:	48 89 cf             	mov    %rcx,%rdi
  8004214ba0:	ff d0                	callq  *%rax
  8004214ba2:	89 c2                	mov    %eax,%edx
  8004214ba4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214ba8:	88 50 1c             	mov    %dl,0x1c(%rax)
    //STAILQ_INIT(&li->li_lflist);
    //STAILQ_INIT(&li->li_lnlist);

    if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004214bab:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214baf:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214bb3:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004214bb6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214bba:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214bbe:	0f b6 c0             	movzbl %al,%eax
  8004214bc1:	83 e8 01             	sub    $0x1,%eax
  8004214bc4:	39 c2                	cmp    %eax,%edx
  8004214bc6:	7d 0c                	jge    8004214bd4 <_dwarf_lineno_init+0x376>
        ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214bc8:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
        DWARF_SET_ERROR(dbg, error, ret);
        goto fail_cleanup;
  8004214bcf:	e9 f1 01 00 00       	jmpq   8004214dc5 <_dwarf_lineno_init+0x567>
    }

    li->li_oplen = global_std_op;
  8004214bd4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214bd8:	48 bb a0 25 4a 04 80 	movabs $0x80044a25a0,%rbx
  8004214bdf:	00 00 00 
  8004214be2:	48 89 58 20          	mov    %rbx,0x20(%rax)

    /*
     * Read in std opcode arg length list. Note that the first
     * element is not used.
     */
    for (i = 1; i < li->li_opbase; i++)
  8004214be6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004214bed:	eb 41                	jmp    8004214c30 <_dwarf_lineno_init+0x3d2>
        li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004214bef:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214bf3:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214bf7:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004214bfa:	48 98                	cltq   
  8004214bfc:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004214c00:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  8004214c07:	00 00 00 
  8004214c0a:	48 8b 00             	mov    (%rax),%rax
  8004214c0d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c11:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214c15:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214c19:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214c20:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214c25:	48 89 cf             	mov    %rcx,%rdi
  8004214c28:	ff d0                	callq  *%rax
  8004214c2a:	88 03                	mov    %al,(%rbx)

    /*
     * Read in std opcode arg length list. Note that the first
     * element is not used.
     */
    for (i = 1; i < li->li_opbase; i++)
  8004214c2c:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004214c30:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214c34:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214c38:	0f b6 c0             	movzbl %al,%eax
  8004214c3b:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004214c3e:	7f af                	jg     8004214bef <_dwarf_lineno_init+0x391>
        li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

    /*
     * Check how many strings in the include dir string array.
     */
    length = 0;
  8004214c40:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214c47:	00 
    p = ds->ds_data + offset;
  8004214c48:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214c4c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214c50:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214c57:	48 01 d0             	add    %rdx,%rax
  8004214c5a:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    while (*p != '\0') {
  8004214c61:	eb 1f                	jmp    8004214c82 <_dwarf_lineno_init+0x424>
        while (*p++ != '\0')
  8004214c63:	90                   	nop
  8004214c64:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214c6b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214c6f:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  8004214c76:	0f b6 00             	movzbl (%rax),%eax
  8004214c79:	84 c0                	test   %al,%al
  8004214c7b:	75 e7                	jne    8004214c64 <_dwarf_lineno_init+0x406>
            ;
        length++;
  8004214c7d:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
    /*
     * Check how many strings in the include dir string array.
     */
    length = 0;
    p = ds->ds_data + offset;
    while (*p != '\0') {
  8004214c82:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214c89:	0f b6 00             	movzbl (%rax),%eax
  8004214c8c:	84 c0                	test   %al,%al
  8004214c8e:	75 d3                	jne    8004214c63 <_dwarf_lineno_init+0x405>
        while (*p++ != '\0')
            ;
        length++;
    }
    li->li_inclen = length;
  8004214c90:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214c94:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214c98:	48 89 50 30          	mov    %rdx,0x30(%rax)

    /* Sanity check. */
    if (p - ds->ds_data > (int) ds->ds_size) {
  8004214c9c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214ca3:	48 89 c2             	mov    %rax,%rdx
  8004214ca6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214caa:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214cae:	48 29 c2             	sub    %rax,%rdx
  8004214cb1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214cb5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214cb9:	48 98                	cltq   
  8004214cbb:	48 39 c2             	cmp    %rax,%rdx
  8004214cbe:	7e 0c                	jle    8004214ccc <_dwarf_lineno_init+0x46e>
        ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214cc0:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
        DWARF_SET_ERROR(dbg, error, ret);
        goto fail_cleanup;
  8004214cc7:	e9 f9 00 00 00       	jmpq   8004214dc5 <_dwarf_lineno_init+0x567>
        li->li_incdirs[i++] = (char *) p;
        while (*p++ != '\0')
            ;
    }
*/
    p++;
  8004214ccc:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214cd3:	48 83 c0 01          	add    $0x1,%rax
  8004214cd7:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

    /*
     * Process file list.
     */
    while (*p != '\0') {
  8004214cde:	eb 3c                	jmp    8004214d1c <_dwarf_lineno_init+0x4be>
        ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004214ce0:	48 b8 a8 c6 22 04 80 	movabs $0x800422c6a8,%rax
  8004214ce7:	00 00 00 
  8004214cea:	48 8b 08             	mov    (%rax),%rcx
  8004214ced:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004214cf4:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004214cfb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214cff:	49 89 c8             	mov    %rcx,%r8
  8004214d02:	48 89 d1             	mov    %rdx,%rcx
  8004214d05:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214d0a:	48 89 c7             	mov    %rax,%rdi
  8004214d0d:	48 b8 ba 47 21 04 80 	movabs $0x80042147ba,%rax
  8004214d14:	00 00 00 
  8004214d17:	ff d0                	callq  *%rax
  8004214d19:	89 45 dc             	mov    %eax,-0x24(%rbp)
    p++;

    /*
     * Process file list.
     */
    while (*p != '\0') {
  8004214d1c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214d23:	0f b6 00             	movzbl (%rax),%eax
  8004214d26:	84 c0                	test   %al,%al
  8004214d28:	75 b6                	jne    8004214ce0 <_dwarf_lineno_init+0x482>
        ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
    }

    p++;
  8004214d2a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214d31:	48 83 c0 01          	add    $0x1,%rax
  8004214d35:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    /* Sanity check. */
    if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  8004214d3c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214d43:	48 89 c2             	mov    %rax,%rdx
  8004214d46:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214d4a:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214d4e:	48 29 c2             	sub    %rax,%rdx
  8004214d51:	48 89 d0             	mov    %rdx,%rax
  8004214d54:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  8004214d58:	48 89 c2             	mov    %rax,%rdx
  8004214d5b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d5f:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214d63:	48 39 c2             	cmp    %rax,%rdx
  8004214d66:	74 09                	je     8004214d71 <_dwarf_lineno_init+0x513>
        ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214d68:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
        DWARF_SET_ERROR(dbg, error, ret);
        goto fail_cleanup;
  8004214d6f:	eb 54                	jmp    8004214dc5 <_dwarf_lineno_init+0x567>
    }

    /*
     * Process line number program.
     */
    ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  8004214d71:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214d75:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214d79:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214d7d:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004214d81:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004214d88:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  8004214d8f:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  8004214d96:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004214d9a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214d9e:	4d 89 c1             	mov    %r8,%r9
  8004214da1:	49 89 f8             	mov    %rdi,%r8
  8004214da4:	48 89 c7             	mov    %rax,%rdi
  8004214da7:	48 b8 02 42 21 04 80 	movabs $0x8004214202,%rax
  8004214dae:	00 00 00 
  8004214db1:	ff d0                	callq  *%rax
  8004214db3:	89 45 dc             	mov    %eax,-0x24(%rbp)
        error);
    if (ret != DW_DLE_NONE)
  8004214db6:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214dba:	74 02                	je     8004214dbe <_dwarf_lineno_init+0x560>
        goto fail_cleanup;
  8004214dbc:	eb 07                	jmp    8004214dc5 <_dwarf_lineno_init+0x567>

    //cu->cu_lineinfo = li;

    return (DW_DLE_NONE);
  8004214dbe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214dc3:	eb 03                	jmp    8004214dc8 <_dwarf_lineno_init+0x56a>
fail_cleanup:

    /*if (li->li_oplen)
        free(li->li_oplen);*/

    return (ret);
  8004214dc5:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004214dc8:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  8004214dcf:	5b                   	pop    %rbx
  8004214dd0:	5d                   	pop    %rbp
  8004214dd1:	c3                   	retq   

0000008004214dd2 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004214dd2:	55                   	push   %rbp
  8004214dd3:	48 89 e5             	mov    %rsp,%rbp
  8004214dd6:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004214ddd:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004214de4:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004214deb:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004214df2:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
    _Dwarf_LineInfo li;
    Dwarf_Attribute *at;

	assert(die);
  8004214df9:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004214e00:	00 
  8004214e01:	75 35                	jne    8004214e38 <dwarf_srclines+0x66>
  8004214e03:	48 b9 57 94 21 04 80 	movabs $0x8004219457,%rcx
  8004214e0a:	00 00 00 
  8004214e0d:	48 ba 1f 94 21 04 80 	movabs $0x800421941f,%rdx
  8004214e14:	00 00 00 
  8004214e17:	be ae 01 00 00       	mov    $0x1ae,%esi
  8004214e1c:	48 bf 34 94 21 04 80 	movabs $0x8004219434,%rdi
  8004214e23:	00 00 00 
  8004214e26:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214e2b:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004214e32:	00 00 00 
  8004214e35:	41 ff d0             	callq  *%r8
	assert(linebuf);
  8004214e38:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004214e3f:	00 
  8004214e40:	75 35                	jne    8004214e77 <dwarf_srclines+0xa5>
  8004214e42:	48 b9 5b 94 21 04 80 	movabs $0x800421945b,%rcx
  8004214e49:	00 00 00 
  8004214e4c:	48 ba 1f 94 21 04 80 	movabs $0x800421941f,%rdx
  8004214e53:	00 00 00 
  8004214e56:	be af 01 00 00       	mov    $0x1af,%esi
  8004214e5b:	48 bf 34 94 21 04 80 	movabs $0x8004219434,%rdi
  8004214e62:	00 00 00 
  8004214e65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214e6a:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004214e71:	00 00 00 
  8004214e74:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  8004214e77:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004214e7e:	ba 88 00 00 00       	mov    $0x88,%edx
  8004214e83:	be 00 00 00 00       	mov    $0x0,%esi
  8004214e88:	48 89 c7             	mov    %rax,%rdi
  8004214e8b:	48 b8 a6 f8 20 04 80 	movabs $0x800420f8a6,%rax
  8004214e92:	00 00 00 
  8004214e95:	ff d0                	callq  *%rax

    if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  8004214e97:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214e9e:	be 10 00 00 00       	mov    $0x10,%esi
  8004214ea3:	48 89 c7             	mov    %rax,%rdi
  8004214ea6:	48 b8 db 17 21 04 80 	movabs $0x80042117db,%rax
  8004214ead:	00 00 00 
  8004214eb0:	ff d0                	callq  *%rax
  8004214eb2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214eb6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214ebb:	75 0a                	jne    8004214ec7 <dwarf_srclines+0xf5>
        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004214ebd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214ec2:	e9 84 00 00 00       	jmpq   8004214f4b <dwarf_srclines+0x179>
    }

    if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  8004214ec7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214ecb:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004214ecf:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8004214ed6:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  8004214edd:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004214ee4:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214eeb:	49 89 f8             	mov    %rdi,%r8
  8004214eee:	48 89 c7             	mov    %rax,%rdi
  8004214ef1:	48 b8 5e 48 21 04 80 	movabs $0x800421485e,%rax
  8004214ef8:	00 00 00 
  8004214efb:	ff d0                	callq  *%rax
  8004214efd:	85 c0                	test   %eax,%eax
  8004214eff:	74 07                	je     8004214f08 <dwarf_srclines+0x136>
        DW_DLE_NONE)
	{
          return (DW_DLV_ERROR);
  8004214f01:	b8 01 00 00 00       	mov    $0x1,%eax
  8004214f06:	eb 43                	jmp    8004214f4b <dwarf_srclines+0x179>
	}
    *linebuf = li.li_line;
  8004214f08:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004214f0f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004214f13:	48 89 10             	mov    %rdx,(%rax)
  8004214f16:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214f1a:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004214f1e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214f22:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004214f26:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214f2a:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004214f2e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214f32:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004214f36:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214f3a:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004214f3e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214f42:	48 89 50 30          	mov    %rdx,0x30(%rax)

    return (DW_DLV_OK);
  8004214f46:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214f4b:	c9                   	leaveq 
  8004214f4c:	c3                   	retq   

0000008004214f4d <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  8004214f4d:	55                   	push   %rbp
  8004214f4e:	48 89 e5             	mov    %rsp,%rbp
  8004214f51:	48 83 ec 20          	sub    $0x20,%rsp
  8004214f55:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Dwarf_Section *ret=NULL;
  8004214f59:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004214f60:	00 
    int i;

    for(i=0; i < NDEBUG_SECT; i++) {
  8004214f61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004214f68:	eb 57                	jmp    8004214fc1 <_dwarf_find_section+0x74>
        if(!strcmp(section_info[i].ds_name, name)) {
  8004214f6a:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004214f71:	00 00 00 
  8004214f74:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214f77:	48 63 d2             	movslq %edx,%rdx
  8004214f7a:	48 c1 e2 05          	shl    $0x5,%rdx
  8004214f7e:	48 01 d0             	add    %rdx,%rax
  8004214f81:	48 8b 00             	mov    (%rax),%rax
  8004214f84:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214f88:	48 89 d6             	mov    %rdx,%rsi
  8004214f8b:	48 89 c7             	mov    %rax,%rdi
  8004214f8e:	48 b8 6f f7 20 04 80 	movabs $0x800420f76f,%rax
  8004214f95:	00 00 00 
  8004214f98:	ff d0                	callq  *%rax
  8004214f9a:	85 c0                	test   %eax,%eax
  8004214f9c:	75 1f                	jne    8004214fbd <_dwarf_find_section+0x70>
            ret = (section_info + i);
  8004214f9e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214fa1:	48 98                	cltq   
  8004214fa3:	48 c1 e0 05          	shl    $0x5,%rax
  8004214fa7:	48 89 c2             	mov    %rax,%rdx
  8004214faa:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004214fb1:	00 00 00 
  8004214fb4:	48 01 d0             	add    %rdx,%rax
  8004214fb7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            break;
  8004214fbb:	eb 0a                	jmp    8004214fc7 <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
    Dwarf_Section *ret=NULL;
    int i;

    for(i=0; i < NDEBUG_SECT; i++) {
  8004214fbd:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004214fc1:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004214fc5:	7e a3                	jle    8004214f6a <_dwarf_find_section+0x1d>
            ret = (section_info + i);
            break;
        }
    }

    return ret;
  8004214fc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004214fcb:	c9                   	leaveq 
  8004214fcc:	c3                   	retq   

0000008004214fcd <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  8004214fcd:	55                   	push   %rbp
  8004214fce:	48 89 e5             	mov    %rsp,%rbp
  8004214fd1:	48 83 ec 40          	sub    $0x40,%rsp
  8004214fd5:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    Elf *ehdr = (Elf *)elf;
  8004214fd9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214fdd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    uintptr_t debug_address = USTABDATA;
  8004214fe1:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  8004214fe8:	00 
    Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  8004214fe9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214fed:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004214ff1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ff5:	48 01 d0             	add    %rdx,%rax
  8004214ff8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  8004214ffc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215000:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004215004:	0f b7 c0             	movzwl %ax,%eax
  8004215007:	48 c1 e0 06          	shl    $0x6,%rax
  800421500b:	48 89 c2             	mov    %rax,%rdx
  800421500e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215012:	48 01 d0             	add    %rdx,%rax
  8004215015:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    Secthdr* esh = sh + ehdr->e_shnum;
  8004215019:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421501d:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004215021:	0f b7 c0             	movzwl %ax,%eax
  8004215024:	48 c1 e0 06          	shl    $0x6,%rax
  8004215028:	48 89 c2             	mov    %rax,%rdx
  800421502b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421502f:	48 01 d0             	add    %rdx,%rax
  8004215032:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    for(;sh < esh; sh++) {
  8004215036:	e9 4b 02 00 00       	jmpq   8004215286 <find_debug_sections+0x2b9>
        char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  800421503b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421503f:	8b 00                	mov    (%rax),%eax
  8004215041:	89 c2                	mov    %eax,%edx
  8004215043:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215047:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800421504b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421504f:	48 01 c8             	add    %rcx,%rax
  8004215052:	48 01 d0             	add    %rdx,%rax
  8004215055:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  8004215059:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421505d:	48 be 63 94 21 04 80 	movabs $0x8004219463,%rsi
  8004215064:	00 00 00 
  8004215067:	48 89 c7             	mov    %rax,%rdi
  800421506a:	48 b8 6f f7 20 04 80 	movabs $0x800420f76f,%rax
  8004215071:	00 00 00 
  8004215074:	ff d0                	callq  *%rax
  8004215076:	85 c0                	test   %eax,%eax
  8004215078:	75 4b                	jne    80042150c5 <find_debug_sections+0xf8>
            section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  800421507a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421507e:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004215085:	00 00 00 
  8004215088:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  800421508c:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004215093:	00 00 00 
  8004215096:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421509a:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  800421509e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042150a2:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042150a6:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042150ad:	00 00 00 
  80042150b0:	48 89 50 18          	mov    %rdx,0x18(%rax)
            debug_address += sh->sh_size;
  80042150b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042150b8:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042150bc:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042150c0:	e9 bc 01 00 00       	jmpq   8004215281 <find_debug_sections+0x2b4>
        } else if(!strcmp(name, ".debug_abbrev")) {
  80042150c5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042150c9:	48 be 6f 94 21 04 80 	movabs $0x800421946f,%rsi
  80042150d0:	00 00 00 
  80042150d3:	48 89 c7             	mov    %rax,%rdi
  80042150d6:	48 b8 6f f7 20 04 80 	movabs $0x800420f76f,%rax
  80042150dd:	00 00 00 
  80042150e0:	ff d0                	callq  *%rax
  80042150e2:	85 c0                	test   %eax,%eax
  80042150e4:	75 4b                	jne    8004215131 <find_debug_sections+0x164>
            section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  80042150e6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042150ea:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042150f1:	00 00 00 
  80042150f4:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  80042150f8:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042150ff:	00 00 00 
  8004215102:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215106:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  800421510a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421510e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215112:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004215119:	00 00 00 
  800421511c:	48 89 50 38          	mov    %rdx,0x38(%rax)
            debug_address += sh->sh_size;
  8004215120:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215124:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215128:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421512c:	e9 50 01 00 00       	jmpq   8004215281 <find_debug_sections+0x2b4>
        } else if(!strcmp(name, ".debug_line")){
  8004215131:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215135:	48 be 87 94 21 04 80 	movabs $0x8004219487,%rsi
  800421513c:	00 00 00 
  800421513f:	48 89 c7             	mov    %rax,%rdi
  8004215142:	48 b8 6f f7 20 04 80 	movabs $0x800420f76f,%rax
  8004215149:	00 00 00 
  800421514c:	ff d0                	callq  *%rax
  800421514e:	85 c0                	test   %eax,%eax
  8004215150:	75 4b                	jne    800421519d <find_debug_sections+0x1d0>
            section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  8004215152:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215156:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  800421515d:	00 00 00 
  8004215160:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  8004215164:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  800421516b:	00 00 00 
  800421516e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215172:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  8004215176:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421517a:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421517e:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004215185:	00 00 00 
  8004215188:	48 89 50 78          	mov    %rdx,0x78(%rax)
            debug_address += sh->sh_size;
  800421518c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215190:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215194:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215198:	e9 e4 00 00 00       	jmpq   8004215281 <find_debug_sections+0x2b4>
        } else if(!strcmp(name, ".eh_frame")){
  800421519d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042151a1:	48 be 7d 94 21 04 80 	movabs $0x800421947d,%rsi
  80042151a8:	00 00 00 
  80042151ab:	48 89 c7             	mov    %rax,%rdi
  80042151ae:	48 b8 6f f7 20 04 80 	movabs $0x800420f76f,%rax
  80042151b5:	00 00 00 
  80042151b8:	ff d0                	callq  *%rax
  80042151ba:	85 c0                	test   %eax,%eax
  80042151bc:	75 53                	jne    8004215211 <find_debug_sections+0x244>
            section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  80042151be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042151c2:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042151c6:	48 89 c2             	mov    %rax,%rdx
  80042151c9:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042151d0:	00 00 00 
  80042151d3:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  80042151d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042151db:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042151df:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042151e6:	00 00 00 
  80042151e9:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  80042151ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042151f1:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042151f5:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042151fc:	00 00 00 
  80042151ff:	48 89 50 58          	mov    %rdx,0x58(%rax)
            debug_address += sh->sh_size;
  8004215203:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215207:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421520b:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421520f:	eb 70                	jmp    8004215281 <find_debug_sections+0x2b4>
        } else if(!strcmp(name, ".debug_str")) {
  8004215211:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215215:	48 be 93 94 21 04 80 	movabs $0x8004219493,%rsi
  800421521c:	00 00 00 
  800421521f:	48 89 c7             	mov    %rax,%rdi
  8004215222:	48 b8 6f f7 20 04 80 	movabs $0x800420f76f,%rax
  8004215229:	00 00 00 
  800421522c:	ff d0                	callq  *%rax
  800421522e:	85 c0                	test   %eax,%eax
  8004215230:	75 4f                	jne    8004215281 <find_debug_sections+0x2b4>
            section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004215232:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215236:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  800421523d:	00 00 00 
  8004215240:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  8004215247:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  800421524e:	00 00 00 
  8004215251:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215255:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  800421525c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215260:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215264:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  800421526b:	00 00 00 
  800421526e:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
            debug_address += sh->sh_size;
  8004215275:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215279:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421527d:	48 01 45 f8          	add    %rax,-0x8(%rbp)
    Elf *ehdr = (Elf *)elf;
    uintptr_t debug_address = USTABDATA;
    Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
    Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
    Secthdr* esh = sh + ehdr->e_shnum;
    for(;sh < esh; sh++) {
  8004215281:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  8004215286:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421528a:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800421528e:	0f 82 a7 fd ff ff    	jb     800421503b <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
            debug_address += sh->sh_size;
        }
    }

}
  8004215294:	c9                   	leaveq 
  8004215295:	c3                   	retq   

0000008004215296 <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  8004215296:	55                   	push   %rbp
  8004215297:	48 89 e5             	mov    %rsp,%rbp
  800421529a:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  80042152a1:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  80042152a8:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
    Secthdr* secthdr_ptr[20] = {0};
  80042152af:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  80042152b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042152bb:	ba 14 00 00 00       	mov    $0x14,%edx
  80042152c0:	48 89 f7             	mov    %rsi,%rdi
  80042152c3:	48 89 d1             	mov    %rdx,%rcx
  80042152c6:	f3 48 ab             	rep stos %rax,%es:(%rdi)
    char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  80042152c9:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  80042152d0:	00 
  80042152d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042152d5:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  80042152dc:	48 01 d0             	add    %rdx,%rax
  80042152df:	48 83 e8 01          	sub    $0x1,%rax
  80042152e3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042152e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042152eb:	ba 00 00 00 00       	mov    $0x0,%edx
  80042152f0:	48 f7 75 e8          	divq   -0x18(%rbp)
  80042152f4:	48 89 d0             	mov    %rdx,%rax
  80042152f7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042152fb:	48 29 c2             	sub    %rax,%rdx
  80042152fe:	48 89 d0             	mov    %rdx,%rax
  8004215301:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    uint64_t kvoffset = 0;
  8004215305:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  800421530c:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004215310:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215314:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    char * secthdr = NULL;
  8004215318:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  800421531f:	00 
    uint64_t offset;
    if(elfhdr == KELFHDR)
  8004215320:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  8004215327:	00 00 00 
  800421532a:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004215331:	75 11                	jne    8004215344 <read_section_headers+0xae>
        offset = ((Elf*)elfhdr)->e_shoff;
  8004215333:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421533a:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421533e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215342:	eb 26                	jmp    800421536a <read_section_headers+0xd4>
    else
        offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  8004215344:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421534b:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421534f:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215356:	48 01 c2             	add    %rax,%rdx
  8004215359:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004215360:	ff ff ff 
  8004215363:	48 01 d0             	add    %rdx,%rax
  8004215366:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  800421536a:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215371:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004215375:	0f b7 c0             	movzwl %ax,%eax
  8004215378:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  800421537b:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215382:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  8004215386:	0f b7 c0             	movzwl %ax,%eax
  8004215389:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  800421538c:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215393:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  8004215397:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421539a:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  800421539e:	48 63 f0             	movslq %eax,%rsi
  80042153a1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042153a5:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042153ac:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042153b0:	48 89 c7             	mov    %rax,%rdi
  80042153b3:	48 b8 d5 59 21 04 80 	movabs $0x80042159d5,%rax
  80042153ba:	00 00 00 
  80042153bd:	ff d0                	callq  *%rax
             offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  80042153bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042153c3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042153c7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042153cb:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042153d1:	48 89 c2             	mov    %rax,%rdx
  80042153d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042153d8:	48 29 d0             	sub    %rdx,%rax
  80042153db:	48 89 c2             	mov    %rax,%rdx
  80042153de:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042153e2:	48 01 d0             	add    %rdx,%rax
  80042153e5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  80042153e9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042153f0:	eb 24                	jmp    8004215416 <read_section_headers+0x180>
	{
		 secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  80042153f2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042153f5:	48 98                	cltq   
  80042153f7:	48 c1 e0 06          	shl    $0x6,%rax
  80042153fb:	48 89 c2             	mov    %rax,%rdx
  80042153fe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215402:	48 01 c2             	add    %rax,%rdx
  8004215405:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215408:	48 98                	cltq   
  800421540a:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004215411:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
             offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004215412:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215416:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215419:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  800421541c:	7c d4                	jl     80042153f2 <read_section_headers+0x15c>
	{
		 secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  800421541e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215422:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004215426:	0f b7 c0             	movzwl %ax,%eax
  8004215429:	48 98                	cltq   
  800421542b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215432:	ff 
  8004215433:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  8004215437:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421543e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004215442:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215446:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421544a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421544e:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215452:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215459:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421545d:	48 01 c8             	add    %rcx,%rax
  8004215460:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215467:	48 89 c7             	mov    %rax,%rdi
  800421546a:	48 b8 d5 59 21 04 80 	movabs $0x80042159d5,%rax
  8004215471:	00 00 00 
  8004215474:	ff d0                	callq  *%rax
            sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  8004215476:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421547a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421547e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215482:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215486:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  800421548a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421548e:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004215494:	48 29 c2             	sub    %rax,%rdx
  8004215497:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421549b:	48 01 c2             	add    %rax,%rdx
  800421549e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042154a2:	48 01 d0             	add    %rdx,%rax
  80042154a5:	48 89 45 90          	mov    %rax,-0x70(%rbp)

    
	for (i = 0; i < numSectionHeaders; i++)
  80042154a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042154b0:	e9 04 05 00 00       	jmpq   80042159b9 <read_section_headers+0x723>
    {
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  80042154b5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042154b8:	48 98                	cltq   
  80042154ba:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042154c1:	ff 
  80042154c2:	8b 00                	mov    (%rax),%eax
  80042154c4:	89 c2                	mov    %eax,%edx
  80042154c6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042154ca:	48 01 d0             	add    %rdx,%rax
  80042154cd:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        assert(kvoffset % SECTSIZE == 0);
  80042154d1:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042154d8:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042154dd:	48 85 c0             	test   %rax,%rax
  80042154e0:	74 35                	je     8004215517 <read_section_headers+0x281>
  80042154e2:	48 b9 9e 94 21 04 80 	movabs $0x800421949e,%rcx
  80042154e9:	00 00 00 
  80042154ec:	48 ba b7 94 21 04 80 	movabs $0x80042194b7,%rdx
  80042154f3:	00 00 00 
  80042154f6:	be 87 00 00 00       	mov    $0x87,%esi
  80042154fb:	48 bf cc 94 21 04 80 	movabs $0x80042194cc,%rdi
  8004215502:	00 00 00 
  8004215505:	b8 00 00 00 00       	mov    $0x0,%eax
  800421550a:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004215511:	00 00 00 
  8004215514:	41 ff d0             	callq  *%r8
        temp = kvoffset;
  8004215517:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421551e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
        cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004215522:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215526:	48 be 63 94 21 04 80 	movabs $0x8004219463,%rsi
  800421552d:	00 00 00 
  8004215530:	48 89 c7             	mov    %rax,%rdi
  8004215533:	48 b8 6f f7 20 04 80 	movabs $0x800420f76f,%rax
  800421553a:	00 00 00 
  800421553d:	ff d0                	callq  *%rax
  800421553f:	85 c0                	test   %eax,%eax
  8004215541:	0f 85 d8 00 00 00    	jne    800421561f <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215547:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421554a:	48 98                	cltq   
  800421554c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215553:	ff 
#ifdef DWARF_DEBUG
        cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215554:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215558:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421555b:	48 98                	cltq   
  800421555d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215564:	ff 
  8004215565:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215569:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215570:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215574:	48 01 c8             	add    %rcx,%rax
  8004215577:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421557e:	48 89 c7             	mov    %rax,%rdi
  8004215581:	48 b8 d5 59 21 04 80 	movabs $0x80042159d5,%rax
  8004215588:	00 00 00 
  800421558b:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421558d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215590:	48 98                	cltq   
  8004215592:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215599:	ff 
  800421559a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421559e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042155a1:	48 98                	cltq   
  80042155a3:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042155aa:	ff 
  80042155ab:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042155af:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  80042155b3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042155b7:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042155bd:	48 29 c2             	sub    %rax,%rdx
  80042155c0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042155c4:	48 01 c2             	add    %rax,%rdx
  80042155c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042155cb:	48 01 c2             	add    %rax,%rdx
  80042155ce:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042155d5:	00 00 00 
  80042155d8:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  80042155dc:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042155e3:	00 00 00 
  80042155e6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042155ea:	48 89 c2             	mov    %rax,%rdx
  80042155ed:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042155f4:	00 00 00 
  80042155f7:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  80042155fb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042155fe:	48 98                	cltq   
  8004215600:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215607:	ff 
  8004215608:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421560c:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004215613:	00 00 00 
  8004215616:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421561a:	e9 96 03 00 00       	jmpq   80042159b5 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  800421561f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215623:	48 be 6f 94 21 04 80 	movabs $0x800421946f,%rsi
  800421562a:	00 00 00 
  800421562d:	48 89 c7             	mov    %rax,%rdi
  8004215630:	48 b8 6f f7 20 04 80 	movabs $0x800420f76f,%rax
  8004215637:	00 00 00 
  800421563a:	ff d0                	callq  *%rax
  800421563c:	85 c0                	test   %eax,%eax
  800421563e:	0f 85 de 00 00 00    	jne    8004215722 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215644:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215647:	48 98                	cltq   
  8004215649:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215650:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215651:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215655:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215658:	48 98                	cltq   
  800421565a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215661:	ff 
  8004215662:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215666:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  800421566d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215671:	48 01 c8             	add    %rcx,%rax
  8004215674:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421567b:	48 89 c7             	mov    %rax,%rdi
  800421567e:	48 b8 d5 59 21 04 80 	movabs $0x80042159d5,%rax
  8004215685:	00 00 00 
  8004215688:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421568a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421568d:	48 98                	cltq   
  800421568f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215696:	ff 
  8004215697:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421569b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421569e:	48 98                	cltq   
  80042156a0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042156a7:	ff 
  80042156a8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042156ac:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042156b3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042156ba:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042156c0:	48 29 c2             	sub    %rax,%rdx
  80042156c3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042156c7:	48 01 c2             	add    %rax,%rdx
  80042156ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042156ce:	48 01 c2             	add    %rax,%rdx
  80042156d1:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042156d8:	00 00 00 
  80042156db:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  80042156df:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042156e6:	00 00 00 
  80042156e9:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042156ed:	48 89 c2             	mov    %rax,%rdx
  80042156f0:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042156f7:	00 00 00 
  80042156fa:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  80042156fe:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215701:	48 98                	cltq   
  8004215703:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421570a:	ff 
  800421570b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421570f:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004215716:	00 00 00 
  8004215719:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800421571d:	e9 93 02 00 00       	jmpq   80042159b5 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_line"))
  8004215722:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215726:	48 be 87 94 21 04 80 	movabs $0x8004219487,%rsi
  800421572d:	00 00 00 
  8004215730:	48 89 c7             	mov    %rax,%rdi
  8004215733:	48 b8 6f f7 20 04 80 	movabs $0x800420f76f,%rax
  800421573a:	00 00 00 
  800421573d:	ff d0                	callq  *%rax
  800421573f:	85 c0                	test   %eax,%eax
  8004215741:	0f 85 de 00 00 00    	jne    8004215825 <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215747:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421574a:	48 98                	cltq   
  800421574c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215753:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215754:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215758:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421575b:	48 98                	cltq   
  800421575d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215764:	ff 
  8004215765:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215769:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215770:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215774:	48 01 c8             	add    %rcx,%rax
  8004215777:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421577e:	48 89 c7             	mov    %rax,%rdi
  8004215781:	48 b8 d5 59 21 04 80 	movabs $0x80042159d5,%rax
  8004215788:	00 00 00 
  800421578b:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421578d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215790:	48 98                	cltq   
  8004215792:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215799:	ff 
  800421579a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421579e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042157a1:	48 98                	cltq   
  80042157a3:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042157aa:	ff 
  80042157ab:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042157af:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  80042157b6:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042157bd:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042157c3:	48 29 c2             	sub    %rax,%rdx
  80042157c6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042157ca:	48 01 c2             	add    %rax,%rdx
  80042157cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042157d1:	48 01 c2             	add    %rax,%rdx
  80042157d4:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042157db:	00 00 00 
  80042157de:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  80042157e2:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042157e9:	00 00 00 
  80042157ec:	48 8b 40 68          	mov    0x68(%rax),%rax
  80042157f0:	48 89 c2             	mov    %rax,%rdx
  80042157f3:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042157fa:	00 00 00 
  80042157fd:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004215801:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215804:	48 98                	cltq   
  8004215806:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421580d:	ff 
  800421580e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215812:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004215819:	00 00 00 
  800421581c:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004215820:	e9 90 01 00 00       	jmpq   80042159b5 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004215825:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215829:	48 be 7d 94 21 04 80 	movabs $0x800421947d,%rsi
  8004215830:	00 00 00 
  8004215833:	48 89 c7             	mov    %rax,%rdi
  8004215836:	48 b8 6f f7 20 04 80 	movabs $0x800420f76f,%rax
  800421583d:	00 00 00 
  8004215840:	ff d0                	callq  *%rax
  8004215842:	85 c0                	test   %eax,%eax
  8004215844:	75 65                	jne    80042158ab <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004215846:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215849:	48 98                	cltq   
  800421584b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215852:	ff 
  8004215853:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215857:	48 89 c2             	mov    %rax,%rdx
  800421585a:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004215861:	00 00 00 
  8004215864:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  8004215868:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  800421586f:	00 00 00 
  8004215872:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004215876:	48 89 c2             	mov    %rax,%rdx
  8004215879:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004215880:	00 00 00 
  8004215883:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004215887:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421588a:	48 98                	cltq   
  800421588c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215893:	ff 
  8004215894:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215898:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  800421589f:	00 00 00 
  80042158a2:	48 89 50 58          	mov    %rdx,0x58(%rax)
  80042158a6:	e9 0a 01 00 00       	jmpq   80042159b5 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_str"))
  80042158ab:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042158af:	48 be 93 94 21 04 80 	movabs $0x8004219493,%rsi
  80042158b6:	00 00 00 
  80042158b9:	48 89 c7             	mov    %rax,%rdi
  80042158bc:	48 b8 6f f7 20 04 80 	movabs $0x800420f76f,%rax
  80042158c3:	00 00 00 
  80042158c6:	ff d0                	callq  *%rax
  80042158c8:	85 c0                	test   %eax,%eax
  80042158ca:	0f 85 e5 00 00 00    	jne    80042159b5 <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042158d0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042158d3:	48 98                	cltq   
  80042158d5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042158dc:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042158dd:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042158e1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042158e4:	48 98                	cltq   
  80042158e6:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042158ed:	ff 
  80042158ee:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042158f2:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  80042158f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042158fd:	48 01 c8             	add    %rcx,%rax
  8004215900:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215907:	48 89 c7             	mov    %rax,%rdi
  800421590a:	48 b8 d5 59 21 04 80 	movabs $0x80042159d5,%rax
  8004215911:	00 00 00 
  8004215914:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004215916:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215919:	48 98                	cltq   
  800421591b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215922:	ff 
  8004215923:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215927:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421592a:	48 98                	cltq   
  800421592c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215933:	ff 
  8004215934:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215938:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  800421593f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004215946:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  800421594c:	48 29 c2             	sub    %rax,%rdx
  800421594f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215953:	48 01 c2             	add    %rax,%rdx
  8004215956:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421595a:	48 01 c2             	add    %rax,%rdx
  800421595d:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004215964:	00 00 00 
  8004215967:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  800421596e:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004215975:	00 00 00 
  8004215978:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800421597f:	48 89 c2             	mov    %rax,%rdx
  8004215982:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  8004215989:	00 00 00 
  800421598c:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004215993:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215996:	48 98                	cltq   
  8004215998:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421599f:	ff 
  80042159a0:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042159a4:	48 b8 e0 c6 22 04 80 	movabs $0x800422c6e0,%rax
  80042159ab:	00 00 00 
  80042159ae:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
            sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

    
	for (i = 0; i < numSectionHeaders; i++)
  80042159b5:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042159b9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042159bc:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  80042159bf:	0f 8c f0 fa ff ff    	jl     80042154b5 <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
    }
	
    return ((uintptr_t)kvbase + kvoffset);
  80042159c5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042159c9:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042159d0:	48 01 d0             	add    %rdx,%rax
}
  80042159d3:	c9                   	leaveq 
  80042159d4:	c3                   	retq   

00000080042159d5 <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  80042159d5:	55                   	push   %rbp
  80042159d6:	48 89 e5             	mov    %rsp,%rbp
  80042159d9:	48 83 ec 30          	sub    $0x30,%rsp
  80042159dd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042159e1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042159e5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042159e9:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  80042159ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042159f1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  80042159f5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042159f9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042159fd:	48 01 d0             	add    %rdx,%rax
  8004215a00:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004215a04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215a08:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215a0d:	48 85 c0             	test   %rax,%rax
  8004215a10:	74 35                	je     8004215a47 <readseg+0x72>
  8004215a12:	48 b9 da 94 21 04 80 	movabs $0x80042194da,%rcx
  8004215a19:	00 00 00 
  8004215a1c:	48 ba b7 94 21 04 80 	movabs $0x80042194b7,%rdx
  8004215a23:	00 00 00 
  8004215a26:	be c1 00 00 00       	mov    $0xc1,%esi
  8004215a2b:	48 bf cc 94 21 04 80 	movabs $0x80042194cc,%rdi
  8004215a32:	00 00 00 
  8004215a35:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215a3a:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004215a41:	00 00 00 
  8004215a44:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004215a47:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004215a4e:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004215a4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215a53:	48 c1 e8 09          	shr    $0x9,%rax
  8004215a57:	48 83 c0 01          	add    $0x1,%rax
  8004215a5b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215a5f:	eb 3c                	jmp    8004215a9d <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  8004215a61:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215a65:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215a69:	48 89 d6             	mov    %rdx,%rsi
  8004215a6c:	48 89 c7             	mov    %rax,%rdi
  8004215a6f:	48 b8 65 5b 21 04 80 	movabs $0x8004215b65,%rax
  8004215a76:	00 00 00 
  8004215a79:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004215a7b:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004215a82:	00 
		*kvoffset += SECTSIZE;
  8004215a83:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215a87:	48 8b 00             	mov    (%rax),%rax
  8004215a8a:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004215a91:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215a95:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004215a98:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215a9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215aa1:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004215aa5:	72 ba                	jb     8004215a61 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004215aa7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215aab:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215ab0:	48 89 c2             	mov    %rax,%rdx
  8004215ab3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215ab7:	48 01 d0             	add    %rdx,%rax
  8004215aba:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004215ac0:	76 2f                	jbe    8004215af1 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004215ac2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215ac6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215aca:	48 89 d6             	mov    %rdx,%rsi
  8004215acd:	48 89 c7             	mov    %rax,%rdi
  8004215ad0:	48 b8 65 5b 21 04 80 	movabs $0x8004215b65,%rax
  8004215ad7:	00 00 00 
  8004215ada:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004215adc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215ae0:	48 8b 00             	mov    (%rax),%rax
  8004215ae3:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004215aea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215aee:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004215af1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215af5:	48 8b 00             	mov    (%rax),%rax
  8004215af8:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215afd:	48 85 c0             	test   %rax,%rax
  8004215b00:	74 35                	je     8004215b37 <readseg+0x162>
  8004215b02:	48 b9 ed 94 21 04 80 	movabs $0x80042194ed,%rcx
  8004215b09:	00 00 00 
  8004215b0c:	48 ba b7 94 21 04 80 	movabs $0x80042194b7,%rdx
  8004215b13:	00 00 00 
  8004215b16:	be d7 00 00 00       	mov    $0xd7,%esi
  8004215b1b:	48 bf cc 94 21 04 80 	movabs $0x80042194cc,%rdi
  8004215b22:	00 00 00 
  8004215b25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215b2a:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004215b31:	00 00 00 
  8004215b34:	41 ff d0             	callq  *%r8
}
  8004215b37:	c9                   	leaveq 
  8004215b38:	c3                   	retq   

0000008004215b39 <waitdisk>:

void
waitdisk(void)
{
  8004215b39:	55                   	push   %rbp
  8004215b3a:	48 89 e5             	mov    %rsp,%rbp
  8004215b3d:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  8004215b41:	90                   	nop
  8004215b42:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004215b49:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215b4c:	89 c2                	mov    %eax,%edx
  8004215b4e:	ec                   	in     (%dx),%al
  8004215b4f:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004215b52:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004215b56:	0f b6 c0             	movzbl %al,%eax
  8004215b59:	25 c0 00 00 00       	and    $0xc0,%eax
  8004215b5e:	83 f8 40             	cmp    $0x40,%eax
  8004215b61:	75 df                	jne    8004215b42 <waitdisk+0x9>
		/* do nothing */;
}
  8004215b63:	c9                   	leaveq 
  8004215b64:	c3                   	retq   

0000008004215b65 <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  8004215b65:	55                   	push   %rbp
  8004215b66:	48 89 e5             	mov    %rsp,%rbp
  8004215b69:	48 83 ec 60          	sub    $0x60,%rsp
  8004215b6d:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004215b71:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  8004215b75:	48 b8 39 5b 21 04 80 	movabs $0x8004215b39,%rax
  8004215b7c:	00 00 00 
  8004215b7f:	ff d0                	callq  *%rax
  8004215b81:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  8004215b88:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215b8c:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004215b90:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215b93:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004215b94:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215b98:	0f b6 c0             	movzbl %al,%eax
  8004215b9b:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004215ba2:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004215ba5:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004215ba9:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215bac:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004215bad:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215bb1:	48 c1 e8 08          	shr    $0x8,%rax
  8004215bb5:	0f b6 c0             	movzbl %al,%eax
  8004215bb8:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  8004215bbf:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004215bc2:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004215bc6:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215bc9:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004215bca:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215bce:	48 c1 e8 10          	shr    $0x10,%rax
  8004215bd2:	0f b6 c0             	movzbl %al,%eax
  8004215bd5:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  8004215bdc:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004215bdf:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004215be3:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004215be6:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004215be7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215beb:	48 c1 e8 18          	shr    $0x18,%rax
  8004215bef:	83 c8 e0             	or     $0xffffffe0,%eax
  8004215bf2:	0f b6 c0             	movzbl %al,%eax
  8004215bf5:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  8004215bfc:	88 45 db             	mov    %al,-0x25(%rbp)
  8004215bff:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004215c03:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215c06:	ee                   	out    %al,(%dx)
  8004215c07:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  8004215c0e:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004215c12:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004215c16:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215c19:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004215c1a:	48 b8 39 5b 21 04 80 	movabs $0x8004215b39,%rax
  8004215c21:	00 00 00 
  8004215c24:	ff d0                	callq  *%rax
  8004215c26:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  8004215c2d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215c31:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004215c35:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  8004215c3c:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215c3f:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004215c43:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004215c46:	48 89 ce             	mov    %rcx,%rsi
  8004215c49:	48 89 f7             	mov    %rsi,%rdi
  8004215c4c:	89 c1                	mov    %eax,%ecx
  8004215c4e:	fc                   	cld    
  8004215c4f:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  8004215c51:	89 c8                	mov    %ecx,%eax
  8004215c53:	48 89 fe             	mov    %rdi,%rsi
  8004215c56:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004215c5a:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004215c5d:	c9                   	leaveq 
  8004215c5e:	c3                   	retq   
  8004215c5f:	90                   	nop

0000008004215c60 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  8004215c60:	fa                   	cli    
	xorw    %ax, %ax
  8004215c61:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  8004215c63:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215c65:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215c67:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  8004215c69:	0f 01 16             	lgdt   (%rsi)
  8004215c6c:	e0 70                	loopne 8004215cde <start64+0x10>
	movl    %cr0, %eax
  8004215c6e:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215c71:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  8004215c75:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004215c78:	ea                   	(bad)  
  8004215c79:	1d 70 08 00 66       	sbb    $0x66000870,%eax

0000008004215c7d <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004215c7d:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004215c81:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215c83:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215c85:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004215c87:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215c8b:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215c8d:	8e e8                	mov    %eax,%gs

	movl $CR4_PAE,%eax
  8004215c8f:	b8 20 00 00 00       	mov    $0x20,%eax
	movl %eax,%cr4
  8004215c94:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  8004215c97:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421cd5e <bootstack+0xd5e>
	movl    %cr0, %eax
  8004215c9e:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215ca1:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  8004215ca4:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  8004215ca7:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004215cac:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004215caf:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  8004215cb4:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  8004215cb6:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004215cba:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004215cbc:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004215cbf:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  8004215cc4:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  8004215cc7:	ea                   	(bad)  
  8004215cc8:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004215cc9:	70 00                	jo     8004215ccb <start32+0x4e>
  8004215ccb:	00 08                	add    %cl,(%rax)
	...

0000008004215cce <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004215cce:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004215cd2:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215cd4:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215cd6:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004215cd8:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215cdc:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215cde:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004215ce0:	48 a1 98 17 4a 04 80 	movabs 0x80044a1798,%rax
  8004215ce7:	00 00 00 
	movq    %rax,%rsp
  8004215cea:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004215ced:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  8004215cf4:	48 b8 60 04 20 04 80 	movabs $0x8004200460,%rax
  8004215cfb:	00 00 00 
	call    *%rax
  8004215cfe:	ff d0                	callq  *%rax

0000008004215d00 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004215d00:	eb fe                	jmp    8004215d00 <spin>
  8004215d02:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004215d08 <gdt>:
	...
  8004215d10:	ff                   	(bad)  
  8004215d11:	ff 00                	incl   (%rax)
  8004215d13:	00 00                	add    %al,(%rax)
  8004215d15:	9a                   	(bad)  
  8004215d16:	af                   	scas   %es:(%rdi),%eax
  8004215d17:	00 ff                	add    %bh,%bh
  8004215d19:	ff 00                	incl   (%rax)
  8004215d1b:	00 00                	add    %al,(%rax)
  8004215d1d:	92                   	xchg   %eax,%edx
  8004215d1e:	af                   	scas   %es:(%rdi),%eax
	...

0000008004215d20 <gdtdesc>:
  8004215d20:	17                   	(bad)  
  8004215d21:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  8004215d27:	90                   	nop

0000008004215d28 <gdt32>:
	...
  8004215d30:	ff                   	(bad)  
  8004215d31:	ff 00                	incl   (%rax)
  8004215d33:	00 00                	add    %al,(%rax)
  8004215d35:	9a                   	(bad)  
  8004215d36:	cf                   	iret   
  8004215d37:	00 ff                	add    %bh,%bh
  8004215d39:	ff 00                	incl   (%rax)
  8004215d3b:	00 00                	add    %al,(%rax)
  8004215d3d:	92                   	xchg   %eax,%edx
  8004215d3e:	cf                   	iret   
	...

0000008004215d40 <gdt32desc>:
  8004215d40:	17                   	(bad)  
  8004215d41:	00 c8                	add    %cl,%al
  8004215d43:	70 00                	jo     8004215d45 <gdt32desc+0x5>
	...

0000008004215d46 <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  8004215d46:	90                   	nop

0000008004215d47 <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  8004215d47:	55                   	push   %rbp
  8004215d48:	48 89 e5             	mov    %rsp,%rbp
  8004215d4b:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004215d4f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215d53:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  8004215d56:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  8004215d5d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004215d64:	eb 1a                	jmp    8004215d80 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  8004215d66:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215d69:	48 63 d0             	movslq %eax,%rdx
  8004215d6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215d70:	48 01 d0             	add    %rdx,%rax
  8004215d73:	0f b6 00             	movzbl (%rax),%eax
  8004215d76:	0f b6 c0             	movzbl %al,%eax
  8004215d79:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  8004215d7c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004215d80:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215d83:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004215d86:	7c de                	jl     8004215d66 <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  8004215d88:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8004215d8b:	c9                   	leaveq 
  8004215d8c:	c3                   	retq   

0000008004215d8d <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  8004215d8d:	55                   	push   %rbp
  8004215d8e:	48 89 e5             	mov    %rsp,%rbp
  8004215d91:	48 83 ec 40          	sub    $0x40,%rsp
  8004215d95:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004215d99:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004215d9c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215da0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004215da4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215da8:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215dac:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215daf:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215db2:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004215db9:	00 00 00 
  8004215dbc:	48 8b 00             	mov    (%rax),%rax
  8004215dbf:	48 39 c2             	cmp    %rax,%rdx
  8004215dc2:	72 32                	jb     8004215df6 <mpsearch1+0x69>
  8004215dc4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215dc8:	48 89 c1             	mov    %rax,%rcx
  8004215dcb:	48 ba 08 95 21 04 80 	movabs $0x8004219508,%rdx
  8004215dd2:	00 00 00 
  8004215dd5:	be 57 00 00 00       	mov    $0x57,%esi
  8004215dda:	48 bf 2b 95 21 04 80 	movabs $0x800421952b,%rdi
  8004215de1:	00 00 00 
  8004215de4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215de9:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004215df0:	00 00 00 
  8004215df3:	41 ff d0             	callq  *%r8
  8004215df6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215dfd:	00 00 00 
  8004215e00:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215e04:	48 01 d0             	add    %rdx,%rax
  8004215e07:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215e0b:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004215e0e:	48 63 d0             	movslq %eax,%rdx
  8004215e11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215e15:	48 01 d0             	add    %rdx,%rax
  8004215e18:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004215e1c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215e20:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215e24:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004215e27:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215e2a:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004215e31:	00 00 00 
  8004215e34:	48 8b 00             	mov    (%rax),%rax
  8004215e37:	48 39 c2             	cmp    %rax,%rdx
  8004215e3a:	72 32                	jb     8004215e6e <mpsearch1+0xe1>
  8004215e3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215e40:	48 89 c1             	mov    %rax,%rcx
  8004215e43:	48 ba 08 95 21 04 80 	movabs $0x8004219508,%rdx
  8004215e4a:	00 00 00 
  8004215e4d:	be 57 00 00 00       	mov    $0x57,%esi
  8004215e52:	48 bf 2b 95 21 04 80 	movabs $0x800421952b,%rdi
  8004215e59:	00 00 00 
  8004215e5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215e61:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004215e68:	00 00 00 
  8004215e6b:	41 ff d0             	callq  *%r8
  8004215e6e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215e75:	00 00 00 
  8004215e78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215e7c:	48 01 d0             	add    %rdx,%rax
  8004215e7f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  8004215e83:	eb 4d                	jmp    8004215ed2 <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004215e85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215e89:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215e8e:	48 be 3b 95 21 04 80 	movabs $0x800421953b,%rsi
  8004215e95:	00 00 00 
  8004215e98:	48 89 c7             	mov    %rax,%rdi
  8004215e9b:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  8004215ea2:	00 00 00 
  8004215ea5:	ff d0                	callq  *%rax
  8004215ea7:	85 c0                	test   %eax,%eax
  8004215ea9:	75 22                	jne    8004215ecd <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  8004215eab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215eaf:	be 10 00 00 00       	mov    $0x10,%esi
  8004215eb4:	48 89 c7             	mov    %rax,%rdi
  8004215eb7:	48 b8 47 5d 21 04 80 	movabs $0x8004215d47,%rax
  8004215ebe:	00 00 00 
  8004215ec1:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004215ec3:	84 c0                	test   %al,%al
  8004215ec5:	75 06                	jne    8004215ecd <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  8004215ec7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215ecb:	eb 14                	jmp    8004215ee1 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  8004215ecd:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  8004215ed2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215ed6:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004215eda:	72 a9                	jb     8004215e85 <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  8004215edc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215ee1:	c9                   	leaveq 
  8004215ee2:	c3                   	retq   

0000008004215ee3 <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  8004215ee3:	55                   	push   %rbp
  8004215ee4:	48 89 e5             	mov    %rsp,%rbp
  8004215ee7:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004215eeb:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  8004215ef2:	00 
  8004215ef3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215ef7:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215efb:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004215efe:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215f01:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004215f08:	00 00 00 
  8004215f0b:	48 8b 00             	mov    (%rax),%rax
  8004215f0e:	48 39 c2             	cmp    %rax,%rdx
  8004215f11:	72 32                	jb     8004215f45 <mpsearch+0x62>
  8004215f13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215f17:	48 89 c1             	mov    %rax,%rcx
  8004215f1a:	48 ba 08 95 21 04 80 	movabs $0x8004219508,%rdx
  8004215f21:	00 00 00 
  8004215f24:	be 6f 00 00 00       	mov    $0x6f,%esi
  8004215f29:	48 bf 2b 95 21 04 80 	movabs $0x800421952b,%rdi
  8004215f30:	00 00 00 
  8004215f33:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215f38:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  8004215f3f:	00 00 00 
  8004215f42:	41 ff d0             	callq  *%r8
  8004215f45:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215f4c:	00 00 00 
  8004215f4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215f53:	48 01 d0             	add    %rdx,%rax
  8004215f56:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  8004215f5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215f5e:	48 83 c0 0e          	add    $0xe,%rax
  8004215f62:	0f b7 00             	movzwl (%rax),%eax
  8004215f65:	0f b7 c0             	movzwl %ax,%eax
  8004215f68:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004215f6b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004215f6f:	74 2c                	je     8004215f9d <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  8004215f71:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  8004215f75:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004215f78:	be 00 04 00 00       	mov    $0x400,%esi
  8004215f7d:	48 89 c7             	mov    %rax,%rdi
  8004215f80:	48 b8 8d 5d 21 04 80 	movabs $0x8004215d8d,%rax
  8004215f87:	00 00 00 
  8004215f8a:	ff d0                	callq  *%rax
  8004215f8c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004215f90:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004215f95:	74 49                	je     8004215fe0 <mpsearch+0xfd>
			return mp;
  8004215f97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215f9b:	eb 59                	jmp    8004215ff6 <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  8004215f9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215fa1:	48 83 c0 13          	add    $0x13,%rax
  8004215fa5:	0f b7 00             	movzwl (%rax),%eax
  8004215fa8:	0f b7 c0             	movzwl %ax,%eax
  8004215fab:	c1 e0 0a             	shl    $0xa,%eax
  8004215fae:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004215fb1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004215fb4:	2d 00 04 00 00       	sub    $0x400,%eax
  8004215fb9:	89 c0                	mov    %eax,%eax
  8004215fbb:	be 00 04 00 00       	mov    $0x400,%esi
  8004215fc0:	48 89 c7             	mov    %rax,%rdi
  8004215fc3:	48 b8 8d 5d 21 04 80 	movabs $0x8004215d8d,%rax
  8004215fca:	00 00 00 
  8004215fcd:	ff d0                	callq  *%rax
  8004215fcf:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004215fd3:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004215fd8:	74 06                	je     8004215fe0 <mpsearch+0xfd>
			return mp;
  8004215fda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215fde:	eb 16                	jmp    8004215ff6 <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004215fe0:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215fe5:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004215fea:	48 b8 8d 5d 21 04 80 	movabs $0x8004215d8d,%rax
  8004215ff1:	00 00 00 
  8004215ff4:	ff d0                	callq  *%rax
}
  8004215ff6:	c9                   	leaveq 
  8004215ff7:	c3                   	retq   

0000008004215ff8 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004215ff8:	55                   	push   %rbp
  8004215ff9:	48 89 e5             	mov    %rsp,%rbp
  8004215ffc:	48 83 ec 30          	sub    $0x30,%rsp
  8004216000:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  8004216004:	48 b8 e3 5e 21 04 80 	movabs $0x8004215ee3,%rax
  800421600b:	00 00 00 
  800421600e:	ff d0                	callq  *%rax
  8004216010:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004216014:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004216019:	75 0a                	jne    8004216025 <mpconfig+0x2d>
		return NULL;
  800421601b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216020:	e9 f6 01 00 00       	jmpq   800421621b <mpconfig+0x223>
	if (mp->physaddr == 0 || mp->type != 0) {
  8004216025:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216029:	8b 40 04             	mov    0x4(%rax),%eax
  800421602c:	85 c0                	test   %eax,%eax
  800421602e:	74 0c                	je     800421603c <mpconfig+0x44>
  8004216030:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216034:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004216038:	84 c0                	test   %al,%al
  800421603a:	74 25                	je     8004216061 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  800421603c:	48 bf 40 95 21 04 80 	movabs $0x8004219540,%rdi
  8004216043:	00 00 00 
  8004216046:	b8 00 00 00 00       	mov    $0x0,%eax
  800421604b:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004216052:	00 00 00 
  8004216055:	ff d2                	callq  *%rdx
		return NULL;
  8004216057:	b8 00 00 00 00       	mov    $0x0,%eax
  800421605c:	e9 ba 01 00 00       	jmpq   800421621b <mpconfig+0x223>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  8004216061:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216065:	8b 40 04             	mov    0x4(%rax),%eax
  8004216068:	89 c0                	mov    %eax,%eax
  800421606a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421606e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216072:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216076:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004216079:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421607c:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004216083:	00 00 00 
  8004216086:	48 8b 00             	mov    (%rax),%rax
  8004216089:	48 39 c2             	cmp    %rax,%rdx
  800421608c:	72 32                	jb     80042160c0 <mpconfig+0xc8>
  800421608e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216092:	48 89 c1             	mov    %rax,%rcx
  8004216095:	48 ba 08 95 21 04 80 	movabs $0x8004219508,%rdx
  800421609c:	00 00 00 
  800421609f:	be 90 00 00 00       	mov    $0x90,%esi
  80042160a4:	48 bf 2b 95 21 04 80 	movabs $0x800421952b,%rdi
  80042160ab:	00 00 00 
  80042160ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80042160b3:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  80042160ba:	00 00 00 
  80042160bd:	41 ff d0             	callq  *%r8
  80042160c0:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042160c7:	00 00 00 
  80042160ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042160ce:	48 01 d0             	add    %rdx,%rax
  80042160d1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  80042160d5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042160d9:	ba 04 00 00 00       	mov    $0x4,%edx
  80042160de:	48 be 6d 95 21 04 80 	movabs $0x800421956d,%rsi
  80042160e5:	00 00 00 
  80042160e8:	48 89 c7             	mov    %rax,%rdi
  80042160eb:	48 b8 7c fa 20 04 80 	movabs $0x800420fa7c,%rax
  80042160f2:	00 00 00 
  80042160f5:	ff d0                	callq  *%rax
  80042160f7:	85 c0                	test   %eax,%eax
  80042160f9:	74 25                	je     8004216120 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  80042160fb:	48 bf 78 95 21 04 80 	movabs $0x8004219578,%rdi
  8004216102:	00 00 00 
  8004216105:	b8 00 00 00 00       	mov    $0x0,%eax
  800421610a:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004216111:	00 00 00 
  8004216114:	ff d2                	callq  *%rdx
		return NULL;
  8004216116:	b8 00 00 00 00       	mov    $0x0,%eax
  800421611b:	e9 fb 00 00 00       	jmpq   800421621b <mpconfig+0x223>
	}
	if (sum(conf, conf->length) != 0) {
  8004216120:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216124:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004216128:	0f b7 d0             	movzwl %ax,%edx
  800421612b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421612f:	89 d6                	mov    %edx,%esi
  8004216131:	48 89 c7             	mov    %rax,%rdi
  8004216134:	48 b8 47 5d 21 04 80 	movabs $0x8004215d47,%rax
  800421613b:	00 00 00 
  800421613e:	ff d0                	callq  *%rax
  8004216140:	84 c0                	test   %al,%al
  8004216142:	74 25                	je     8004216169 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  8004216144:	48 bf b0 95 21 04 80 	movabs $0x80042195b0,%rdi
  800421614b:	00 00 00 
  800421614e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216153:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800421615a:	00 00 00 
  800421615d:	ff d2                	callq  *%rdx
		return NULL;
  800421615f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216164:	e9 b2 00 00 00       	jmpq   800421621b <mpconfig+0x223>
	}
	if (conf->version != 1 && conf->version != 4) {
  8004216169:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421616d:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216171:	3c 01                	cmp    $0x1,%al
  8004216173:	74 3b                	je     80042161b0 <mpconfig+0x1b8>
  8004216175:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216179:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  800421617d:	3c 04                	cmp    $0x4,%al
  800421617f:	74 2f                	je     80042161b0 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  8004216181:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216185:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216189:	0f b6 c0             	movzbl %al,%eax
  800421618c:	89 c6                	mov    %eax,%esi
  800421618e:	48 bf d8 95 21 04 80 	movabs $0x80042195d8,%rdi
  8004216195:	00 00 00 
  8004216198:	b8 00 00 00 00       	mov    $0x0,%eax
  800421619d:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042161a4:	00 00 00 
  80042161a7:	ff d2                	callq  *%rdx
		return NULL;
  80042161a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042161ae:	eb 6b                	jmp    800421621b <mpconfig+0x223>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  80042161b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042161b4:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80042161b8:	0f b7 c0             	movzwl %ax,%eax
  80042161bb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042161bf:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  80042161c3:	0f b7 ca             	movzwl %dx,%ecx
  80042161c6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042161ca:	48 01 ca             	add    %rcx,%rdx
  80042161cd:	89 c6                	mov    %eax,%esi
  80042161cf:	48 89 d7             	mov    %rdx,%rdi
  80042161d2:	48 b8 47 5d 21 04 80 	movabs $0x8004215d47,%rax
  80042161d9:	00 00 00 
  80042161dc:	ff d0                	callq  *%rax
  80042161de:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042161e2:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  80042161e6:	38 d0                	cmp    %dl,%al
  80042161e8:	74 22                	je     800421620c <mpconfig+0x214>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  80042161ea:	48 bf f8 95 21 04 80 	movabs $0x80042195f8,%rdi
  80042161f1:	00 00 00 
  80042161f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042161f9:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004216200:	00 00 00 
  8004216203:	ff d2                	callq  *%rdx
		return NULL;
  8004216205:	b8 00 00 00 00       	mov    $0x0,%eax
  800421620a:	eb 0f                	jmp    800421621b <mpconfig+0x223>
	}
	*pmp = mp;
  800421620c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216210:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216214:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  8004216217:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  800421621b:	c9                   	leaveq 
  800421621c:	c3                   	retq   

000000800421621d <mp_init>:

void
mp_init(void)
{
  800421621d:	55                   	push   %rbp
  800421621e:	48 89 e5             	mov    %rsp,%rbp
  8004216221:	53                   	push   %rbx
  8004216222:	48 83 ec 48          	sub    $0x48,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  8004216226:	48 b8 e0 33 4a 04 80 	movabs $0x80044a33e0,%rax
  800421622d:	00 00 00 
  8004216230:	48 bb 20 30 4a 04 80 	movabs $0x80044a3020,%rbx
  8004216237:	00 00 00 
  800421623a:	48 89 18             	mov    %rbx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  800421623d:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8004216241:	48 89 c7             	mov    %rax,%rdi
  8004216244:	48 b8 f8 5f 21 04 80 	movabs $0x8004215ff8,%rax
  800421624b:	00 00 00 
  800421624e:	ff d0                	callq  *%rax
  8004216250:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004216254:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004216259:	75 05                	jne    8004216260 <mp_init+0x43>
		return;
  800421625b:	e9 b5 02 00 00       	jmpq   8004216515 <mp_init+0x2f8>
	ismp = 1;
  8004216260:	48 b8 00 30 4a 04 80 	movabs $0x80044a3000,%rax
  8004216267:	00 00 00 
  800421626a:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  8004216270:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216274:	8b 40 24             	mov    0x24(%rax),%eax
  8004216277:	89 c2                	mov    %eax,%edx
  8004216279:	48 b8 00 40 52 04 80 	movabs $0x8004524000,%rax
  8004216280:	00 00 00 
  8004216283:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004216286:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421628a:	48 83 c0 2c          	add    $0x2c,%rax
  800421628e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004216292:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  8004216299:	e9 5c 01 00 00       	jmpq   80042163fa <mp_init+0x1dd>
		switch (*p) {
  800421629e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042162a2:	0f b6 00             	movzbl (%rax),%eax
  80042162a5:	0f b6 c0             	movzbl %al,%eax
  80042162a8:	85 c0                	test   %eax,%eax
  80042162aa:	74 16                	je     80042162c2 <mp_init+0xa5>
  80042162ac:	85 c0                	test   %eax,%eax
  80042162ae:	0f 88 fd 00 00 00    	js     80042163b1 <mp_init+0x194>
  80042162b4:	83 f8 04             	cmp    $0x4,%eax
  80042162b7:	0f 8f f4 00 00 00    	jg     80042163b1 <mp_init+0x194>
  80042162bd:	e9 e8 00 00 00       	jmpq   80042163aa <mp_init+0x18d>
		case MPPROC:
			proc = (struct mpproc *)p;
  80042162c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042162c6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT)
  80042162ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042162ce:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042162d2:	0f b6 c0             	movzbl %al,%eax
  80042162d5:	83 e0 02             	and    $0x2,%eax
  80042162d8:	85 c0                	test   %eax,%eax
  80042162da:	74 36                	je     8004216312 <mp_init+0xf5>
				bootcpu = &cpus[ncpu];
  80042162dc:	48 b8 e8 33 4a 04 80 	movabs $0x80044a33e8,%rax
  80042162e3:	00 00 00 
  80042162e6:	8b 00                	mov    (%rax),%eax
  80042162e8:	48 98                	cltq   
  80042162ea:	48 c1 e0 03          	shl    $0x3,%rax
  80042162ee:	48 89 c2             	mov    %rax,%rdx
  80042162f1:	48 c1 e2 04          	shl    $0x4,%rdx
  80042162f5:	48 29 c2             	sub    %rax,%rdx
  80042162f8:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  80042162ff:	00 00 00 
  8004216302:	48 01 c2             	add    %rax,%rdx
  8004216305:	48 b8 e0 33 4a 04 80 	movabs $0x80044a33e0,%rax
  800421630c:	00 00 00 
  800421630f:	48 89 10             	mov    %rdx,(%rax)
			if (ncpu < NCPU) {
  8004216312:	48 b8 e8 33 4a 04 80 	movabs $0x80044a33e8,%rax
  8004216319:	00 00 00 
  800421631c:	8b 00                	mov    (%rax),%eax
  800421631e:	83 f8 07             	cmp    $0x7,%eax
  8004216321:	7f 58                	jg     800421637b <mp_init+0x15e>
				cpus[ncpu].cpu_id = ncpu;
  8004216323:	48 b8 e8 33 4a 04 80 	movabs $0x80044a33e8,%rax
  800421632a:	00 00 00 
  800421632d:	8b 10                	mov    (%rax),%edx
  800421632f:	48 b8 e8 33 4a 04 80 	movabs $0x80044a33e8,%rax
  8004216336:	00 00 00 
  8004216339:	8b 00                	mov    (%rax),%eax
  800421633b:	89 c1                	mov    %eax,%ecx
  800421633d:	48 be 20 30 4a 04 80 	movabs $0x80044a3020,%rsi
  8004216344:	00 00 00 
  8004216347:	48 63 c2             	movslq %edx,%rax
  800421634a:	48 c1 e0 03          	shl    $0x3,%rax
  800421634e:	48 89 c2             	mov    %rax,%rdx
  8004216351:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216355:	48 29 c2             	sub    %rax,%rdx
  8004216358:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  800421635c:	88 08                	mov    %cl,(%rax)
				ncpu++;
  800421635e:	48 b8 e8 33 4a 04 80 	movabs $0x80044a33e8,%rax
  8004216365:	00 00 00 
  8004216368:	8b 00                	mov    (%rax),%eax
  800421636a:	8d 50 01             	lea    0x1(%rax),%edx
  800421636d:	48 b8 e8 33 4a 04 80 	movabs $0x80044a33e8,%rax
  8004216374:	00 00 00 
  8004216377:	89 10                	mov    %edx,(%rax)
  8004216379:	eb 28                	jmp    80042163a3 <mp_init+0x186>
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  800421637b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421637f:	0f b6 40 01          	movzbl 0x1(%rax),%eax
				bootcpu = &cpus[ncpu];
			if (ncpu < NCPU) {
				cpus[ncpu].cpu_id = ncpu;
				ncpu++;
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  8004216383:	0f b6 c0             	movzbl %al,%eax
  8004216386:	89 c6                	mov    %eax,%esi
  8004216388:	48 bf 28 96 21 04 80 	movabs $0x8004219628,%rdi
  800421638f:	00 00 00 
  8004216392:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216397:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  800421639e:	00 00 00 
  80042163a1:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  80042163a3:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  80042163a8:	eb 4c                	jmp    80042163f6 <mp_init+0x1d9>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
			p += 8;
  80042163aa:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
			continue;
  80042163af:	eb 45                	jmp    80042163f6 <mp_init+0x1d9>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  80042163b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042163b5:	0f b6 00             	movzbl (%rax),%eax
  80042163b8:	0f b6 c0             	movzbl %al,%eax
  80042163bb:	89 c6                	mov    %eax,%esi
  80042163bd:	48 bf 50 96 21 04 80 	movabs $0x8004219650,%rdi
  80042163c4:	00 00 00 
  80042163c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042163cc:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042163d3:	00 00 00 
  80042163d6:	ff d2                	callq  *%rdx
			ismp = 0;
  80042163d8:	48 b8 00 30 4a 04 80 	movabs $0x80044a3000,%rax
  80042163df:	00 00 00 
  80042163e2:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  80042163e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042163ec:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  80042163f0:	0f b7 c0             	movzwl %ax,%eax
  80042163f3:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  80042163f6:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  80042163fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042163fe:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004216402:	0f b7 c0             	movzwl %ax,%eax
  8004216405:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004216408:	0f 87 90 fe ff ff    	ja     800421629e <mp_init+0x81>
			ismp = 0;
			i = conf->entry;
		}
	}

	bootcpu->cpu_status = CPU_STARTED;
  800421640e:	48 b8 e0 33 4a 04 80 	movabs $0x80044a33e0,%rax
  8004216415:	00 00 00 
  8004216418:	48 8b 00             	mov    (%rax),%rax
  800421641b:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  8004216422:	48 b8 00 30 4a 04 80 	movabs $0x80044a3000,%rax
  8004216429:	00 00 00 
  800421642c:	8b 00                	mov    (%rax),%eax
  800421642e:	85 c0                	test   %eax,%eax
  8004216430:	75 41                	jne    8004216473 <mp_init+0x256>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  8004216432:	48 b8 e8 33 4a 04 80 	movabs $0x80044a33e8,%rax
  8004216439:	00 00 00 
  800421643c:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  8004216442:	48 b8 00 40 52 04 80 	movabs $0x8004524000,%rax
  8004216449:	00 00 00 
  800421644c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  8004216453:	48 bf 70 96 21 04 80 	movabs $0x8004219670,%rdi
  800421645a:	00 00 00 
  800421645d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216462:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004216469:	00 00 00 
  800421646c:	ff d2                	callq  *%rdx
		return;
  800421646e:	e9 a2 00 00 00       	jmpq   8004216515 <mp_init+0x2f8>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  8004216473:	48 b8 e8 33 4a 04 80 	movabs $0x80044a33e8,%rax
  800421647a:	00 00 00 
  800421647d:	8b 10                	mov    (%rax),%edx
  800421647f:	48 b8 e0 33 4a 04 80 	movabs $0x80044a33e0,%rax
  8004216486:	00 00 00 
  8004216489:	48 8b 00             	mov    (%rax),%rax
  800421648c:	0f b6 00             	movzbl (%rax),%eax
  800421648f:	0f b6 c0             	movzbl %al,%eax
  8004216492:	89 c6                	mov    %eax,%esi
  8004216494:	48 bf 9c 96 21 04 80 	movabs $0x800421969c,%rdi
  800421649b:	00 00 00 
  800421649e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042164a3:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  80042164aa:	00 00 00 
  80042164ad:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  80042164af:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042164b3:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  80042164b7:	84 c0                	test   %al,%al
  80042164b9:	74 5a                	je     8004216515 <mp_init+0x2f8>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  80042164bb:	48 bf c0 96 21 04 80 	movabs $0x80042196c0,%rdi
  80042164c2:	00 00 00 
  80042164c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042164ca:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  80042164d1:	00 00 00 
  80042164d4:	ff d2                	callq  *%rdx
  80042164d6:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  80042164dd:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042164e1:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042164e5:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042164e8:	ee                   	out    %al,(%dx)
  80042164e9:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042164f0:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042164f3:	89 c2                	mov    %eax,%edx
  80042164f5:	ec                   	in     (%dx),%al
  80042164f6:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  80042164f9:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  80042164fd:	83 c8 01             	or     $0x1,%eax
  8004216500:	0f b6 c0             	movzbl %al,%eax
  8004216503:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  800421650a:	88 45 bb             	mov    %al,-0x45(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800421650d:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004216511:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004216514:	ee                   	out    %al,(%dx)
	}
}
  8004216515:	48 83 c4 48          	add    $0x48,%rsp
  8004216519:	5b                   	pop    %rbx
  800421651a:	5d                   	pop    %rbp
  800421651b:	c3                   	retq   

000000800421651c <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  800421651c:	55                   	push   %rbp
  800421651d:	48 89 e5             	mov    %rsp,%rbp
  8004216520:	48 83 ec 08          	sub    $0x8,%rsp
  8004216524:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004216527:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  800421652a:	48 b8 08 40 52 04 80 	movabs $0x8004524008,%rax
  8004216531:	00 00 00 
  8004216534:	48 8b 00             	mov    (%rax),%rax
  8004216537:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421653a:	48 63 d2             	movslq %edx,%rdx
  800421653d:	48 c1 e2 02          	shl    $0x2,%rdx
  8004216541:	48 01 c2             	add    %rax,%rdx
  8004216544:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004216547:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  8004216549:	48 b8 08 40 52 04 80 	movabs $0x8004524008,%rax
  8004216550:	00 00 00 
  8004216553:	48 8b 00             	mov    (%rax),%rax
  8004216556:	48 83 c0 20          	add    $0x20,%rax
  800421655a:	8b 00                	mov    (%rax),%eax
}
  800421655c:	c9                   	leaveq 
  800421655d:	c3                   	retq   

000000800421655e <lapic_init>:

void
lapic_init(void)
{
  800421655e:	55                   	push   %rbp
  800421655f:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  8004216562:	48 b8 00 40 52 04 80 	movabs $0x8004524000,%rax
  8004216569:	00 00 00 
  800421656c:	48 8b 00             	mov    (%rax),%rax
  800421656f:	48 85 c0             	test   %rax,%rax
  8004216572:	75 05                	jne    8004216579 <lapic_init+0x1b>
		return;
  8004216574:	e9 da 01 00 00       	jmpq   8004216753 <lapic_init+0x1f5>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  8004216579:	48 b8 00 40 52 04 80 	movabs $0x8004524000,%rax
  8004216580:	00 00 00 
  8004216583:	48 8b 00             	mov    (%rax),%rax
  8004216586:	be 00 10 00 00       	mov    $0x1000,%esi
  800421658b:	48 89 c7             	mov    %rax,%rdi
  800421658e:	48 b8 1b 3b 20 04 80 	movabs $0x8004203b1b,%rax
  8004216595:	00 00 00 
  8004216598:	ff d0                	callq  *%rax
  800421659a:	48 ba 08 40 52 04 80 	movabs $0x8004524008,%rdx
  80042165a1:	00 00 00 
  80042165a4:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  80042165a7:	be 27 01 00 00       	mov    $0x127,%esi
  80042165ac:	bf 3c 00 00 00       	mov    $0x3c,%edi
  80042165b1:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  80042165b8:	00 00 00 
  80042165bb:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  80042165bd:	be 0b 00 00 00       	mov    $0xb,%esi
  80042165c2:	bf f8 00 00 00       	mov    $0xf8,%edi
  80042165c7:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  80042165ce:	00 00 00 
  80042165d1:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  80042165d3:	be 20 00 02 00       	mov    $0x20020,%esi
  80042165d8:	bf c8 00 00 00       	mov    $0xc8,%edi
  80042165dd:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  80042165e4:	00 00 00 
  80042165e7:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  80042165e9:	be 80 96 98 00       	mov    $0x989680,%esi
  80042165ee:	bf e0 00 00 00       	mov    $0xe0,%edi
  80042165f3:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  80042165fa:	00 00 00 
  80042165fd:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  80042165ff:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004216606:	00 00 00 
  8004216609:	ff d0                	callq  *%rax
  800421660b:	48 98                	cltq   
  800421660d:	48 c1 e0 03          	shl    $0x3,%rax
  8004216611:	48 89 c2             	mov    %rax,%rdx
  8004216614:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216618:	48 29 c2             	sub    %rax,%rdx
  800421661b:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  8004216622:	00 00 00 
  8004216625:	48 01 c2             	add    %rax,%rdx
  8004216628:	48 b8 e0 33 4a 04 80 	movabs $0x80044a33e0,%rax
  800421662f:	00 00 00 
  8004216632:	48 8b 00             	mov    (%rax),%rax
  8004216635:	48 39 c2             	cmp    %rax,%rdx
  8004216638:	74 16                	je     8004216650 <lapic_init+0xf2>
		lapicw(LINT0, MASKED);
  800421663a:	be 00 00 01 00       	mov    $0x10000,%esi
  800421663f:	bf d4 00 00 00       	mov    $0xd4,%edi
  8004216644:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  800421664b:	00 00 00 
  800421664e:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  8004216650:	be 00 00 01 00       	mov    $0x10000,%esi
  8004216655:	bf d8 00 00 00       	mov    $0xd8,%edi
  800421665a:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  8004216661:	00 00 00 
  8004216664:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  8004216666:	48 b8 08 40 52 04 80 	movabs $0x8004524008,%rax
  800421666d:	00 00 00 
  8004216670:	48 8b 00             	mov    (%rax),%rax
  8004216673:	48 83 c0 30          	add    $0x30,%rax
  8004216677:	8b 00                	mov    (%rax),%eax
  8004216679:	c1 e8 10             	shr    $0x10,%eax
  800421667c:	0f b6 c0             	movzbl %al,%eax
  800421667f:	83 f8 03             	cmp    $0x3,%eax
  8004216682:	76 16                	jbe    800421669a <lapic_init+0x13c>
		lapicw(PCINT, MASKED);
  8004216684:	be 00 00 01 00       	mov    $0x10000,%esi
  8004216689:	bf d0 00 00 00       	mov    $0xd0,%edi
  800421668e:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  8004216695:	00 00 00 
  8004216698:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  800421669a:	be 33 00 00 00       	mov    $0x33,%esi
  800421669f:	bf dc 00 00 00       	mov    $0xdc,%edi
  80042166a4:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  80042166ab:	00 00 00 
  80042166ae:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  80042166b0:	be 00 00 00 00       	mov    $0x0,%esi
  80042166b5:	bf a0 00 00 00       	mov    $0xa0,%edi
  80042166ba:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  80042166c1:	00 00 00 
  80042166c4:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  80042166c6:	be 00 00 00 00       	mov    $0x0,%esi
  80042166cb:	bf a0 00 00 00       	mov    $0xa0,%edi
  80042166d0:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  80042166d7:	00 00 00 
  80042166da:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  80042166dc:	be 00 00 00 00       	mov    $0x0,%esi
  80042166e1:	bf 2c 00 00 00       	mov    $0x2c,%edi
  80042166e6:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  80042166ed:	00 00 00 
  80042166f0:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  80042166f2:	be 00 00 00 00       	mov    $0x0,%esi
  80042166f7:	bf c4 00 00 00       	mov    $0xc4,%edi
  80042166fc:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  8004216703:	00 00 00 
  8004216706:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004216708:	be 00 85 08 00       	mov    $0x88500,%esi
  800421670d:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216712:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  8004216719:	00 00 00 
  800421671c:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  800421671e:	90                   	nop
  800421671f:	48 b8 08 40 52 04 80 	movabs $0x8004524008,%rax
  8004216726:	00 00 00 
  8004216729:	48 8b 00             	mov    (%rax),%rax
  800421672c:	48 05 00 03 00 00    	add    $0x300,%rax
  8004216732:	8b 00                	mov    (%rax),%eax
  8004216734:	25 00 10 00 00       	and    $0x1000,%eax
  8004216739:	85 c0                	test   %eax,%eax
  800421673b:	75 e2                	jne    800421671f <lapic_init+0x1c1>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  800421673d:	be 00 00 00 00       	mov    $0x0,%esi
  8004216742:	bf 20 00 00 00       	mov    $0x20,%edi
  8004216747:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  800421674e:	00 00 00 
  8004216751:	ff d0                	callq  *%rax
}
  8004216753:	5d                   	pop    %rbp
  8004216754:	c3                   	retq   

0000008004216755 <cpunum>:

int
cpunum(void)
{
  8004216755:	55                   	push   %rbp
  8004216756:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004216759:	48 b8 08 40 52 04 80 	movabs $0x8004524008,%rax
  8004216760:	00 00 00 
  8004216763:	48 8b 00             	mov    (%rax),%rax
  8004216766:	48 85 c0             	test   %rax,%rax
  8004216769:	74 18                	je     8004216783 <cpunum+0x2e>
		return lapic[ID] >> 24;
  800421676b:	48 b8 08 40 52 04 80 	movabs $0x8004524008,%rax
  8004216772:	00 00 00 
  8004216775:	48 8b 00             	mov    (%rax),%rax
  8004216778:	48 83 c0 20          	add    $0x20,%rax
  800421677c:	8b 00                	mov    (%rax),%eax
  800421677e:	c1 e8 18             	shr    $0x18,%eax
  8004216781:	eb 05                	jmp    8004216788 <cpunum+0x33>
	return 0;
  8004216783:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216788:	5d                   	pop    %rbp
  8004216789:	c3                   	retq   

000000800421678a <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  800421678a:	55                   	push   %rbp
  800421678b:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  800421678e:	48 b8 08 40 52 04 80 	movabs $0x8004524008,%rax
  8004216795:	00 00 00 
  8004216798:	48 8b 00             	mov    (%rax),%rax
  800421679b:	48 85 c0             	test   %rax,%rax
  800421679e:	74 16                	je     80042167b6 <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  80042167a0:	be 00 00 00 00       	mov    $0x0,%esi
  80042167a5:	bf 2c 00 00 00       	mov    $0x2c,%edi
  80042167aa:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  80042167b1:	00 00 00 
  80042167b4:	ff d0                	callq  *%rax
}
  80042167b6:	5d                   	pop    %rbp
  80042167b7:	c3                   	retq   

00000080042167b8 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  80042167b8:	55                   	push   %rbp
  80042167b9:	48 89 e5             	mov    %rsp,%rbp
  80042167bc:	48 83 ec 04          	sub    $0x4,%rsp
  80042167c0:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  80042167c3:	c9                   	leaveq 
  80042167c4:	c3                   	retq   

00000080042167c5 <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  80042167c5:	55                   	push   %rbp
  80042167c6:	48 89 e5             	mov    %rsp,%rbp
  80042167c9:	48 83 ec 40          	sub    $0x40,%rsp
  80042167cd:	89 f8                	mov    %edi,%eax
  80042167cf:	89 75 c8             	mov    %esi,-0x38(%rbp)
  80042167d2:	88 45 cc             	mov    %al,-0x34(%rbp)
  80042167d5:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  80042167dc:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  80042167e0:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042167e4:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042167e7:	ee                   	out    %al,(%dx)
  80042167e8:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  80042167ef:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  80042167f3:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042167f7:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042167fa:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  80042167fb:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  8004216802:	00 
  8004216803:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216807:	48 c1 e8 0c          	shr    $0xc,%rax
  800421680b:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800421680e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216811:	48 b8 b0 17 4a 04 80 	movabs $0x80044a17b0,%rax
  8004216818:	00 00 00 
  800421681b:	48 8b 00             	mov    (%rax),%rax
  800421681e:	48 39 c2             	cmp    %rax,%rdx
  8004216821:	72 32                	jb     8004216855 <lapic_startap+0x90>
  8004216823:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216827:	48 89 c1             	mov    %rax,%rcx
  800421682a:	48 ba 08 97 21 04 80 	movabs $0x8004219708,%rdx
  8004216831:	00 00 00 
  8004216834:	be 98 00 00 00       	mov    $0x98,%esi
  8004216839:	48 bf 2b 97 21 04 80 	movabs $0x800421972b,%rdi
  8004216840:	00 00 00 
  8004216843:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216848:	49 b8 26 05 20 04 80 	movabs $0x8004200526,%r8
  800421684f:	00 00 00 
  8004216852:	41 ff d0             	callq  *%r8
  8004216855:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421685c:	00 00 00 
  800421685f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216863:	48 01 d0             	add    %rdx,%rax
  8004216866:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  800421686a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421686e:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004216873:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216877:	48 8d 50 02          	lea    0x2(%rax),%rdx
  800421687b:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421687e:	c1 e8 04             	shr    $0x4,%eax
  8004216881:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004216884:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004216888:	c1 e0 18             	shl    $0x18,%eax
  800421688b:	89 c6                	mov    %eax,%esi
  800421688d:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216892:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  8004216899:	00 00 00 
  800421689c:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  800421689e:	be 00 c5 00 00       	mov    $0xc500,%esi
  80042168a3:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042168a8:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  80042168af:	00 00 00 
  80042168b2:	ff d0                	callq  *%rax
	microdelay(200);
  80042168b4:	bf c8 00 00 00       	mov    $0xc8,%edi
  80042168b9:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  80042168c0:	00 00 00 
  80042168c3:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  80042168c5:	be 00 85 00 00       	mov    $0x8500,%esi
  80042168ca:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042168cf:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  80042168d6:	00 00 00 
  80042168d9:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  80042168db:	bf 64 00 00 00       	mov    $0x64,%edi
  80042168e0:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  80042168e7:	00 00 00 
  80042168ea:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  80042168ec:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042168f3:	eb 4b                	jmp    8004216940 <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  80042168f5:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042168f9:	c1 e0 18             	shl    $0x18,%eax
  80042168fc:	89 c6                	mov    %eax,%esi
  80042168fe:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216903:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  800421690a:	00 00 00 
  800421690d:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  800421690f:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004216912:	c1 e8 0c             	shr    $0xc,%eax
  8004216915:	80 cc 06             	or     $0x6,%ah
  8004216918:	89 c6                	mov    %eax,%esi
  800421691a:	bf c0 00 00 00       	mov    $0xc0,%edi
  800421691f:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  8004216926:	00 00 00 
  8004216929:	ff d0                	callq  *%rax
		microdelay(200);
  800421692b:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216930:	48 b8 b8 67 21 04 80 	movabs $0x80042167b8,%rax
  8004216937:	00 00 00 
  800421693a:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  800421693c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004216940:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004216944:	7e af                	jle    80042168f5 <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  8004216946:	c9                   	leaveq 
  8004216947:	c3                   	retq   

0000008004216948 <lapic_ipi>:

void
lapic_ipi(int vector)
{
  8004216948:	55                   	push   %rbp
  8004216949:	48 89 e5             	mov    %rsp,%rbp
  800421694c:	48 83 ec 08          	sub    $0x8,%rsp
  8004216950:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  8004216953:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216956:	0d 00 00 0c 00       	or     $0xc0000,%eax
  800421695b:	89 c6                	mov    %eax,%esi
  800421695d:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216962:	48 b8 1c 65 21 04 80 	movabs $0x800421651c,%rax
  8004216969:	00 00 00 
  800421696c:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  800421696e:	90                   	nop
  800421696f:	48 b8 08 40 52 04 80 	movabs $0x8004524008,%rax
  8004216976:	00 00 00 
  8004216979:	48 8b 00             	mov    (%rax),%rax
  800421697c:	48 05 00 03 00 00    	add    $0x300,%rax
  8004216982:	8b 00                	mov    (%rax),%eax
  8004216984:	25 00 10 00 00       	and    $0x1000,%eax
  8004216989:	85 c0                	test   %eax,%eax
  800421698b:	75 e2                	jne    800421696f <lapic_ipi+0x27>
		;
}
  800421698d:	c9                   	leaveq 
  800421698e:	c3                   	retq   

000000800421698f <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800421698f:	55                   	push   %rbp
  8004216990:	48 89 e5             	mov    %rsp,%rbp
  8004216993:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004216997:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421699b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800421699e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042169a2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042169a5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042169a9:	f0 87 02             	lock xchg %eax,(%rdx)
  80042169ac:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  80042169af:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042169b2:	c9                   	leaveq 
  80042169b3:	c3                   	retq   

00000080042169b4 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  80042169b4:	55                   	push   %rbp
  80042169b5:	48 89 e5             	mov    %rsp,%rbp
  80042169b8:	48 83 ec 28          	sub    $0x28,%rsp
  80042169bc:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
        uint64_t rbp;
        __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042169c0:	48 89 e8             	mov    %rbp,%rax
  80042169c3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        return rbp;
  80042169c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  80042169cb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  80042169cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042169d6:	eb 45                	jmp    8004216a1d <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  80042169d8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042169dd:	74 44                	je     8004216a23 <get_caller_pcs+0x6f>
  80042169df:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042169e6:	00 00 00 
  80042169e9:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042169ed:	76 34                	jbe    8004216a23 <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  80042169ef:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042169f2:	48 98                	cltq   
  80042169f4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042169fb:	00 
  80042169fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216a00:	48 01 c2             	add    %rax,%rdx
  8004216a03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a07:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004216a0b:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004216a0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a12:	48 8b 00             	mov    (%rax),%rax
  8004216a15:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  8004216a19:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216a1d:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004216a21:	7e b5                	jle    80042169d8 <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216a23:	eb 1f                	jmp    8004216a44 <get_caller_pcs+0x90>
		pcs[i] = 0;
  8004216a25:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216a28:	48 98                	cltq   
  8004216a2a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004216a31:	00 
  8004216a32:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216a36:	48 01 d0             	add    %rdx,%rax
  8004216a39:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216a40:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216a44:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004216a48:	7e db                	jle    8004216a25 <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  8004216a4a:	c9                   	leaveq 
  8004216a4b:	c3                   	retq   

0000008004216a4c <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004216a4c:	55                   	push   %rbp
  8004216a4d:	48 89 e5             	mov    %rsp,%rbp
  8004216a50:	53                   	push   %rbx
  8004216a51:	48 83 ec 18          	sub    $0x18,%rsp
  8004216a55:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  8004216a59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216a5d:	8b 00                	mov    (%rax),%eax
  8004216a5f:	85 c0                	test   %eax,%eax
  8004216a61:	74 3d                	je     8004216aa0 <holding+0x54>
  8004216a63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216a67:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004216a6b:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004216a72:	00 00 00 
  8004216a75:	ff d0                	callq  *%rax
  8004216a77:	48 98                	cltq   
  8004216a79:	48 c1 e0 03          	shl    $0x3,%rax
  8004216a7d:	48 89 c2             	mov    %rax,%rdx
  8004216a80:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216a84:	48 29 c2             	sub    %rax,%rdx
  8004216a87:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  8004216a8e:	00 00 00 
  8004216a91:	48 01 d0             	add    %rdx,%rax
  8004216a94:	48 39 c3             	cmp    %rax,%rbx
  8004216a97:	75 07                	jne    8004216aa0 <holding+0x54>
  8004216a99:	b8 01 00 00 00       	mov    $0x1,%eax
  8004216a9e:	eb 05                	jmp    8004216aa5 <holding+0x59>
  8004216aa0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216aa5:	48 83 c4 18          	add    $0x18,%rsp
  8004216aa9:	5b                   	pop    %rbx
  8004216aaa:	5d                   	pop    %rbp
  8004216aab:	c3                   	retq   

0000008004216aac <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004216aac:	55                   	push   %rbp
  8004216aad:	48 89 e5             	mov    %rsp,%rbp
  8004216ab0:	48 83 ec 10          	sub    $0x10,%rsp
  8004216ab4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004216ab8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004216abc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216ac0:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004216ac6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216aca:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004216ace:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  8004216ad2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216ad6:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004216add:	00 
#endif
}
  8004216ade:	c9                   	leaveq 
  8004216adf:	c3                   	retq   

0000008004216ae0 <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004216ae0:	55                   	push   %rbp
  8004216ae1:	48 89 e5             	mov    %rsp,%rbp
  8004216ae4:	53                   	push   %rbx
  8004216ae5:	48 83 ec 18          	sub    $0x18,%rsp
  8004216ae9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  8004216aed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216af1:	48 89 c7             	mov    %rax,%rdi
  8004216af4:	48 b8 4c 6a 21 04 80 	movabs $0x8004216a4c,%rax
  8004216afb:	00 00 00 
  8004216afe:	ff d0                	callq  *%rax
  8004216b00:	85 c0                	test   %eax,%eax
  8004216b02:	74 44                	je     8004216b48 <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004216b04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216b08:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216b0c:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004216b13:	00 00 00 
  8004216b16:	ff d0                	callq  *%rax
  8004216b18:	49 89 d8             	mov    %rbx,%r8
  8004216b1b:	89 c1                	mov    %eax,%ecx
  8004216b1d:	48 ba 48 97 21 04 80 	movabs $0x8004219748,%rdx
  8004216b24:	00 00 00 
  8004216b27:	be 41 00 00 00       	mov    $0x41,%esi
  8004216b2c:	48 bf 72 97 21 04 80 	movabs $0x8004219772,%rdi
  8004216b33:	00 00 00 
  8004216b36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216b3b:	49 b9 26 05 20 04 80 	movabs $0x8004200526,%r9
  8004216b42:	00 00 00 
  8004216b45:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004216b48:	eb 02                	jmp    8004216b4c <spin_lock+0x6c>
		asm volatile ("pause");
  8004216b4a:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004216b4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216b50:	be 01 00 00 00       	mov    $0x1,%esi
  8004216b55:	48 89 c7             	mov    %rax,%rdi
  8004216b58:	48 b8 8f 69 21 04 80 	movabs $0x800421698f,%rax
  8004216b5f:	00 00 00 
  8004216b62:	ff d0                	callq  *%rax
  8004216b64:	85 c0                	test   %eax,%eax
  8004216b66:	75 e2                	jne    8004216b4a <spin_lock+0x6a>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  8004216b68:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004216b6f:	00 00 00 
  8004216b72:	ff d0                	callq  *%rax
  8004216b74:	48 98                	cltq   
  8004216b76:	48 c1 e0 03          	shl    $0x3,%rax
  8004216b7a:	48 89 c2             	mov    %rax,%rdx
  8004216b7d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216b81:	48 29 c2             	sub    %rax,%rdx
  8004216b84:	48 b8 20 30 4a 04 80 	movabs $0x80044a3020,%rax
  8004216b8b:	00 00 00 
  8004216b8e:	48 01 c2             	add    %rax,%rdx
  8004216b91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216b95:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004216b99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216b9d:	48 83 c0 18          	add    $0x18,%rax
  8004216ba1:	48 89 c7             	mov    %rax,%rdi
  8004216ba4:	48 b8 b4 69 21 04 80 	movabs $0x80042169b4,%rax
  8004216bab:	00 00 00 
  8004216bae:	ff d0                	callq  *%rax
#endif
}
  8004216bb0:	48 83 c4 18          	add    $0x18,%rsp
  8004216bb4:	5b                   	pop    %rbx
  8004216bb5:	5d                   	pop    %rbp
  8004216bb6:	c3                   	retq   

0000008004216bb7 <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004216bb7:	55                   	push   %rbp
  8004216bb8:	48 89 e5             	mov    %rsp,%rbp
  8004216bbb:	41 54                	push   %r12
  8004216bbd:	53                   	push   %rbx
  8004216bbe:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004216bc5:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004216bcc:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216bd3:	48 89 c7             	mov    %rax,%rdi
  8004216bd6:	48 b8 4c 6a 21 04 80 	movabs $0x8004216a4c,%rax
  8004216bdd:	00 00 00 
  8004216be0:	ff d0                	callq  *%rax
  8004216be2:	85 c0                	test   %eax,%eax
  8004216be4:	0f 85 d2 01 00 00    	jne    8004216dbc <spin_unlock+0x205>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  8004216bea:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216bf1:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004216bf5:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004216bfc:	ba 28 00 00 00       	mov    $0x28,%edx
  8004216c01:	48 89 ce             	mov    %rcx,%rsi
  8004216c04:	48 89 c7             	mov    %rax,%rdi
  8004216c07:	48 b8 31 f9 20 04 80 	movabs $0x800420f931,%rax
  8004216c0e:	00 00 00 
  8004216c11:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004216c13:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216c1a:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216c1e:	48 85 c0             	test   %rax,%rax
  8004216c21:	75 39                	jne    8004216c5c <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  8004216c23:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216c2a:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216c2e:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004216c35:	00 00 00 
  8004216c38:	ff d0                	callq  *%rax
  8004216c3a:	48 89 da             	mov    %rbx,%rdx
  8004216c3d:	89 c6                	mov    %eax,%esi
  8004216c3f:	48 bf 88 97 21 04 80 	movabs $0x8004219788,%rdi
  8004216c46:	00 00 00 
  8004216c49:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216c4e:	48 b9 99 8d 20 04 80 	movabs $0x8004208d99,%rcx
  8004216c55:	00 00 00 
  8004216c58:	ff d1                	callq  *%rcx
  8004216c5a:	eb 4d                	jmp    8004216ca9 <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004216c5c:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216c63:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216c67:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  8004216c6a:	44 0f b6 e0          	movzbl %al,%r12d
  8004216c6e:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216c75:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216c79:	48 b8 55 67 21 04 80 	movabs $0x8004216755,%rax
  8004216c80:	00 00 00 
  8004216c83:	ff d0                	callq  *%rax
  8004216c85:	44 89 e1             	mov    %r12d,%ecx
  8004216c88:	48 89 da             	mov    %rbx,%rdx
  8004216c8b:	89 c6                	mov    %eax,%esi
  8004216c8d:	48 bf c8 97 21 04 80 	movabs $0x80042197c8,%rdi
  8004216c94:	00 00 00 
  8004216c97:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216c9c:	49 b8 99 8d 20 04 80 	movabs $0x8004208d99,%r8
  8004216ca3:	00 00 00 
  8004216ca6:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004216ca9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004216cb0:	e9 c3 00 00 00       	jmpq   8004216d78 <spin_unlock+0x1c1>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  8004216cb5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216cb8:	48 98                	cltq   
  8004216cba:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216cc1:	89 c0                	mov    %eax,%eax
  8004216cc3:	48 8d 95 10 fb ff ff 	lea    -0x4f0(%rbp),%rdx
  8004216cca:	48 89 d6             	mov    %rdx,%rsi
  8004216ccd:	48 89 c7             	mov    %rax,%rdi
  8004216cd0:	48 b8 0e e5 20 04 80 	movabs $0x800420e50e,%rax
  8004216cd7:	00 00 00 
  8004216cda:	ff d0                	callq  *%rax
  8004216cdc:	85 c0                	test   %eax,%eax
  8004216cde:	78 6b                	js     8004216d4b <spin_unlock+0x194>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004216ce0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216ce3:	48 98                	cltq   
  8004216ce5:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004216cec:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004216cee:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004216cf5:	48 29 c2             	sub    %rax,%rdx
  8004216cf8:	49 89 d0             	mov    %rdx,%r8
  8004216cfb:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  8004216d02:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  8004216d08:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  8004216d0e:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8004216d15:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216d18:	48 98                	cltq   
  8004216d1a:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216d21:	4c 89 04 24          	mov    %r8,(%rsp)
  8004216d25:	49 89 f9             	mov    %rdi,%r9
  8004216d28:	41 89 f0             	mov    %esi,%r8d
  8004216d2b:	89 c6                	mov    %eax,%esi
  8004216d2d:	48 bf fe 97 21 04 80 	movabs $0x80042197fe,%rdi
  8004216d34:	00 00 00 
  8004216d37:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d3c:	49 ba 99 8d 20 04 80 	movabs $0x8004208d99,%r10
  8004216d43:	00 00 00 
  8004216d46:	41 ff d2             	callq  *%r10
  8004216d49:	eb 29                	jmp    8004216d74 <spin_unlock+0x1bd>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  8004216d4b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216d4e:	48 98                	cltq   
  8004216d50:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216d57:	89 c6                	mov    %eax,%esi
  8004216d59:	48 bf 15 98 21 04 80 	movabs $0x8004219815,%rdi
  8004216d60:	00 00 00 
  8004216d63:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d68:	48 ba 99 8d 20 04 80 	movabs $0x8004208d99,%rdx
  8004216d6f:	00 00 00 
  8004216d72:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004216d74:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004216d78:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  8004216d7c:	7f 14                	jg     8004216d92 <spin_unlock+0x1db>
  8004216d7e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216d81:	48 98                	cltq   
  8004216d83:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216d8a:	85 c0                	test   %eax,%eax
  8004216d8c:	0f 85 23 ff ff ff    	jne    8004216cb5 <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  8004216d92:	48 ba 1d 98 21 04 80 	movabs $0x800421981d,%rdx
  8004216d99:	00 00 00 
  8004216d9c:	be 6b 00 00 00       	mov    $0x6b,%esi
  8004216da1:	48 bf 72 97 21 04 80 	movabs $0x8004219772,%rdi
  8004216da8:	00 00 00 
  8004216dab:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216db0:	48 b9 26 05 20 04 80 	movabs $0x8004200526,%rcx
  8004216db7:	00 00 00 
  8004216dba:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  8004216dbc:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216dc3:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  8004216dca:	00 
	lk->cpu = 0;
  8004216dcb:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216dd2:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004216dd9:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  8004216dda:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216de1:	be 00 00 00 00       	mov    $0x0,%esi
  8004216de6:	48 89 c7             	mov    %rax,%rdi
  8004216de9:	48 b8 8f 69 21 04 80 	movabs $0x800421698f,%rax
  8004216df0:	00 00 00 
  8004216df3:	ff d0                	callq  *%rax
}
  8004216df5:	48 81 c4 20 05 00 00 	add    $0x520,%rsp
  8004216dfc:	5b                   	pop    %rbx
  8004216dfd:	41 5c                	pop    %r12
  8004216dff:	5d                   	pop    %rbp
  8004216e00:	c3                   	retq   
