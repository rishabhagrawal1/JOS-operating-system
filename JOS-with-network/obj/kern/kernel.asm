
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
.globl _head64
_head64:

# Save multiboot_info addr passed by bootloader
	
    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

    movw $0x1234,0x472			# warm boot	
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
	
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
    movl $CR4_PAE,%eax	
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
  100115:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011c:	00 00 00 
  10011f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100126:	00 00 00 
  100129:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100130:	00 00 00 
  100133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10013a:	00 00 00 
  10013d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100144:	00 00 00 
  100147:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014e:	00 00 00 
  100151:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100158:	00 00 00 
  10015b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100162:	00 00 00 
  100165:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016c:	00 00 00 
  10016f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100176:	00 00 00 
  100179:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100180:	00 00 00 
  100183:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10018a:	00 00 00 
  10018d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100194:	00 00 00 
  100197:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019e:	00 00 00 
  1001a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a8:	00 00 00 
  1001ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b2:	00 00 00 
  1001b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bc:	00 00 00 
  1001bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c6:	00 00 00 
  1001c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d0:	00 00 00 
  1001d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001da:	00 00 00 
  1001dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e4:	00 00 00 
  1001e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ee:	00 00 00 
  1001f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f8:	00 00 00 
  1001fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100202:	00 00 00 
  100205:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020c:	00 00 00 
  10020f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100216:	00 00 00 
  100219:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100220:	00 00 00 
  100223:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10022a:	00 00 00 
  10022d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100234:	00 00 00 
  100237:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023e:	00 00 00 
  100241:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100248:	00 00 00 
  10024b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100252:	00 00 00 
  100255:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025c:	00 00 00 
  10025f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100266:	00 00 00 
  100269:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100270:	00 00 00 
  100273:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10027a:	00 00 00 
  10027d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100284:	00 00 00 
  100287:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028e:	00 00 00 
  100291:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100298:	00 00 00 
  10029b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a2:	00 00 00 
  1002a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ac:	00 00 00 
  1002af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b6:	00 00 00 
  1002b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c0:	00 00 00 
  1002c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ca:	00 00 00 
  1002cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d4:	00 00 00 
  1002d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002de:	00 00 00 
  1002e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e8:	00 00 00 
  1002eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f2:	00 00 00 
  1002f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fc:	00 00 00 
  1002ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100306:	00 00 00 
  100309:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100310:	00 00 00 
  100313:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10031a:	00 00 00 
  10031d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100324:	00 00 00 
  100327:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032e:	00 00 00 
  100331:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100338:	00 00 00 
  10033b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100342:	00 00 00 
  100345:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034c:	00 00 00 
  10034f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100356:	00 00 00 
  100359:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100360:	00 00 00 
  100363:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10036a:	00 00 00 
  10036d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100374:	00 00 00 
  100377:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037e:	00 00 00 
  100381:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100388:	00 00 00 
  10038b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100392:	00 00 00 
  100395:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039c:	00 00 00 
  10039f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a6:	00 00 00 
  1003a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b0:	00 00 00 
  1003b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ba:	00 00 00 
  1003bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c4:	00 00 00 
  1003c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ce:	00 00 00 
  1003d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d8:	00 00 00 
  1003db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e2:	00 00 00 
  1003e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ec:	00 00 00 
  1003ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f6:	00 00 00 
  1003f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100400:	00 00 00 
  100403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10040a:	00 00 00 
  10040d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100414:	00 00 00 
  100417:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041e:	00 00 00 
  100421:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100428:	00 00 00 
  10042b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100432:	00 00 00 
  100435:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043c:	00 00 00 
  10043f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100446:	00 00 00 
  100449:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100450:	00 00 00 
  100453:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10045a:	00 00 00 
  10045d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100464:	00 00 00 
  100467:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046e:	00 00 00 
  100471:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100478:	00 00 00 
  10047b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100482:	00 00 00 
  100485:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048c:	00 00 00 
  10048f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100496:	00 00 00 
  100499:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a0:	00 00 00 
  1004a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004aa:	00 00 00 
  1004ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b4:	00 00 00 
  1004b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004be:	00 00 00 
  1004c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c8:	00 00 00 
  1004cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d2:	00 00 00 
  1004d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004dc:	00 00 00 
  1004df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e6:	00 00 00 
  1004e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f0:	00 00 00 
  1004f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004fa:	00 00 00 
  1004fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100504:	00 00 00 
  100507:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050e:	00 00 00 
  100511:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100518:	00 00 00 
  10051b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100522:	00 00 00 
  100525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052c:	00 00 00 
  10052f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100536:	00 00 00 
  100539:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100540:	00 00 00 
  100543:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10054a:	00 00 00 
  10054d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100554:	00 00 00 
  100557:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055e:	00 00 00 
  100561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100568:	00 00 00 
  10056b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100572:	00 00 00 
  100575:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057c:	00 00 00 
  10057f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100586:	00 00 00 
  100589:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100590:	00 00 00 
  100593:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10059a:	00 00 00 
  10059d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a4:	00 00 00 
  1005a7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ae:	00 00 00 
  1005b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b8:	00 00 00 
  1005bb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c2:	00 00 00 
  1005c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cc:	00 00 00 
  1005cf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d6:	00 00 00 
  1005d9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e0:	00 00 00 
  1005e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ea:	00 00 00 
  1005ed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f4:	00 00 00 
  1005f7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fe:	00 00 00 
  100601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100608:	00 00 00 
  10060b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100612:	00 00 00 
  100615:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061c:	00 00 00 
  10061f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100626:	00 00 00 
  100629:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100630:	00 00 00 
  100633:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10063a:	00 00 00 
  10063d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100644:	00 00 00 
  100647:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064e:	00 00 00 
  100651:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100658:	00 00 00 
  10065b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100662:	00 00 00 
  100665:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066c:	00 00 00 
  10066f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100676:	00 00 00 
  100679:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100680:	00 00 00 
  100683:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10068a:	00 00 00 
  10068d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100694:	00 00 00 
  100697:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069e:	00 00 00 
  1006a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a8:	00 00 00 
  1006ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b2:	00 00 00 
  1006b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bc:	00 00 00 
  1006bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c6:	00 00 00 
  1006c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d0:	00 00 00 
  1006d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006da:	00 00 00 
  1006dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e4:	00 00 00 
  1006e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ee:	00 00 00 
  1006f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f8:	00 00 00 
  1006fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100702:	00 00 00 
  100705:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070c:	00 00 00 
  10070f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100716:	00 00 00 
  100719:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100720:	00 00 00 
  100723:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10072a:	00 00 00 
  10072d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100734:	00 00 00 
  100737:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073e:	00 00 00 
  100741:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100748:	00 00 00 
  10074b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100752:	00 00 00 
  100755:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075c:	00 00 00 
  10075f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100766:	00 00 00 
  100769:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100770:	00 00 00 
  100773:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10077a:	00 00 00 
  10077d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100784:	00 00 00 
  100787:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078e:	00 00 00 
  100791:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100798:	00 00 00 
  10079b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a2:	00 00 00 
  1007a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ac:	00 00 00 
  1007af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b6:	00 00 00 
  1007b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c0:	00 00 00 
  1007c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ca:	00 00 00 
  1007cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d4:	00 00 00 
  1007d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007de:	00 00 00 
  1007e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e8:	00 00 00 
  1007eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f2:	00 00 00 
  1007f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fc:	00 00 00 
  1007ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100806:	00 00 00 
  100809:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100810:	00 00 00 
  100813:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10081a:	00 00 00 
  10081d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100824:	00 00 00 
  100827:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082e:	00 00 00 
  100831:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100838:	00 00 00 
  10083b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100842:	00 00 00 
  100845:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084c:	00 00 00 
  10084f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100856:	00 00 00 
  100859:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100860:	00 00 00 
  100863:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10086a:	00 00 00 
  10086d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100874:	00 00 00 
  100877:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087e:	00 00 00 
  100881:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100888:	00 00 00 
  10088b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100892:	00 00 00 
  100895:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089c:	00 00 00 
  10089f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a6:	00 00 00 
  1008a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b0:	00 00 00 
  1008b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ba:	00 00 00 
  1008bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c4:	00 00 00 
  1008c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ce:	00 00 00 
  1008d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d8:	00 00 00 
  1008db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e2:	00 00 00 
  1008e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ec:	00 00 00 
  1008ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f6:	00 00 00 
  1008f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100900:	00 00 00 
  100903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10090a:	00 00 00 
  10090d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100914:	00 00 00 
  100917:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091e:	00 00 00 
  100921:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100928:	00 00 00 
  10092b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100932:	00 00 00 
  100935:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093c:	00 00 00 
  10093f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100946:	00 00 00 
  100949:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100950:	00 00 00 
  100953:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10095a:	00 00 00 
  10095d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100964:	00 00 00 
  100967:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096e:	00 00 00 
  100971:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100978:	00 00 00 
  10097b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100982:	00 00 00 
  100985:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098c:	00 00 00 
  10098f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100996:	00 00 00 
  100999:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a0:	00 00 00 
  1009a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009aa:	00 00 00 
  1009ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b4:	00 00 00 
  1009b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009be:	00 00 00 
  1009c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c8:	00 00 00 
  1009cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d2:	00 00 00 
  1009d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009dc:	00 00 00 
  1009df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e6:	00 00 00 
  1009e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f0:	00 00 00 
  1009f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009fa:	00 00 00 
  1009fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a04:	00 00 00 
  100a07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0e:	00 00 00 
  100a11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a18:	00 00 00 
  100a1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a22:	00 00 00 
  100a25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2c:	00 00 00 
  100a2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a36:	00 00 00 
  100a39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a40:	00 00 00 
  100a43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a4a:	00 00 00 
  100a4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a54:	00 00 00 
  100a57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5e:	00 00 00 
  100a61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a68:	00 00 00 
  100a6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a72:	00 00 00 
  100a75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7c:	00 00 00 
  100a7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a86:	00 00 00 
  100a89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a90:	00 00 00 
  100a93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a9a:	00 00 00 
  100a9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa4:	00 00 00 
  100aa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aae:	00 00 00 
  100ab1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab8:	00 00 00 
  100abb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac2:	00 00 00 
  100ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acc:	00 00 00 
  100acf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad6:	00 00 00 
  100ad9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae0:	00 00 00 
  100ae3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aea:	00 00 00 
  100aed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af4:	00 00 00 
  100af7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afe:	00 00 00 
  100b01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b08:	00 00 00 
  100b0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b12:	00 00 00 
  100b15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1c:	00 00 00 
  100b1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b26:	00 00 00 
  100b29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b30:	00 00 00 
  100b33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b3a:	00 00 00 
  100b3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b44:	00 00 00 
  100b47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4e:	00 00 00 
  100b51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b58:	00 00 00 
  100b5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b62:	00 00 00 
  100b65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6c:	00 00 00 
  100b6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b76:	00 00 00 
  100b79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b80:	00 00 00 
  100b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b8a:	00 00 00 
  100b8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b94:	00 00 00 
  100b97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9e:	00 00 00 
  100ba1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba8:	00 00 00 
  100bab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb2:	00 00 00 
  100bb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbc:	00 00 00 
  100bbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc6:	00 00 00 
  100bc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd0:	00 00 00 
  100bd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bda:	00 00 00 
  100bdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be4:	00 00 00 
  100be7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bee:	00 00 00 
  100bf1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf8:	00 00 00 
  100bfb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c02:	00 00 00 
  100c05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0c:	00 00 00 
  100c0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c16:	00 00 00 
  100c19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c20:	00 00 00 
  100c23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c2a:	00 00 00 
  100c2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c34:	00 00 00 
  100c37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3e:	00 00 00 
  100c41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c48:	00 00 00 
  100c4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c52:	00 00 00 
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5c:	00 00 00 
  100c5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c66:	00 00 00 
  100c69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c70:	00 00 00 
  100c73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c7a:	00 00 00 
  100c7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c84:	00 00 00 
  100c87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8e:	00 00 00 
  100c91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c98:	00 00 00 
  100c9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca2:	00 00 00 
  100ca5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cac:	00 00 00 
  100caf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb6:	00 00 00 
  100cb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc0:	00 00 00 
  100cc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cca:	00 00 00 
  100ccd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd4:	00 00 00 
  100cd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cde:	00 00 00 
  100ce1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce8:	00 00 00 
  100ceb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf2:	00 00 00 
  100cf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfc:	00 00 00 
  100cff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d06:	00 00 00 
  100d09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d10:	00 00 00 
  100d13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d1a:	00 00 00 
  100d1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d24:	00 00 00 
  100d27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2e:	00 00 00 
  100d31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d38:	00 00 00 
  100d3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d42:	00 00 00 
  100d45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4c:	00 00 00 
  100d4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d56:	00 00 00 
  100d59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d60:	00 00 00 
  100d63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d6a:	00 00 00 
  100d6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d74:	00 00 00 
  100d77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7e:	00 00 00 
  100d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d88:	00 00 00 
  100d8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d92:	00 00 00 
  100d95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9c:	00 00 00 
  100d9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da6:	00 00 00 
  100da9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db0:	00 00 00 
  100db3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dba:	00 00 00 
  100dbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc4:	00 00 00 
  100dc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dce:	00 00 00 
  100dd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd8:	00 00 00 
  100ddb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de2:	00 00 00 
  100de5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dec:	00 00 00 
  100def:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df6:	00 00 00 
  100df9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e00:	00 00 00 
  100e03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e0a:	00 00 00 
  100e0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e14:	00 00 00 
  100e17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1e:	00 00 00 
  100e21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e28:	00 00 00 
  100e2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e32:	00 00 00 
  100e35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3c:	00 00 00 
  100e3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e46:	00 00 00 
  100e49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e50:	00 00 00 
  100e53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e5a:	00 00 00 
  100e5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e64:	00 00 00 
  100e67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6e:	00 00 00 
  100e71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e78:	00 00 00 
  100e7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e82:	00 00 00 
  100e85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8c:	00 00 00 
  100e8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e96:	00 00 00 
  100e99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea0:	00 00 00 
  100ea3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eaa:	00 00 00 
  100ead:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb4:	00 00 00 
  100eb7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebe:	00 00 00 
  100ec1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec8:	00 00 00 
  100ecb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed2:	00 00 00 
  100ed5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edc:	00 00 00 
  100edf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee6:	00 00 00 
  100ee9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef0:	00 00 00 
  100ef3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100efa:	00 00 00 
  100efd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f04:	00 00 00 
  100f07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0e:	00 00 00 
  100f11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f18:	00 00 00 
  100f1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f22:	00 00 00 
  100f25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2c:	00 00 00 
  100f2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f36:	00 00 00 
  100f39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f40:	00 00 00 
  100f43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f4a:	00 00 00 
  100f4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f54:	00 00 00 
  100f57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5e:	00 00 00 
  100f61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f68:	00 00 00 
  100f6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f72:	00 00 00 
  100f75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7c:	00 00 00 
  100f7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f86:	00 00 00 
  100f89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f90:	00 00 00 
  100f93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f9a:	00 00 00 
  100f9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa4:	00 00 00 
  100fa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fae:	00 00 00 
  100fb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb8:	00 00 00 
  100fbb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc2:	00 00 00 
  100fc5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcc:	00 00 00 
  100fcf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd6:	00 00 00 
  100fd9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe0:	00 00 00 
  100fe3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fea:	00 00 00 
  100fed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff4:	00 00 00 
  100ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  100ffe:	00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 d0 22 04 80 	movabs $0x800422d038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 d0 22 04 80 	movabs $0x800422d000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 1d 01 20 04 80 	movabs $0x800420011d,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004200060:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004200064:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200067:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420006b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420006e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004200072:	f0 87 02             	lock xchg %eax,(%rdx)
  8004200075:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004200078:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420007b:	c9                   	leaveq 
  800420007c:	c3                   	retq   

000000800420007d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420007d:	55                   	push   %rbp
  800420007e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004200081:	48 bf 80 d7 22 04 80 	movabs $0x800422d780,%rdi
  8004200088:	00 00 00 
  800420008b:	48 b8 b4 6c 21 04 80 	movabs $0x8004216cb4,%rax
  8004200092:	00 00 00 
  8004200095:	ff d0                	callq  *%rax
}
  8004200097:	5d                   	pop    %rbp
  8004200098:	c3                   	retq   

0000008004200099 <test_backtrace>:
static void boot_aps(void);

// Test the stack backtrace function (lab 1 only)
void
test_backtrace(int x)
{
  8004200099:	55                   	push   %rbp
  800420009a:	48 89 e5             	mov    %rsp,%rbp
  800420009d:	48 83 ec 10          	sub    $0x10,%rsp
  80042000a1:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cprintf("entering test_backtrace %d\n", x);
  80042000a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000a7:	89 c6                	mov    %eax,%esi
  80042000a9:	48 bf e0 80 21 04 80 	movabs $0x80042180e0,%rdi
  80042000b0:	00 00 00 
  80042000b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000b8:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042000bf:	00 00 00 
  80042000c2:	ff d2                	callq  *%rdx
	if (x > 0)
  80042000c4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042000c8:	7e 16                	jle    80042000e0 <test_backtrace+0x47>
		test_backtrace(x-1);
  80042000ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000cd:	83 e8 01             	sub    $0x1,%eax
  80042000d0:	89 c7                	mov    %eax,%edi
  80042000d2:	48 b8 99 00 20 04 80 	movabs $0x8004200099,%rax
  80042000d9:	00 00 00 
  80042000dc:	ff d0                	callq  *%rax
  80042000de:	eb 1b                	jmp    80042000fb <test_backtrace+0x62>
	else
		mon_backtrace(0, 0, 0);
  80042000e0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042000e5:	be 00 00 00 00       	mov    $0x0,%esi
  80042000ea:	bf 00 00 00 00       	mov    $0x0,%edi
  80042000ef:	48 b8 50 16 20 04 80 	movabs $0x8004201650,%rax
  80042000f6:	00 00 00 
  80042000f9:	ff d0                	callq  *%rax
	cprintf("leaving test_backtrace %d\n", x);
  80042000fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000fe:	89 c6                	mov    %eax,%esi
  8004200100:	48 bf fc 80 21 04 80 	movabs $0x80042180fc,%rdi
  8004200107:	00 00 00 
  800420010a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420010f:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004200116:	00 00 00 
  8004200119:	ff d2                	callq  *%rdx
}
  800420011b:	c9                   	leaveq 
  800420011c:	c3                   	retq   

000000800420011d <i386_init>:


void
i386_init(void)
{
  800420011d:	55                   	push   %rbp
  800420011e:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  8004200121:	48 ba 28 b4 68 04 80 	movabs $0x800468b428,%rdx
  8004200128:	00 00 00 
  800420012b:	48 b8 ca 60 60 04 80 	movabs $0x80046060ca,%rax
  8004200132:	00 00 00 
  8004200135:	48 29 c2             	sub    %rax,%rdx
  8004200138:	48 89 d0             	mov    %rdx,%rax
  800420013b:	48 89 c2             	mov    %rax,%rdx
  800420013e:	be 00 00 00 00       	mov    $0x0,%esi
  8004200143:	48 bf ca 60 60 04 80 	movabs $0x80046060ca,%rdi
  800420014a:	00 00 00 
  800420014d:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004200154:	00 00 00 
  8004200157:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  8004200159:	48 b8 f4 11 20 04 80 	movabs $0x80042011f4,%rax
  8004200160:	00 00 00 
  8004200163:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  8004200165:	be ac 1a 00 00       	mov    $0x1aac,%esi
  800420016a:	48 bf 17 81 21 04 80 	movabs $0x8004218117,%rdi
  8004200171:	00 00 00 
  8004200174:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200179:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004200180:	00 00 00 
  8004200183:	ff d2                	callq  *%rdx

	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end);
  8004200185:	48 b8 28 b4 68 04 80 	movabs $0x800468b428,%rax
  800420018c:	00 00 00 
  800420018f:	48 89 c6             	mov    %rax,%rsi
  8004200192:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200199:	00 00 00 
  800420019c:	48 b8 a8 53 21 04 80 	movabs $0x80042153a8,%rax
  80042001a3:	00 00 00 
  80042001a6:	ff d0                	callq  *%rax
  80042001a8:	48 ba 58 87 60 04 80 	movabs $0x8004608758,%rdx
  80042001af:	00 00 00 
  80042001b2:	48 89 02             	mov    %rax,(%rdx)

	// Lab 2 memory management initialization functions
	x64_vm_init();
  80042001b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042001ba:	48 ba 08 27 20 04 80 	movabs $0x8004202708,%rdx
  80042001c1:	00 00 00 
  80042001c4:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  80042001c6:	48 b8 cb 79 20 04 80 	movabs $0x80042079cb,%rax
  80042001cd:	00 00 00 
  80042001d0:	ff d0                	callq  *%rax
	trap_init();
  80042001d2:	48 b8 3b 8f 20 04 80 	movabs $0x8004208f3b,%rax
  80042001d9:	00 00 00 
  80042001dc:	ff d0                	callq  *%rax

	// Lab 4 multiprocessor initialization functions
	mp_init();
  80042001de:	48 b8 35 63 21 04 80 	movabs $0x8004216335,%rax
  80042001e5:	00 00 00 
  80042001e8:	ff d0                	callq  *%rax
	lapic_init();
  80042001ea:	48 b8 32 67 21 04 80 	movabs $0x8004216732,%rax
  80042001f1:	00 00 00 
  80042001f4:	ff d0                	callq  *%rax

	// Lab 4 multitasking initialization functions
	pic_init();
  80042001f6:	48 b8 c3 8a 20 04 80 	movabs $0x8004208ac3,%rax
  80042001fd:	00 00 00 
  8004200200:	ff d0                	callq  *%rax

	// Lab 6 hardware initialization functions
	time_init();
  8004200202:	48 b8 2b 80 21 04 80 	movabs $0x800421802b,%rax
  8004200209:	00 00 00 
  800420020c:	ff d0                	callq  *%rax
	pci_init();
  800420020e:	48 b8 ef 7f 21 04 80 	movabs $0x8004217fef,%rax
  8004200215:	00 00 00 
  8004200218:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:

	//Starting non-boot CPUs
	lock_kernel();
  800420021a:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200221:	00 00 00 
  8004200224:	ff d0                	callq  *%rax
	boot_aps();
  8004200226:	48 b8 59 02 20 04 80 	movabs $0x8004200259,%rax
  800420022d:	00 00 00 
  8004200230:	ff d0                	callq  *%rax
	ENV_CREATE(net_ns, ENV_TYPE_NS);
#endif

#if defined(TEST)
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
  8004200232:	be 00 00 00 00       	mov    $0x0,%esi
  8004200237:	48 bf 54 62 4c 04 80 	movabs $0x80044c6254,%rdi
  800420023e:	00 00 00 
  8004200241:	48 b8 8f 80 20 04 80 	movabs $0x800420808f,%rax
  8004200248:	00 00 00 
  800420024b:	ff d0                	callq  *%rax
	ENV_CREATE(net_testoutput, ENV_TYPE_USER);
	
#endif // TEST*

	// Schedule and run the first user environment!
	sched_yield();
  800420024d:	48 b8 c9 ce 20 04 80 	movabs $0x800420cec9,%rax
  8004200254:	00 00 00 
  8004200257:	ff d0                	callq  *%rax

0000008004200259 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  8004200259:	55                   	push   %rbp
  800420025a:	48 89 e5             	mov    %rsp,%rbp
  800420025d:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  8004200261:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  8004200268:	00 
  8004200269:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420026d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004200271:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200274:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200277:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  800420027e:	00 00 00 
  8004200281:	48 8b 00             	mov    (%rax),%rax
  8004200284:	48 39 c2             	cmp    %rax,%rdx
  8004200287:	72 32                	jb     80042002bb <boot_aps+0x62>
  8004200289:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420028d:	48 89 c1             	mov    %rax,%rcx
  8004200290:	48 ba 38 81 21 04 80 	movabs $0x8004218138,%rdx
  8004200297:	00 00 00 
  800420029a:	be 8f 00 00 00       	mov    $0x8f,%esi
  800420029f:	48 bf 5b 81 21 04 80 	movabs $0x800421815b,%rdi
  80042002a6:	00 00 00 
  80042002a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042002ae:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042002b5:	00 00 00 
  80042002b8:	41 ff d0             	callq  *%r8
  80042002bb:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042002c2:	00 00 00 
  80042002c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042002c9:	48 01 d0             	add    %rdx,%rax
  80042002cc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  80042002d0:	48 ba 5e 5e 21 04 80 	movabs $0x8004215e5e,%rdx
  80042002d7:	00 00 00 
  80042002da:	48 b8 78 5d 21 04 80 	movabs $0x8004215d78,%rax
  80042002e1:	00 00 00 
  80042002e4:	48 29 c2             	sub    %rax,%rdx
  80042002e7:	48 89 d0             	mov    %rdx,%rax
  80042002ea:	48 89 c2             	mov    %rax,%rdx
  80042002ed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042002f1:	48 be 78 5d 21 04 80 	movabs $0x8004215d78,%rsi
  80042002f8:	00 00 00 
  80042002fb:	48 89 c7             	mov    %rax,%rdi
  80042002fe:	48 b8 13 fa 20 04 80 	movabs $0x800420fa13,%rax
  8004200305:	00 00 00 
  8004200308:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  800420030a:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  8004200311:	00 00 00 
  8004200314:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004200318:	e9 0b 01 00 00       	jmpq   8004200428 <boot_aps+0x1cf>
		if (c == cpus + cpunum())  // We've started already.
  800420031d:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004200324:	00 00 00 
  8004200327:	ff d0                	callq  *%rax
  8004200329:	48 98                	cltq   
  800420032b:	48 c1 e0 03          	shl    $0x3,%rax
  800420032f:	48 89 c2             	mov    %rax,%rdx
  8004200332:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200336:	48 29 c2             	sub    %rax,%rdx
  8004200339:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  8004200340:	00 00 00 
  8004200343:	48 01 d0             	add    %rdx,%rax
  8004200346:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420034a:	75 05                	jne    8004200351 <boot_aps+0xf8>
			continue;
  800420034c:	e9 d2 00 00 00       	jmpq   8004200423 <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  8004200351:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200355:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  800420035c:	00 00 00 
  800420035f:	48 29 c2             	sub    %rax,%rdx
  8004200362:	48 89 d0             	mov    %rdx,%rax
  8004200365:	48 c1 f8 03          	sar    $0x3,%rax
  8004200369:	48 89 c2             	mov    %rax,%rdx
  800420036c:	48 b8 ef ee ee ee ee 	movabs $0xeeeeeeeeeeeeeeef,%rax
  8004200373:	ee ee ee 
  8004200376:	48 0f af c2          	imul   %rdx,%rax
  800420037a:	48 83 c0 01          	add    $0x1,%rax
  800420037e:	48 c1 e0 10          	shl    $0x10,%rax
  8004200382:	48 89 c2             	mov    %rax,%rdx
  8004200385:	48 b8 00 b0 60 04 80 	movabs $0x800460b000,%rax
  800420038c:	00 00 00 
  800420038f:	48 01 c2             	add    %rax,%rdx
  8004200392:	48 b8 68 87 60 04 80 	movabs $0x8004608768,%rax
  8004200399:	00 00 00 
  800420039c:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  800420039f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042003a3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042003a7:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042003ae:	00 00 00 
  80042003b1:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80042003b5:	77 32                	ja     80042003e9 <boot_aps+0x190>
  80042003b7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042003bb:	48 89 c1             	mov    %rax,%rcx
  80042003be:	48 ba 68 81 21 04 80 	movabs $0x8004218168,%rdx
  80042003c5:	00 00 00 
  80042003c8:	be 99 00 00 00       	mov    $0x99,%esi
  80042003cd:	48 bf 5b 81 21 04 80 	movabs $0x800421815b,%rdi
  80042003d4:	00 00 00 
  80042003d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042003dc:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042003e3:	00 00 00 
  80042003e6:	41 ff d0             	callq  *%r8
  80042003e9:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042003f0:	ff ff ff 
  80042003f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042003f7:	48 01 d0             	add    %rdx,%rax
  80042003fa:	89 c2                	mov    %eax,%edx
  80042003fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200400:	0f b6 00             	movzbl (%rax),%eax
  8004200403:	0f b6 c0             	movzbl %al,%eax
  8004200406:	89 d6                	mov    %edx,%esi
  8004200408:	89 c7                	mov    %eax,%edi
  800420040a:	48 b8 99 69 21 04 80 	movabs $0x8004216999,%rax
  8004200411:	00 00 00 
  8004200414:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  8004200416:	90                   	nop
  8004200417:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420041b:	8b 40 04             	mov    0x4(%rax),%eax
  800420041e:	83 f8 01             	cmp    $0x1,%eax
  8004200421:	75 f4                	jne    8004200417 <boot_aps+0x1be>

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  8004200423:	48 83 45 f8 78       	addq   $0x78,-0x8(%rbp)
  8004200428:	48 b8 e8 a3 60 04 80 	movabs $0x800460a3e8,%rax
  800420042f:	00 00 00 
  8004200432:	8b 00                	mov    (%rax),%eax
  8004200434:	48 98                	cltq   
  8004200436:	48 c1 e0 03          	shl    $0x3,%rax
  800420043a:	48 89 c2             	mov    %rax,%rdx
  800420043d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200441:	48 29 c2             	sub    %rax,%rdx
  8004200444:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  800420044b:	00 00 00 
  800420044e:	48 01 d0             	add    %rdx,%rax
  8004200451:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200455:	0f 87 c2 fe ff ff    	ja     800420031d <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  800420045b:	c9                   	leaveq 
  800420045c:	c3                   	retq   

000000800420045d <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  800420045d:	55                   	push   %rbp
  800420045e:	48 89 e5             	mov    %rsp,%rbp
  8004200461:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  8004200465:	48 b8 70 87 60 04 80 	movabs $0x8004608770,%rax
  800420046c:	00 00 00 
  800420046f:	48 8b 00             	mov    (%rax),%rax
  8004200472:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004200476:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420047a:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  800420047d:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004200484:	00 00 00 
  8004200487:	ff d0                	callq  *%rax
  8004200489:	89 c6                	mov    %eax,%esi
  800420048b:	48 bf 8c 81 21 04 80 	movabs $0x800421818c,%rdi
  8004200492:	00 00 00 
  8004200495:	b8 00 00 00 00       	mov    $0x0,%eax
  800420049a:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042004a1:	00 00 00 
  80042004a4:	ff d2                	callq  *%rdx

	lapic_init();
  80042004a6:	48 b8 32 67 21 04 80 	movabs $0x8004216732,%rax
  80042004ad:	00 00 00 
  80042004b0:	ff d0                	callq  *%rax
	env_init_percpu();
  80042004b2:	48 b8 bc 7a 20 04 80 	movabs $0x8004207abc,%rax
  80042004b9:	00 00 00 
  80042004bc:	ff d0                	callq  *%rax
	trap_init_percpu();
  80042004be:	48 b8 eb b6 20 04 80 	movabs $0x800420b6eb,%rax
  80042004c5:	00 00 00 
  80042004c8:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  80042004ca:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  80042004d1:	00 00 00 
  80042004d4:	ff d0                	callq  *%rax
  80042004d6:	48 98                	cltq   
  80042004d8:	48 c1 e0 03          	shl    $0x3,%rax
  80042004dc:	48 89 c2             	mov    %rax,%rdx
  80042004df:	48 c1 e2 04          	shl    $0x4,%rdx
  80042004e3:	48 29 c2             	sub    %rax,%rdx
  80042004e6:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  80042004ed:	00 00 00 
  80042004f0:	48 01 d0             	add    %rdx,%rax
  80042004f3:	48 83 c0 04          	add    $0x4,%rax
  80042004f7:	be 01 00 00 00       	mov    $0x1,%esi
  80042004fc:	48 89 c7             	mov    %rax,%rdi
  80042004ff:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  8004200506:	00 00 00 
  8004200509:	ff d0                	callq  *%rax
	// Now that we have finished some basic setup, call sched_yield()
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:
	lock_kernel();
  800420050b:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200512:	00 00 00 
  8004200515:	ff d0                	callq  *%rax
	sched_yield();
  8004200517:	48 b8 c9 ce 20 04 80 	movabs $0x800420cec9,%rax
  800420051e:	00 00 00 
  8004200521:	ff d0                	callq  *%rax

0000008004200523 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  8004200523:	55                   	push   %rbp
  8004200524:	48 89 e5             	mov    %rsp,%rbp
  8004200527:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420052e:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200535:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  800420053b:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200542:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200549:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200550:	84 c0                	test   %al,%al
  8004200552:	74 20                	je     8004200574 <_panic+0x51>
  8004200554:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200558:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420055c:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200560:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200564:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200568:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420056c:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200570:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200574:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  800420057b:	48 b8 60 87 60 04 80 	movabs $0x8004608760,%rax
  8004200582:	00 00 00 
  8004200585:	48 8b 00             	mov    (%rax),%rax
  8004200588:	48 85 c0             	test   %rax,%rax
  800420058b:	74 05                	je     8004200592 <_panic+0x6f>
		goto dead;
  800420058d:	e9 b5 00 00 00       	jmpq   8004200647 <_panic+0x124>
	panicstr = fmt;
  8004200592:	48 b8 60 87 60 04 80 	movabs $0x8004608760,%rax
  8004200599:	00 00 00 
  800420059c:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  80042005a3:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  80042005a6:	fa                   	cli    
  80042005a7:	fc                   	cld    

	va_start(ap, fmt);
  80042005a8:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042005af:	00 00 00 
  80042005b2:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042005b9:	00 00 00 
  80042005bc:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042005c0:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042005c7:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042005ce:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  80042005d5:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  80042005dc:	00 00 00 
  80042005df:	ff d0                	callq  *%rax
  80042005e1:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  80042005e7:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80042005ee:	89 c6                	mov    %eax,%esi
  80042005f0:	48 bf a8 81 21 04 80 	movabs $0x80042181a8,%rdi
  80042005f7:	00 00 00 
  80042005fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042005ff:	49 b8 c3 8d 20 04 80 	movabs $0x8004208dc3,%r8
  8004200606:	00 00 00 
  8004200609:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  800420060c:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200613:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800420061a:	48 89 d6             	mov    %rdx,%rsi
  800420061d:	48 89 c7             	mov    %rax,%rdi
  8004200620:	48 b8 64 8d 20 04 80 	movabs $0x8004208d64,%rax
  8004200627:	00 00 00 
  800420062a:	ff d0                	callq  *%rax
	cprintf("\n");
  800420062c:	48 bf ca 81 21 04 80 	movabs $0x80042181ca,%rdi
  8004200633:	00 00 00 
  8004200636:	b8 00 00 00 00       	mov    $0x0,%eax
  800420063b:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004200642:	00 00 00 
  8004200645:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  8004200647:	bf 00 00 00 00       	mov    $0x0,%edi
  800420064c:	48 b8 2e 1b 20 04 80 	movabs $0x8004201b2e,%rax
  8004200653:	00 00 00 
  8004200656:	ff d0                	callq  *%rax
  8004200658:	eb ed                	jmp    8004200647 <_panic+0x124>

000000800420065a <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  800420065a:	55                   	push   %rbp
  800420065b:	48 89 e5             	mov    %rsp,%rbp
  800420065e:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200665:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420066c:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200672:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200679:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200680:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200687:	84 c0                	test   %al,%al
  8004200689:	74 20                	je     80042006ab <_warn+0x51>
  800420068b:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420068f:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200693:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200697:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420069b:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420069f:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042006a3:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042006a7:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042006ab:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  80042006b2:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042006b9:	00 00 00 
  80042006bc:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042006c3:	00 00 00 
  80042006c6:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042006ca:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042006d1:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042006d8:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  80042006df:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  80042006e5:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042006ec:	48 89 c6             	mov    %rax,%rsi
  80042006ef:	48 bf cc 81 21 04 80 	movabs $0x80042181cc,%rdi
  80042006f6:	00 00 00 
  80042006f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006fe:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  8004200705:	00 00 00 
  8004200708:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  800420070a:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200711:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004200718:	48 89 d6             	mov    %rdx,%rsi
  800420071b:	48 89 c7             	mov    %rax,%rdi
  800420071e:	48 b8 64 8d 20 04 80 	movabs $0x8004208d64,%rax
  8004200725:	00 00 00 
  8004200728:	ff d0                	callq  *%rax
	cprintf("\n");
  800420072a:	48 bf ca 81 21 04 80 	movabs $0x80042181ca,%rdi
  8004200731:	00 00 00 
  8004200734:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200739:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004200740:	00 00 00 
  8004200743:	ff d2                	callq  *%rdx
	va_end(ap);
}
  8004200745:	c9                   	leaveq 
  8004200746:	c3                   	retq   

0000008004200747 <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  8004200747:	55                   	push   %rbp
  8004200748:	48 89 e5             	mov    %rsp,%rbp
  800420074b:	48 83 ec 20          	sub    $0x20,%rsp
  800420074f:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200756:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200759:	89 c2                	mov    %eax,%edx
  800420075b:	ec                   	in     (%dx),%al
  800420075c:	88 45 fb             	mov    %al,-0x5(%rbp)
  800420075f:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  8004200766:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200769:	89 c2                	mov    %eax,%edx
  800420076b:	ec                   	in     (%dx),%al
  800420076c:	88 45 f3             	mov    %al,-0xd(%rbp)
  800420076f:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  8004200776:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200779:	89 c2                	mov    %eax,%edx
  800420077b:	ec                   	in     (%dx),%al
  800420077c:	88 45 eb             	mov    %al,-0x15(%rbp)
  800420077f:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  8004200786:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200789:	89 c2                	mov    %eax,%edx
  800420078b:	ec                   	in     (%dx),%al
  800420078c:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  800420078f:	c9                   	leaveq 
  8004200790:	c3                   	retq   

0000008004200791 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  8004200791:	55                   	push   %rbp
  8004200792:	48 89 e5             	mov    %rsp,%rbp
  8004200795:	48 83 ec 10          	sub    $0x10,%rsp
  8004200799:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  80042007a0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042007a3:	89 c2                	mov    %eax,%edx
  80042007a5:	ec                   	in     (%dx),%al
  80042007a6:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  80042007a9:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  80042007ad:	0f b6 c0             	movzbl %al,%eax
  80042007b0:	83 e0 01             	and    $0x1,%eax
  80042007b3:	85 c0                	test   %eax,%eax
  80042007b5:	75 07                	jne    80042007be <serial_proc_data+0x2d>
		return -1;
  80042007b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042007bc:	eb 17                	jmp    80042007d5 <serial_proc_data+0x44>
  80042007be:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042007c5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042007c8:	89 c2                	mov    %eax,%edx
  80042007ca:	ec                   	in     (%dx),%al
  80042007cb:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  80042007ce:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  80042007d2:	0f b6 c0             	movzbl %al,%eax
}
  80042007d5:	c9                   	leaveq 
  80042007d6:	c3                   	retq   

00000080042007d7 <serial_intr>:

void
serial_intr(void)
{
  80042007d7:	55                   	push   %rbp
  80042007d8:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  80042007db:	48 b8 00 70 60 04 80 	movabs $0x8004607000,%rax
  80042007e2:	00 00 00 
  80042007e5:	0f b6 00             	movzbl (%rax),%eax
  80042007e8:	84 c0                	test   %al,%al
  80042007ea:	74 16                	je     8004200802 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  80042007ec:	48 bf 91 07 20 04 80 	movabs $0x8004200791,%rdi
  80042007f3:	00 00 00 
  80042007f6:	48 b8 77 10 20 04 80 	movabs $0x8004201077,%rax
  80042007fd:	00 00 00 
  8004200800:	ff d0                	callq  *%rax
}
  8004200802:	5d                   	pop    %rbp
  8004200803:	c3                   	retq   

0000008004200804 <serial_putc>:

static void
serial_putc(int c)
{
  8004200804:	55                   	push   %rbp
  8004200805:	48 89 e5             	mov    %rsp,%rbp
  8004200808:	48 83 ec 28          	sub    $0x28,%rsp
  800420080c:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  800420080f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200816:	eb 10                	jmp    8004200828 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  8004200818:	48 b8 47 07 20 04 80 	movabs $0x8004200747,%rax
  800420081f:	00 00 00 
  8004200822:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  8004200824:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200828:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420082f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200832:	89 c2                	mov    %eax,%edx
  8004200834:	ec                   	in     (%dx),%al
  8004200835:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200838:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  800420083c:	0f b6 c0             	movzbl %al,%eax
  800420083f:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  8004200842:	85 c0                	test   %eax,%eax
  8004200844:	75 09                	jne    800420084f <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200846:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  800420084d:	7e c9                	jle    8004200818 <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  800420084f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200852:	0f b6 c0             	movzbl %al,%eax
  8004200855:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  800420085c:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420085f:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200863:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200866:	ee                   	out    %al,(%dx)
}
  8004200867:	c9                   	leaveq 
  8004200868:	c3                   	retq   

0000008004200869 <serial_init>:

static void
serial_init(void)
{
  8004200869:	55                   	push   %rbp
  800420086a:	48 89 e5             	mov    %rsp,%rbp
  800420086d:	48 83 ec 50          	sub    $0x50,%rsp
  8004200871:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  8004200878:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  800420087c:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200880:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200883:	ee                   	out    %al,(%dx)
  8004200884:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  800420088b:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  800420088f:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004200893:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200896:	ee                   	out    %al,(%dx)
  8004200897:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  800420089e:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  80042008a2:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  80042008a6:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042008a9:	ee                   	out    %al,(%dx)
  80042008aa:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  80042008b1:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  80042008b5:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042008b9:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042008bc:	ee                   	out    %al,(%dx)
  80042008bd:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  80042008c4:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  80042008c8:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042008cc:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042008cf:	ee                   	out    %al,(%dx)
  80042008d0:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  80042008d7:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  80042008db:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042008df:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042008e2:	ee                   	out    %al,(%dx)
  80042008e3:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  80042008ea:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  80042008ee:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042008f2:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042008f5:	ee                   	out    %al,(%dx)
  80042008f6:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008fd:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004200900:	89 c2                	mov    %eax,%edx
  8004200902:	ec                   	in     (%dx),%al
  8004200903:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  8004200906:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  800420090a:	3c ff                	cmp    $0xff,%al
  800420090c:	0f 95 c2             	setne  %dl
  800420090f:	48 b8 00 70 60 04 80 	movabs $0x8004607000,%rax
  8004200916:	00 00 00 
  8004200919:	88 10                	mov    %dl,(%rax)
  800420091b:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200922:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004200925:	89 c2                	mov    %eax,%edx
  8004200927:	ec                   	in     (%dx),%al
  8004200928:	88 45 bb             	mov    %al,-0x45(%rbp)
  800420092b:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  8004200932:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004200935:	89 c2                	mov    %eax,%edx
  8004200937:	ec                   	in     (%dx),%al
  8004200938:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	// Enable serial interrupts
	if (serial_exists)
  800420093b:	48 b8 00 70 60 04 80 	movabs $0x8004607000,%rax
  8004200942:	00 00 00 
  8004200945:	0f b6 00             	movzbl (%rax),%eax
  8004200948:	84 c0                	test   %al,%al
  800420094a:	74 23                	je     800420096f <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  800420094c:	48 b8 92 d6 22 04 80 	movabs $0x800422d692,%rax
  8004200953:	00 00 00 
  8004200956:	0f b7 00             	movzwl (%rax),%eax
  8004200959:	0f b7 c0             	movzwl %ax,%eax
  800420095c:	25 ef ff 00 00       	and    $0xffef,%eax
  8004200961:	89 c7                	mov    %eax,%edi
  8004200963:	48 b8 15 8c 20 04 80 	movabs $0x8004208c15,%rax
  800420096a:	00 00 00 
  800420096d:	ff d0                	callq  *%rax
}
  800420096f:	c9                   	leaveq 
  8004200970:	c3                   	retq   

0000008004200971 <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  8004200971:	55                   	push   %rbp
  8004200972:	48 89 e5             	mov    %rsp,%rbp
  8004200975:	48 83 ec 38          	sub    $0x38,%rsp
  8004200979:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  800420097c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200983:	eb 10                	jmp    8004200995 <lpt_putc+0x24>
		delay();
  8004200985:	48 b8 47 07 20 04 80 	movabs $0x8004200747,%rax
  800420098c:	00 00 00 
  800420098f:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200991:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200995:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  800420099c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420099f:	89 c2                	mov    %eax,%edx
  80042009a1:	ec                   	in     (%dx),%al
  80042009a2:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  80042009a5:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  80042009a9:	84 c0                	test   %al,%al
  80042009ab:	78 09                	js     80042009b6 <lpt_putc+0x45>
  80042009ad:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  80042009b4:	7e cf                	jle    8004200985 <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  80042009b6:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042009b9:	0f b6 c0             	movzbl %al,%eax
  80042009bc:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  80042009c3:	88 45 ef             	mov    %al,-0x11(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042009c6:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042009ca:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042009cd:	ee                   	out    %al,(%dx)
  80042009ce:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  80042009d5:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  80042009d9:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042009dd:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042009e0:	ee                   	out    %al,(%dx)
  80042009e1:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  80042009e8:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  80042009ec:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042009f0:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80042009f3:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  80042009f4:	c9                   	leaveq 
  80042009f5:	c3                   	retq   

00000080042009f6 <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  80042009f6:	55                   	push   %rbp
  80042009f7:	48 89 e5             	mov    %rsp,%rbp
  80042009fa:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  80042009fe:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200a05:	00 00 00 
  8004200a08:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  8004200a0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a10:	0f b7 00             	movzwl (%rax),%eax
  8004200a13:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200a17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a1b:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  8004200a20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a24:	0f b7 00             	movzwl (%rax),%eax
  8004200a27:	66 3d 5a a5          	cmp    $0xa55a,%ax
  8004200a2b:	74 20                	je     8004200a4d <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  8004200a2d:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  8004200a34:	00 00 00 
  8004200a37:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  8004200a3b:	48 b8 04 70 60 04 80 	movabs $0x8004607004,%rax
  8004200a42:	00 00 00 
  8004200a45:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200a4b:	eb 1b                	jmp    8004200a68 <cga_init+0x72>
	} else {
		*cp = was;
  8004200a4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a51:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200a55:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200a58:	48 b8 04 70 60 04 80 	movabs $0x8004607004,%rax
  8004200a5f:	00 00 00 
  8004200a62:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200a68:	48 b8 04 70 60 04 80 	movabs $0x8004607004,%rax
  8004200a6f:	00 00 00 
  8004200a72:	8b 00                	mov    (%rax),%eax
  8004200a74:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200a77:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200a7b:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200a7f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200a82:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200a83:	48 b8 04 70 60 04 80 	movabs $0x8004607004,%rax
  8004200a8a:	00 00 00 
  8004200a8d:	8b 00                	mov    (%rax),%eax
  8004200a8f:	83 c0 01             	add    $0x1,%eax
  8004200a92:	89 45 e4             	mov    %eax,-0x1c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a95:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200a98:	89 c2                	mov    %eax,%edx
  8004200a9a:	ec                   	in     (%dx),%al
  8004200a9b:	88 45 e3             	mov    %al,-0x1d(%rbp)
	return data;
  8004200a9e:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200aa2:	0f b6 c0             	movzbl %al,%eax
  8004200aa5:	c1 e0 08             	shl    $0x8,%eax
  8004200aa8:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200aab:	48 b8 04 70 60 04 80 	movabs $0x8004607004,%rax
  8004200ab2:	00 00 00 
  8004200ab5:	8b 00                	mov    (%rax),%eax
  8004200ab7:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004200aba:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200abe:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200ac2:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200ac5:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200ac6:	48 b8 04 70 60 04 80 	movabs $0x8004607004,%rax
  8004200acd:	00 00 00 
  8004200ad0:	8b 00                	mov    (%rax),%eax
  8004200ad2:	83 c0 01             	add    $0x1,%eax
  8004200ad5:	89 45 d4             	mov    %eax,-0x2c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200ad8:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200adb:	89 c2                	mov    %eax,%edx
  8004200add:	ec                   	in     (%dx),%al
  8004200ade:	88 45 d3             	mov    %al,-0x2d(%rbp)
	return data;
  8004200ae1:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200ae5:	0f b6 c0             	movzbl %al,%eax
  8004200ae8:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200aeb:	48 b8 08 70 60 04 80 	movabs $0x8004607008,%rax
  8004200af2:	00 00 00 
  8004200af5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200af9:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200afc:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200aff:	89 c2                	mov    %eax,%edx
  8004200b01:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200b08:	00 00 00 
  8004200b0b:	66 89 10             	mov    %dx,(%rax)
}
  8004200b0e:	c9                   	leaveq 
  8004200b0f:	c3                   	retq   

0000008004200b10 <cga_putc>:



static void
cga_putc(int c)
{
  8004200b10:	55                   	push   %rbp
  8004200b11:	48 89 e5             	mov    %rsp,%rbp
  8004200b14:	48 83 ec 40          	sub    $0x40,%rsp
  8004200b18:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200b1b:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b1e:	b0 00                	mov    $0x0,%al
  8004200b20:	85 c0                	test   %eax,%eax
  8004200b22:	75 07                	jne    8004200b2b <cga_putc+0x1b>
		c |= 0x0700;
  8004200b24:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200b2b:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b2e:	0f b6 c0             	movzbl %al,%eax
  8004200b31:	83 f8 09             	cmp    $0x9,%eax
  8004200b34:	0f 84 f6 00 00 00    	je     8004200c30 <cga_putc+0x120>
  8004200b3a:	83 f8 09             	cmp    $0x9,%eax
  8004200b3d:	7f 0a                	jg     8004200b49 <cga_putc+0x39>
  8004200b3f:	83 f8 08             	cmp    $0x8,%eax
  8004200b42:	74 18                	je     8004200b5c <cga_putc+0x4c>
  8004200b44:	e9 3e 01 00 00       	jmpq   8004200c87 <cga_putc+0x177>
  8004200b49:	83 f8 0a             	cmp    $0xa,%eax
  8004200b4c:	74 75                	je     8004200bc3 <cga_putc+0xb3>
  8004200b4e:	83 f8 0d             	cmp    $0xd,%eax
  8004200b51:	0f 84 89 00 00 00    	je     8004200be0 <cga_putc+0xd0>
  8004200b57:	e9 2b 01 00 00       	jmpq   8004200c87 <cga_putc+0x177>
	case '\b':
		if (crt_pos > 0) {
  8004200b5c:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200b63:	00 00 00 
  8004200b66:	0f b7 00             	movzwl (%rax),%eax
  8004200b69:	66 85 c0             	test   %ax,%ax
  8004200b6c:	74 50                	je     8004200bbe <cga_putc+0xae>
			crt_pos--;
  8004200b6e:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200b75:	00 00 00 
  8004200b78:	0f b7 00             	movzwl (%rax),%eax
  8004200b7b:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200b7e:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200b85:	00 00 00 
  8004200b88:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200b8b:	48 b8 08 70 60 04 80 	movabs $0x8004607008,%rax
  8004200b92:	00 00 00 
  8004200b95:	48 8b 10             	mov    (%rax),%rdx
  8004200b98:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200b9f:	00 00 00 
  8004200ba2:	0f b7 00             	movzwl (%rax),%eax
  8004200ba5:	0f b7 c0             	movzwl %ax,%eax
  8004200ba8:	48 01 c0             	add    %rax,%rax
  8004200bab:	48 01 c2             	add    %rax,%rdx
  8004200bae:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200bb1:	b0 00                	mov    $0x0,%al
  8004200bb3:	83 c8 20             	or     $0x20,%eax
  8004200bb6:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200bb9:	e9 04 01 00 00       	jmpq   8004200cc2 <cga_putc+0x1b2>
  8004200bbe:	e9 ff 00 00 00       	jmpq   8004200cc2 <cga_putc+0x1b2>
	case '\n':
		crt_pos += CRT_COLS;
  8004200bc3:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200bca:	00 00 00 
  8004200bcd:	0f b7 00             	movzwl (%rax),%eax
  8004200bd0:	8d 50 50             	lea    0x50(%rax),%edx
  8004200bd3:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200bda:	00 00 00 
  8004200bdd:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200be0:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200be7:	00 00 00 
  8004200bea:	0f b7 30             	movzwl (%rax),%esi
  8004200bed:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200bf4:	00 00 00 
  8004200bf7:	0f b7 08             	movzwl (%rax),%ecx
  8004200bfa:	0f b7 c1             	movzwl %cx,%eax
  8004200bfd:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200c03:	c1 e8 10             	shr    $0x10,%eax
  8004200c06:	89 c2                	mov    %eax,%edx
  8004200c08:	66 c1 ea 06          	shr    $0x6,%dx
  8004200c0c:	89 d0                	mov    %edx,%eax
  8004200c0e:	c1 e0 02             	shl    $0x2,%eax
  8004200c11:	01 d0                	add    %edx,%eax
  8004200c13:	c1 e0 04             	shl    $0x4,%eax
  8004200c16:	29 c1                	sub    %eax,%ecx
  8004200c18:	89 ca                	mov    %ecx,%edx
  8004200c1a:	29 d6                	sub    %edx,%esi
  8004200c1c:	89 f2                	mov    %esi,%edx
  8004200c1e:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200c25:	00 00 00 
  8004200c28:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200c2b:	e9 92 00 00 00       	jmpq   8004200cc2 <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200c30:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c35:	48 b8 b4 11 20 04 80 	movabs $0x80042011b4,%rax
  8004200c3c:	00 00 00 
  8004200c3f:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c41:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c46:	48 b8 b4 11 20 04 80 	movabs $0x80042011b4,%rax
  8004200c4d:	00 00 00 
  8004200c50:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c52:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c57:	48 b8 b4 11 20 04 80 	movabs $0x80042011b4,%rax
  8004200c5e:	00 00 00 
  8004200c61:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c63:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c68:	48 b8 b4 11 20 04 80 	movabs $0x80042011b4,%rax
  8004200c6f:	00 00 00 
  8004200c72:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c74:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c79:	48 b8 b4 11 20 04 80 	movabs $0x80042011b4,%rax
  8004200c80:	00 00 00 
  8004200c83:	ff d0                	callq  *%rax
		break;
  8004200c85:	eb 3b                	jmp    8004200cc2 <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200c87:	48 b8 08 70 60 04 80 	movabs $0x8004607008,%rax
  8004200c8e:	00 00 00 
  8004200c91:	48 8b 30             	mov    (%rax),%rsi
  8004200c94:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200c9b:	00 00 00 
  8004200c9e:	0f b7 00             	movzwl (%rax),%eax
  8004200ca1:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200ca4:	48 ba 10 70 60 04 80 	movabs $0x8004607010,%rdx
  8004200cab:	00 00 00 
  8004200cae:	66 89 0a             	mov    %cx,(%rdx)
  8004200cb1:	0f b7 c0             	movzwl %ax,%eax
  8004200cb4:	48 01 c0             	add    %rax,%rax
  8004200cb7:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  8004200cbb:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200cbe:	66 89 02             	mov    %ax,(%rdx)
		break;
  8004200cc1:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200cc2:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200cc9:	00 00 00 
  8004200ccc:	0f b7 00             	movzwl (%rax),%eax
  8004200ccf:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200cd3:	0f 86 89 00 00 00    	jbe    8004200d62 <cga_putc+0x252>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200cd9:	48 b8 08 70 60 04 80 	movabs $0x8004607008,%rax
  8004200ce0:	00 00 00 
  8004200ce3:	48 8b 00             	mov    (%rax),%rax
  8004200ce6:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200ced:	48 b8 08 70 60 04 80 	movabs $0x8004607008,%rax
  8004200cf4:	00 00 00 
  8004200cf7:	48 8b 00             	mov    (%rax),%rax
  8004200cfa:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200cff:	48 89 ce             	mov    %rcx,%rsi
  8004200d02:	48 89 c7             	mov    %rax,%rdi
  8004200d05:	48 b8 13 fa 20 04 80 	movabs $0x800420fa13,%rax
  8004200d0c:	00 00 00 
  8004200d0f:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d11:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200d18:	eb 22                	jmp    8004200d3c <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200d1a:	48 b8 08 70 60 04 80 	movabs $0x8004607008,%rax
  8004200d21:	00 00 00 
  8004200d24:	48 8b 00             	mov    (%rax),%rax
  8004200d27:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200d2a:	48 63 d2             	movslq %edx,%rdx
  8004200d2d:	48 01 d2             	add    %rdx,%rdx
  8004200d30:	48 01 d0             	add    %rdx,%rax
  8004200d33:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d38:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200d3c:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200d43:	7e d5                	jle    8004200d1a <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200d45:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200d4c:	00 00 00 
  8004200d4f:	0f b7 00             	movzwl (%rax),%eax
  8004200d52:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200d55:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200d5c:	00 00 00 
  8004200d5f:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200d62:	48 b8 04 70 60 04 80 	movabs $0x8004607004,%rax
  8004200d69:	00 00 00 
  8004200d6c:	8b 00                	mov    (%rax),%eax
  8004200d6e:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200d71:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200d75:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200d79:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200d7c:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200d7d:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200d84:	00 00 00 
  8004200d87:	0f b7 00             	movzwl (%rax),%eax
  8004200d8a:	66 c1 e8 08          	shr    $0x8,%ax
  8004200d8e:	0f b6 c0             	movzbl %al,%eax
  8004200d91:	48 ba 04 70 60 04 80 	movabs $0x8004607004,%rdx
  8004200d98:	00 00 00 
  8004200d9b:	8b 12                	mov    (%rdx),%edx
  8004200d9d:	83 c2 01             	add    $0x1,%edx
  8004200da0:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200da3:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200da6:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200daa:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200dad:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200dae:	48 b8 04 70 60 04 80 	movabs $0x8004607004,%rax
  8004200db5:	00 00 00 
  8004200db8:	8b 00                	mov    (%rax),%eax
  8004200dba:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200dbd:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200dc1:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200dc5:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200dc8:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200dc9:	48 b8 10 70 60 04 80 	movabs $0x8004607010,%rax
  8004200dd0:	00 00 00 
  8004200dd3:	0f b7 00             	movzwl (%rax),%eax
  8004200dd6:	0f b6 c0             	movzbl %al,%eax
  8004200dd9:	48 ba 04 70 60 04 80 	movabs $0x8004607004,%rdx
  8004200de0:	00 00 00 
  8004200de3:	8b 12                	mov    (%rdx),%edx
  8004200de5:	83 c2 01             	add    $0x1,%edx
  8004200de8:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200deb:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200dee:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200df2:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200df5:	ee                   	out    %al,(%dx)
}
  8004200df6:	c9                   	leaveq 
  8004200df7:	c3                   	retq   

0000008004200df8 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200df8:	55                   	push   %rbp
  8004200df9:	48 89 e5             	mov    %rsp,%rbp
  8004200dfc:	48 83 ec 20          	sub    $0x20,%rsp
  8004200e00:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e07:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200e0a:	89 c2                	mov    %eax,%edx
  8004200e0c:	ec                   	in     (%dx),%al
  8004200e0d:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200e10:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200e14:	0f b6 c0             	movzbl %al,%eax
  8004200e17:	83 e0 01             	and    $0x1,%eax
  8004200e1a:	85 c0                	test   %eax,%eax
  8004200e1c:	75 0a                	jne    8004200e28 <kbd_proc_data+0x30>
		return -1;
  8004200e1e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200e23:	e9 fc 01 00 00       	jmpq   8004201024 <kbd_proc_data+0x22c>
  8004200e28:	c7 45 ec 60 00 00 00 	movl   $0x60,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e2f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200e32:	89 c2                	mov    %eax,%edx
  8004200e34:	ec                   	in     (%dx),%al
  8004200e35:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  8004200e38:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax

	data = inb(KBDATAP);
  8004200e3c:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200e3f:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200e43:	75 27                	jne    8004200e6c <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200e45:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200e4c:	00 00 00 
  8004200e4f:	8b 00                	mov    (%rax),%eax
  8004200e51:	83 c8 40             	or     $0x40,%eax
  8004200e54:	89 c2                	mov    %eax,%edx
  8004200e56:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200e5d:	00 00 00 
  8004200e60:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e62:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e67:	e9 b8 01 00 00       	jmpq   8004201024 <kbd_proc_data+0x22c>
	} else if (data & 0x80) {
  8004200e6c:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e70:	84 c0                	test   %al,%al
  8004200e72:	79 65                	jns    8004200ed9 <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200e74:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200e7b:	00 00 00 
  8004200e7e:	8b 00                	mov    (%rax),%eax
  8004200e80:	83 e0 40             	and    $0x40,%eax
  8004200e83:	85 c0                	test   %eax,%eax
  8004200e85:	75 09                	jne    8004200e90 <kbd_proc_data+0x98>
  8004200e87:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e8b:	83 e0 7f             	and    $0x7f,%eax
  8004200e8e:	eb 04                	jmp    8004200e94 <kbd_proc_data+0x9c>
  8004200e90:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e94:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200e97:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e9b:	48 ba 60 d0 22 04 80 	movabs $0x800422d060,%rdx
  8004200ea2:	00 00 00 
  8004200ea5:	48 98                	cltq   
  8004200ea7:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200eab:	83 c8 40             	or     $0x40,%eax
  8004200eae:	0f b6 c0             	movzbl %al,%eax
  8004200eb1:	f7 d0                	not    %eax
  8004200eb3:	89 c2                	mov    %eax,%edx
  8004200eb5:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200ebc:	00 00 00 
  8004200ebf:	8b 00                	mov    (%rax),%eax
  8004200ec1:	21 c2                	and    %eax,%edx
  8004200ec3:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200eca:	00 00 00 
  8004200ecd:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200ecf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200ed4:	e9 4b 01 00 00       	jmpq   8004201024 <kbd_proc_data+0x22c>
	} else if (shift & E0ESC) {
  8004200ed9:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200ee0:	00 00 00 
  8004200ee3:	8b 00                	mov    (%rax),%eax
  8004200ee5:	83 e0 40             	and    $0x40,%eax
  8004200ee8:	85 c0                	test   %eax,%eax
  8004200eea:	74 21                	je     8004200f0d <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200eec:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200ef0:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200ef7:	00 00 00 
  8004200efa:	8b 00                	mov    (%rax),%eax
  8004200efc:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200eff:	89 c2                	mov    %eax,%edx
  8004200f01:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200f08:	00 00 00 
  8004200f0b:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200f0d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f11:	48 ba 60 d0 22 04 80 	movabs $0x800422d060,%rdx
  8004200f18:	00 00 00 
  8004200f1b:	48 98                	cltq   
  8004200f1d:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f21:	0f b6 d0             	movzbl %al,%edx
  8004200f24:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200f2b:	00 00 00 
  8004200f2e:	8b 00                	mov    (%rax),%eax
  8004200f30:	09 c2                	or     %eax,%edx
  8004200f32:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200f39:	00 00 00 
  8004200f3c:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200f3e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f42:	48 ba 60 d1 22 04 80 	movabs $0x800422d160,%rdx
  8004200f49:	00 00 00 
  8004200f4c:	48 98                	cltq   
  8004200f4e:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f52:	0f b6 d0             	movzbl %al,%edx
  8004200f55:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200f5c:	00 00 00 
  8004200f5f:	8b 00                	mov    (%rax),%eax
  8004200f61:	31 c2                	xor    %eax,%edx
  8004200f63:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200f6a:	00 00 00 
  8004200f6d:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200f6f:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200f76:	00 00 00 
  8004200f79:	8b 00                	mov    (%rax),%eax
  8004200f7b:	83 e0 03             	and    $0x3,%eax
  8004200f7e:	89 c2                	mov    %eax,%edx
  8004200f80:	48 b8 60 d5 22 04 80 	movabs $0x800422d560,%rax
  8004200f87:	00 00 00 
  8004200f8a:	89 d2                	mov    %edx,%edx
  8004200f8c:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200f90:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f94:	48 01 d0             	add    %rdx,%rax
  8004200f97:	0f b6 00             	movzbl (%rax),%eax
  8004200f9a:	0f b6 c0             	movzbl %al,%eax
  8004200f9d:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200fa0:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200fa7:	00 00 00 
  8004200faa:	8b 00                	mov    (%rax),%eax
  8004200fac:	83 e0 08             	and    $0x8,%eax
  8004200faf:	85 c0                	test   %eax,%eax
  8004200fb1:	74 22                	je     8004200fd5 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200fb3:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200fb7:	7e 0c                	jle    8004200fc5 <kbd_proc_data+0x1cd>
  8004200fb9:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200fbd:	7f 06                	jg     8004200fc5 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200fbf:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200fc3:	eb 10                	jmp    8004200fd5 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200fc5:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200fc9:	7e 0a                	jle    8004200fd5 <kbd_proc_data+0x1dd>
  8004200fcb:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200fcf:	7f 04                	jg     8004200fd5 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200fd1:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200fd5:	48 b8 28 72 60 04 80 	movabs $0x8004607228,%rax
  8004200fdc:	00 00 00 
  8004200fdf:	8b 00                	mov    (%rax),%eax
  8004200fe1:	f7 d0                	not    %eax
  8004200fe3:	83 e0 06             	and    $0x6,%eax
  8004200fe6:	85 c0                	test   %eax,%eax
  8004200fe8:	75 37                	jne    8004201021 <kbd_proc_data+0x229>
  8004200fea:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004200ff1:	75 2e                	jne    8004201021 <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004200ff3:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004200ffa:	00 00 00 
  8004200ffd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201002:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004201009:	00 00 00 
  800420100c:	ff d2                	callq  *%rdx
  800420100e:	c7 45 e4 92 00 00 00 	movl   $0x92,-0x1c(%rbp)
  8004201015:	c6 45 e3 03          	movb   $0x3,-0x1d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004201019:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  800420101d:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201020:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}
	return c;
  8004201021:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004201024:	c9                   	leaveq 
  8004201025:	c3                   	retq   

0000008004201026 <kbd_intr>:

void
kbd_intr(void)
{
  8004201026:	55                   	push   %rbp
  8004201027:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  800420102a:	48 bf f8 0d 20 04 80 	movabs $0x8004200df8,%rdi
  8004201031:	00 00 00 
  8004201034:	48 b8 77 10 20 04 80 	movabs $0x8004201077,%rax
  800420103b:	00 00 00 
  800420103e:	ff d0                	callq  *%rax
}
  8004201040:	5d                   	pop    %rbp
  8004201041:	c3                   	retq   

0000008004201042 <kbd_init>:

static void
kbd_init(void)
{
  8004201042:	55                   	push   %rbp
  8004201043:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004201046:	48 b8 26 10 20 04 80 	movabs $0x8004201026,%rax
  800420104d:	00 00 00 
  8004201050:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  8004201052:	48 b8 92 d6 22 04 80 	movabs $0x800422d692,%rax
  8004201059:	00 00 00 
  800420105c:	0f b7 00             	movzwl (%rax),%eax
  800420105f:	0f b7 c0             	movzwl %ax,%eax
  8004201062:	25 fd ff 00 00       	and    $0xfffd,%eax
  8004201067:	89 c7                	mov    %eax,%edi
  8004201069:	48 b8 15 8c 20 04 80 	movabs $0x8004208c15,%rax
  8004201070:	00 00 00 
  8004201073:	ff d0                	callq  *%rax
}
  8004201075:	5d                   	pop    %rbp
  8004201076:	c3                   	retq   

0000008004201077 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  8004201077:	55                   	push   %rbp
  8004201078:	48 89 e5             	mov    %rsp,%rbp
  800420107b:	48 83 ec 20          	sub    $0x20,%rsp
  800420107f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  8004201083:	eb 6a                	jmp    80042010ef <cons_intr+0x78>
		if (c == 0)
  8004201085:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201089:	75 02                	jne    800420108d <cons_intr+0x16>
			continue;
  800420108b:	eb 62                	jmp    80042010ef <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  800420108d:	48 b8 20 70 60 04 80 	movabs $0x8004607020,%rax
  8004201094:	00 00 00 
  8004201097:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420109d:	8d 48 01             	lea    0x1(%rax),%ecx
  80042010a0:	48 ba 20 70 60 04 80 	movabs $0x8004607020,%rdx
  80042010a7:	00 00 00 
  80042010aa:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  80042010b0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042010b3:	89 d1                	mov    %edx,%ecx
  80042010b5:	48 ba 20 70 60 04 80 	movabs $0x8004607020,%rdx
  80042010bc:	00 00 00 
  80042010bf:	89 c0                	mov    %eax,%eax
  80042010c1:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  80042010c4:	48 b8 20 70 60 04 80 	movabs $0x8004607020,%rax
  80042010cb:	00 00 00 
  80042010ce:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010d4:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042010d9:	75 14                	jne    80042010ef <cons_intr+0x78>
			cons.wpos = 0;
  80042010db:	48 b8 20 70 60 04 80 	movabs $0x8004607020,%rax
  80042010e2:	00 00 00 
  80042010e5:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  80042010ec:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  80042010ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042010f3:	ff d0                	callq  *%rax
  80042010f5:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042010f8:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80042010fc:	75 87                	jne    8004201085 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  80042010fe:	c9                   	leaveq 
  80042010ff:	c3                   	retq   

0000008004201100 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  8004201100:	55                   	push   %rbp
  8004201101:	48 89 e5             	mov    %rsp,%rbp
  8004201104:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  8004201108:	48 b8 d7 07 20 04 80 	movabs $0x80042007d7,%rax
  800420110f:	00 00 00 
  8004201112:	ff d0                	callq  *%rax
	kbd_intr();
  8004201114:	48 b8 26 10 20 04 80 	movabs $0x8004201026,%rax
  800420111b:	00 00 00 
  800420111e:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  8004201120:	48 b8 20 70 60 04 80 	movabs $0x8004607020,%rax
  8004201127:	00 00 00 
  800420112a:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  8004201130:	48 b8 20 70 60 04 80 	movabs $0x8004607020,%rax
  8004201137:	00 00 00 
  800420113a:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201140:	39 c2                	cmp    %eax,%edx
  8004201142:	74 69                	je     80042011ad <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  8004201144:	48 b8 20 70 60 04 80 	movabs $0x8004607020,%rax
  800420114b:	00 00 00 
  800420114e:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201154:	8d 48 01             	lea    0x1(%rax),%ecx
  8004201157:	48 ba 20 70 60 04 80 	movabs $0x8004607020,%rdx
  800420115e:	00 00 00 
  8004201161:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  8004201167:	48 ba 20 70 60 04 80 	movabs $0x8004607020,%rdx
  800420116e:	00 00 00 
  8004201171:	89 c0                	mov    %eax,%eax
  8004201173:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201177:	0f b6 c0             	movzbl %al,%eax
  800420117a:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  800420117d:	48 b8 20 70 60 04 80 	movabs $0x8004607020,%rax
  8004201184:	00 00 00 
  8004201187:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  800420118d:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004201192:	75 14                	jne    80042011a8 <cons_getc+0xa8>
			cons.rpos = 0;
  8004201194:	48 b8 20 70 60 04 80 	movabs $0x8004607020,%rax
  800420119b:	00 00 00 
  800420119e:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  80042011a5:	00 00 00 
		return c;
  80042011a8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011ab:	eb 05                	jmp    80042011b2 <cons_getc+0xb2>
	}
	return 0;
  80042011ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042011b2:	c9                   	leaveq 
  80042011b3:	c3                   	retq   

00000080042011b4 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  80042011b4:	55                   	push   %rbp
  80042011b5:	48 89 e5             	mov    %rsp,%rbp
  80042011b8:	48 83 ec 10          	sub    $0x10,%rsp
  80042011bc:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  80042011bf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011c2:	89 c7                	mov    %eax,%edi
  80042011c4:	48 b8 04 08 20 04 80 	movabs $0x8004200804,%rax
  80042011cb:	00 00 00 
  80042011ce:	ff d0                	callq  *%rax
	lpt_putc(c);
  80042011d0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011d3:	89 c7                	mov    %eax,%edi
  80042011d5:	48 b8 71 09 20 04 80 	movabs $0x8004200971,%rax
  80042011dc:	00 00 00 
  80042011df:	ff d0                	callq  *%rax
	cga_putc(c);
  80042011e1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011e4:	89 c7                	mov    %eax,%edi
  80042011e6:	48 b8 10 0b 20 04 80 	movabs $0x8004200b10,%rax
  80042011ed:	00 00 00 
  80042011f0:	ff d0                	callq  *%rax
}
  80042011f2:	c9                   	leaveq 
  80042011f3:	c3                   	retq   

00000080042011f4 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  80042011f4:	55                   	push   %rbp
  80042011f5:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  80042011f8:	48 b8 f6 09 20 04 80 	movabs $0x80042009f6,%rax
  80042011ff:	00 00 00 
  8004201202:	ff d0                	callq  *%rax
	kbd_init();
  8004201204:	48 b8 42 10 20 04 80 	movabs $0x8004201042,%rax
  800420120b:	00 00 00 
  800420120e:	ff d0                	callq  *%rax
	serial_init();
  8004201210:	48 b8 69 08 20 04 80 	movabs $0x8004200869,%rax
  8004201217:	00 00 00 
  800420121a:	ff d0                	callq  *%rax

	if (!serial_exists)
  800420121c:	48 b8 00 70 60 04 80 	movabs $0x8004607000,%rax
  8004201223:	00 00 00 
  8004201226:	0f b6 00             	movzbl (%rax),%eax
  8004201229:	83 f0 01             	xor    $0x1,%eax
  800420122c:	84 c0                	test   %al,%al
  800420122e:	74 1b                	je     800420124b <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  8004201230:	48 bf f2 81 21 04 80 	movabs $0x80042181f2,%rdi
  8004201237:	00 00 00 
  800420123a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420123f:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004201246:	00 00 00 
  8004201249:	ff d2                	callq  *%rdx
}
  800420124b:	5d                   	pop    %rbp
  800420124c:	c3                   	retq   

000000800420124d <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  800420124d:	55                   	push   %rbp
  800420124e:	48 89 e5             	mov    %rsp,%rbp
  8004201251:	48 83 ec 10          	sub    $0x10,%rsp
  8004201255:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  8004201258:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420125b:	89 c7                	mov    %eax,%edi
  800420125d:	48 b8 b4 11 20 04 80 	movabs $0x80042011b4,%rax
  8004201264:	00 00 00 
  8004201267:	ff d0                	callq  *%rax
}
  8004201269:	c9                   	leaveq 
  800420126a:	c3                   	retq   

000000800420126b <getchar>:

int
getchar(void)
{
  800420126b:	55                   	push   %rbp
  800420126c:	48 89 e5             	mov    %rsp,%rbp
  800420126f:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  8004201273:	48 b8 00 11 20 04 80 	movabs $0x8004201100,%rax
  800420127a:	00 00 00 
  800420127d:	ff d0                	callq  *%rax
  800420127f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201282:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201286:	74 eb                	je     8004201273 <getchar+0x8>
		/* do nothing */;
	return c;
  8004201288:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420128b:	c9                   	leaveq 
  800420128c:	c3                   	retq   

000000800420128d <iscons>:

int
iscons(int fdnum)
{
  800420128d:	55                   	push   %rbp
  800420128e:	48 89 e5             	mov    %rsp,%rbp
  8004201291:	48 83 ec 04          	sub    $0x4,%rsp
  8004201295:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  8004201298:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800420129d:	c9                   	leaveq 
  800420129e:	c3                   	retq   

000000800420129f <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  800420129f:	55                   	push   %rbp
  80042012a0:	48 89 e5             	mov    %rsp,%rbp
  80042012a3:	48 83 ec 30          	sub    $0x30,%rsp
  80042012a7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042012aa:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042012ae:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042012b2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042012b9:	eb 6c                	jmp    8004201327 <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  80042012bb:	48 b9 80 d5 22 04 80 	movabs $0x800422d580,%rcx
  80042012c2:	00 00 00 
  80042012c5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012c8:	48 63 d0             	movslq %eax,%rdx
  80042012cb:	48 89 d0             	mov    %rdx,%rax
  80042012ce:	48 01 c0             	add    %rax,%rax
  80042012d1:	48 01 d0             	add    %rdx,%rax
  80042012d4:	48 c1 e0 03          	shl    $0x3,%rax
  80042012d8:	48 01 c8             	add    %rcx,%rax
  80042012db:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042012df:	48 be 80 d5 22 04 80 	movabs $0x800422d580,%rsi
  80042012e6:	00 00 00 
  80042012e9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012ec:	48 63 d0             	movslq %eax,%rdx
  80042012ef:	48 89 d0             	mov    %rdx,%rax
  80042012f2:	48 01 c0             	add    %rax,%rax
  80042012f5:	48 01 d0             	add    %rdx,%rax
  80042012f8:	48 c1 e0 03          	shl    $0x3,%rax
  80042012fc:	48 01 f0             	add    %rsi,%rax
  80042012ff:	48 8b 00             	mov    (%rax),%rax
  8004201302:	48 89 ca             	mov    %rcx,%rdx
  8004201305:	48 89 c6             	mov    %rax,%rsi
  8004201308:	48 bf 8a 82 21 04 80 	movabs $0x800421828a,%rdi
  800420130f:	00 00 00 
  8004201312:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201317:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  800420131e:	00 00 00 
  8004201321:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201323:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201327:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420132a:	83 f8 02             	cmp    $0x2,%eax
  800420132d:	76 8c                	jbe    80042012bb <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	cprintf("%d",sizeof(int));	
  800420132f:	be 04 00 00 00       	mov    $0x4,%esi
  8004201334:	48 bf 93 82 21 04 80 	movabs $0x8004218293,%rdi
  800420133b:	00 00 00 
  800420133e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201343:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420134a:	00 00 00 
  800420134d:	ff d2                	callq  *%rdx
	return 0;
  800420134f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201354:	c9                   	leaveq 
  8004201355:	c3                   	retq   

0000008004201356 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  8004201356:	55                   	push   %rbp
  8004201357:	48 89 e5             	mov    %rsp,%rbp
  800420135a:	48 83 ec 30          	sub    $0x30,%rsp
  800420135e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004201361:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201365:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  8004201369:	48 bf 96 82 21 04 80 	movabs $0x8004218296,%rdi
  8004201370:	00 00 00 
  8004201373:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201378:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420137f:	00 00 00 
  8004201382:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  8004201384:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  800420138b:	00 00 00 
  800420138e:	48 bf b0 82 21 04 80 	movabs $0x80042182b0,%rdi
  8004201395:	00 00 00 
  8004201398:	b8 00 00 00 00       	mov    $0x0,%eax
  800420139d:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042013a4:	00 00 00 
  80042013a7:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  80042013a9:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  80042013b0:	00 00 00 
  80042013b3:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  80042013ba:	00 00 00 
  80042013bd:	48 bf d8 82 21 04 80 	movabs $0x80042182d8,%rdi
  80042013c4:	00 00 00 
  80042013c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013cc:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  80042013d3:	00 00 00 
  80042013d6:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  80042013d8:	48 ba ce 80 21 00 00 	movabs $0x2180ce,%rdx
  80042013df:	00 00 00 
  80042013e2:	48 be ce 80 21 04 80 	movabs $0x80042180ce,%rsi
  80042013e9:	00 00 00 
  80042013ec:	48 bf 00 83 21 04 80 	movabs $0x8004218300,%rdi
  80042013f3:	00 00 00 
  80042013f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013fb:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  8004201402:	00 00 00 
  8004201405:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  8004201407:	48 ba ca 60 60 00 00 	movabs $0x6060ca,%rdx
  800420140e:	00 00 00 
  8004201411:	48 be ca 60 60 04 80 	movabs $0x80046060ca,%rsi
  8004201418:	00 00 00 
  800420141b:	48 bf 28 83 21 04 80 	movabs $0x8004218328,%rdi
  8004201422:	00 00 00 
  8004201425:	b8 00 00 00 00       	mov    $0x0,%eax
  800420142a:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  8004201431:	00 00 00 
  8004201434:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004201436:	48 ba 28 b4 68 00 00 	movabs $0x68b428,%rdx
  800420143d:	00 00 00 
  8004201440:	48 be 28 b4 68 04 80 	movabs $0x800468b428,%rsi
  8004201447:	00 00 00 
  800420144a:	48 bf 50 83 21 04 80 	movabs $0x8004218350,%rdi
  8004201451:	00 00 00 
  8004201454:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201459:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  8004201460:	00 00 00 
  8004201463:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  8004201465:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800420146c:	00 
  800420146d:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201474:	00 00 00 
  8004201477:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420147b:	48 29 c2             	sub    %rax,%rdx
  800420147e:	48 b8 28 b4 68 04 80 	movabs $0x800468b428,%rax
  8004201485:	00 00 00 
  8004201488:	48 83 e8 01          	sub    $0x1,%rax
  800420148c:	48 01 d0             	add    %rdx,%rax
  800420148f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201493:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201497:	ba 00 00 00 00       	mov    $0x0,%edx
  800420149c:	48 f7 75 f8          	divq   -0x8(%rbp)
  80042014a0:	48 89 d0             	mov    %rdx,%rax
  80042014a3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042014a7:	48 29 c2             	sub    %rax,%rdx
  80042014aa:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  80042014ad:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  80042014b4:	48 85 c0             	test   %rax,%rax
  80042014b7:	48 0f 48 c2          	cmovs  %rdx,%rax
  80042014bb:	48 c1 f8 0a          	sar    $0xa,%rax
  80042014bf:	48 89 c6             	mov    %rax,%rsi
  80042014c2:	48 bf 78 83 21 04 80 	movabs $0x8004218378,%rdi
  80042014c9:	00 00 00 
  80042014cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014d1:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042014d8:	00 00 00 
  80042014db:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  80042014dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042014e2:	c9                   	leaveq 
  80042014e3:	c3                   	retq   

00000080042014e4 <printArgList>:

void printArgList(uint64_t* prbp, struct Ripdebuginfo *info)
{
  80042014e4:	55                   	push   %rbp
  80042014e5:	48 89 e5             	mov    %rsp,%rbp
  80042014e8:	48 83 ec 30          	sub    $0x30,%rsp
  80042014ec:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042014f0:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t* tprbp = (uint64_t*)(prbp - 4);
  80042014f4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042014f8:	48 83 e8 20          	sub    $0x20,%rax
  80042014fc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	int numberArg = info->rip_fn_narg;
  8004201500:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201504:	8b 40 28             	mov    0x28(%rax),%eax
  8004201507:	89 45 f4             	mov    %eax,-0xc(%rbp)
	int i = 0;
  800420150a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	uint64_t size = 0;
  8004201511:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004201518:	00 
	if(numberArg <= 0)
  8004201519:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420151d:	7f 20                	jg     800420153f <printArgList+0x5b>
	{
		cprintf("\n");
  800420151f:	48 bf a2 83 21 04 80 	movabs $0x80042183a2,%rdi
  8004201526:	00 00 00 
  8004201529:	b8 00 00 00 00       	mov    $0x0,%eax
  800420152e:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004201535:	00 00 00 
  8004201538:	ff d2                	callq  *%rdx
		return;
  800420153a:	e9 0f 01 00 00       	jmpq   800420164e <printArgList+0x16a>
	}
	
	while(numberArg > 0)
  800420153f:	e9 e5 00 00 00       	jmpq   8004201629 <printArgList+0x145>
	{
		//cprintf("size of argument %d is %d %x",i, info->size_fn_arg[i],*prbp);
		size = info->size_fn_arg[i];
  8004201544:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201548:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800420154b:	48 63 d2             	movslq %edx,%rdx
  800420154e:	48 83 c2 08          	add    $0x8,%rdx
  8004201552:	8b 44 90 0c          	mov    0xc(%rax,%rdx,4),%eax
  8004201556:	48 98                	cltq   
  8004201558:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		cprintf(" ");
  800420155c:	48 bf a4 83 21 04 80 	movabs $0x80042183a4,%rdi
  8004201563:	00 00 00 
  8004201566:	b8 00 00 00 00       	mov    $0x0,%eax
  800420156b:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004201572:	00 00 00 
  8004201575:	ff d2                	callq  *%rdx
		switch(size)
  8004201577:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420157b:	48 83 f8 04          	cmp    $0x4,%rax
  800420157f:	74 43                	je     80042015c4 <printArgList+0xe0>
  8004201581:	48 83 f8 08          	cmp    $0x8,%rax
  8004201585:	74 6b                	je     80042015f2 <printArgList+0x10e>
  8004201587:	48 83 f8 01          	cmp    $0x1,%rax
  800420158b:	74 05                	je     8004201592 <printArgList+0xae>
			case 8:
				cprintf("%016x",*(tprbp -1));
				tprbp = tprbp - 1;
				break;
			default:
				break;
  800420158d:	e9 8f 00 00 00       	jmpq   8004201621 <printArgList+0x13d>
		size = info->size_fn_arg[i];
		cprintf(" ");
		switch(size)
		{
			case 1:
				cprintf("%016x",*((char*)tprbp -1));
  8004201592:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201596:	48 83 e8 01          	sub    $0x1,%rax
  800420159a:	0f b6 00             	movzbl (%rax),%eax
  800420159d:	0f be c0             	movsbl %al,%eax
  80042015a0:	89 c6                	mov    %eax,%esi
  80042015a2:	48 bf a6 83 21 04 80 	movabs $0x80042183a6,%rdi
  80042015a9:	00 00 00 
  80042015ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015b1:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042015b8:	00 00 00 
  80042015bb:	ff d2                	callq  *%rdx
				tprbp = (uint64_t*)((char*)tprbp - 1);
  80042015bd:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
				break;
  80042015c2:	eb 5d                	jmp    8004201621 <printArgList+0x13d>
			case 4:
				cprintf("%016x",*((int*)tprbp -1));
  80042015c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042015c8:	48 83 e8 04          	sub    $0x4,%rax
  80042015cc:	8b 00                	mov    (%rax),%eax
  80042015ce:	89 c6                	mov    %eax,%esi
  80042015d0:	48 bf a6 83 21 04 80 	movabs $0x80042183a6,%rdi
  80042015d7:	00 00 00 
  80042015da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015df:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042015e6:	00 00 00 
  80042015e9:	ff d2                	callq  *%rdx
				tprbp = (uint64_t*)((int*)tprbp - 1);
  80042015eb:	48 83 6d f8 04       	subq   $0x4,-0x8(%rbp)
				break;
  80042015f0:	eb 2f                	jmp    8004201621 <printArgList+0x13d>
			case 8:
				cprintf("%016x",*(tprbp -1));
  80042015f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042015f6:	48 83 e8 08          	sub    $0x8,%rax
  80042015fa:	48 8b 00             	mov    (%rax),%rax
  80042015fd:	48 89 c6             	mov    %rax,%rsi
  8004201600:	48 bf a6 83 21 04 80 	movabs $0x80042183a6,%rdi
  8004201607:	00 00 00 
  800420160a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420160f:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004201616:	00 00 00 
  8004201619:	ff d2                	callq  *%rdx
				tprbp = tprbp - 1;
  800420161b:	48 83 6d f8 08       	subq   $0x8,-0x8(%rbp)
				break;
  8004201620:	90                   	nop
			default:
				break;
		}
		i++;
  8004201621:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
		numberArg--;
  8004201625:	83 6d f4 01          	subl   $0x1,-0xc(%rbp)
	{
		cprintf("\n");
		return;
	}
	
	while(numberArg > 0)
  8004201629:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420162d:	0f 8f 11 ff ff ff    	jg     8004201544 <printArgList+0x60>
				break;
		}
		i++;
		numberArg--;
	}
	cprintf("\n");
  8004201633:	48 bf a2 83 21 04 80 	movabs $0x80042183a2,%rdi
  800420163a:	00 00 00 
  800420163d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201642:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004201649:	00 00 00 
  800420164c:	ff d2                	callq  *%rdx
}
  800420164e:	c9                   	leaveq 
  800420164f:	c3                   	retq   

0000008004201650 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  8004201650:	55                   	push   %rbp
  8004201651:	48 89 e5             	mov    %rsp,%rbp
  8004201654:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  800420165b:	89 bd fc fa ff ff    	mov    %edi,-0x504(%rbp)
  8004201661:	48 89 b5 f0 fa ff ff 	mov    %rsi,-0x510(%rbp)
  8004201668:	48 89 95 e8 fa ff ff 	mov    %rdx,-0x518(%rbp)
	// Your code here.
	uint64_t rbp = 0x0;
  800420166f:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004201676:	00 
	uint64_t rip = 0x0;
  8004201677:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420167e:	00 
	uint64_t* prbp = NULL;
  800420167f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004201686:	00 

	struct Ripdebuginfo info;

	cprintf("Stack backtrace:\n");
  8004201687:	48 bf ac 83 21 04 80 	movabs $0x80042183ac,%rdi
  800420168e:	00 00 00 
  8004201691:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201696:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420169d:	00 00 00 
  80042016a0:	ff d2                	callq  *%rdx

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042016a2:	48 89 e8             	mov    %rbp,%rax
  80042016a5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	return rbp;
  80042016a9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	rbp = read_rbp();
  80042016ad:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	read_rip(rip);
  80042016b1:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 80042016b8 <mon_backtrace+0x68>
  80042016b8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(rbp == 0x0 || rip == 0x0)
  80042016bc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042016c1:	74 07                	je     80042016ca <mon_backtrace+0x7a>
  80042016c3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042016c8:	75 25                	jne    80042016ef <mon_backtrace+0x9f>
	{
		cprintf("Not able to show backtrace");
  80042016ca:	48 bf be 83 21 04 80 	movabs $0x80042183be,%rdi
  80042016d1:	00 00 00 
  80042016d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016d9:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042016e0:	00 00 00 
  80042016e3:	ff d2                	callq  *%rdx
		return -1;
  80042016e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042016ea:	e9 2c 02 00 00       	jmpq   800420191b <mon_backtrace+0x2cb>
	}
	prbp = (uint64_t*)(rbp);
  80042016ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042016f3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("    rbp %016x  rip %016x\n", prbp, rip);
  80042016f7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042016fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042016ff:	48 89 c6             	mov    %rax,%rsi
  8004201702:	48 bf d9 83 21 04 80 	movabs $0x80042183d9,%rdi
  8004201709:	00 00 00 
  800420170c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201711:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  8004201718:	00 00 00 
  800420171b:	ff d1                	callq  *%rcx
	debuginfo_rip(rip ,&info);
  800420171d:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  8004201724:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201728:	48 89 d6             	mov    %rdx,%rsi
  800420172b:	48 89 c7             	mov    %rax,%rdi
  800420172e:	48 b8 f0 e5 20 04 80 	movabs $0x800420e5f0,%rax
  8004201735:	00 00 00 
  8004201738:	ff d0                	callq  *%rax
	
	cprintf("        %s:%d: ",info.rip_file, info.rip_line);
  800420173a:	8b 95 08 fb ff ff    	mov    -0x4f8(%rbp),%edx
  8004201740:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
  8004201747:	48 89 c6             	mov    %rax,%rsi
  800420174a:	48 bf f3 83 21 04 80 	movabs $0x80042183f3,%rdi
  8004201751:	00 00 00 
  8004201754:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201759:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  8004201760:	00 00 00 
  8004201763:	ff d1                	callq  *%rcx
	cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
  8004201765:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
  800420176c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201770:	48 89 d1             	mov    %rdx,%rcx
  8004201773:	48 29 c1             	sub    %rax,%rcx
  8004201776:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  800420177d:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  8004201783:	89 c6                	mov    %eax,%esi
  8004201785:	48 bf 03 84 21 04 80 	movabs $0x8004218403,%rdi
  800420178c:	00 00 00 
  800420178f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201794:	49 b8 c3 8d 20 04 80 	movabs $0x8004208dc3,%r8
  800420179b:	00 00 00 
  800420179e:	41 ff d0             	callq  *%r8
	cprintf(" args:%d", info.rip_fn_narg);
  80042017a1:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  80042017a7:	89 c6                	mov    %eax,%esi
  80042017a9:	48 bf 0e 84 21 04 80 	movabs $0x800421840e,%rdi
  80042017b0:	00 00 00 
  80042017b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017b8:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042017bf:	00 00 00 
  80042017c2:	ff d2                	callq  *%rdx
	printArgList(prbp, &info);
  80042017c4:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  80042017cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017cf:	48 89 d6             	mov    %rdx,%rsi
  80042017d2:	48 89 c7             	mov    %rax,%rdi
  80042017d5:	48 b8 e4 14 20 04 80 	movabs $0x80042014e4,%rax
  80042017dc:	00 00 00 
  80042017df:	ff d0                	callq  *%rax

	while(prbp && *(prbp) != 0x0 && *(prbp+1) != 0x0)
  80042017e1:	e9 09 01 00 00       	jmpq   80042018ef <mon_backtrace+0x29f>
	{
		cprintf("    rbp %016x  rip %016x\n",*(prbp),*((prbp) +1));
  80042017e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017ea:	48 83 c0 08          	add    $0x8,%rax
  80042017ee:	48 8b 10             	mov    (%rax),%rdx
  80042017f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017f5:	48 8b 00             	mov    (%rax),%rax
  80042017f8:	48 89 c6             	mov    %rax,%rsi
  80042017fb:	48 bf d9 83 21 04 80 	movabs $0x80042183d9,%rdi
  8004201802:	00 00 00 
  8004201805:	b8 00 00 00 00       	mov    $0x0,%eax
  800420180a:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  8004201811:	00 00 00 
  8004201814:	ff d1                	callq  *%rcx
		debuginfo_rip(*(prbp+1) ,&info);
  8004201816:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420181a:	48 83 c0 08          	add    $0x8,%rax
  800420181e:	48 8b 00             	mov    (%rax),%rax
  8004201821:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  8004201828:	48 89 d6             	mov    %rdx,%rsi
  800420182b:	48 89 c7             	mov    %rax,%rdi
  800420182e:	48 b8 f0 e5 20 04 80 	movabs $0x800420e5f0,%rax
  8004201835:	00 00 00 
  8004201838:	ff d0                	callq  *%rax

		cprintf("        %s:%d: ",info.rip_file, info.rip_line);
  800420183a:	8b 95 08 fb ff ff    	mov    -0x4f8(%rbp),%edx
  8004201840:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
  8004201847:	48 89 c6             	mov    %rax,%rsi
  800420184a:	48 bf f3 83 21 04 80 	movabs $0x80042183f3,%rdi
  8004201851:	00 00 00 
  8004201854:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201859:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  8004201860:	00 00 00 
  8004201863:	ff d1                	callq  *%rcx
		cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
  8004201865:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
  800420186c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201870:	48 89 d1             	mov    %rdx,%rcx
  8004201873:	48 29 c1             	sub    %rax,%rcx
  8004201876:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  800420187d:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  8004201883:	89 c6                	mov    %eax,%esi
  8004201885:	48 bf 03 84 21 04 80 	movabs $0x8004218403,%rdi
  800420188c:	00 00 00 
  800420188f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201894:	49 b8 c3 8d 20 04 80 	movabs $0x8004208dc3,%r8
  800420189b:	00 00 00 
  800420189e:	41 ff d0             	callq  *%r8
		cprintf(" args:%d", info.rip_fn_narg);
  80042018a1:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  80042018a7:	89 c6                	mov    %eax,%esi
  80042018a9:	48 bf 0e 84 21 04 80 	movabs $0x800421840e,%rdi
  80042018b0:	00 00 00 
  80042018b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018b8:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042018bf:	00 00 00 
  80042018c2:	ff d2                	callq  *%rdx
		printArgList((uint64_t*)(*(prbp)), &info);
  80042018c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042018c8:	48 8b 00             	mov    (%rax),%rax
  80042018cb:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  80042018d2:	48 89 d6             	mov    %rdx,%rsi
  80042018d5:	48 89 c7             	mov    %rax,%rdi
  80042018d8:	48 b8 e4 14 20 04 80 	movabs $0x80042014e4,%rax
  80042018df:	00 00 00 
  80042018e2:	ff d0                	callq  *%rax
		
		prbp = (uint64_t*)(*(prbp)); 
  80042018e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042018e8:	48 8b 00             	mov    (%rax),%rax
  80042018eb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	cprintf("        %s:%d: ",info.rip_file, info.rip_line);
	cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
	cprintf(" args:%d", info.rip_fn_narg);
	printArgList(prbp, &info);

	while(prbp && *(prbp) != 0x0 && *(prbp+1) != 0x0)
  80042018ef:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042018f4:	74 20                	je     8004201916 <mon_backtrace+0x2c6>
  80042018f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042018fa:	48 8b 00             	mov    (%rax),%rax
  80042018fd:	48 85 c0             	test   %rax,%rax
  8004201900:	74 14                	je     8004201916 <mon_backtrace+0x2c6>
  8004201902:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201906:	48 83 c0 08          	add    $0x8,%rax
  800420190a:	48 8b 00             	mov    (%rax),%rax
  800420190d:	48 85 c0             	test   %rax,%rax
  8004201910:	0f 85 d0 fe ff ff    	jne    80042017e6 <mon_backtrace+0x196>
		cprintf(" args:%d", info.rip_fn_narg);
		printArgList((uint64_t*)(*(prbp)), &info);
		
		prbp = (uint64_t*)(*(prbp)); 
	}
	return 0;
  8004201916:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420191b:	c9                   	leaveq 
  800420191c:	c3                   	retq   

000000800420191d <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  800420191d:	55                   	push   %rbp
  800420191e:	48 89 e5             	mov    %rsp,%rbp
  8004201921:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004201928:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800420192f:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  8004201936:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  800420193d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201940:	48 98                	cltq   
  8004201942:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201949:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  800420194e:	eb 15                	jmp    8004201965 <runcmd+0x48>
			*buf++ = 0;
  8004201950:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201957:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420195b:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  8004201962:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201965:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420196c:	0f b6 00             	movzbl (%rax),%eax
  800420196f:	84 c0                	test   %al,%al
  8004201971:	74 2a                	je     800420199d <runcmd+0x80>
  8004201973:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420197a:	0f b6 00             	movzbl (%rax),%eax
  800420197d:	0f be c0             	movsbl %al,%eax
  8004201980:	89 c6                	mov    %eax,%esi
  8004201982:	48 bf 17 84 21 04 80 	movabs $0x8004218417,%rdi
  8004201989:	00 00 00 
  800420198c:	48 b8 15 f9 20 04 80 	movabs $0x800420f915,%rax
  8004201993:	00 00 00 
  8004201996:	ff d0                	callq  *%rax
  8004201998:	48 85 c0             	test   %rax,%rax
  800420199b:	75 b3                	jne    8004201950 <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  800420199d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042019a4:	0f b6 00             	movzbl (%rax),%eax
  80042019a7:	84 c0                	test   %al,%al
  80042019a9:	75 21                	jne    80042019cc <runcmd+0xaf>
			break;
  80042019ab:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  80042019ac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042019af:	48 98                	cltq   
  80042019b1:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042019b8:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  80042019bd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042019c1:	0f 85 a1 00 00 00    	jne    8004201a68 <runcmd+0x14b>
  80042019c7:	e9 92 00 00 00       	jmpq   8004201a5e <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  80042019cc:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042019d0:	75 2a                	jne    80042019fc <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  80042019d2:	be 10 00 00 00       	mov    $0x10,%esi
  80042019d7:	48 bf 1c 84 21 04 80 	movabs $0x800421841c,%rdi
  80042019de:	00 00 00 
  80042019e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019e6:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042019ed:	00 00 00 
  80042019f0:	ff d2                	callq  *%rdx
			return 0;
  80042019f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019f7:	e9 30 01 00 00       	jmpq   8004201b2c <runcmd+0x20f>
		}
		argv[argc++] = buf;
  80042019fc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042019ff:	8d 50 01             	lea    0x1(%rax),%edx
  8004201a02:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004201a05:	48 98                	cltq   
  8004201a07:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004201a0e:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  8004201a15:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201a16:	eb 08                	jmp    8004201a20 <runcmd+0x103>
			buf++;
  8004201a18:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  8004201a1f:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201a20:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201a27:	0f b6 00             	movzbl (%rax),%eax
  8004201a2a:	84 c0                	test   %al,%al
  8004201a2c:	74 2a                	je     8004201a58 <runcmd+0x13b>
  8004201a2e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201a35:	0f b6 00             	movzbl (%rax),%eax
  8004201a38:	0f be c0             	movsbl %al,%eax
  8004201a3b:	89 c6                	mov    %eax,%esi
  8004201a3d:	48 bf 17 84 21 04 80 	movabs $0x8004218417,%rdi
  8004201a44:	00 00 00 
  8004201a47:	48 b8 15 f9 20 04 80 	movabs $0x800420f915,%rax
  8004201a4e:	00 00 00 
  8004201a51:	ff d0                	callq  *%rax
  8004201a53:	48 85 c0             	test   %rax,%rax
  8004201a56:	74 c0                	je     8004201a18 <runcmd+0xfb>
			buf++;
	}
  8004201a58:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201a59:	e9 07 ff ff ff       	jmpq   8004201965 <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  8004201a5e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a63:	e9 c4 00 00 00       	jmpq   8004201b2c <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  8004201a68:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004201a6f:	e9 82 00 00 00       	jmpq   8004201af6 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004201a74:	48 b9 80 d5 22 04 80 	movabs $0x800422d580,%rcx
  8004201a7b:	00 00 00 
  8004201a7e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201a81:	48 63 d0             	movslq %eax,%rdx
  8004201a84:	48 89 d0             	mov    %rdx,%rax
  8004201a87:	48 01 c0             	add    %rax,%rax
  8004201a8a:	48 01 d0             	add    %rdx,%rax
  8004201a8d:	48 c1 e0 03          	shl    $0x3,%rax
  8004201a91:	48 01 c8             	add    %rcx,%rax
  8004201a94:	48 8b 10             	mov    (%rax),%rdx
  8004201a97:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201a9e:	48 89 d6             	mov    %rdx,%rsi
  8004201aa1:	48 89 c7             	mov    %rax,%rdi
  8004201aa4:	48 b8 51 f8 20 04 80 	movabs $0x800420f851,%rax
  8004201aab:	00 00 00 
  8004201aae:	ff d0                	callq  *%rax
  8004201ab0:	85 c0                	test   %eax,%eax
  8004201ab2:	75 3e                	jne    8004201af2 <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  8004201ab4:	48 b9 80 d5 22 04 80 	movabs $0x800422d580,%rcx
  8004201abb:	00 00 00 
  8004201abe:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201ac1:	48 63 d0             	movslq %eax,%rdx
  8004201ac4:	48 89 d0             	mov    %rdx,%rax
  8004201ac7:	48 01 c0             	add    %rax,%rax
  8004201aca:	48 01 d0             	add    %rdx,%rax
  8004201acd:	48 c1 e0 03          	shl    $0x3,%rax
  8004201ad1:	48 01 c8             	add    %rcx,%rax
  8004201ad4:	48 83 c0 10          	add    $0x10,%rax
  8004201ad8:	48 8b 00             	mov    (%rax),%rax
  8004201adb:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004201ae2:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201ae9:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004201aec:	89 cf                	mov    %ecx,%edi
  8004201aee:	ff d0                	callq  *%rax
  8004201af0:	eb 3a                	jmp    8004201b2c <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  8004201af2:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201af6:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201af9:	83 f8 02             	cmp    $0x2,%eax
  8004201afc:	0f 86 72 ff ff ff    	jbe    8004201a74 <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004201b02:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201b09:	48 89 c6             	mov    %rax,%rsi
  8004201b0c:	48 bf 39 84 21 04 80 	movabs $0x8004218439,%rdi
  8004201b13:	00 00 00 
  8004201b16:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b1b:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004201b22:	00 00 00 
  8004201b25:	ff d2                	callq  *%rdx
	return 0;
  8004201b27:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201b2c:	c9                   	leaveq 
  8004201b2d:	c3                   	retq   

0000008004201b2e <monitor>:

void
monitor(struct Trapframe *tf)
{
  8004201b2e:	55                   	push   %rbp
  8004201b2f:	48 89 e5             	mov    %rsp,%rbp
  8004201b32:	48 83 ec 20          	sub    $0x20,%rsp
  8004201b36:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  8004201b3a:	48 bf 50 84 21 04 80 	movabs $0x8004218450,%rdi
  8004201b41:	00 00 00 
  8004201b44:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b49:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004201b50:	00 00 00 
  8004201b53:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004201b55:	48 bf 78 84 21 04 80 	movabs $0x8004218478,%rdi
  8004201b5c:	00 00 00 
  8004201b5f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b64:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004201b6b:	00 00 00 
  8004201b6e:	ff d2                	callq  *%rdx

	if (tf != NULL)
  8004201b70:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201b75:	74 13                	je     8004201b8a <monitor+0x5c>
		print_trapframe(tf);
  8004201b77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201b7b:	48 89 c7             	mov    %rax,%rdi
  8004201b7e:	48 b8 cc bd 20 04 80 	movabs $0x800420bdcc,%rax
  8004201b85:	00 00 00 
  8004201b88:	ff d0                	callq  *%rax

	while (1) {
		buf = readline("K> ");
  8004201b8a:	48 bf 9d 84 21 04 80 	movabs $0x800421849d,%rdi
  8004201b91:	00 00 00 
  8004201b94:	48 b8 2e f5 20 04 80 	movabs $0x800420f52e,%rax
  8004201b9b:	00 00 00 
  8004201b9e:	ff d0                	callq  *%rax
  8004201ba0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201ba4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201ba9:	74 20                	je     8004201bcb <monitor+0x9d>
			if (runcmd(buf, tf) < 0)
  8004201bab:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201baf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201bb3:	48 89 d6             	mov    %rdx,%rsi
  8004201bb6:	48 89 c7             	mov    %rax,%rdi
  8004201bb9:	48 b8 1d 19 20 04 80 	movabs $0x800420191d,%rax
  8004201bc0:	00 00 00 
  8004201bc3:	ff d0                	callq  *%rax
  8004201bc5:	85 c0                	test   %eax,%eax
  8004201bc7:	79 02                	jns    8004201bcb <monitor+0x9d>
				break;
  8004201bc9:	eb 02                	jmp    8004201bcd <monitor+0x9f>
	}
  8004201bcb:	eb bd                	jmp    8004201b8a <monitor+0x5c>
}
  8004201bcd:	c9                   	leaveq 
  8004201bce:	c3                   	retq   

0000008004201bcf <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004201bcf:	55                   	push   %rbp
  8004201bd0:	48 89 e5             	mov    %rsp,%rbp
  8004201bd3:	48 83 ec 08          	sub    $0x8,%rsp
  8004201bd7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004201bdb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201bdf:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004201be6:	00 00 00 
  8004201be9:	48 8b 00             	mov    (%rax),%rax
  8004201bec:	48 29 c2             	sub    %rax,%rdx
  8004201bef:	48 89 d0             	mov    %rdx,%rax
  8004201bf2:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201bf6:	c9                   	leaveq 
  8004201bf7:	c3                   	retq   

0000008004201bf8 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201bf8:	55                   	push   %rbp
  8004201bf9:	48 89 e5             	mov    %rsp,%rbp
  8004201bfc:	48 83 ec 08          	sub    $0x8,%rsp
  8004201c00:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201c04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c08:	48 89 c7             	mov    %rax,%rdi
  8004201c0b:	48 b8 cf 1b 20 04 80 	movabs $0x8004201bcf,%rax
  8004201c12:	00 00 00 
  8004201c15:	ff d0                	callq  *%rax
  8004201c17:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004201c1b:	c9                   	leaveq 
  8004201c1c:	c3                   	retq   

0000008004201c1d <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004201c1d:	55                   	push   %rbp
  8004201c1e:	48 89 e5             	mov    %rsp,%rbp
  8004201c21:	48 83 ec 10          	sub    $0x10,%rsp
  8004201c25:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004201c29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c2d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201c31:	48 89 c2             	mov    %rax,%rdx
  8004201c34:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004201c3b:	00 00 00 
  8004201c3e:	48 8b 00             	mov    (%rax),%rax
  8004201c41:	48 39 c2             	cmp    %rax,%rdx
  8004201c44:	72 2a                	jb     8004201c70 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004201c46:	48 ba a8 84 21 04 80 	movabs $0x80042184a8,%rdx
  8004201c4d:	00 00 00 
  8004201c50:	be 54 00 00 00       	mov    $0x54,%esi
  8004201c55:	48 bf c7 84 21 04 80 	movabs $0x80042184c7,%rdi
  8004201c5c:	00 00 00 
  8004201c5f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c64:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  8004201c6b:	00 00 00 
  8004201c6e:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201c70:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004201c77:	00 00 00 
  8004201c7a:	48 8b 00             	mov    (%rax),%rax
  8004201c7d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201c81:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201c85:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201c89:	48 01 d0             	add    %rdx,%rax
}
  8004201c8c:	c9                   	leaveq 
  8004201c8d:	c3                   	retq   

0000008004201c8e <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004201c8e:	55                   	push   %rbp
  8004201c8f:	48 89 e5             	mov    %rsp,%rbp
  8004201c92:	48 83 ec 20          	sub    $0x20,%rsp
  8004201c96:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004201c9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201c9e:	48 89 c7             	mov    %rax,%rdi
  8004201ca1:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004201ca8:	00 00 00 
  8004201cab:	ff d0                	callq  *%rax
  8004201cad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201cb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201cb5:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201cb9:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004201cbc:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004201cbf:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004201cc6:	00 00 00 
  8004201cc9:	48 8b 00             	mov    (%rax),%rax
  8004201ccc:	48 39 c2             	cmp    %rax,%rdx
  8004201ccf:	72 32                	jb     8004201d03 <page2kva+0x75>
  8004201cd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201cd5:	48 89 c1             	mov    %rax,%rcx
  8004201cd8:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004201cdf:	00 00 00 
  8004201ce2:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004201ce7:	48 bf c7 84 21 04 80 	movabs $0x80042184c7,%rdi
  8004201cee:	00 00 00 
  8004201cf1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201cf6:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004201cfd:	00 00 00 
  8004201d00:	41 ff d0             	callq  *%r8
  8004201d03:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201d0a:	00 00 00 
  8004201d0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d11:	48 01 d0             	add    %rdx,%rax
}
  8004201d14:	c9                   	leaveq 
  8004201d15:	c3                   	retq   

0000008004201d16 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201d16:	55                   	push   %rbp
  8004201d17:	48 89 e5             	mov    %rsp,%rbp
  8004201d1a:	48 83 ec 08          	sub    $0x8,%rsp
  8004201d1e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201d21:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201d24:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201d28:	74 06                	je     8004201d30 <restrictive_type+0x1a>
  8004201d2a:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  8004201d2e:	75 07                	jne    8004201d37 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201d30:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201d35:	eb 3e                	jmp    8004201d75 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201d37:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201d3b:	74 06                	je     8004201d43 <restrictive_type+0x2d>
  8004201d3d:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201d41:	75 07                	jne    8004201d4a <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201d43:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201d48:	eb 2b                	jmp    8004201d75 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201d4a:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  8004201d4e:	74 06                	je     8004201d56 <restrictive_type+0x40>
  8004201d50:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201d54:	75 07                	jne    8004201d5d <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201d56:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201d5b:	eb 18                	jmp    8004201d75 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004201d5d:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201d61:	74 06                	je     8004201d69 <restrictive_type+0x53>
  8004201d63:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201d67:	75 07                	jne    8004201d70 <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004201d69:	b8 03 00 00 00       	mov    $0x3,%eax
  8004201d6e:	eb 05                	jmp    8004201d75 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201d70:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201d75:	c9                   	leaveq 
  8004201d76:	c3                   	retq   

0000008004201d77 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201d77:	55                   	push   %rbp
  8004201d78:	48 89 e5             	mov    %rsp,%rbp
  8004201d7b:	53                   	push   %rbx
  8004201d7c:	48 83 ec 18          	sub    $0x18,%rsp
  8004201d80:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201d83:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d86:	89 c7                	mov    %eax,%edi
  8004201d88:	48 b8 47 8a 20 04 80 	movabs $0x8004208a47,%rax
  8004201d8f:	00 00 00 
  8004201d92:	ff d0                	callq  *%rax
  8004201d94:	89 c3                	mov    %eax,%ebx
  8004201d96:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d99:	83 c0 01             	add    $0x1,%eax
  8004201d9c:	89 c7                	mov    %eax,%edi
  8004201d9e:	48 b8 47 8a 20 04 80 	movabs $0x8004208a47,%rax
  8004201da5:	00 00 00 
  8004201da8:	ff d0                	callq  *%rax
  8004201daa:	c1 e0 08             	shl    $0x8,%eax
  8004201dad:	09 d8                	or     %ebx,%eax
}
  8004201daf:	48 83 c4 18          	add    $0x18,%rsp
  8004201db3:	5b                   	pop    %rbx
  8004201db4:	5d                   	pop    %rbp
  8004201db5:	c3                   	retq   

0000008004201db6 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201db6:	55                   	push   %rbp
  8004201db7:	48 89 e5             	mov    %rsp,%rbp
  8004201dba:	41 54                	push   %r12
  8004201dbc:	53                   	push   %rbx
  8004201dbd:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004201dc4:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201dcb:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201dd2:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201dd9:	48 89 e0             	mov    %rsp,%rax
  8004201ddc:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  8004201ddf:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201de6:	8b 40 30             	mov    0x30(%rax),%eax
  8004201de9:	89 c0                	mov    %eax,%eax
  8004201deb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  8004201def:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201df6:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201df9:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201dfe:	f7 e2                	mul    %edx
  8004201e00:	89 d0                	mov    %edx,%eax
  8004201e02:	c1 e8 04             	shr    $0x4,%eax
  8004201e05:	89 c0                	mov    %eax,%eax
  8004201e07:	48 89 c2             	mov    %rax,%rdx
  8004201e0a:	48 83 ea 01          	sub    $0x1,%rdx
  8004201e0e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201e12:	49 89 c0             	mov    %rax,%r8
  8004201e15:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004201e1b:	48 89 c1             	mov    %rax,%rcx
  8004201e1e:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004201e23:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e27:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004201e2b:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201e30:	48 83 e8 01          	sub    $0x1,%rax
  8004201e34:	48 01 d0             	add    %rdx,%rax
  8004201e37:	bb 10 00 00 00       	mov    $0x10,%ebx
  8004201e3c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201e41:	48 f7 f3             	div    %rbx
  8004201e44:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201e48:	48 29 c4             	sub    %rax,%rsp
  8004201e4b:	48 89 e0             	mov    %rsp,%rax
  8004201e4e:	48 83 c0 07          	add    $0x7,%rax
  8004201e52:	48 c1 e8 03          	shr    $0x3,%rax
  8004201e56:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e5a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004201e5e:	48 bf fb 84 21 04 80 	movabs $0x80042184fb,%rdi
  8004201e65:	00 00 00 
  8004201e68:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201e6d:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004201e74:	00 00 00 
  8004201e77:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201e79:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201e80:	e9 6c 01 00 00       	jmpq   8004201ff1 <multiboot_read+0x23b>
		memory_map_t* mmap = &mmap_base[i];
  8004201e85:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201e88:	48 63 d0             	movslq %eax,%rdx
  8004201e8b:	48 89 d0             	mov    %rdx,%rax
  8004201e8e:	48 01 c0             	add    %rax,%rax
  8004201e91:	48 01 d0             	add    %rdx,%rax
  8004201e94:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e98:	48 89 c2             	mov    %rax,%rdx
  8004201e9b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201e9f:	48 01 d0             	add    %rdx,%rax
  8004201ea2:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201ea6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201eaa:	8b 40 08             	mov    0x8(%rax),%eax
  8004201ead:	89 c0                	mov    %eax,%eax
  8004201eaf:	48 c1 e0 20          	shl    $0x20,%rax
  8004201eb3:	48 89 c2             	mov    %rax,%rdx
  8004201eb6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201eba:	8b 40 04             	mov    0x4(%rax),%eax
  8004201ebd:	89 c0                	mov    %eax,%eax
  8004201ebf:	48 01 d0             	add    %rdx,%rax
  8004201ec2:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201ec6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201eca:	8b 40 10             	mov    0x10(%rax),%eax
  8004201ecd:	89 c0                	mov    %eax,%eax
  8004201ecf:	48 c1 e0 20          	shl    $0x20,%rax
  8004201ed3:	48 89 c2             	mov    %rax,%rdx
  8004201ed6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201eda:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201edd:	89 c0                	mov    %eax,%eax
  8004201edf:	48 01 d0             	add    %rdx,%rax
  8004201ee2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  8004201ee6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201eea:	8b 70 14             	mov    0x14(%rax),%esi
  8004201eed:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ef1:	8b 00                	mov    (%rax),%eax
  8004201ef3:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201ef7:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201efb:	41 89 f0             	mov    %esi,%r8d
  8004201efe:	89 c6                	mov    %eax,%esi
  8004201f00:	48 bf 10 85 21 04 80 	movabs $0x8004218510,%rdi
  8004201f07:	00 00 00 
  8004201f0a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f0f:	49 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%r9
  8004201f16:	00 00 00 
  8004201f19:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  8004201f1c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f20:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f23:	83 f8 05             	cmp    $0x5,%eax
  8004201f26:	77 0b                	ja     8004201f33 <multiboot_read+0x17d>
  8004201f28:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f2c:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f2f:	85 c0                	test   %eax,%eax
  8004201f31:	75 0b                	jne    8004201f3e <multiboot_read+0x188>
			mmap->type = MB_TYPE_RESERVED;
  8004201f33:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f37:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
		//Insert into the sorted list
		int j = 0;
  8004201f3e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004201f45:	e9 85 00 00 00       	jmpq   8004201fcf <multiboot_read+0x219>
			memory_map_t* this = mmap_list[j];
  8004201f4a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f4e:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201f51:	48 63 d2             	movslq %edx,%rdx
  8004201f54:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201f58:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201f5c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201f60:	8b 40 08             	mov    0x8(%rax),%eax
  8004201f63:	89 c0                	mov    %eax,%eax
  8004201f65:	48 c1 e0 20          	shl    $0x20,%rax
  8004201f69:	48 89 c2             	mov    %rax,%rdx
  8004201f6c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201f70:	8b 40 04             	mov    0x4(%rax),%eax
  8004201f73:	89 c0                	mov    %eax,%eax
  8004201f75:	48 01 d0             	add    %rdx,%rax
  8004201f78:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004201f7c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201f80:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201f84:	76 45                	jbe    8004201fcb <multiboot_read+0x215>
				int last = i+1;
  8004201f86:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201f89:	83 c0 01             	add    $0x1,%eax
  8004201f8c:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004201f8f:	eb 30                	jmp    8004201fc1 <multiboot_read+0x20b>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201f91:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f95:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201f98:	48 63 d2             	movslq %edx,%rdx
  8004201f9b:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201f9f:	48 01 c2             	add    %rax,%rdx
  8004201fa2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fa6:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201fa9:	48 63 c9             	movslq %ecx,%rcx
  8004201fac:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201fb0:	48 83 e9 08          	sub    $0x8,%rcx
  8004201fb4:	48 01 c8             	add    %rcx,%rax
  8004201fb7:	48 8b 00             	mov    (%rax),%rax
  8004201fba:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004201fbd:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004201fc1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201fc4:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201fc7:	75 c8                	jne    8004201f91 <multiboot_read+0x1db>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break; 
  8004201fc9:	eb 10                	jmp    8004201fdb <multiboot_read+0x225>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;
       
		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  8004201fcb:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004201fcf:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201fd2:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201fd5:	0f 8c 6f ff ff ff    	jl     8004201f4a <multiboot_read+0x194>
					last--;
				}
				break; 
			}
		}
		mmap_list[j] = mmap;  
  8004201fdb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fdf:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201fe2:	48 63 d2             	movslq %edx,%rdx
  8004201fe5:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004201fe9:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201fed:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201ff1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ff4:	48 63 c8             	movslq %eax,%rcx
  8004201ff7:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201ffe:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202001:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202006:	f7 e2                	mul    %edx
  8004202008:	89 d0                	mov    %edx,%eax
  800420200a:	c1 e8 04             	shr    $0x4,%eax
  800420200d:	89 c0                	mov    %eax,%eax
  800420200f:	48 39 c1             	cmp    %rax,%rcx
  8004202012:	0f 82 6d fe ff ff    	jb     8004201e85 <multiboot_read+0xcf>
				break; 
			}
		}
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
  8004202018:	48 bf 47 85 21 04 80 	movabs $0x8004218547,%rdi
  800420201f:	00 00 00 
  8004202022:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202027:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420202e:	00 00 00 
  8004202031:	ff d2                	callq  *%rdx
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202033:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  800420203a:	e9 93 01 00 00       	jmpq   80042021d2 <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  800420203f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202042:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202045:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202049:	48 63 d2             	movslq %edx,%rdx
  800420204c:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202050:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004202054:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202058:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420205b:	48 63 d2             	movslq %edx,%rdx
  800420205e:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202062:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004202066:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420206a:	8b 40 08             	mov    0x8(%rax),%eax
  800420206d:	89 c0                	mov    %eax,%eax
  800420206f:	48 c1 e0 20          	shl    $0x20,%rax
  8004202073:	48 89 c2             	mov    %rax,%rdx
  8004202076:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420207a:	8b 40 04             	mov    0x4(%rax),%eax
  800420207d:	89 c0                	mov    %eax,%eax
  800420207f:	48 01 d0             	add    %rdx,%rax
  8004202082:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004202086:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420208a:	8b 40 08             	mov    0x8(%rax),%eax
  800420208d:	89 c0                	mov    %eax,%eax
  800420208f:	48 c1 e0 20          	shl    $0x20,%rax
  8004202093:	48 89 c2             	mov    %rax,%rdx
  8004202096:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420209a:	8b 40 04             	mov    0x4(%rax),%eax
  800420209d:	89 c0                	mov    %eax,%eax
  800420209f:	48 01 d0             	add    %rdx,%rax
  80042020a2:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  80042020a6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020aa:	8b 40 10             	mov    0x10(%rax),%eax
  80042020ad:	89 c0                	mov    %eax,%eax
  80042020af:	48 c1 e0 20          	shl    $0x20,%rax
  80042020b3:	48 89 c2             	mov    %rax,%rdx
  80042020b6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020ba:	8b 40 0c             	mov    0xc(%rax),%eax
  80042020bd:	89 c0                	mov    %eax,%eax
  80042020bf:	48 01 d0             	add    %rdx,%rax
  80042020c2:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  80042020c9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020cd:	8b 40 10             	mov    0x10(%rax),%eax
  80042020d0:	89 c0                	mov    %eax,%eax
  80042020d2:	48 c1 e0 20          	shl    $0x20,%rax
  80042020d6:	48 89 c2             	mov    %rax,%rdx
  80042020d9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020dd:	8b 40 0c             	mov    0xc(%rax),%eax
  80042020e0:	89 c0                	mov    %eax,%eax
  80042020e2:	48 01 d0             	add    %rdx,%rax
  80042020e5:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  80042020ec:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042020f3:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042020f7:	48 01 d0             	add    %rdx,%rax
  80042020fa:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  80042020fe:	75 7c                	jne    800420217c <multiboot_read+0x3c6>
  8004202100:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202104:	8b 50 14             	mov    0x14(%rax),%edx
  8004202107:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420210b:	8b 40 14             	mov    0x14(%rax),%eax
  800420210e:	39 c2                	cmp    %eax,%edx
  8004202110:	75 6a                	jne    800420217c <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  8004202112:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202119:	89 c2                	mov    %eax,%edx
  800420211b:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202122:	01 c2                	add    %eax,%edx
  8004202124:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202128:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  800420212b:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202132:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004202139:	48 01 d0             	add    %rdx,%rax
  800420213c:	48 c1 e8 20          	shr    $0x20,%rax
  8004202140:	89 c2                	mov    %eax,%edx
  8004202142:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202146:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  8004202149:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420214d:	8b 50 04             	mov    0x4(%rax),%edx
  8004202150:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202154:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  8004202157:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420215b:	8b 50 08             	mov    0x8(%rax),%edx
  800420215e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202162:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004202165:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202168:	8d 50 ff             	lea    -0x1(%rax),%edx
  800420216b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420216f:	48 63 d2             	movslq %edx,%rdx
  8004202172:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  8004202179:	00 
  800420217a:	eb 52                	jmp    80042021ce <multiboot_read+0x418>
		} else if(prev_addr + prev_length > this_addr) {
  800420217c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202183:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202187:	48 01 d0             	add    %rdx,%rax
  800420218a:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  800420218e:	76 3e                	jbe    80042021ce <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  8004202190:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202194:	8b 50 14             	mov    0x14(%rax),%edx
  8004202197:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420219b:	8b 40 14             	mov    0x14(%rax),%eax
  800420219e:	89 d6                	mov    %edx,%esi
  80042021a0:	89 c7                	mov    %eax,%edi
  80042021a2:	48 b8 16 1d 20 04 80 	movabs $0x8004201d16,%rax
  80042021a9:	00 00 00 
  80042021ac:	ff d0                	callq  *%rax
  80042021ae:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  80042021b4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042021b8:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042021be:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  80042021c1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021c5:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042021cb:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042021ce:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042021d2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042021d5:	48 63 c8             	movslq %eax,%rcx
  80042021d8:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042021df:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042021e2:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  80042021e7:	f7 e2                	mul    %edx
  80042021e9:	89 d0                	mov    %edx,%eax
  80042021eb:	c1 e8 04             	shr    $0x4,%eax
  80042021ee:	89 c0                	mov    %eax,%eax
  80042021f0:	48 39 c1             	cmp    %rax,%rcx
  80042021f3:	0f 82 46 fe ff ff    	jb     800420203f <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042021f9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004202200:	e9 dc 00 00 00       	jmpq   80042022e1 <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004202205:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202209:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420220c:	48 63 d2             	movslq %edx,%rdx
  800420220f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202213:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  800420221a:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004202221:	00 
  8004202222:	0f 84 b5 00 00 00    	je     80042022dd <multiboot_read+0x527>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004202228:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420222f:	8b 40 14             	mov    0x14(%rax),%eax
  8004202232:	83 f8 01             	cmp    $0x1,%eax
  8004202235:	74 13                	je     800420224a <multiboot_read+0x494>
  8004202237:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420223e:	8b 40 14             	mov    0x14(%rax),%eax
  8004202241:	83 f8 03             	cmp    $0x3,%eax
  8004202244:	0f 85 93 00 00 00    	jne    80042022dd <multiboot_read+0x527>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  800420224a:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202251:	8b 40 04             	mov    0x4(%rax),%eax
  8004202254:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8004202259:	77 49                	ja     80042022a4 <multiboot_read+0x4ee>
  800420225b:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202262:	8b 40 08             	mov    0x8(%rax),%eax
  8004202265:	85 c0                	test   %eax,%eax
  8004202267:	75 3b                	jne    80042022a4 <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004202269:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004202270:	48 8b 10             	mov    (%rax),%rdx
  8004202273:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420227a:	8b 40 10             	mov    0x10(%rax),%eax
  800420227d:	89 c0                	mov    %eax,%eax
  800420227f:	48 c1 e0 20          	shl    $0x20,%rax
  8004202283:	48 89 c1             	mov    %rax,%rcx
  8004202286:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420228d:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202290:	89 c0                	mov    %eax,%eax
  8004202292:	48 01 c8             	add    %rcx,%rax
  8004202295:	48 01 c2             	add    %rax,%rdx
  8004202298:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420229f:	48 89 10             	mov    %rdx,(%rax)
  80042022a2:	eb 39                	jmp    80042022dd <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042022a4:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042022ab:	48 8b 10             	mov    (%rax),%rdx
  80042022ae:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022b5:	8b 40 10             	mov    0x10(%rax),%eax
  80042022b8:	89 c0                	mov    %eax,%eax
  80042022ba:	48 c1 e0 20          	shl    $0x20,%rax
  80042022be:	48 89 c1             	mov    %rax,%rcx
  80042022c1:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022c8:	8b 40 0c             	mov    0xc(%rax),%eax
  80042022cb:	89 c0                	mov    %eax,%eax
  80042022cd:	48 01 c8             	add    %rcx,%rax
  80042022d0:	48 01 c2             	add    %rax,%rdx
  80042022d3:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042022da:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042022dd:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042022e1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042022e4:	48 63 c8             	movslq %eax,%rcx
  80042022e7:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042022ee:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042022f1:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  80042022f6:	f7 e2                	mul    %edx
  80042022f8:	89 d0                	mov    %edx,%eax
  80042022fa:	c1 e8 04             	shr    $0x4,%eax
  80042022fd:	89 c0                	mov    %eax,%eax
  80042022ff:	48 39 c1             	cmp    %rax,%rcx
  8004202302:	0f 82 fd fe ff ff    	jb     8004202205 <multiboot_read+0x44f>
  8004202308:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  800420230b:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  800420230f:	5b                   	pop    %rbx
  8004202310:	41 5c                	pop    %r12
  8004202312:	5d                   	pop    %rbp
  8004202313:	c3                   	retq   

0000008004202314 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004202314:	55                   	push   %rbp
  8004202315:	48 89 e5             	mov    %rsp,%rbp
  8004202318:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  800420231c:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004202323:	00 
	size_t extmem = 0;
  8004202324:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  800420232b:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  800420232c:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004202333:	00 00 00 
  8004202336:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  800420233a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420233e:	48 8b 00             	mov    (%rax),%rax
  8004202341:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004202345:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420234a:	74 2d                	je     8004202379 <i386_detect_memory+0x65>
  800420234c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202350:	8b 00                	mov    (%rax),%eax
  8004202352:	83 e0 40             	and    $0x40,%eax
  8004202355:	85 c0                	test   %eax,%eax
  8004202357:	74 20                	je     8004202379 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004202359:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  800420235d:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8004202361:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202365:	48 89 ce             	mov    %rcx,%rsi
  8004202368:	48 89 c7             	mov    %rax,%rdi
  800420236b:	48 b8 b6 1d 20 04 80 	movabs $0x8004201db6,%rax
  8004202372:	00 00 00 
  8004202375:	ff d0                	callq  *%rax
  8004202377:	eb 34                	jmp    80042023ad <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004202379:	bf 15 00 00 00       	mov    $0x15,%edi
  800420237e:	48 b8 77 1d 20 04 80 	movabs $0x8004201d77,%rax
  8004202385:	00 00 00 
  8004202388:	ff d0                	callq  *%rax
  800420238a:	c1 e0 0a             	shl    $0xa,%eax
  800420238d:	48 98                	cltq   
  800420238f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  8004202393:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202398:	48 b8 77 1d 20 04 80 	movabs $0x8004201d77,%rax
  800420239f:	00 00 00 
  80042023a2:	ff d0                	callq  *%rax
  80042023a4:	c1 e0 0a             	shl    $0xa,%eax
  80042023a7:	48 98                	cltq   
  80042023a9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  80042023ad:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042023b1:	48 85 c0             	test   %rax,%rax
  80042023b4:	75 35                	jne    80042023eb <i386_detect_memory+0xd7>
  80042023b6:	48 b9 49 85 21 04 80 	movabs $0x8004218549,%rcx
  80042023bd:	00 00 00 
  80042023c0:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042023c7:	00 00 00 
  80042023ca:	be 89 00 00 00       	mov    $0x89,%esi
  80042023cf:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042023d6:	00 00 00 
  80042023d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042023de:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042023e5:	00 00 00 
  80042023e8:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  80042023eb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042023ef:	48 c1 e8 0c          	shr    $0xc,%rax
  80042023f3:	48 89 c2             	mov    %rax,%rdx
  80042023f6:	48 b8 30 72 60 04 80 	movabs $0x8004607230,%rax
  80042023fd:	00 00 00 
  8004202400:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004202403:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202407:	48 c1 e8 0c          	shr    $0xc,%rax
  800420240b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  800420240f:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202414:	48 b8 77 1d 20 04 80 	movabs $0x8004201d77,%rax
  800420241b:	00 00 00 
  800420241e:	ff d0                	callq  *%rax
  8004202420:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202425:	75 2c                	jne    8004202453 <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202427:	bf 34 00 00 00       	mov    $0x34,%edi
  800420242c:	48 b8 77 1d 20 04 80 	movabs $0x8004201d77,%rax
  8004202433:	00 00 00 
  8004202436:	ff d0                	callq  *%rax
  8004202438:	c1 e0 10             	shl    $0x10,%eax
  800420243b:	48 98                	cltq   
  800420243d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  8004202441:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202445:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  800420244b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420244f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004202453:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202458:	74 1a                	je     8004202474 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  800420245a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420245e:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004202465:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  800420246c:	00 00 00 
  800420246f:	48 89 10             	mov    %rdx,(%rax)
  8004202472:	eb 1a                	jmp    800420248e <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  8004202474:	48 b8 30 72 60 04 80 	movabs $0x8004607230,%rax
  800420247b:	00 00 00 
  800420247e:	48 8b 10             	mov    (%rax),%rdx
  8004202481:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004202488:	00 00 00 
  800420248b:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  800420248e:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004202495:	00 00 00 
  8004202498:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  800420249b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420249f:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024a3:	48 c1 e8 0a          	shr    $0xa,%rax
  80042024a7:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  80042024aa:	48 b8 30 72 60 04 80 	movabs $0x8004607230,%rax
  80042024b1:	00 00 00 
  80042024b4:	48 8b 00             	mov    (%rax),%rax
  80042024b7:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024bb:	48 c1 e8 0a          	shr    $0xa,%rax
  80042024bf:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  80042024c2:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  80042024c9:	00 00 00 
  80042024cc:	48 8b 00             	mov    (%rax),%rax
  80042024cf:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024d3:	48 c1 e8 14          	shr    $0x14,%rax
  80042024d7:	49 89 f0             	mov    %rsi,%r8
  80042024da:	48 89 c6             	mov    %rax,%rsi
  80042024dd:	48 bf 78 85 21 04 80 	movabs $0x8004218578,%rdi
  80042024e4:	00 00 00 
  80042024e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042024ec:	49 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%r9
  80042024f3:	00 00 00 
  80042024f6:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  80042024f9:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  8004202500:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  8004202501:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004202508:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004202509:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420250d:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  8004202511:	48 c1 e8 14          	shr    $0x14,%rax
  8004202515:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004202518:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420251c:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  8004202520:	48 c1 e8 14          	shr    $0x14,%rax
  8004202524:	48 89 c6             	mov    %rax,%rsi
  8004202527:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420252b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420252f:	49 89 c8             	mov    %rcx,%r8
  8004202532:	48 89 d1             	mov    %rdx,%rcx
  8004202535:	48 89 f2             	mov    %rsi,%rdx
  8004202538:	48 89 c6             	mov    %rax,%rsi
  800420253b:	48 bf c8 85 21 04 80 	movabs $0x80042185c8,%rdi
  8004202542:	00 00 00 
  8004202545:	b8 00 00 00 00       	mov    $0x0,%eax
  800420254a:	49 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%r9
  8004202551:	00 00 00 
  8004202554:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  8004202557:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420255b:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420255f:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  8004202564:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  8004202568:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  800420256f:	00 00 00 
  8004202572:	48 8b 00             	mov    (%rax),%rax
  8004202575:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004202579:	76 3a                	jbe    80042025b5 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  800420257b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420257f:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  8004202586:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  800420258d:	00 00 00 
  8004202590:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  8004202593:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202597:	48 89 c6             	mov    %rax,%rsi
  800420259a:	48 bf 30 86 21 04 80 	movabs $0x8004218630,%rdi
  80042025a1:	00 00 00 
  80042025a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042025a9:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042025b0:	00 00 00 
  80042025b3:	ff d2                	callq  *%rdx
	}
}
  80042025b5:	c9                   	leaveq 
  80042025b6:	c3                   	retq   

00000080042025b7 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  80042025b7:	55                   	push   %rbp
  80042025b8:	48 89 e5             	mov    %rsp,%rbp
  80042025bb:	48 83 ec 40          	sub    $0x40,%rsp
  80042025bf:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  80042025c2:	48 b8 48 72 60 04 80 	movabs $0x8004607248,%rax
  80042025c9:	00 00 00 
  80042025cc:	48 8b 00             	mov    (%rax),%rax
  80042025cf:	48 85 c0             	test   %rax,%rax
  80042025d2:	75 4b                	jne    800420261f <boot_alloc+0x68>
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
  80042025d4:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  80042025db:	00 
  80042025dc:	48 b8 28 b4 68 04 80 	movabs $0x800468b428,%rax
  80042025e3:	00 00 00 
  80042025e6:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  80042025ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042025ee:	48 01 d0             	add    %rdx,%rax
  80042025f1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042025f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042025f9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042025fe:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004202602:	48 89 d0             	mov    %rdx,%rax
  8004202605:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004202609:	48 29 c2             	sub    %rax,%rdx
  800420260c:	48 89 d0             	mov    %rdx,%rax
  800420260f:	48 89 c2             	mov    %rax,%rdx
  8004202612:	48 b8 48 72 60 04 80 	movabs $0x8004607248,%rax
  8004202619:	00 00 00 
  800420261c:	48 89 10             	mov    %rdx,(%rax)
	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	if (n == 0) 
  800420261f:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004202623:	75 12                	jne    8004202637 <boot_alloc+0x80>
		return nextfree;
  8004202625:	48 b8 48 72 60 04 80 	movabs $0x8004607248,%rax
  800420262c:	00 00 00 
  800420262f:	48 8b 00             	mov    (%rax),%rax
  8004202632:	e9 cf 00 00 00       	jmpq   8004202706 <boot_alloc+0x14f>
	result = nextfree;
  8004202637:	48 b8 48 72 60 04 80 	movabs $0x8004607248,%rax
  800420263e:	00 00 00 
  8004202641:	48 8b 00             	mov    (%rax),%rax
  8004202644:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nextfree = nextfree + n;
  8004202648:	48 b8 48 72 60 04 80 	movabs $0x8004607248,%rax
  800420264f:	00 00 00 
  8004202652:	48 8b 10             	mov    (%rax),%rdx
  8004202655:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004202658:	48 01 c2             	add    %rax,%rdx
  800420265b:	48 b8 48 72 60 04 80 	movabs $0x8004607248,%rax
  8004202662:	00 00 00 
  8004202665:	48 89 10             	mov    %rdx,(%rax)
	nextfree = ROUNDUP(nextfree, PGSIZE);
  8004202668:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  800420266f:	00 
  8004202670:	48 b8 48 72 60 04 80 	movabs $0x8004607248,%rax
  8004202677:	00 00 00 
  800420267a:	48 8b 00             	mov    (%rax),%rax
  800420267d:	48 89 c2             	mov    %rax,%rdx
  8004202680:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202684:	48 01 d0             	add    %rdx,%rax
  8004202687:	48 83 e8 01          	sub    $0x1,%rax
  800420268b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420268f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202693:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202698:	48 f7 75 e0          	divq   -0x20(%rbp)
  800420269c:	48 89 d0             	mov    %rdx,%rax
  800420269f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042026a3:	48 29 c2             	sub    %rax,%rdx
  80042026a6:	48 89 d0             	mov    %rdx,%rax
  80042026a9:	48 89 c2             	mov    %rax,%rdx
  80042026ac:	48 b8 48 72 60 04 80 	movabs $0x8004607248,%rax
  80042026b3:	00 00 00 
  80042026b6:	48 89 10             	mov    %rdx,(%rax)
	//process memory wrap arounds on memory full
	if((uint64_t)nextfree < (uint64_t)end)
  80042026b9:	48 b8 48 72 60 04 80 	movabs $0x8004607248,%rax
  80042026c0:	00 00 00 
  80042026c3:	48 8b 00             	mov    (%rax),%rax
  80042026c6:	48 89 c2             	mov    %rax,%rdx
  80042026c9:	48 b8 28 b4 68 04 80 	movabs $0x800468b428,%rax
  80042026d0:	00 00 00 
  80042026d3:	48 39 c2             	cmp    %rax,%rdx
  80042026d6:	73 2a                	jae    8004202702 <boot_alloc+0x14b>
	{
		panic("we're out of memory");
  80042026d8:	48 ba 59 86 21 04 80 	movabs $0x8004218659,%rdx
  80042026df:	00 00 00 
  80042026e2:	be e9 00 00 00       	mov    $0xe9,%esi
  80042026e7:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042026ee:	00 00 00 
  80042026f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042026f6:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  80042026fd:	00 00 00 
  8004202700:	ff d1                	callq  *%rcx
	}
	return result;
  8004202702:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004202706:	c9                   	leaveq 
  8004202707:	c3                   	retq   

0000008004202708 <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  8004202708:	55                   	push   %rbp
  8004202709:	48 89 e5             	mov    %rsp,%rbp
  800420270c:	48 83 ec 60          	sub    $0x60,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  8004202710:	48 b8 14 23 20 04 80 	movabs $0x8004202314,%rax
  8004202717:	00 00 00 
  800420271a:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	//panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  800420271c:	bf 00 10 00 00       	mov    $0x1000,%edi
  8004202721:	48 b8 b7 25 20 04 80 	movabs $0x80042025b7,%rax
  8004202728:	00 00 00 
  800420272b:	ff d0                	callq  *%rax
  800420272d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  8004202731:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202735:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420273a:	be 00 00 00 00       	mov    $0x0,%esi
  800420273f:	48 89 c7             	mov    %rax,%rdi
  8004202742:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004202749:	00 00 00 
  800420274c:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  800420274e:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004202755:	00 00 00 
  8004202758:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420275c:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  800420275f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202763:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202767:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420276e:	00 00 00 
  8004202771:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  8004202775:	77 32                	ja     80042027a9 <x64_vm_init+0xa1>
  8004202777:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420277b:	48 89 c1             	mov    %rax,%rcx
  800420277e:	48 ba 70 86 21 04 80 	movabs $0x8004218670,%rdx
  8004202785:	00 00 00 
  8004202788:	be 07 01 00 00       	mov    $0x107,%esi
  800420278d:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004202794:	00 00 00 
  8004202797:	b8 00 00 00 00       	mov    $0x0,%eax
  800420279c:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042027a3:	00 00 00 
  80042027a6:	41 ff d0             	callq  *%r8
  80042027a9:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042027b0:	ff ff ff 
  80042027b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042027b7:	48 01 c2             	add    %rax,%rdx
  80042027ba:	48 b8 70 87 60 04 80 	movabs $0x8004608770,%rax
  80042027c1:	00 00 00 
  80042027c4:	48 89 10             	mov    %rdx,(%rax)
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:
	pages = (struct PageInfo*)boot_alloc(npages * sizeof(struct PageInfo));
  80042027c7:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  80042027ce:	00 00 00 
  80042027d1:	48 8b 00             	mov    (%rax),%rax
  80042027d4:	c1 e0 04             	shl    $0x4,%eax
  80042027d7:	89 c7                	mov    %eax,%edi
  80042027d9:	48 b8 b7 25 20 04 80 	movabs $0x80042025b7,%rax
  80042027e0:	00 00 00 
  80042027e3:	ff d0                	callq  *%rax
  80042027e5:	48 ba 88 87 60 04 80 	movabs $0x8004608788,%rdx
  80042027ec:	00 00 00 
  80042027ef:	48 89 02             	mov    %rax,(%rdx)

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	
	envs = (struct Env*)boot_alloc(NENV * sizeof(struct Env));
  80042027f2:	bf 00 80 04 00       	mov    $0x48000,%edi
  80042027f7:	48 b8 b7 25 20 04 80 	movabs $0x80042025b7,%rax
  80042027fe:	00 00 00 
  8004202801:	ff d0                	callq  *%rax
  8004202803:	48 ba 50 72 60 04 80 	movabs $0x8004607250,%rdx
  800420280a:	00 00 00 
  800420280d:	48 89 02             	mov    %rax,(%rdx)
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  8004202810:	48 b8 7c 2b 20 04 80 	movabs $0x8004202b7c,%rax
  8004202817:	00 00 00 
  800420281a:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
    boot_map_region(pml4e, UPAGES, npages * sizeof(struct PageInfo), PADDR(pages), PTE_U|PTE_P);
  800420281c:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004202823:	00 00 00 
  8004202826:	48 8b 00             	mov    (%rax),%rax
  8004202829:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420282d:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202834:	00 00 00 
  8004202837:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420283b:	77 32                	ja     800420286f <x64_vm_init+0x167>
  800420283d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202841:	48 89 c1             	mov    %rax,%rcx
  8004202844:	48 ba 70 86 21 04 80 	movabs $0x8004218670,%rdx
  800420284b:	00 00 00 
  800420284e:	be 26 01 00 00       	mov    $0x126,%esi
  8004202853:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420285a:	00 00 00 
  800420285d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202862:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004202869:	00 00 00 
  800420286c:	41 ff d0             	callq  *%r8
  800420286f:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202876:	ff ff ff 
  8004202879:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420287d:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004202881:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004202888:	00 00 00 
  800420288b:	48 8b 00             	mov    (%rax),%rax
  800420288e:	48 c1 e0 04          	shl    $0x4,%rax
  8004202892:	48 89 c2             	mov    %rax,%rdx
  8004202895:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202899:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  800420289f:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  80042028a6:	00 00 00 
  80042028a9:	48 89 c7             	mov    %rax,%rdi
  80042028ac:	48 b8 fc 36 20 04 80 	movabs $0x80042036fc,%rax
  80042028b3:	00 00 00 
  80042028b6:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	boot_map_region(pml4e, UENVS, NENV * sizeof(struct Env), PADDR(envs), PTE_U|PTE_P);
  80042028b8:	48 b8 50 72 60 04 80 	movabs $0x8004607250,%rax
  80042028bf:	00 00 00 
  80042028c2:	48 8b 00             	mov    (%rax),%rax
  80042028c5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042028c9:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042028d0:	00 00 00 
  80042028d3:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042028d7:	77 32                	ja     800420290b <x64_vm_init+0x203>
  80042028d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042028dd:	48 89 c1             	mov    %rax,%rcx
  80042028e0:	48 ba 70 86 21 04 80 	movabs $0x8004218670,%rdx
  80042028e7:	00 00 00 
  80042028ea:	be 2f 01 00 00       	mov    $0x12f,%esi
  80042028ef:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042028f6:	00 00 00 
  80042028f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042028fe:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004202905:	00 00 00 
  8004202908:	41 ff d0             	callq  *%r8
  800420290b:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202912:	ff ff ff 
  8004202915:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202919:	48 01 c2             	add    %rax,%rdx
  800420291c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202920:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202926:	48 89 d1             	mov    %rdx,%rcx
  8004202929:	ba 00 80 04 00       	mov    $0x48000,%edx
  800420292e:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004202935:	00 00 00 
  8004202938:	48 89 c7             	mov    %rax,%rdi
  800420293b:	48 b8 fc 36 20 04 80 	movabs $0x80042036fc,%rax
  8004202942:	00 00 00 
  8004202945:	ff d0                	callq  *%rax
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here: 
	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  8004202947:	48 b8 9d 2a 20 04 80 	movabs $0x8004202a9d,%rax
  800420294e:	00 00 00 
  8004202951:	ff d0                	callq  *%rax
	boot_map_region(pml4e, KERNBASE, npages*PGSIZE, 0, PTE_P|PTE_W);
  8004202953:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  800420295a:	00 00 00 
  800420295d:	48 8b 00             	mov    (%rax),%rax
  8004202960:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202964:	48 89 c2             	mov    %rax,%rdx
  8004202967:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420296b:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202971:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004202976:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  800420297d:	00 00 00 
  8004202980:	48 89 c7             	mov    %rax,%rdi
  8004202983:	48 b8 fc 36 20 04 80 	movabs $0x80042036fc,%rax
  800420298a:	00 00 00 
  800420298d:	ff d0                	callq  *%rax
	//check_boot_pml4e(boot_pml4e);

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE

	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  800420298f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202993:	48 83 c0 08          	add    $0x8,%rax
  8004202997:	48 8b 00             	mov    (%rax),%rax
  800420299a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042029a0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042029a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042029a8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042029ac:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  80042029af:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042029b2:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  80042029b9:	00 00 00 
  80042029bc:	48 8b 00             	mov    (%rax),%rax
  80042029bf:	48 39 c2             	cmp    %rax,%rdx
  80042029c2:	72 32                	jb     80042029f6 <x64_vm_init+0x2ee>
  80042029c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042029c8:	48 89 c1             	mov    %rax,%rcx
  80042029cb:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  80042029d2:	00 00 00 
  80042029d5:	be 4f 01 00 00       	mov    $0x14f,%esi
  80042029da:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042029e1:	00 00 00 
  80042029e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042029e9:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042029f0:	00 00 00 
  80042029f3:	41 ff d0             	callq  *%r8
  80042029f6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042029fd:	00 00 00 
  8004202a00:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202a04:	48 01 d0             	add    %rdx,%rax
  8004202a07:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004202a0b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202a0f:	48 8b 00             	mov    (%rax),%rax
  8004202a12:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202a18:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202a1c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a20:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202a24:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004202a27:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202a2a:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004202a31:	00 00 00 
  8004202a34:	48 8b 00             	mov    (%rax),%rax
  8004202a37:	48 39 c2             	cmp    %rax,%rdx
  8004202a3a:	72 32                	jb     8004202a6e <x64_vm_init+0x366>
  8004202a3c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a40:	48 89 c1             	mov    %rax,%rcx
  8004202a43:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004202a4a:	00 00 00 
  8004202a4d:	be 50 01 00 00       	mov    $0x150,%esi
  8004202a52:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004202a59:	00 00 00 
  8004202a5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a61:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004202a68:	00 00 00 
  8004202a6b:	41 ff d0             	callq  *%r8
  8004202a6e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202a75:	00 00 00 
  8004202a78:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a7c:	48 01 d0             	add    %rdx,%rax
  8004202a7f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	lcr3(boot_cr3);
  8004202a83:	48 b8 70 87 60 04 80 	movabs $0x8004608770,%rax
  8004202a8a:	00 00 00 
  8004202a8d:	48 8b 00             	mov    (%rax),%rax
  8004202a90:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202a94:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202a98:	0f 22 d8             	mov    %rax,%cr3

    //check_page_free_list(1);
	//check_page_alloc();
	//page_check();
	//check_page_free_list(0);
}
  8004202a9b:	c9                   	leaveq 
  8004202a9c:	c3                   	retq   

0000008004202a9d <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  8004202a9d:	55                   	push   %rbp
  8004202a9e:	48 89 e5             	mov    %rsp,%rbp
  8004202aa1:	48 83 ec 20          	sub    $0x20,%rsp
	//             it will fault rather than overwrite another CPU's stack.
	//             Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int i = 0;
  8004202aa5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	uint64_t la = KSTACKTOP;
  8004202aac:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004202ab3:	00 00 00 
  8004202ab6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for(; i < NCPU; i++)
  8004202aba:	e9 b1 00 00 00       	jmpq   8004202b70 <mem_init_mp+0xd3>
	{
		//cprintf("\npercpu_kstacks %x", PADDR(percpu_kstacks[i]));
		boot_map_region(boot_pml4e, la - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
  8004202abf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202ac2:	48 98                	cltq   
  8004202ac4:	48 c1 e0 10          	shl    $0x10,%rax
  8004202ac8:	48 89 c2             	mov    %rax,%rdx
  8004202acb:	48 b8 00 b0 60 04 80 	movabs $0x800460b000,%rax
  8004202ad2:	00 00 00 
  8004202ad5:	48 01 d0             	add    %rdx,%rax
  8004202ad8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202adc:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202ae3:	00 00 00 
  8004202ae6:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202aea:	77 32                	ja     8004202b1e <mem_init_mp+0x81>
  8004202aec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202af0:	48 89 c1             	mov    %rax,%rcx
  8004202af3:	48 ba 70 86 21 04 80 	movabs $0x8004218670,%rdx
  8004202afa:	00 00 00 
  8004202afd:	be 75 01 00 00       	mov    $0x175,%esi
  8004202b02:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004202b09:	00 00 00 
  8004202b0c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b11:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004202b18:	00 00 00 
  8004202b1b:	41 ff d0             	callq  *%r8
  8004202b1e:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202b25:	ff ff ff 
  8004202b28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202b2c:	48 01 c2             	add    %rax,%rdx
  8004202b2f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202b33:	48 8d b0 00 00 ff ff 	lea    -0x10000(%rax),%rsi
  8004202b3a:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004202b41:	00 00 00 
  8004202b44:	48 8b 00             	mov    (%rax),%rax
  8004202b47:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202b4d:	48 89 d1             	mov    %rdx,%rcx
  8004202b50:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202b55:	48 89 c7             	mov    %rax,%rdi
  8004202b58:	48 b8 fc 36 20 04 80 	movabs $0x80042036fc,%rax
  8004202b5f:	00 00 00 
  8004202b62:	ff d0                	callq  *%rax
		la -= (KSTKSIZE + KSTKGAP);
  8004202b64:	48 81 6d f0 00 80 01 	subq   $0x18000,-0x10(%rbp)
  8004202b6b:	00 
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int i = 0;
	uint64_t la = KSTACKTOP;
	for(; i < NCPU; i++)
  8004202b6c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004202b70:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
  8004202b74:	0f 8e 45 ff ff ff    	jle    8004202abf <mem_init_mp+0x22>
	{
		//cprintf("\npercpu_kstacks %x", PADDR(percpu_kstacks[i]));
		boot_map_region(boot_pml4e, la - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
		la -= (KSTKSIZE + KSTKGAP);
	}
}
  8004202b7a:	c9                   	leaveq 
  8004202b7b:	c3                   	retq   

0000008004202b7c <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004202b7c:	55                   	push   %rbp
  8004202b7d:	48 89 e5             	mov    %rsp,%rbp
  8004202b80:	48 83 ec 70          	sub    $0x70,%rsp
	// NB: Make sure you preserve the direction in which your page_free_list 
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

	size_t i, holeS, kernE, bootPTS, bootPTE;
	struct PageInfo* last = NULL;
  8004202b84:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004202b8b:	00 
	for (i = 0; i < npages; i++) {
  8004202b8c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202b93:	00 
  8004202b94:	e9 ab 00 00 00       	jmpq   8004202c44 <page_init+0xc8>
		pages[i].pp_ref = 0;
  8004202b99:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004202ba0:	00 00 00 
  8004202ba3:	48 8b 00             	mov    (%rax),%rax
  8004202ba6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202baa:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202bae:	48 01 d0             	add    %rdx,%rax
  8004202bb1:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
		pages[i].pp_link = NULL;
  8004202bb7:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004202bbe:	00 00 00 
  8004202bc1:	48 8b 00             	mov    (%rax),%rax
  8004202bc4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202bc8:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202bcc:	48 01 d0             	add    %rdx,%rax
  8004202bcf:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if(last)
  8004202bd6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004202bdb:	74 21                	je     8004202bfe <page_init+0x82>
			last->pp_link = &pages[i];
  8004202bdd:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004202be4:	00 00 00 
  8004202be7:	48 8b 00             	mov    (%rax),%rax
  8004202bea:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202bee:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202bf2:	48 01 c2             	add    %rax,%rdx
  8004202bf5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202bf9:	48 89 10             	mov    %rdx,(%rax)
  8004202bfc:	eb 25                	jmp    8004202c23 <page_init+0xa7>
		else
			page_free_list = &pages[i];
  8004202bfe:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004202c05:	00 00 00 
  8004202c08:	48 8b 00             	mov    (%rax),%rax
  8004202c0b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c0f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c13:	48 01 c2             	add    %rax,%rdx
  8004202c16:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004202c1d:	00 00 00 
  8004202c20:	48 89 10             	mov    %rdx,(%rax)
		last = &pages[i];
  8004202c23:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004202c2a:	00 00 00 
  8004202c2d:	48 8b 00             	mov    (%rax),%rax
  8004202c30:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c34:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c38:	48 01 d0             	add    %rdx,%rax
  8004202c3b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

	size_t i, holeS, kernE, bootPTS, bootPTE;
	struct PageInfo* last = NULL;
	for (i = 0; i < npages; i++) {
  8004202c3f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202c44:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004202c4b:	00 00 00 
  8004202c4e:	48 8b 00             	mov    (%rax),%rax
  8004202c51:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202c55:	0f 82 3e ff ff ff    	jb     8004202b99 <page_init+0x1d>
		else
			page_free_list = &pages[i];
		last = &pages[i];
	}
	//remove page 0 from page list
	page_free_list = page_free_list->pp_link;
  8004202c5b:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004202c62:	00 00 00 
  8004202c65:	48 8b 00             	mov    (%rax),%rax
  8004202c68:	48 8b 10             	mov    (%rax),%rdx
  8004202c6b:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004202c72:	00 00 00 
  8004202c75:	48 89 10             	mov    %rdx,(%rax)

	//remove entries of holes till current kernel available memory pointer
	holeS = IOPHYSMEM/PGSIZE;
  8004202c78:	48 c7 45 e8 a0 00 00 	movq   $0xa0,-0x18(%rbp)
  8004202c7f:	00 
	kernE = PADDR(boot_alloc(0))/PGSIZE;
  8004202c80:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202c85:	48 b8 b7 25 20 04 80 	movabs $0x80042025b7,%rax
  8004202c8c:	00 00 00 
  8004202c8f:	ff d0                	callq  *%rax
  8004202c91:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202c95:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202c9c:	00 00 00 
  8004202c9f:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202ca3:	77 32                	ja     8004202cd7 <page_init+0x15b>
  8004202ca5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202ca9:	48 89 c1             	mov    %rax,%rcx
  8004202cac:	48 ba 70 86 21 04 80 	movabs $0x8004218670,%rdx
  8004202cb3:	00 00 00 
  8004202cb6:	be b2 01 00 00       	mov    $0x1b2,%esi
  8004202cbb:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004202cc2:	00 00 00 
  8004202cc5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202cca:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004202cd1:	00 00 00 
  8004202cd4:	41 ff d0             	callq  *%r8
  8004202cd7:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202cde:	ff ff ff 
  8004202ce1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202ce5:	48 01 d0             	add    %rdx,%rax
  8004202ce8:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202cec:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	pages[holeS - 1].pp_link = &pages[kernE];
  8004202cf0:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004202cf7:	00 00 00 
  8004202cfa:	48 8b 00             	mov    (%rax),%rax
  8004202cfd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202d01:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202d05:	48 83 ea 10          	sub    $0x10,%rdx
  8004202d09:	48 01 c2             	add    %rax,%rdx
  8004202d0c:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004202d13:	00 00 00 
  8004202d16:	48 8b 00             	mov    (%rax),%rax
  8004202d19:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004202d1d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004202d21:	48 01 c8             	add    %rcx,%rax
  8004202d24:	48 89 02             	mov    %rax,(%rdx)

	bootPTS = PADDR(BOOT_PAGE_TABLE_START)/PGSIZE;	
  8004202d27:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202d2e:	00 00 00 
  8004202d31:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202d35:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202d39:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202d3d:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004202d40:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004202d43:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004202d4a:	00 00 00 
  8004202d4d:	48 8b 00             	mov    (%rax),%rax
  8004202d50:	48 39 c2             	cmp    %rax,%rdx
  8004202d53:	72 32                	jb     8004202d87 <page_init+0x20b>
  8004202d55:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202d59:	48 89 c1             	mov    %rax,%rcx
  8004202d5c:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004202d63:	00 00 00 
  8004202d66:	be b5 01 00 00       	mov    $0x1b5,%esi
  8004202d6b:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004202d72:	00 00 00 
  8004202d75:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202d7a:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004202d81:	00 00 00 
  8004202d84:	41 ff d0             	callq  *%r8
  8004202d87:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202d8e:	00 00 00 
  8004202d91:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202d95:	48 01 d0             	add    %rdx,%rax
  8004202d98:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202d9c:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202da3:	00 00 00 
  8004202da6:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004202daa:	77 32                	ja     8004202dde <page_init+0x262>
  8004202dac:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202db0:	48 89 c1             	mov    %rax,%rcx
  8004202db3:	48 ba 70 86 21 04 80 	movabs $0x8004218670,%rdx
  8004202dba:	00 00 00 
  8004202dbd:	be b5 01 00 00       	mov    $0x1b5,%esi
  8004202dc2:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004202dc9:	00 00 00 
  8004202dcc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202dd1:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004202dd8:	00 00 00 
  8004202ddb:	41 ff d0             	callq  *%r8
  8004202dde:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202de5:	ff ff ff 
  8004202de8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202dec:	48 01 d0             	add    %rdx,%rax
  8004202def:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202df3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	bootPTE = PADDR(BOOT_PAGE_TABLE_END - 1)/PGSIZE;
  8004202df7:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202dfe:	00 00 00 
  8004202e01:	48 05 00 50 00 00    	add    $0x5000,%rax
  8004202e07:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004202e0b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202e0f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202e13:	89 45 ac             	mov    %eax,-0x54(%rbp)
  8004202e16:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004202e19:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004202e20:	00 00 00 
  8004202e23:	48 8b 00             	mov    (%rax),%rax
  8004202e26:	48 39 c2             	cmp    %rax,%rdx
  8004202e29:	72 32                	jb     8004202e5d <page_init+0x2e1>
  8004202e2b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202e2f:	48 89 c1             	mov    %rax,%rcx
  8004202e32:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004202e39:	00 00 00 
  8004202e3c:	be b6 01 00 00       	mov    $0x1b6,%esi
  8004202e41:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004202e48:	00 00 00 
  8004202e4b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e50:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004202e57:	00 00 00 
  8004202e5a:	41 ff d0             	callq  *%r8
  8004202e5d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202e64:	00 00 00 
  8004202e67:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202e6b:	48 01 d0             	add    %rdx,%rax
  8004202e6e:	48 83 e8 01          	sub    $0x1,%rax
  8004202e72:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004202e76:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202e7d:	00 00 00 
  8004202e80:	48 39 45 a0          	cmp    %rax,-0x60(%rbp)
  8004202e84:	77 32                	ja     8004202eb8 <page_init+0x33c>
  8004202e86:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202e8a:	48 89 c1             	mov    %rax,%rcx
  8004202e8d:	48 ba 70 86 21 04 80 	movabs $0x8004218670,%rdx
  8004202e94:	00 00 00 
  8004202e97:	be b6 01 00 00       	mov    $0x1b6,%esi
  8004202e9c:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004202ea3:	00 00 00 
  8004202ea6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202eab:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004202eb2:	00 00 00 
  8004202eb5:	41 ff d0             	callq  *%r8
  8004202eb8:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202ebf:	ff ff ff 
  8004202ec2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202ec6:	48 01 d0             	add    %rdx,%rax
  8004202ec9:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202ecd:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pages[bootPTS - 1].pp_link = &pages[bootPTE + 1];
  8004202ed1:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004202ed8:	00 00 00 
  8004202edb:	48 8b 00             	mov    (%rax),%rax
  8004202ede:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004202ee2:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202ee6:	48 83 ea 10          	sub    $0x10,%rdx
  8004202eea:	48 01 c2             	add    %rax,%rdx
  8004202eed:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004202ef4:	00 00 00 
  8004202ef7:	48 8b 00             	mov    (%rax),%rax
  8004202efa:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  8004202efe:	48 83 c1 01          	add    $0x1,%rcx
  8004202f02:	48 c1 e1 04          	shl    $0x4,%rcx
  8004202f06:	48 01 c8             	add    %rcx,%rax
  8004202f09:	48 89 02             	mov    %rax,(%rdx)

	//marking page at MPENTRY_PADDR as being used 
	pages[MPENTRY_PADDR / PGSIZE - 1].pp_link = &pages[MPENTRY_PADDR / PGSIZE + 1];
  8004202f0c:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004202f13:	00 00 00 
  8004202f16:	48 8b 00             	mov    (%rax),%rax
  8004202f19:	48 8d 50 60          	lea    0x60(%rax),%rdx
  8004202f1d:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004202f24:	00 00 00 
  8004202f27:	48 8b 00             	mov    (%rax),%rax
  8004202f2a:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  8004202f2e:	48 89 02             	mov    %rax,(%rdx)
}
  8004202f31:	c9                   	leaveq 
  8004202f32:	c3                   	retq   

0000008004202f33 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202f33:	55                   	push   %rbp
  8004202f34:	48 89 e5             	mov    %rsp,%rbp
  8004202f37:	48 83 ec 20          	sub    $0x20,%rsp
  8004202f3b:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in
	struct PageInfo * page = NULL;
  8004202f3e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202f45:	00 
	if(page_free_list)
  8004202f46:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004202f4d:	00 00 00 
  8004202f50:	48 8b 00             	mov    (%rax),%rax
  8004202f53:	48 85 c0             	test   %rax,%rax
  8004202f56:	74 6f                	je     8004202fc7 <page_alloc+0x94>
	{
		page = page_free_list;
  8004202f58:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004202f5f:	00 00 00 
  8004202f62:	48 8b 00             	mov    (%rax),%rax
  8004202f65:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		page_free_list = page_free_list->pp_link;
  8004202f69:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004202f70:	00 00 00 
  8004202f73:	48 8b 00             	mov    (%rax),%rax
  8004202f76:	48 8b 10             	mov    (%rax),%rdx
  8004202f79:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004202f80:	00 00 00 
  8004202f83:	48 89 10             	mov    %rdx,(%rax)
		page->pp_link = NULL;
  8004202f86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f8a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
//		cprintf("Umesh: physical addresses =[%x]\n",page);
		if(alloc_flags & ALLOC_ZERO)
  8004202f91:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202f94:	83 e0 01             	and    $0x1,%eax
  8004202f97:	85 c0                	test   %eax,%eax
  8004202f99:	74 2c                	je     8004202fc7 <page_alloc+0x94>
		{
			memset(page2kva(page), '\0', PGSIZE);
  8004202f9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f9f:	48 89 c7             	mov    %rax,%rdi
  8004202fa2:	48 b8 8e 1c 20 04 80 	movabs $0x8004201c8e,%rax
  8004202fa9:	00 00 00 
  8004202fac:	ff d0                	callq  *%rax
  8004202fae:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202fb3:	be 00 00 00 00       	mov    $0x0,%esi
  8004202fb8:	48 89 c7             	mov    %rax,%rdi
  8004202fbb:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004202fc2:	00 00 00 
  8004202fc5:	ff d0                	callq  *%rax
		}
	}
	else{
		//cprintf("page alloc failed\n");
	}
	return page;
  8004202fc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004202fcb:	c9                   	leaveq 
  8004202fcc:	c3                   	retq   

0000008004202fcd <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004202fcd:	55                   	push   %rbp
  8004202fce:	48 89 e5             	mov    %rsp,%rbp
  8004202fd1:	48 83 ec 10          	sub    $0x10,%rsp
  8004202fd5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004202fd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fdd:	ba 10 00 00 00       	mov    $0x10,%edx
  8004202fe2:	be 00 00 00 00       	mov    $0x0,%esi
  8004202fe7:	48 89 c7             	mov    %rax,%rdi
  8004202fea:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004202ff1:	00 00 00 
  8004202ff4:	ff d0                	callq  *%rax
}
  8004202ff6:	c9                   	leaveq 
  8004202ff7:	c3                   	retq   

0000008004202ff8 <insertAtBegining>:

void insertAtBegining(struct PageInfo ** list, struct PageInfo * node)
{
  8004202ff8:	55                   	push   %rbp
  8004202ff9:	48 89 e5             	mov    %rsp,%rbp
  8004202ffc:	48 83 ec 10          	sub    $0x10,%rsp
  8004203000:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004203004:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	if(*list == NULL)
  8004203008:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420300c:	48 8b 00             	mov    (%rax),%rax
  800420300f:	48 85 c0             	test   %rax,%rax
  8004203012:	75 0d                	jne    8004203021 <insertAtBegining+0x29>
	{
		*list = node;
  8004203014:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203018:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420301c:	48 89 10             	mov    %rdx,(%rax)
  800420301f:	eb 2c                	jmp    800420304d <insertAtBegining+0x55>
	}
	else if(*list != NULL && node != NULL)
  8004203021:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203025:	48 8b 00             	mov    (%rax),%rax
  8004203028:	48 85 c0             	test   %rax,%rax
  800420302b:	74 20                	je     800420304d <insertAtBegining+0x55>
  800420302d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203032:	74 19                	je     800420304d <insertAtBegining+0x55>
	{
		node->pp_link = *list;
  8004203034:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203038:	48 8b 10             	mov    (%rax),%rdx
  800420303b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420303f:	48 89 10             	mov    %rdx,(%rax)
		*list = node;
  8004203042:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203046:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420304a:	48 89 10             	mov    %rdx,(%rax)
	}
}
  800420304d:	c9                   	leaveq 
  800420304e:	c3                   	retq   

000000800420304f <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  800420304f:	55                   	push   %rbp
  8004203050:	48 89 e5             	mov    %rsp,%rbp
  8004203053:	48 83 ec 10          	sub    $0x10,%rsp
  8004203057:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if(pp->pp_ref != 0)
  800420305b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420305f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203063:	66 85 c0             	test   %ax,%ax
  8004203066:	74 2a                	je     8004203092 <page_free+0x43>
	{	
		panic("pp->pp_ref is nonzero");
  8004203068:	48 ba 94 86 21 04 80 	movabs $0x8004218694,%rdx
  800420306f:	00 00 00 
  8004203072:	be 03 02 00 00       	mov    $0x203,%esi
  8004203077:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420307e:	00 00 00 
  8004203081:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203086:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  800420308d:	00 00 00 
  8004203090:	ff d1                	callq  *%rcx
	}
	else if(pp->pp_link)
  8004203092:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203096:	48 8b 00             	mov    (%rax),%rax
  8004203099:	48 85 c0             	test   %rax,%rax
  800420309c:	74 2a                	je     80042030c8 <page_free+0x79>
	{
		panic("pp->pp_link is not NULL");
  800420309e:	48 ba aa 86 21 04 80 	movabs $0x80042186aa,%rdx
  80042030a5:	00 00 00 
  80042030a8:	be 07 02 00 00       	mov    $0x207,%esi
  80042030ad:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042030b4:	00 00 00 
  80042030b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042030bc:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  80042030c3:	00 00 00 
  80042030c6:	ff d1                	callq  *%rcx
	}
	else
	{
		//insert node to be freed at the begining of free node list
		insertAtBegining(&page_free_list, pp);
  80042030c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030cc:	48 89 c6             	mov    %rax,%rsi
  80042030cf:	48 bf 38 72 60 04 80 	movabs $0x8004607238,%rdi
  80042030d6:	00 00 00 
  80042030d9:	48 b8 f8 2f 20 04 80 	movabs $0x8004202ff8,%rax
  80042030e0:	00 00 00 
  80042030e3:	ff d0                	callq  *%rax
	}
}
  80042030e5:	c9                   	leaveq 
  80042030e6:	c3                   	retq   

00000080042030e7 <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  80042030e7:	55                   	push   %rbp
  80042030e8:	48 89 e5             	mov    %rsp,%rbp
  80042030eb:	48 83 ec 10          	sub    $0x10,%rsp
  80042030ef:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  80042030f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030f7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042030fb:	8d 50 ff             	lea    -0x1(%rax),%edx
  80042030fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203102:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004203106:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420310a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420310e:	66 85 c0             	test   %ax,%ax
  8004203111:	75 13                	jne    8004203126 <page_decref+0x3f>
		page_free(pp);
  8004203113:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203117:	48 89 c7             	mov    %rax,%rdi
  800420311a:	48 b8 4f 30 20 04 80 	movabs $0x800420304f,%rax
  8004203121:	00 00 00 
  8004203124:	ff d0                	callq  *%rax
}
  8004203126:	c9                   	leaveq 
  8004203127:	c3                   	retq   

0000008004203128 <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  8004203128:	55                   	push   %rbp
  8004203129:	48 89 e5             	mov    %rsp,%rbp
  800420312c:	53                   	push   %rbx
  800420312d:	48 83 ec 58          	sub    $0x58,%rsp
  8004203131:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203135:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004203139:	89 55 ac             	mov    %edx,-0x54(%rbp)
	//Need to return
	pte_t * pml4eIndexPtr = NULL;
  800420313c:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004203143:	00 
	int pml4eIndex;
	int pdpeIndex;
	uint64_t temp;
	struct PageInfo * page = NULL;
  8004203144:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420314b:	00 
	if(pml4e == NULL)
  800420314c:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004203151:	75 0a                	jne    800420315d <pml4e_walk+0x35>
	{
		return NULL;
  8004203153:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203158:	e9 c5 01 00 00       	jmpq   8004203322 <pml4e_walk+0x1fa>
	}
	pml4eIndex = PML4(va);
  800420315d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203161:	48 c1 e8 27          	shr    $0x27,%rax
  8004203165:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420316a:	89 45 dc             	mov    %eax,-0x24(%rbp)

	if((uint64_t*)pml4e[pml4eIndex] == NULL && create == false)
  800420316d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203170:	48 98                	cltq   
  8004203172:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203179:	00 
  800420317a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420317e:	48 01 d0             	add    %rdx,%rax
  8004203181:	48 8b 00             	mov    (%rax),%rax
  8004203184:	48 85 c0             	test   %rax,%rax
  8004203187:	75 10                	jne    8004203199 <pml4e_walk+0x71>
  8004203189:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800420318d:	75 0a                	jne    8004203199 <pml4e_walk+0x71>
	{
		return NULL;
  800420318f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203194:	e9 89 01 00 00       	jmpq   8004203322 <pml4e_walk+0x1fa>
	}
	else if((uint64_t*)pml4e[pml4eIndex] == NULL && create == true)
  8004203199:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420319c:	48 98                	cltq   
  800420319e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042031a5:	00 
  80042031a6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042031aa:	48 01 d0             	add    %rdx,%rax
  80042031ad:	48 8b 00             	mov    (%rax),%rax
  80042031b0:	48 85 c0             	test   %rax,%rax
  80042031b3:	75 7a                	jne    800420322f <pml4e_walk+0x107>
  80042031b5:	83 7d ac 01          	cmpl   $0x1,-0x54(%rbp)
  80042031b9:	75 74                	jne    800420322f <pml4e_walk+0x107>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  80042031bb:	c7 45 d8 07 00 00 00 	movl   $0x7,-0x28(%rbp)
		page = page_alloc(ALLOC_ZERO);
  80042031c2:	bf 01 00 00 00       	mov    $0x1,%edi
  80042031c7:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  80042031ce:	00 00 00 
  80042031d1:	ff d0                	callq  *%rax
  80042031d3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(!page)
  80042031d7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042031dc:	75 0a                	jne    80042031e8 <pml4e_walk+0xc0>
			return NULL;
  80042031de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031e3:	e9 3a 01 00 00       	jmpq   8004203322 <pml4e_walk+0x1fa>
		page->pp_ref++;
  80042031e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042031ec:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042031f0:	8d 50 01             	lea    0x1(%rax),%edx
  80042031f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042031f7:	66 89 50 08          	mov    %dx,0x8(%rax)
		//cprintf("pml4eIndex = [%d], pml4e[pml4eIndex] = %d", pml4eIndex, pml4e[pml4eIndex]);
		pml4e[pml4eIndex] = page2pa(page) | perm;
  80042031fb:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042031fe:	48 98                	cltq   
  8004203200:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203207:	00 
  8004203208:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420320c:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203210:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203214:	48 89 c7             	mov    %rax,%rdi
  8004203217:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  800420321e:	00 00 00 
  8004203221:	ff d0                	callq  *%rax
  8004203223:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004203226:	48 63 d2             	movslq %edx,%rdx
  8004203229:	48 09 d0             	or     %rdx,%rax
  800420322c:	48 89 03             	mov    %rax,(%rbx)
		//cprintf("pml4eIndex = [%d], pml4e[pml4eIndex] = %d", pml4eIndex, pml4e[pml4eIndex]);
	}
	//pml4e entry with last 12 bits permissions
	temp = pml4e[pml4eIndex];
  800420322f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203232:	48 98                	cltq   
  8004203234:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420323b:	00 
  800420323c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203240:	48 01 d0             	add    %rdx,%rax
  8004203243:	48 8b 00             	mov    (%rax),%rax
  8004203246:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  800420324a:	48 81 65 d0 00 f0 ff 	andq   $0xfffffffffffff000,-0x30(%rbp)
  8004203251:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  8004203252:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203256:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800420325a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420325e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203262:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004203265:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004203268:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  800420326f:	00 00 00 
  8004203272:	48 8b 00             	mov    (%rax),%rax
  8004203275:	48 39 c2             	cmp    %rax,%rdx
  8004203278:	72 32                	jb     80042032ac <pml4e_walk+0x184>
  800420327a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420327e:	48 89 c1             	mov    %rax,%rcx
  8004203281:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004203288:	00 00 00 
  800420328b:	be 57 02 00 00       	mov    $0x257,%esi
  8004203290:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004203297:	00 00 00 
  800420329a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420329f:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042032a6:	00 00 00 
  80042032a9:	41 ff d0             	callq  *%r8
  80042032ac:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042032b3:	00 00 00 
  80042032b6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042032ba:	48 01 d0             	add    %rdx,%rax
  80042032bd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//increase pgtable index to get index pointer in page table
	pml4eIndexPtr = (pte_t *)pdpe_walk((pte_t *)temp, va, create); 
  80042032c1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042032c5:	8b 55 ac             	mov    -0x54(%rbp),%edx
  80042032c8:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042032cc:	48 89 ce             	mov    %rcx,%rsi
  80042032cf:	48 89 c7             	mov    %rax,%rdi
  80042032d2:	48 b8 29 33 20 04 80 	movabs $0x8004203329,%rax
  80042032d9:	00 00 00 
  80042032dc:	ff d0                	callq  *%rax
  80042032de:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	//Null check
	if(pml4eIndexPtr == NULL && page != NULL)
  80042032e2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042032e7:	75 35                	jne    800420331e <pml4e_walk+0x1f6>
  80042032e9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042032ee:	74 2e                	je     800420331e <pml4e_walk+0x1f6>
	{
		page_decref(page);
  80042032f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042032f4:	48 89 c7             	mov    %rax,%rdi
  80042032f7:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  80042032fe:	00 00 00 
  8004203301:	ff d0                	callq  *%rax
        pml4e[pml4eIndex] = 0;
  8004203303:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203306:	48 98                	cltq   
  8004203308:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420330f:	00 
  8004203310:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203314:	48 01 d0             	add    %rdx,%rax
  8004203317:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
	return pml4eIndexPtr;
  800420331e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004203322:	48 83 c4 58          	add    $0x58,%rsp
  8004203326:	5b                   	pop    %rbx
  8004203327:	5d                   	pop    %rbp
  8004203328:	c3                   	retq   

0000008004203329 <pdpe_walk>:
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create)
{
  8004203329:	55                   	push   %rbp
  800420332a:	48 89 e5             	mov    %rsp,%rbp
  800420332d:	53                   	push   %rbx
  800420332e:	48 83 ec 68          	sub    $0x68,%rsp
  8004203332:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203336:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420333a:	89 55 9c             	mov    %edx,-0x64(%rbp)
	//Need to return
	pte_t * pdpeIndexPtr = NULL;
  800420333d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203344:	00 
	int pdpeIndex = 0;
  8004203345:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
	int pgdirIndex = 0;
  800420334c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
	uint64_t temp;
	struct PageInfo * page = NULL;
  8004203353:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  800420335a:	00 
	if(pdpe == NULL)
  800420335b:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004203360:	75 0a                	jne    800420336c <pdpe_walk+0x43>
	{
		return NULL;
  8004203362:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203367:	e9 c5 01 00 00       	jmpq   8004203531 <pdpe_walk+0x208>
	}
	pdpeIndex = PDPE(va);
  800420336c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203370:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203374:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203379:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if(!(uint64_t*)pdpe[pdpeIndex] && create == false)
  800420337c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420337f:	48 98                	cltq   
  8004203381:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203388:	00 
  8004203389:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420338d:	48 01 d0             	add    %rdx,%rax
  8004203390:	48 8b 00             	mov    (%rax),%rax
  8004203393:	48 85 c0             	test   %rax,%rax
  8004203396:	75 10                	jne    80042033a8 <pdpe_walk+0x7f>
  8004203398:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  800420339c:	75 0a                	jne    80042033a8 <pdpe_walk+0x7f>
	{
		return NULL;
  800420339e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042033a3:	e9 89 01 00 00       	jmpq   8004203531 <pdpe_walk+0x208>
	}
	else if((uint64_t*)pdpe[pdpeIndex] == NULL && create == true)
  80042033a8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042033ab:	48 98                	cltq   
  80042033ad:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042033b4:	00 
  80042033b5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042033b9:	48 01 d0             	add    %rdx,%rax
  80042033bc:	48 8b 00             	mov    (%rax),%rax
  80042033bf:	48 85 c0             	test   %rax,%rax
  80042033c2:	75 7a                	jne    800420343e <pdpe_walk+0x115>
  80042033c4:	83 7d 9c 01          	cmpl   $0x1,-0x64(%rbp)
  80042033c8:	75 74                	jne    800420343e <pdpe_walk+0x115>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  80042033ca:	c7 45 d4 07 00 00 00 	movl   $0x7,-0x2c(%rbp)
		struct PageInfo * page = page_alloc(ALLOC_ZERO);
  80042033d1:	bf 01 00 00 00       	mov    $0x1,%edi
  80042033d6:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  80042033dd:	00 00 00 
  80042033e0:	ff d0                	callq  *%rax
  80042033e2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		if(!page)
  80042033e6:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042033eb:	75 0a                	jne    80042033f7 <pdpe_walk+0xce>
			return NULL;
  80042033ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042033f2:	e9 3a 01 00 00       	jmpq   8004203531 <pdpe_walk+0x208>
		page->pp_ref++;
  80042033f7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042033fb:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042033ff:	8d 50 01             	lea    0x1(%rax),%edx
  8004203402:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203406:	66 89 50 08          	mov    %dx,0x8(%rax)
		pdpe[pdpeIndex] = page2pa(page) | perm;
  800420340a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420340d:	48 98                	cltq   
  800420340f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203416:	00 
  8004203417:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420341b:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420341f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203423:	48 89 c7             	mov    %rax,%rdi
  8004203426:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  800420342d:	00 00 00 
  8004203430:	ff d0                	callq  *%rax
  8004203432:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203435:	48 63 d2             	movslq %edx,%rdx
  8004203438:	48 09 d0             	or     %rdx,%rax
  800420343b:	48 89 03             	mov    %rax,(%rbx)
	}
	//pdpe entry with last 12 bits permissions
	temp = pdpe[pdpeIndex];
  800420343e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203441:	48 98                	cltq   
  8004203443:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420344a:	00 
  800420344b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420344f:	48 01 d0             	add    %rdx,%rax
  8004203452:	48 8b 00             	mov    (%rax),%rax
  8004203455:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  8004203459:	48 81 65 c0 00 f0 ff 	andq   $0xfffffffffffff000,-0x40(%rbp)
  8004203460:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  8004203461:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203465:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004203469:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420346d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203471:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004203474:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004203477:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  800420347e:	00 00 00 
  8004203481:	48 8b 00             	mov    (%rax),%rax
  8004203484:	48 39 c2             	cmp    %rax,%rdx
  8004203487:	72 32                	jb     80042034bb <pdpe_walk+0x192>
  8004203489:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420348d:	48 89 c1             	mov    %rax,%rcx
  8004203490:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004203497:	00 00 00 
  800420349a:	be 88 02 00 00       	mov    $0x288,%esi
  800420349f:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042034a6:	00 00 00 
  80042034a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034ae:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042034b5:	00 00 00 
  80042034b8:	41 ff d0             	callq  *%r8
  80042034bb:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042034c2:	00 00 00 
  80042034c5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042034c9:	48 01 d0             	add    %rdx,%rax
  80042034cc:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	//increase pgtable index to get index pointer in page table
	pdpeIndexPtr = (pte_t *)pgdir_walk((pte_t *)temp, va, create);
  80042034d0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042034d4:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042034d7:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042034db:	48 89 ce             	mov    %rcx,%rsi
  80042034de:	48 89 c7             	mov    %rax,%rdi
  80042034e1:	48 b8 38 35 20 04 80 	movabs $0x8004203538,%rax
  80042034e8:	00 00 00 
  80042034eb:	ff d0                	callq  *%rax
  80042034ed:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//Null check
	if(pdpeIndexPtr == NULL && page != NULL)
  80042034f1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042034f6:	75 35                	jne    800420352d <pdpe_walk+0x204>
  80042034f8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042034fd:	74 2e                	je     800420352d <pdpe_walk+0x204>
	{
        page_decref(page);
  80042034ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203503:	48 89 c7             	mov    %rax,%rdi
  8004203506:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  800420350d:	00 00 00 
  8004203510:	ff d0                	callq  *%rax
        pdpe[pdpeIndex] = 0;
  8004203512:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203515:	48 98                	cltq   
  8004203517:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420351e:	00 
  800420351f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203523:	48 01 d0             	add    %rdx,%rax
  8004203526:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
	
	//cprintf("Address is %x  value is %x \n", (uint64_t)KADDR(pdpe[pdpeIndex]), (uint64_t)KADDR(PTE_ADDR(pgdir[dirIndex])));
	return pdpeIndexPtr;
  800420352d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004203531:	48 83 c4 68          	add    $0x68,%rsp
  8004203535:	5b                   	pop    %rbx
  8004203536:	5d                   	pop    %rbp
  8004203537:	c3                   	retq   

0000008004203538 <pgdir_walk>:
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  8004203538:	55                   	push   %rbp
  8004203539:	48 89 e5             	mov    %rsp,%rbp
  800420353c:	53                   	push   %rbx
  800420353d:	48 83 ec 68          	sub    $0x68,%rsp
  8004203541:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203545:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004203549:	89 55 9c             	mov    %edx,-0x64(%rbp)
	// Fill this function in
	//Need to return
	pte_t * pgTblIndexPtr = NULL;
  800420354c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203553:	00 
	int dirIndex;
	int pgTblIndex;
	uint64_t temp;
	if(pgdir == NULL)
  8004203554:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004203559:	75 0a                	jne    8004203565 <pgdir_walk+0x2d>
	{
		return NULL;
  800420355b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203560:	e9 90 01 00 00       	jmpq   80042036f5 <pgdir_walk+0x1bd>
	}
	dirIndex = PDX(va);
  8004203565:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203569:	48 c1 e8 15          	shr    $0x15,%rax
  800420356d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203572:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	pgTblIndex = PTX(va);
  8004203575:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203579:	48 c1 e8 0c          	shr    $0xc,%rax
  800420357d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203582:	89 45 e0             	mov    %eax,-0x20(%rbp)
	if((uint64_t*)pgdir[dirIndex] == NULL && create == false)
  8004203585:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203588:	48 98                	cltq   
  800420358a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203591:	00 
  8004203592:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203596:	48 01 d0             	add    %rdx,%rax
  8004203599:	48 8b 00             	mov    (%rax),%rax
  800420359c:	48 85 c0             	test   %rax,%rax
  800420359f:	75 10                	jne    80042035b1 <pgdir_walk+0x79>
  80042035a1:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042035a5:	75 0a                	jne    80042035b1 <pgdir_walk+0x79>
	{
		return NULL;
  80042035a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042035ac:	e9 44 01 00 00       	jmpq   80042036f5 <pgdir_walk+0x1bd>
	}
	else if((uint64_t*)pgdir[dirIndex] == NULL && create == true)
  80042035b1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042035b4:	48 98                	cltq   
  80042035b6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042035bd:	00 
  80042035be:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042035c2:	48 01 d0             	add    %rdx,%rax
  80042035c5:	48 8b 00             	mov    (%rax),%rax
  80042035c8:	48 85 c0             	test   %rax,%rax
  80042035cb:	75 7a                	jne    8004203647 <pgdir_walk+0x10f>
  80042035cd:	83 7d 9c 01          	cmpl   $0x1,-0x64(%rbp)
  80042035d1:	75 74                	jne    8004203647 <pgdir_walk+0x10f>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  80042035d3:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%rbp)
		struct PageInfo * page = page_alloc(ALLOC_ZERO);
  80042035da:	bf 01 00 00 00       	mov    $0x1,%edi
  80042035df:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  80042035e6:	00 00 00 
  80042035e9:	ff d0                	callq  *%rax
  80042035eb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!page)
  80042035ef:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042035f4:	75 0a                	jne    8004203600 <pgdir_walk+0xc8>
			return NULL;
  80042035f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042035fb:	e9 f5 00 00 00       	jmpq   80042036f5 <pgdir_walk+0x1bd>
		page->pp_ref++;
  8004203600:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203604:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203608:	8d 50 01             	lea    0x1(%rax),%edx
  800420360b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420360f:	66 89 50 08          	mov    %dx,0x8(%rax)
		pgdir[dirIndex] = page2pa(page) | perm;
  8004203613:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203616:	48 98                	cltq   
  8004203618:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420361f:	00 
  8004203620:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203624:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203628:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420362c:	48 89 c7             	mov    %rax,%rdi
  800420362f:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004203636:	00 00 00 
  8004203639:	ff d0                	callq  *%rax
  800420363b:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420363e:	48 63 d2             	movslq %edx,%rdx
  8004203641:	48 09 d0             	or     %rdx,%rax
  8004203644:	48 89 03             	mov    %rax,(%rbx)
	}
	//pgdir entry with last 12 bits permissions
	temp = pgdir[dirIndex];
  8004203647:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420364a:	48 98                	cltq   
  800420364c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203653:	00 
  8004203654:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203658:	48 01 d0             	add    %rdx,%rax
  800420365b:	48 8b 00             	mov    (%rax),%rax
  800420365e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  8004203662:	48 81 65 c8 00 f0 ff 	andq   $0xfffffffffffff000,-0x38(%rbp)
  8004203669:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  800420366a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420366e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004203672:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203676:	48 c1 e8 0c          	shr    $0xc,%rax
  800420367a:	89 45 bc             	mov    %eax,-0x44(%rbp)
  800420367d:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004203680:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004203687:	00 00 00 
  800420368a:	48 8b 00             	mov    (%rax),%rax
  800420368d:	48 39 c2             	cmp    %rax,%rdx
  8004203690:	72 32                	jb     80042036c4 <pgdir_walk+0x18c>
  8004203692:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203696:	48 89 c1             	mov    %rax,%rcx
  8004203699:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  80042036a0:	00 00 00 
  80042036a3:	be bb 02 00 00       	mov    $0x2bb,%esi
  80042036a8:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042036af:	00 00 00 
  80042036b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036b7:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042036be:	00 00 00 
  80042036c1:	41 ff d0             	callq  *%r8
  80042036c4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042036cb:	00 00 00 
  80042036ce:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042036d2:	48 01 d0             	add    %rdx,%rax
  80042036d5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//increase pgtable index to get index pointer in page table
	pgTblIndexPtr = (pte_t *)temp + pgTblIndex;
  80042036d9:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042036dc:	48 98                	cltq   
  80042036de:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042036e5:	00 
  80042036e6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042036ea:	48 01 d0             	add    %rdx,%rax
  80042036ed:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//cprintf("Address is %x  value is %x \n", (uint64_t)KADDR((uint64_t)(pgdir + dirIndex)), (uint64_t)KADDR(PTE_ADDR(pgdir[dirIndex])));
	return pgTblIndexPtr;
  80042036f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80042036f5:	48 83 c4 68          	add    $0x68,%rsp
  80042036f9:	5b                   	pop    %rbx
  80042036fa:	5d                   	pop    %rbp
  80042036fb:	c3                   	retq   

00000080042036fc <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  80042036fc:	55                   	push   %rbp
  80042036fd:	48 89 e5             	mov    %rsp,%rbp
  8004203700:	48 83 ec 50          	sub    $0x50,%rsp
  8004203704:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203708:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420370c:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004203710:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004203714:	44 89 45 bc          	mov    %r8d,-0x44(%rbp)
        // Fill this function in
        pte_t *pte_store = NULL;
  8004203718:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420371f:	00 
        pte_t * pgTblIndexPtr = NULL;
  8004203720:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203727:	00 

        int i = 0;
  8004203728:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
        if(pml4e == NULL)
  800420372f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203734:	75 05                	jne    800420373b <boot_map_region+0x3f>
        {
                return;
  8004203736:	e9 82 00 00 00       	jmpq   80042037bd <boot_map_region+0xc1>
        }

        for(; i < size / PGSIZE; i++)
  800420373b:	eb 6e                	jmp    80042037ab <boot_map_region+0xaf>
        {
        	pgTblIndexPtr = pml4e_walk(pml4e, (void *)la , 1);
  800420373d:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004203741:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203745:	ba 01 00 00 00       	mov    $0x1,%edx
  800420374a:	48 89 ce             	mov    %rcx,%rsi
  800420374d:	48 89 c7             	mov    %rax,%rdi
  8004203750:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  8004203757:	00 00 00 
  800420375a:	ff d0                	callq  *%rax
  800420375c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        	if(pgTblIndexPtr == NULL)
  8004203760:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203765:	75 1d                	jne    8004203784 <boot_map_region+0x88>
        	{
        		cprintf("Error: could not bootmap");
  8004203767:	48 bf c2 86 21 04 80 	movabs $0x80042186c2,%rdi
  800420376e:	00 00 00 
  8004203771:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203776:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420377d:	00 00 00 
  8004203780:	ff d2                	callq  *%rdx
        	    continue;
  8004203782:	eb 23                	jmp    80042037a7 <boot_map_region+0xab>
        	}
            *pgTblIndexPtr = pa | perm;
  8004203784:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004203787:	48 98                	cltq   
  8004203789:	48 0b 45 c0          	or     -0x40(%rbp),%rax
  800420378d:	48 89 c2             	mov    %rax,%rdx
  8004203790:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203794:	48 89 10             	mov    %rdx,(%rax)
            pa += PGSIZE;
  8004203797:	48 81 45 c0 00 10 00 	addq   $0x1000,-0x40(%rbp)
  800420379e:	00 
            la += PGSIZE;
  800420379f:	48 81 45 d0 00 10 00 	addq   $0x1000,-0x30(%rbp)
  80042037a6:	00 
        if(pml4e == NULL)
        {
                return;
        }

        for(; i < size / PGSIZE; i++)
  80042037a7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042037ab:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042037ae:	48 98                	cltq   
  80042037b0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042037b4:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042037b8:	48 39 d0             	cmp    %rdx,%rax
  80042037bb:	72 80                	jb     800420373d <boot_map_region+0x41>
        	}
            *pgTblIndexPtr = pa | perm;
            pa += PGSIZE;
            la += PGSIZE;
        }
}
  80042037bd:	c9                   	leaveq 
  80042037be:	c3                   	retq   

00000080042037bf <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  80042037bf:	55                   	push   %rbp
  80042037c0:	48 89 e5             	mov    %rsp,%rbp
  80042037c3:	48 83 ec 30          	sub    $0x30,%rsp
  80042037c7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042037cb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042037cf:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042037d3:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
	// Fill this function in
	pte_t * pgTblIndexPtr;
	if(pml4e == NULL || pp == NULL)
  80042037d6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042037db:	74 07                	je     80042037e4 <page_insert+0x25>
  80042037dd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042037e2:	75 0a                	jne    80042037ee <page_insert+0x2f>
	{
		return 0;
  80042037e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042037e9:	e9 2c 01 00 00       	jmpq   800420391a <page_insert+0x15b>
	}
	
	pgTblIndexPtr =  pml4e_walk(pml4e, va, 1);
  80042037ee:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042037f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042037f6:	ba 01 00 00 00       	mov    $0x1,%edx
  80042037fb:	48 89 ce             	mov    %rcx,%rsi
  80042037fe:	48 89 c7             	mov    %rax,%rdi
  8004203801:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  8004203808:	00 00 00 
  800420380b:	ff d0                	callq  *%rax
  800420380d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//cprintf("pgTblIndexPtr %p %x\n", pgTblIndexPtr, pgTblIndexPtr);
	if(!pgTblIndexPtr)
  8004203811:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203816:	75 0a                	jne    8004203822 <page_insert+0x63>
	{
		return 	-E_NO_MEM;
  8004203818:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420381d:	e9 f8 00 00 00       	jmpq   800420391a <page_insert+0x15b>
	}
	//set present bit
	perm = perm|PTE_P;
  8004203822:	83 4d d4 01          	orl    $0x1,-0x2c(%rbp)
	bool present = *pgTblIndexPtr & PTE_P;
  8004203826:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420382a:	48 8b 00             	mov    (%rax),%rax
  800420382d:	83 e0 01             	and    $0x1,%eax
  8004203830:	48 85 c0             	test   %rax,%rax
  8004203833:	0f 95 c0             	setne  %al
  8004203836:	88 45 f7             	mov    %al,-0x9(%rbp)
	if(present &&pa2page(PTE_ADDR(*pgTblIndexPtr)) == pp)
  8004203839:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  800420383d:	74 66                	je     80042038a5 <page_insert+0xe6>
  800420383f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203843:	48 8b 00             	mov    (%rax),%rax
  8004203846:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420384c:	48 89 c7             	mov    %rax,%rdi
  800420384f:	48 b8 1d 1c 20 04 80 	movabs $0x8004201c1d,%rax
  8004203856:	00 00 00 
  8004203859:	ff d0                	callq  *%rax
  800420385b:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420385f:	75 44                	jne    80042038a5 <page_insert+0xe6>
	{		
		*pgTblIndexPtr = (page2pa(pp) | perm);
  8004203861:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203865:	48 89 c7             	mov    %rax,%rdi
  8004203868:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  800420386f:	00 00 00 
  8004203872:	ff d0                	callq  *%rax
  8004203874:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203877:	48 63 d2             	movslq %edx,%rdx
  800420387a:	48 09 c2             	or     %rax,%rdx
  800420387d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203881:	48 89 10             	mov    %rdx,(%rax)
		tlb_invalidate(pml4e, va);
  8004203884:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004203888:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420388c:	48 89 d6             	mov    %rdx,%rsi
  800420388f:	48 89 c7             	mov    %rax,%rdi
  8004203892:	48 b8 44 3a 20 04 80 	movabs $0x8004203a44,%rax
  8004203899:	00 00 00 
  800420389c:	ff d0                	callq  *%rax
		return 0;
  800420389e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038a3:	eb 75                	jmp    800420391a <page_insert+0x15b>
	}
	//check and remove previous existing page
	else if(present)
  80042038a5:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80042038a9:	74 34                	je     80042038df <page_insert+0x120>
	{
		page_remove(pml4e, va);
  80042038ab:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042038af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038b3:	48 89 d6             	mov    %rdx,%rsi
  80042038b6:	48 89 c7             	mov    %rax,%rdi
  80042038b9:	48 b8 b6 39 20 04 80 	movabs $0x80042039b6,%rax
  80042038c0:	00 00 00 
  80042038c3:	ff d0                	callq  *%rax
		//invalidate tlb
		tlb_invalidate(pml4e, va);
  80042038c5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042038c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038cd:	48 89 d6             	mov    %rdx,%rsi
  80042038d0:	48 89 c7             	mov    %rax,%rdi
  80042038d3:	48 b8 44 3a 20 04 80 	movabs $0x8004203a44,%rax
  80042038da:	00 00 00 
  80042038dd:	ff d0                	callq  *%rax
	}

	//add new page
	*pgTblIndexPtr = (page2pa(pp) | perm);
  80042038df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042038e3:	48 89 c7             	mov    %rax,%rdi
  80042038e6:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  80042038ed:	00 00 00 
  80042038f0:	ff d0                	callq  *%rax
  80042038f2:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042038f5:	48 63 d2             	movslq %edx,%rdx
  80042038f8:	48 09 c2             	or     %rax,%rdx
  80042038fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038ff:	48 89 10             	mov    %rdx,(%rax)

	//increment reference
	pp->pp_ref += 1;
  8004203902:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203906:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420390a:	8d 50 01             	lea    0x1(%rax),%edx
  800420390d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203911:	66 89 50 08          	mov    %dx,0x8(%rax)

	return 0;
  8004203915:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420391a:	c9                   	leaveq 
  800420391b:	c3                   	retq   

000000800420391c <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  800420391c:	55                   	push   %rbp
  800420391d:	48 89 e5             	mov    %rsp,%rbp
  8004203920:	48 83 ec 30          	sub    $0x30,%rsp
  8004203924:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203928:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420392c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in
	pte_t * pgTblIndexPtr;
	struct PageInfo * page = NULL;
  8004203930:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203937:	00 
	bool present;

	if(pml4e == NULL)
  8004203938:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420393d:	75 06                	jne    8004203945 <page_lookup+0x29>
	{
		return page;
  800420393f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203943:	eb 6f                	jmp    80042039b4 <page_lookup+0x98>
	}
	
	pgTblIndexPtr =  pml4e_walk(pml4e, va, 1);
  8004203945:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203949:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420394d:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203952:	48 89 ce             	mov    %rcx,%rsi
  8004203955:	48 89 c7             	mov    %rax,%rdi
  8004203958:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  800420395f:	00 00 00 
  8004203962:	ff d0                	callq  *%rax
  8004203964:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(pgTblIndexPtr == NULL)
  8004203968:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420396d:	75 06                	jne    8004203975 <page_lookup+0x59>
		return page;
  800420396f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203973:	eb 3f                	jmp    80042039b4 <page_lookup+0x98>
	
	if(*pgTblIndexPtr & PTE_P)
  8004203975:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203979:	48 8b 00             	mov    (%rax),%rax
  800420397c:	83 e0 01             	and    $0x1,%eax
  800420397f:	48 85 c0             	test   %rax,%rax
  8004203982:	74 2c                	je     80042039b0 <page_lookup+0x94>
	{
		page = pa2page(*pgTblIndexPtr);				
  8004203984:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203988:	48 8b 00             	mov    (%rax),%rax
  800420398b:	48 89 c7             	mov    %rax,%rdi
  800420398e:	48 b8 1d 1c 20 04 80 	movabs $0x8004201c1d,%rax
  8004203995:	00 00 00 
  8004203998:	ff d0                	callq  *%rax
  800420399a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if(pte_store)
  800420399e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042039a3:	74 0b                	je     80042039b0 <page_lookup+0x94>
		{
			*pte_store = pgTblIndexPtr;
  80042039a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042039a9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042039ad:	48 89 10             	mov    %rdx,(%rax)
		}
	}
	return page;
  80042039b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042039b4:	c9                   	leaveq 
  80042039b5:	c3                   	retq   

00000080042039b6 <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  80042039b6:	55                   	push   %rbp
  80042039b7:	48 89 e5             	mov    %rsp,%rbp
  80042039ba:	48 83 ec 20          	sub    $0x20,%rsp
  80042039be:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042039c2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in
	
	pte_t *pte_store = NULL;
  80042039c6:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042039cd:	00 
	struct PageInfo* page_add = NULL;
  80042039ce:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042039d5:	00 
	if(pml4e == NULL)
  80042039d6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042039db:	75 02                	jne    80042039df <page_remove+0x29>
	{
		return;
  80042039dd:	eb 63                	jmp    8004203a42 <page_remove+0x8c>
	}
	
	page_add =  page_lookup(pml4e, va, &pte_store);
  80042039df:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80042039e3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80042039e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042039eb:	48 89 ce             	mov    %rcx,%rsi
  80042039ee:	48 89 c7             	mov    %rax,%rdi
  80042039f1:	48 b8 1c 39 20 04 80 	movabs $0x800420391c,%rax
  80042039f8:	00 00 00 
  80042039fb:	ff d0                	callq  *%rax
  80042039fd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(page_add == NULL)
  8004203a01:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203a06:	75 02                	jne    8004203a0a <page_remove+0x54>
		return;
  8004203a08:	eb 38                	jmp    8004203a42 <page_remove+0x8c>
	
	tlb_invalidate(pml4e, va);
  8004203a0a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203a0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203a12:	48 89 d6             	mov    %rdx,%rsi
  8004203a15:	48 89 c7             	mov    %rax,%rdi
  8004203a18:	48 b8 44 3a 20 04 80 	movabs $0x8004203a44,%rax
  8004203a1f:	00 00 00 
  8004203a22:	ff d0                	callq  *%rax
	page_decref(page_add);
  8004203a24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a28:	48 89 c7             	mov    %rax,%rdi
  8004203a2b:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  8004203a32:	00 00 00 
  8004203a35:	ff d0                	callq  *%rax
	//The pg table entry corresponding to 'va' should be set to 0.
	*pte_store = 0;
  8004203a37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203a3b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
}
  8004203a42:	c9                   	leaveq 
  8004203a43:	c3                   	retq   

0000008004203a44 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203a44:	55                   	push   %rbp
  8004203a45:	48 89 e5             	mov    %rsp,%rbp
  8004203a48:	48 83 ec 20          	sub    $0x20,%rsp
  8004203a4c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203a50:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  8004203a54:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203a59:	75 35                	jne    8004203a90 <tlb_invalidate+0x4c>
  8004203a5b:	48 b9 db 86 21 04 80 	movabs $0x80042186db,%rcx
  8004203a62:	00 00 00 
  8004203a65:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004203a6c:	00 00 00 
  8004203a6f:	be 80 03 00 00       	mov    $0x380,%esi
  8004203a74:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004203a7b:	00 00 00 
  8004203a7e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a83:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004203a8a:	00 00 00 
  8004203a8d:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  8004203a90:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004203a97:	00 00 00 
  8004203a9a:	ff d0                	callq  *%rax
  8004203a9c:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  8004203aa3:	00 00 00 
  8004203aa6:	48 98                	cltq   
  8004203aa8:	48 c1 e0 03          	shl    $0x3,%rax
  8004203aac:	48 89 c2             	mov    %rax,%rdx
  8004203aaf:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203ab3:	48 29 c2             	sub    %rax,%rdx
  8004203ab6:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203aba:	48 83 c0 08          	add    $0x8,%rax
  8004203abe:	48 8b 00             	mov    (%rax),%rax
  8004203ac1:	48 85 c0             	test   %rax,%rax
  8004203ac4:	74 3e                	je     8004203b04 <tlb_invalidate+0xc0>
  8004203ac6:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004203acd:	00 00 00 
  8004203ad0:	ff d0                	callq  *%rax
  8004203ad2:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  8004203ad9:	00 00 00 
  8004203adc:	48 98                	cltq   
  8004203ade:	48 c1 e0 03          	shl    $0x3,%rax
  8004203ae2:	48 89 c2             	mov    %rax,%rdx
  8004203ae5:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203ae9:	48 29 c2             	sub    %rax,%rdx
  8004203aec:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004203af0:	48 83 c0 08          	add    $0x8,%rax
  8004203af4:	48 8b 00             	mov    (%rax),%rax
  8004203af7:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203afe:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004203b02:	75 0f                	jne    8004203b13 <tlb_invalidate+0xcf>
  8004203b04:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203b08:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004203b0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b10:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  8004203b13:	c9                   	leaveq 
  8004203b14:	c3                   	retq   

0000008004203b15 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004203b15:	55                   	push   %rbp
  8004203b16:	48 89 e5             	mov    %rsp,%rbp
  8004203b19:	48 83 ec 30          	sub    $0x30,%rsp
  8004203b1d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203b21:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// beginning of the MMIO region.  Because this is static, its
	// value will be preserved between calls to mmio_map_region
	// (just like nextfree in boot_alloc).
	static uintptr_t base = MMIOBASE;
	uintptr_t base_prev;
	base_prev = base;
  8004203b25:	48 b8 c8 d5 22 04 80 	movabs $0x800422d5c8,%rax
  8004203b2c:	00 00 00 
  8004203b2f:	48 8b 00             	mov    (%rax),%rax
  8004203b32:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	/* check if base+size < MMIOLIM,roundpu size, do we need to round down/round up pa???? move base to new size,*/
	if((base+size) >= MMIOLIM){
  8004203b36:	48 b8 c8 d5 22 04 80 	movabs $0x800422d5c8,%rax
  8004203b3d:	00 00 00 
  8004203b40:	48 8b 10             	mov    (%rax),%rdx
  8004203b43:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203b47:	48 01 c2             	add    %rax,%rdx
  8004203b4a:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004203b51:	00 00 00 
  8004203b54:	48 39 c2             	cmp    %rax,%rdx
  8004203b57:	76 2a                	jbe    8004203b83 <mmio_map_region+0x6e>
			panic("Out of bound memory");
  8004203b59:	48 ba e7 86 21 04 80 	movabs $0x80042186e7,%rdx
  8004203b60:	00 00 00 
  8004203b63:	be a9 03 00 00       	mov    $0x3a9,%esi
  8004203b68:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004203b6f:	00 00 00 
  8004203b72:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b77:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  8004203b7e:	00 00 00 
  8004203b81:	ff d1                	callq  *%rcx
	}
	size = ROUNDUP(size, PGSIZE);
  8004203b83:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  8004203b8a:	00 
  8004203b8b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203b8f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203b93:	48 01 d0             	add    %rdx,%rax
  8004203b96:	48 83 e8 01          	sub    $0x1,%rax
  8004203b9a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203b9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203ba2:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203ba7:	48 f7 75 f0          	divq   -0x10(%rbp)
  8004203bab:	48 89 d0             	mov    %rdx,%rax
  8004203bae:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203bb2:	48 29 c2             	sub    %rax,%rdx
  8004203bb5:	48 89 d0             	mov    %rdx,%rax
  8004203bb8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	boot_map_region(boot_pml4e, base, size,  pa,  PTE_PCD|PTE_PWT|PTE_W|PTE_P);
  8004203bbc:	48 b8 c8 d5 22 04 80 	movabs $0x800422d5c8,%rax
  8004203bc3:	00 00 00 
  8004203bc6:	48 8b 30             	mov    (%rax),%rsi
  8004203bc9:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004203bd0:	00 00 00 
  8004203bd3:	48 8b 00             	mov    (%rax),%rax
  8004203bd6:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203bda:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203bde:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  8004203be4:	48 89 c7             	mov    %rax,%rdi
  8004203be7:	48 b8 fc 36 20 04 80 	movabs $0x80042036fc,%rax
  8004203bee:	00 00 00 
  8004203bf1:	ff d0                	callq  *%rax
	base+= size;
  8004203bf3:	48 b8 c8 d5 22 04 80 	movabs $0x800422d5c8,%rax
  8004203bfa:	00 00 00 
  8004203bfd:	48 8b 10             	mov    (%rax),%rdx
  8004203c00:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203c04:	48 01 c2             	add    %rax,%rdx
  8004203c07:	48 b8 c8 d5 22 04 80 	movabs $0x800422d5c8,%rax
  8004203c0e:	00 00 00 
  8004203c11:	48 89 10             	mov    %rdx,(%rax)
	return (void*)base_prev;
  8004203c14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	//panic("mmio_map_region not implemented");

}
  8004203c18:	c9                   	leaveq 
  8004203c19:	c3                   	retq   

0000008004203c1a <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004203c1a:	55                   	push   %rbp
  8004203c1b:	48 89 e5             	mov    %rsp,%rbp
  8004203c1e:	48 83 ec 50          	sub    $0x50,%rsp
  8004203c22:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004203c26:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004203c2a:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004203c2e:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
	// LAB 3: Your code here.
	struct PageInfo * page;
	pte_t *pte_store;
	void * vaT = (void*)va;
  8004203c31:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203c35:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	void *vaE;
	vaT = ROUNDDOWN(vaT,PGSIZE);
  8004203c39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c3d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203c41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203c45:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203c4b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	vaE = ROUNDUP(vaT + len, PGSIZE);
  8004203c4f:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004203c56:	00 
  8004203c57:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203c5b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203c5f:	48 01 d0             	add    %rdx,%rax
  8004203c62:	48 89 c2             	mov    %rax,%rdx
  8004203c65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203c69:	48 01 d0             	add    %rdx,%rax
  8004203c6c:	48 83 e8 01          	sub    $0x1,%rax
  8004203c70:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203c74:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203c78:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203c7d:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004203c81:	48 89 d0             	mov    %rdx,%rax
  8004203c84:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203c88:	48 29 c2             	sub    %rax,%rdx
  8004203c8b:	48 89 d0             	mov    %rdx,%rax
  8004203c8e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;vaT < vaE; vaT = vaT + PGSIZE)
  8004203c92:	e9 8c 00 00 00       	jmpq   8004203d23 <user_mem_check+0x109>
	{
		if((uintptr_t)vaT >= ULIM || !page_lookup(env->env_pml4e, vaT, &pte_store) || !pte_store || !(*pte_store & perm))
  8004203c97:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203c9b:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004203ca2:	00 00 00 
  8004203ca5:	48 39 c2             	cmp    %rax,%rdx
  8004203ca8:	77 47                	ja     8004203cf1 <user_mem_check+0xd7>
  8004203caa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203cae:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203cb5:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004203cb9:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004203cbd:	48 89 ce             	mov    %rcx,%rsi
  8004203cc0:	48 89 c7             	mov    %rax,%rdi
  8004203cc3:	48 b8 1c 39 20 04 80 	movabs $0x800420391c,%rax
  8004203cca:	00 00 00 
  8004203ccd:	ff d0                	callq  *%rax
  8004203ccf:	48 85 c0             	test   %rax,%rax
  8004203cd2:	74 1d                	je     8004203cf1 <user_mem_check+0xd7>
  8004203cd4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203cd8:	48 85 c0             	test   %rax,%rax
  8004203cdb:	74 14                	je     8004203cf1 <user_mem_check+0xd7>
  8004203cdd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203ce1:	48 8b 10             	mov    (%rax),%rdx
  8004203ce4:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004203ce7:	48 98                	cltq   
  8004203ce9:	48 21 d0             	and    %rdx,%rax
  8004203cec:	48 85 c0             	test   %rax,%rax
  8004203cef:	75 2a                	jne    8004203d1b <user_mem_check+0x101>
		{
			if(vaT < va){
  8004203cf1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203cf5:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004203cf9:	73 08                	jae    8004203d03 <user_mem_check+0xe9>
				vaT = (void*)va;
  8004203cfb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203cff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			}
			user_mem_check_addr = (uintptr_t)vaT;
  8004203d03:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203d07:	48 b8 40 72 60 04 80 	movabs $0x8004607240,%rax
  8004203d0e:	00 00 00 
  8004203d11:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;		
  8004203d14:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004203d19:	eb 1b                	jmp    8004203d36 <user_mem_check+0x11c>
	pte_t *pte_store;
	void * vaT = (void*)va;
	void *vaE;
	vaT = ROUNDDOWN(vaT,PGSIZE);
	vaE = ROUNDUP(vaT + len, PGSIZE);
	for(;vaT < vaE; vaT = vaT + PGSIZE)
  8004203d1b:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203d22:	00 
  8004203d23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d27:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203d2b:	0f 82 66 ff ff ff    	jb     8004203c97 <user_mem_check+0x7d>
			}
			user_mem_check_addr = (uintptr_t)vaT;
			return -E_FAULT;		
		}
	}
	return 0;
  8004203d31:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203d36:	c9                   	leaveq 
  8004203d37:	c3                   	retq   

0000008004203d38 <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  8004203d38:	55                   	push   %rbp
  8004203d39:	48 89 e5             	mov    %rsp,%rbp
  8004203d3c:	48 83 ec 20          	sub    $0x20,%rsp
  8004203d40:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004203d44:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004203d48:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004203d4c:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004203d4f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203d52:	83 c8 04             	or     $0x4,%eax
  8004203d55:	89 c1                	mov    %eax,%ecx
  8004203d57:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203d5b:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004203d5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d63:	48 89 c7             	mov    %rax,%rdi
  8004203d66:	48 b8 1a 3c 20 04 80 	movabs $0x8004203c1a,%rax
  8004203d6d:	00 00 00 
  8004203d70:	ff d0                	callq  *%rax
  8004203d72:	85 c0                	test   %eax,%eax
  8004203d74:	79 47                	jns    8004203dbd <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  8004203d76:	48 b8 40 72 60 04 80 	movabs $0x8004607240,%rax
  8004203d7d:	00 00 00 
  8004203d80:	48 8b 10             	mov    (%rax),%rdx
  8004203d83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d87:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004203d8d:	89 c6                	mov    %eax,%esi
  8004203d8f:	48 bf 00 87 21 04 80 	movabs $0x8004218700,%rdi
  8004203d96:	00 00 00 
  8004203d99:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d9e:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  8004203da5:	00 00 00 
  8004203da8:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  8004203daa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203dae:	48 89 c7             	mov    %rax,%rdi
  8004203db1:	48 b8 b9 85 20 04 80 	movabs $0x80042085b9,%rax
  8004203db8:	00 00 00 
  8004203dbb:	ff d0                	callq  *%rax
	}
}
  8004203dbd:	c9                   	leaveq 
  8004203dbe:	c3                   	retq   

0000008004203dbf <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004203dbf:	55                   	push   %rbp
  8004203dc0:	48 89 e5             	mov    %rsp,%rbp
  8004203dc3:	48 83 ec 60          	sub    $0x60,%rsp
  8004203dc7:	89 f8                	mov    %edi,%eax
  8004203dc9:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004203dcc:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203dd0:	74 07                	je     8004203dd9 <check_page_free_list+0x1a>
  8004203dd2:	b8 01 00 00 00       	mov    $0x1,%eax
  8004203dd7:	eb 05                	jmp    8004203dde <check_page_free_list+0x1f>
  8004203dd9:	b8 00 02 00 00       	mov    $0x200,%eax
  8004203dde:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004203de1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203de8:	00 
  8004203de9:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203df0:	00 
	char *first_free_page;

	if (!page_free_list)
  8004203df1:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004203df8:	00 00 00 
  8004203dfb:	48 8b 00             	mov    (%rax),%rax
  8004203dfe:	48 85 c0             	test   %rax,%rax
  8004203e01:	75 2a                	jne    8004203e2d <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004203e03:	48 ba 38 87 21 04 80 	movabs $0x8004218738,%rdx
  8004203e0a:	00 00 00 
  8004203e0d:	be 02 04 00 00       	mov    $0x402,%esi
  8004203e12:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004203e19:	00 00 00 
  8004203e1c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e21:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  8004203e28:	00 00 00 
  8004203e2b:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004203e2d:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203e31:	0f 84 a9 00 00 00    	je     8004203ee0 <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  8004203e37:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004203e3b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004203e3f:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004203e43:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203e47:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004203e4e:	00 00 00 
  8004203e51:	48 8b 00             	mov    (%rax),%rax
  8004203e54:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203e58:	eb 58                	jmp    8004203eb2 <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  8004203e5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e5e:	48 89 c7             	mov    %rax,%rdi
  8004203e61:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004203e68:	00 00 00 
  8004203e6b:	ff d0                	callq  *%rax
  8004203e6d:	48 c1 e8 15          	shr    $0x15,%rax
  8004203e71:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203e76:	48 89 c2             	mov    %rax,%rdx
  8004203e79:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203e7c:	48 39 c2             	cmp    %rax,%rdx
  8004203e7f:	0f 93 c0             	setae  %al
  8004203e82:	0f b6 c0             	movzbl %al,%eax
  8004203e85:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  8004203e88:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203e8b:	48 98                	cltq   
  8004203e8d:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  8004203e92:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203e96:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  8004203e99:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203e9d:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203ea0:	48 98                	cltq   
  8004203ea2:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203ea7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203eab:	48 8b 00             	mov    (%rax),%rax
  8004203eae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203eb2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203eb7:	75 a1                	jne    8004203e5a <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004203eb9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203ebd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004203ec4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203ec8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203ecc:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004203ecf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203ed3:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004203eda:	00 00 00 
  8004203edd:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203ee0:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004203ee7:	00 00 00 
  8004203eea:	48 8b 00             	mov    (%rax),%rax
  8004203eed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203ef1:	eb 5e                	jmp    8004203f51 <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004203ef3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ef7:	48 89 c7             	mov    %rax,%rdi
  8004203efa:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004203f01:	00 00 00 
  8004203f04:	ff d0                	callq  *%rax
  8004203f06:	48 c1 e8 15          	shr    $0x15,%rax
  8004203f0a:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203f0f:	48 89 c2             	mov    %rax,%rdx
  8004203f12:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203f15:	48 39 c2             	cmp    %rax,%rdx
  8004203f18:	73 2c                	jae    8004203f46 <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  8004203f1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f1e:	48 89 c7             	mov    %rax,%rdi
  8004203f21:	48 b8 8e 1c 20 04 80 	movabs $0x8004201c8e,%rax
  8004203f28:	00 00 00 
  8004203f2b:	ff d0                	callq  *%rax
  8004203f2d:	ba 80 00 00 00       	mov    $0x80,%edx
  8004203f32:	be 97 00 00 00       	mov    $0x97,%esi
  8004203f37:	48 89 c7             	mov    %rax,%rdi
  8004203f3a:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004203f41:	00 00 00 
  8004203f44:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203f46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f4a:	48 8b 00             	mov    (%rax),%rax
  8004203f4d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f51:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203f56:	75 9b                	jne    8004203ef3 <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  8004203f58:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203f5d:	48 b8 b7 25 20 04 80 	movabs $0x80042025b7,%rax
  8004203f64:	00 00 00 
  8004203f67:	ff d0                	callq  *%rax
  8004203f69:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203f6d:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004203f74:	00 00 00 
  8004203f77:	48 8b 00             	mov    (%rax),%rax
  8004203f7a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f7e:	e9 20 03 00 00       	jmpq   80042042a3 <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  8004203f83:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004203f8a:	00 00 00 
  8004203f8d:	48 8b 00             	mov    (%rax),%rax
  8004203f90:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203f94:	73 35                	jae    8004203fcb <check_page_free_list+0x20c>
  8004203f96:	48 b9 5c 87 21 04 80 	movabs $0x800421875c,%rcx
  8004203f9d:	00 00 00 
  8004203fa0:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004203fa7:	00 00 00 
  8004203faa:	be 1c 04 00 00       	mov    $0x41c,%esi
  8004203faf:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004203fb6:	00 00 00 
  8004203fb9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fbe:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004203fc5:	00 00 00 
  8004203fc8:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004203fcb:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004203fd2:	00 00 00 
  8004203fd5:	48 8b 10             	mov    (%rax),%rdx
  8004203fd8:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004203fdf:	00 00 00 
  8004203fe2:	48 8b 00             	mov    (%rax),%rax
  8004203fe5:	48 c1 e0 04          	shl    $0x4,%rax
  8004203fe9:	48 01 d0             	add    %rdx,%rax
  8004203fec:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203ff0:	77 35                	ja     8004204027 <check_page_free_list+0x268>
  8004203ff2:	48 b9 68 87 21 04 80 	movabs $0x8004218768,%rcx
  8004203ff9:	00 00 00 
  8004203ffc:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204003:	00 00 00 
  8004204006:	be 1d 04 00 00       	mov    $0x41d,%esi
  800420400b:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204012:	00 00 00 
  8004204015:	b8 00 00 00 00       	mov    $0x0,%eax
  800420401a:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204021:	00 00 00 
  8004204024:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  8004204027:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420402b:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004204032:	00 00 00 
  8004204035:	48 8b 00             	mov    (%rax),%rax
  8004204038:	48 29 c2             	sub    %rax,%rdx
  800420403b:	48 89 d0             	mov    %rdx,%rax
  800420403e:	83 e0 0f             	and    $0xf,%eax
  8004204041:	48 85 c0             	test   %rax,%rax
  8004204044:	74 35                	je     800420407b <check_page_free_list+0x2bc>
  8004204046:	48 b9 80 87 21 04 80 	movabs $0x8004218780,%rcx
  800420404d:	00 00 00 
  8004204050:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204057:	00 00 00 
  800420405a:	be 1e 04 00 00       	mov    $0x41e,%esi
  800420405f:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204066:	00 00 00 
  8004204069:	b8 00 00 00 00       	mov    $0x0,%eax
  800420406e:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204075:	00 00 00 
  8004204078:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  800420407b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420407f:	48 89 c7             	mov    %rax,%rdi
  8004204082:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004204089:	00 00 00 
  800420408c:	ff d0                	callq  *%rax
  800420408e:	48 85 c0             	test   %rax,%rax
  8004204091:	75 35                	jne    80042040c8 <check_page_free_list+0x309>
  8004204093:	48 b9 b2 87 21 04 80 	movabs $0x80042187b2,%rcx
  800420409a:	00 00 00 
  800420409d:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042040a4:	00 00 00 
  80042040a7:	be 21 04 00 00       	mov    $0x421,%esi
  80042040ac:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042040b3:	00 00 00 
  80042040b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040bb:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042040c2:	00 00 00 
  80042040c5:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  80042040c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042040cc:	48 89 c7             	mov    %rax,%rdi
  80042040cf:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  80042040d6:	00 00 00 
  80042040d9:	ff d0                	callq  *%rax
  80042040db:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  80042040e1:	75 35                	jne    8004204118 <check_page_free_list+0x359>
  80042040e3:	48 b9 c3 87 21 04 80 	movabs $0x80042187c3,%rcx
  80042040ea:	00 00 00 
  80042040ed:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042040f4:	00 00 00 
  80042040f7:	be 22 04 00 00       	mov    $0x422,%esi
  80042040fc:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204103:	00 00 00 
  8004204106:	b8 00 00 00 00       	mov    $0x0,%eax
  800420410b:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204112:	00 00 00 
  8004204115:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004204118:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420411c:	48 89 c7             	mov    %rax,%rdi
  800420411f:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004204126:	00 00 00 
  8004204129:	ff d0                	callq  *%rax
  800420412b:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204131:	75 35                	jne    8004204168 <check_page_free_list+0x3a9>
  8004204133:	48 b9 e0 87 21 04 80 	movabs $0x80042187e0,%rcx
  800420413a:	00 00 00 
  800420413d:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204144:	00 00 00 
  8004204147:	be 23 04 00 00       	mov    $0x423,%esi
  800420414c:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204153:	00 00 00 
  8004204156:	b8 00 00 00 00       	mov    $0x0,%eax
  800420415b:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204162:	00 00 00 
  8004204165:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  8004204168:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420416c:	48 89 c7             	mov    %rax,%rdi
  800420416f:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004204176:	00 00 00 
  8004204179:	ff d0                	callq  *%rax
  800420417b:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204181:	75 35                	jne    80042041b8 <check_page_free_list+0x3f9>
  8004204183:	48 b9 03 88 21 04 80 	movabs $0x8004218803,%rcx
  800420418a:	00 00 00 
  800420418d:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204194:	00 00 00 
  8004204197:	be 24 04 00 00       	mov    $0x424,%esi
  800420419c:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042041a3:	00 00 00 
  80042041a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041ab:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042041b2:	00 00 00 
  80042041b5:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  80042041b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041bc:	48 89 c7             	mov    %rax,%rdi
  80042041bf:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  80042041c6:	00 00 00 
  80042041c9:	ff d0                	callq  *%rax
  80042041cb:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042041d1:	76 4e                	jbe    8004204221 <check_page_free_list+0x462>
  80042041d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041d7:	48 89 c7             	mov    %rax,%rdi
  80042041da:	48 b8 8e 1c 20 04 80 	movabs $0x8004201c8e,%rax
  80042041e1:	00 00 00 
  80042041e4:	ff d0                	callq  *%rax
  80042041e6:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042041ea:	73 35                	jae    8004204221 <check_page_free_list+0x462>
  80042041ec:	48 b9 20 88 21 04 80 	movabs $0x8004218820,%rcx
  80042041f3:	00 00 00 
  80042041f6:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042041fd:	00 00 00 
  8004204200:	be 25 04 00 00       	mov    $0x425,%esi
  8004204205:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420420c:	00 00 00 
  800420420f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204214:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420421b:	00 00 00 
  800420421e:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004204221:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204225:	48 89 c7             	mov    %rax,%rdi
  8004204228:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  800420422f:	00 00 00 
  8004204232:	ff d0                	callq  *%rax
  8004204234:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  800420423a:	75 35                	jne    8004204271 <check_page_free_list+0x4b2>
  800420423c:	48 b9 65 88 21 04 80 	movabs $0x8004218865,%rcx
  8004204243:	00 00 00 
  8004204246:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420424d:	00 00 00 
  8004204250:	be 27 04 00 00       	mov    $0x427,%esi
  8004204255:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420425c:	00 00 00 
  800420425f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204264:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420426b:	00 00 00 
  800420426e:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  8004204271:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204275:	48 89 c7             	mov    %rax,%rdi
  8004204278:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  800420427f:	00 00 00 
  8004204282:	ff d0                	callq  *%rax
  8004204284:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  800420428a:	77 07                	ja     8004204293 <check_page_free_list+0x4d4>
			++nfree_basemem;
  800420428c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004204291:	eb 05                	jmp    8004204298 <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  8004204293:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004204298:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420429c:	48 8b 00             	mov    (%rax),%rax
  800420429f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042042a3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042042a8:	0f 85 d5 fc ff ff    	jne    8004203f83 <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  80042042ae:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042042b3:	75 35                	jne    80042042ea <check_page_free_list+0x52b>
  80042042b5:	48 b9 82 88 21 04 80 	movabs $0x8004218882,%rcx
  80042042bc:	00 00 00 
  80042042bf:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042042c6:	00 00 00 
  80042042c9:	be 2f 04 00 00       	mov    $0x42f,%esi
  80042042ce:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042042d5:	00 00 00 
  80042042d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042dd:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042042e4:	00 00 00 
  80042042e7:	41 ff d0             	callq  *%r8
}
  80042042ea:	c9                   	leaveq 
  80042042eb:	c3                   	retq   

00000080042042ec <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  80042042ec:	55                   	push   %rbp
  80042042ed:	48 89 e5             	mov    %rsp,%rbp
  80042042f0:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042042f4:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  80042042fb:	00 00 00 
  80042042fe:	48 8b 00             	mov    (%rax),%rax
  8004204301:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  800420430c:	eb 37                	jmp    8004204345 <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  800420430e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204312:	48 89 c7             	mov    %rax,%rdi
  8004204315:	48 b8 8e 1c 20 04 80 	movabs $0x8004201c8e,%rax
  800420431c:	00 00 00 
  800420431f:	ff d0                	callq  *%rax
  8004204321:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204326:	be 97 00 00 00       	mov    $0x97,%esi
  800420432b:	48 89 c7             	mov    %rax,%rdi
  800420432e:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004204335:	00 00 00 
  8004204338:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420433a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420433e:	48 8b 00             	mov    (%rax),%rax
  8004204341:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204345:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420434a:	75 c2                	jne    800420430e <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420434c:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004204353:	00 00 00 
  8004204356:	48 8b 00             	mov    (%rax),%rax
  8004204359:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420435d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004204364:	e9 ec 01 00 00       	jmpq   8004204555 <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  8004204369:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004204370:	00 00 00 
  8004204373:	48 8b 00             	mov    (%rax),%rax
  8004204376:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800420437a:	73 35                	jae    80042043b1 <check_page_alloc+0xc5>
  800420437c:	48 b9 93 88 21 04 80 	movabs $0x8004218893,%rcx
  8004204383:	00 00 00 
  8004204386:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420438d:	00 00 00 
  8004204390:	be 48 04 00 00       	mov    $0x448,%esi
  8004204395:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420439c:	00 00 00 
  800420439f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043a4:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042043ab:	00 00 00 
  80042043ae:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  80042043b1:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  80042043b8:	00 00 00 
  80042043bb:	48 8b 10             	mov    (%rax),%rdx
  80042043be:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  80042043c5:	00 00 00 
  80042043c8:	48 8b 00             	mov    (%rax),%rax
  80042043cb:	48 c1 e0 04          	shl    $0x4,%rax
  80042043cf:	48 01 d0             	add    %rdx,%rax
  80042043d2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042043d6:	77 35                	ja     800420440d <check_page_alloc+0x121>
  80042043d8:	48 b9 a0 88 21 04 80 	movabs $0x80042188a0,%rcx
  80042043df:	00 00 00 
  80042043e2:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042043e9:	00 00 00 
  80042043ec:	be 49 04 00 00       	mov    $0x449,%esi
  80042043f1:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042043f8:	00 00 00 
  80042043fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204400:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204407:	00 00 00 
  800420440a:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  800420440d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204411:	48 89 c7             	mov    %rax,%rdi
  8004204414:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  800420441b:	00 00 00 
  800420441e:	ff d0                	callq  *%rax
  8004204420:	48 85 c0             	test   %rax,%rax
  8004204423:	75 35                	jne    800420445a <check_page_alloc+0x16e>
  8004204425:	48 b9 b5 88 21 04 80 	movabs $0x80042188b5,%rcx
  800420442c:	00 00 00 
  800420442f:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204436:	00 00 00 
  8004204439:	be 4c 04 00 00       	mov    $0x44c,%esi
  800420443e:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204445:	00 00 00 
  8004204448:	b8 00 00 00 00       	mov    $0x0,%eax
  800420444d:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204454:	00 00 00 
  8004204457:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  800420445a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420445e:	48 89 c7             	mov    %rax,%rdi
  8004204461:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004204468:	00 00 00 
  800420446b:	ff d0                	callq  *%rax
  800420446d:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204473:	75 35                	jne    80042044aa <check_page_alloc+0x1be>
  8004204475:	48 b9 c7 88 21 04 80 	movabs $0x80042188c7,%rcx
  800420447c:	00 00 00 
  800420447f:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204486:	00 00 00 
  8004204489:	be 4d 04 00 00       	mov    $0x44d,%esi
  800420448e:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204495:	00 00 00 
  8004204498:	b8 00 00 00 00       	mov    $0x0,%eax
  800420449d:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042044a4:	00 00 00 
  80042044a7:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  80042044aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042044ae:	48 89 c7             	mov    %rax,%rdi
  80042044b1:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  80042044b8:	00 00 00 
  80042044bb:	ff d0                	callq  *%rax
  80042044bd:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  80042044c3:	75 35                	jne    80042044fa <check_page_alloc+0x20e>
  80042044c5:	48 b9 e8 88 21 04 80 	movabs $0x80042188e8,%rcx
  80042044cc:	00 00 00 
  80042044cf:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042044d6:	00 00 00 
  80042044d9:	be 4e 04 00 00       	mov    $0x44e,%esi
  80042044de:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042044e5:	00 00 00 
  80042044e8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044ed:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042044f4:	00 00 00 
  80042044f7:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  80042044fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042044fe:	48 89 c7             	mov    %rax,%rdi
  8004204501:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004204508:	00 00 00 
  800420450b:	ff d0                	callq  *%rax
  800420450d:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204513:	75 35                	jne    800420454a <check_page_alloc+0x25e>
  8004204515:	48 b9 0c 89 21 04 80 	movabs $0x800421890c,%rcx
  800420451c:	00 00 00 
  800420451f:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204526:	00 00 00 
  8004204529:	be 4f 04 00 00       	mov    $0x44f,%esi
  800420452e:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204535:	00 00 00 
  8004204538:	b8 00 00 00 00       	mov    $0x0,%eax
  800420453d:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204544:	00 00 00 
  8004204547:	41 ff d0             	callq  *%r8
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420454a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420454e:	48 8b 00             	mov    (%rax),%rax
  8004204551:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204555:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420455a:	0f 85 09 fe ff ff    	jne    8004204369 <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  8004204560:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204567:	00 
  8004204568:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420456c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204570:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204574:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204578:	bf 00 00 00 00       	mov    $0x0,%edi
  800420457d:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  8004204584:	00 00 00 
  8004204587:	ff d0                	callq  *%rax
  8004204589:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420458d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204592:	75 35                	jne    80042045c9 <check_page_alloc+0x2dd>
  8004204594:	48 b9 27 89 21 04 80 	movabs $0x8004218927,%rcx
  800420459b:	00 00 00 
  800420459e:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042045a5:	00 00 00 
  80042045a8:	be 53 04 00 00       	mov    $0x453,%esi
  80042045ad:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042045b4:	00 00 00 
  80042045b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045bc:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042045c3:	00 00 00 
  80042045c6:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  80042045c9:	bf 00 00 00 00       	mov    $0x0,%edi
  80042045ce:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  80042045d5:	00 00 00 
  80042045d8:	ff d0                	callq  *%rax
  80042045da:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042045de:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042045e3:	75 35                	jne    800420461a <check_page_alloc+0x32e>
  80042045e5:	48 b9 3d 89 21 04 80 	movabs $0x800421893d,%rcx
  80042045ec:	00 00 00 
  80042045ef:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042045f6:	00 00 00 
  80042045f9:	be 54 04 00 00       	mov    $0x454,%esi
  80042045fe:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204605:	00 00 00 
  8004204608:	b8 00 00 00 00       	mov    $0x0,%eax
  800420460d:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204614:	00 00 00 
  8004204617:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  800420461a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420461f:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  8004204626:	00 00 00 
  8004204629:	ff d0                	callq  *%rax
  800420462b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420462f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204634:	75 35                	jne    800420466b <check_page_alloc+0x37f>
  8004204636:	48 b9 53 89 21 04 80 	movabs $0x8004218953,%rcx
  800420463d:	00 00 00 
  8004204640:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204647:	00 00 00 
  800420464a:	be 55 04 00 00       	mov    $0x455,%esi
  800420464f:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204656:	00 00 00 
  8004204659:	b8 00 00 00 00       	mov    $0x0,%eax
  800420465e:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204665:	00 00 00 
  8004204668:	41 ff d0             	callq  *%r8
	assert(pp0);
  800420466b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204670:	75 35                	jne    80042046a7 <check_page_alloc+0x3bb>
  8004204672:	48 b9 69 89 21 04 80 	movabs $0x8004218969,%rcx
  8004204679:	00 00 00 
  800420467c:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204683:	00 00 00 
  8004204686:	be 56 04 00 00       	mov    $0x456,%esi
  800420468b:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204692:	00 00 00 
  8004204695:	b8 00 00 00 00       	mov    $0x0,%eax
  800420469a:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042046a1:	00 00 00 
  80042046a4:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  80042046a7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042046ac:	74 0a                	je     80042046b8 <check_page_alloc+0x3cc>
  80042046ae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042046b2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042046b6:	75 35                	jne    80042046ed <check_page_alloc+0x401>
  80042046b8:	48 b9 6d 89 21 04 80 	movabs $0x800421896d,%rcx
  80042046bf:	00 00 00 
  80042046c2:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042046c9:	00 00 00 
  80042046cc:	be 57 04 00 00       	mov    $0x457,%esi
  80042046d1:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042046d8:	00 00 00 
  80042046db:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046e0:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042046e7:	00 00 00 
  80042046ea:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  80042046ed:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042046f2:	74 14                	je     8004204708 <check_page_alloc+0x41c>
  80042046f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042046f8:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042046fc:	74 0a                	je     8004204708 <check_page_alloc+0x41c>
  80042046fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204702:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204706:	75 35                	jne    800420473d <check_page_alloc+0x451>
  8004204708:	48 b9 80 89 21 04 80 	movabs $0x8004218980,%rcx
  800420470f:	00 00 00 
  8004204712:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204719:	00 00 00 
  800420471c:	be 58 04 00 00       	mov    $0x458,%esi
  8004204721:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204728:	00 00 00 
  800420472b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204730:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204737:	00 00 00 
  800420473a:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  800420473d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204741:	48 89 c7             	mov    %rax,%rdi
  8004204744:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  800420474b:	00 00 00 
  800420474e:	ff d0                	callq  *%rax
  8004204750:	48 ba 80 87 60 04 80 	movabs $0x8004608780,%rdx
  8004204757:	00 00 00 
  800420475a:	48 8b 12             	mov    (%rdx),%rdx
  800420475d:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204761:	48 39 d0             	cmp    %rdx,%rax
  8004204764:	72 35                	jb     800420479b <check_page_alloc+0x4af>
  8004204766:	48 b9 a0 89 21 04 80 	movabs $0x80042189a0,%rcx
  800420476d:	00 00 00 
  8004204770:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204777:	00 00 00 
  800420477a:	be 59 04 00 00       	mov    $0x459,%esi
  800420477f:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204786:	00 00 00 
  8004204789:	b8 00 00 00 00       	mov    $0x0,%eax
  800420478e:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204795:	00 00 00 
  8004204798:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  800420479b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420479f:	48 89 c7             	mov    %rax,%rdi
  80042047a2:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  80042047a9:	00 00 00 
  80042047ac:	ff d0                	callq  *%rax
  80042047ae:	48 ba 80 87 60 04 80 	movabs $0x8004608780,%rdx
  80042047b5:	00 00 00 
  80042047b8:	48 8b 12             	mov    (%rdx),%rdx
  80042047bb:	48 c1 e2 0c          	shl    $0xc,%rdx
  80042047bf:	48 39 d0             	cmp    %rdx,%rax
  80042047c2:	72 35                	jb     80042047f9 <check_page_alloc+0x50d>
  80042047c4:	48 b9 bd 89 21 04 80 	movabs $0x80042189bd,%rcx
  80042047cb:	00 00 00 
  80042047ce:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042047d5:	00 00 00 
  80042047d8:	be 5a 04 00 00       	mov    $0x45a,%esi
  80042047dd:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042047e4:	00 00 00 
  80042047e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047ec:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042047f3:	00 00 00 
  80042047f6:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  80042047f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042047fd:	48 89 c7             	mov    %rax,%rdi
  8004204800:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004204807:	00 00 00 
  800420480a:	ff d0                	callq  *%rax
  800420480c:	48 ba 80 87 60 04 80 	movabs $0x8004608780,%rdx
  8004204813:	00 00 00 
  8004204816:	48 8b 12             	mov    (%rdx),%rdx
  8004204819:	48 c1 e2 0c          	shl    $0xc,%rdx
  800420481d:	48 39 d0             	cmp    %rdx,%rax
  8004204820:	72 35                	jb     8004204857 <check_page_alloc+0x56b>
  8004204822:	48 b9 da 89 21 04 80 	movabs $0x80042189da,%rcx
  8004204829:	00 00 00 
  800420482c:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204833:	00 00 00 
  8004204836:	be 5b 04 00 00       	mov    $0x45b,%esi
  800420483b:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204842:	00 00 00 
  8004204845:	b8 00 00 00 00       	mov    $0x0,%eax
  800420484a:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204851:	00 00 00 
  8004204854:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004204857:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  800420485e:	00 00 00 
  8004204861:	48 8b 00             	mov    (%rax),%rax
  8004204864:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  8004204868:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  800420486f:	00 00 00 
  8004204872:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004204879:	bf 00 00 00 00       	mov    $0x0,%edi
  800420487e:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  8004204885:	00 00 00 
  8004204888:	ff d0                	callq  *%rax
  800420488a:	48 85 c0             	test   %rax,%rax
  800420488d:	74 35                	je     80042048c4 <check_page_alloc+0x5d8>
  800420488f:	48 b9 f7 89 21 04 80 	movabs $0x80042189f7,%rcx
  8004204896:	00 00 00 
  8004204899:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042048a0:	00 00 00 
  80042048a3:	be 62 04 00 00       	mov    $0x462,%esi
  80042048a8:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042048af:	00 00 00 
  80042048b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048b7:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042048be:	00 00 00 
  80042048c1:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  80042048c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048c8:	48 89 c7             	mov    %rax,%rdi
  80042048cb:	48 b8 4f 30 20 04 80 	movabs $0x800420304f,%rax
  80042048d2:	00 00 00 
  80042048d5:	ff d0                	callq  *%rax
	page_free(pp1);
  80042048d7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042048db:	48 89 c7             	mov    %rax,%rdi
  80042048de:	48 b8 4f 30 20 04 80 	movabs $0x800420304f,%rax
  80042048e5:	00 00 00 
  80042048e8:	ff d0                	callq  *%rax
	page_free(pp2);
  80042048ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042048ee:	48 89 c7             	mov    %rax,%rdi
  80042048f1:	48 b8 4f 30 20 04 80 	movabs $0x800420304f,%rax
  80042048f8:	00 00 00 
  80042048fb:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  80042048fd:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204904:	00 
  8004204905:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204909:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420490d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204911:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204915:	bf 00 00 00 00       	mov    $0x0,%edi
  800420491a:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  8004204921:	00 00 00 
  8004204924:	ff d0                	callq  *%rax
  8004204926:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420492a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420492f:	75 35                	jne    8004204966 <check_page_alloc+0x67a>
  8004204931:	48 b9 27 89 21 04 80 	movabs $0x8004218927,%rcx
  8004204938:	00 00 00 
  800420493b:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204942:	00 00 00 
  8004204945:	be 69 04 00 00       	mov    $0x469,%esi
  800420494a:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204951:	00 00 00 
  8004204954:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204959:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204960:	00 00 00 
  8004204963:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204966:	bf 00 00 00 00       	mov    $0x0,%edi
  800420496b:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  8004204972:	00 00 00 
  8004204975:	ff d0                	callq  *%rax
  8004204977:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420497b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204980:	75 35                	jne    80042049b7 <check_page_alloc+0x6cb>
  8004204982:	48 b9 3d 89 21 04 80 	movabs $0x800421893d,%rcx
  8004204989:	00 00 00 
  800420498c:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204993:	00 00 00 
  8004204996:	be 6a 04 00 00       	mov    $0x46a,%esi
  800420499b:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042049a2:	00 00 00 
  80042049a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049aa:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042049b1:	00 00 00 
  80042049b4:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  80042049b7:	bf 00 00 00 00       	mov    $0x0,%edi
  80042049bc:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  80042049c3:	00 00 00 
  80042049c6:	ff d0                	callq  *%rax
  80042049c8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042049cc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042049d1:	75 35                	jne    8004204a08 <check_page_alloc+0x71c>
  80042049d3:	48 b9 53 89 21 04 80 	movabs $0x8004218953,%rcx
  80042049da:	00 00 00 
  80042049dd:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042049e4:	00 00 00 
  80042049e7:	be 6b 04 00 00       	mov    $0x46b,%esi
  80042049ec:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042049f3:	00 00 00 
  80042049f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049fb:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204a02:	00 00 00 
  8004204a05:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204a08:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204a0d:	75 35                	jne    8004204a44 <check_page_alloc+0x758>
  8004204a0f:	48 b9 69 89 21 04 80 	movabs $0x8004218969,%rcx
  8004204a16:	00 00 00 
  8004204a19:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204a20:	00 00 00 
  8004204a23:	be 6c 04 00 00       	mov    $0x46c,%esi
  8004204a28:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204a2f:	00 00 00 
  8004204a32:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a37:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204a3e:	00 00 00 
  8004204a41:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204a44:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204a49:	74 0a                	je     8004204a55 <check_page_alloc+0x769>
  8004204a4b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a4f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204a53:	75 35                	jne    8004204a8a <check_page_alloc+0x79e>
  8004204a55:	48 b9 6d 89 21 04 80 	movabs $0x800421896d,%rcx
  8004204a5c:	00 00 00 
  8004204a5f:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204a66:	00 00 00 
  8004204a69:	be 6d 04 00 00       	mov    $0x46d,%esi
  8004204a6e:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204a75:	00 00 00 
  8004204a78:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a7d:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204a84:	00 00 00 
  8004204a87:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204a8a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204a8f:	74 14                	je     8004204aa5 <check_page_alloc+0x7b9>
  8004204a91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204a95:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204a99:	74 0a                	je     8004204aa5 <check_page_alloc+0x7b9>
  8004204a9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204a9f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204aa3:	75 35                	jne    8004204ada <check_page_alloc+0x7ee>
  8004204aa5:	48 b9 80 89 21 04 80 	movabs $0x8004218980,%rcx
  8004204aac:	00 00 00 
  8004204aaf:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204ab6:	00 00 00 
  8004204ab9:	be 6e 04 00 00       	mov    $0x46e,%esi
  8004204abe:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204ac5:	00 00 00 
  8004204ac8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204acd:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204ad4:	00 00 00 
  8004204ad7:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004204ada:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204adf:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  8004204ae6:	00 00 00 
  8004204ae9:	ff d0                	callq  *%rax
  8004204aeb:	48 85 c0             	test   %rax,%rax
  8004204aee:	74 35                	je     8004204b25 <check_page_alloc+0x839>
  8004204af0:	48 b9 f7 89 21 04 80 	movabs $0x80042189f7,%rcx
  8004204af7:	00 00 00 
  8004204afa:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204b01:	00 00 00 
  8004204b04:	be 6f 04 00 00       	mov    $0x46f,%esi
  8004204b09:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204b10:	00 00 00 
  8004204b13:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b18:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204b1f:	00 00 00 
  8004204b22:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  8004204b25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b29:	48 89 c7             	mov    %rax,%rdi
  8004204b2c:	48 b8 8e 1c 20 04 80 	movabs $0x8004201c8e,%rax
  8004204b33:	00 00 00 
  8004204b36:	ff d0                	callq  *%rax
  8004204b38:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204b3d:	be 01 00 00 00       	mov    $0x1,%esi
  8004204b42:	48 89 c7             	mov    %rax,%rdi
  8004204b45:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004204b4c:	00 00 00 
  8004204b4f:	ff d0                	callq  *%rax
	page_free(pp0);
  8004204b51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b55:	48 89 c7             	mov    %rax,%rdi
  8004204b58:	48 b8 4f 30 20 04 80 	movabs $0x800420304f,%rax
  8004204b5f:	00 00 00 
  8004204b62:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  8004204b64:	bf 01 00 00 00       	mov    $0x1,%edi
  8004204b69:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  8004204b70:	00 00 00 
  8004204b73:	ff d0                	callq  *%rax
  8004204b75:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204b79:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204b7e:	75 35                	jne    8004204bb5 <check_page_alloc+0x8c9>
  8004204b80:	48 b9 06 8a 21 04 80 	movabs $0x8004218a06,%rcx
  8004204b87:	00 00 00 
  8004204b8a:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204b91:	00 00 00 
  8004204b94:	be 74 04 00 00       	mov    $0x474,%esi
  8004204b99:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204ba0:	00 00 00 
  8004204ba3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ba8:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204baf:	00 00 00 
  8004204bb2:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  8004204bb5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204bba:	74 0a                	je     8004204bc6 <check_page_alloc+0x8da>
  8004204bbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204bc0:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004204bc4:	74 35                	je     8004204bfb <check_page_alloc+0x90f>
  8004204bc6:	48 b9 24 8a 21 04 80 	movabs $0x8004218a24,%rcx
  8004204bcd:	00 00 00 
  8004204bd0:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204bd7:	00 00 00 
  8004204bda:	be 75 04 00 00       	mov    $0x475,%esi
  8004204bdf:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204be6:	00 00 00 
  8004204be9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bee:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204bf5:	00 00 00 
  8004204bf8:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004204bfb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204bff:	48 89 c7             	mov    %rax,%rdi
  8004204c02:	48 b8 8e 1c 20 04 80 	movabs $0x8004201c8e,%rax
  8004204c09:	00 00 00 
  8004204c0c:	ff d0                	callq  *%rax
  8004204c0e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  8004204c12:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004204c19:	eb 4d                	jmp    8004204c68 <check_page_alloc+0x97c>
		assert(c[i] == 0);
  8004204c1b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004204c1e:	48 63 d0             	movslq %eax,%rdx
  8004204c21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204c25:	48 01 d0             	add    %rdx,%rax
  8004204c28:	0f b6 00             	movzbl (%rax),%eax
  8004204c2b:	84 c0                	test   %al,%al
  8004204c2d:	74 35                	je     8004204c64 <check_page_alloc+0x978>
  8004204c2f:	48 b9 34 8a 21 04 80 	movabs $0x8004218a34,%rcx
  8004204c36:	00 00 00 
  8004204c39:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204c40:	00 00 00 
  8004204c43:	be 78 04 00 00       	mov    $0x478,%esi
  8004204c48:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204c4f:	00 00 00 
  8004204c52:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c57:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204c5e:	00 00 00 
  8004204c61:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  8004204c64:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004204c68:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  8004204c6f:	7e aa                	jle    8004204c1b <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  8004204c71:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004204c78:	00 00 00 
  8004204c7b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204c7f:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  8004204c82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c86:	48 89 c7             	mov    %rax,%rdi
  8004204c89:	48 b8 4f 30 20 04 80 	movabs $0x800420304f,%rax
  8004204c90:	00 00 00 
  8004204c93:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204c95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204c99:	48 89 c7             	mov    %rax,%rdi
  8004204c9c:	48 b8 4f 30 20 04 80 	movabs $0x800420304f,%rax
  8004204ca3:	00 00 00 
  8004204ca6:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204ca8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204cac:	48 89 c7             	mov    %rax,%rdi
  8004204caf:	48 b8 4f 30 20 04 80 	movabs $0x800420304f,%rax
  8004204cb6:	00 00 00 
  8004204cb9:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  8004204cbb:	48 bf 40 8a 21 04 80 	movabs $0x8004218a40,%rdi
  8004204cc2:	00 00 00 
  8004204cc5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204cca:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004204cd1:	00 00 00 
  8004204cd4:	ff d2                	callq  *%rdx
}
  8004204cd6:	c9                   	leaveq 
  8004204cd7:	c3                   	retq   

0000008004204cd8 <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  8004204cd8:	55                   	push   %rbp
  8004204cd9:	48 89 e5             	mov    %rsp,%rbp
  8004204cdc:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004204ce3:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  8004204cea:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004204cf1:	00 00 00 
  8004204cf4:	48 8b 00             	mov    (%rax),%rax
  8004204cf7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004204cfb:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004204d02:	00 
  8004204d03:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004204d0a:	00 00 00 
  8004204d0d:	48 8b 00             	mov    (%rax),%rax
  8004204d10:	48 c1 e0 04          	shl    $0x4,%rax
  8004204d14:	48 89 c2             	mov    %rax,%rdx
  8004204d17:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204d1b:	48 01 d0             	add    %rdx,%rax
  8004204d1e:	48 83 e8 01          	sub    $0x1,%rax
  8004204d22:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004204d26:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204d2a:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204d2f:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004204d33:	48 89 d0             	mov    %rdx,%rax
  8004204d36:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204d3a:	48 29 c2             	sub    %rax,%rdx
  8004204d3d:	48 89 d0             	mov    %rdx,%rax
  8004204d40:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  8004204d44:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204d4b:	00 
  8004204d4c:	e9 d4 00 00 00       	jmpq   8004204e25 <check_boot_pml4e+0x14d>
		 //cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  8004204d51:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  8004204d58:	00 00 00 
  8004204d5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204d5f:	48 01 c2             	add    %rax,%rdx
  8004204d62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d66:	48 89 d6             	mov    %rdx,%rsi
  8004204d69:	48 89 c7             	mov    %rax,%rdi
  8004204d6c:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  8004204d73:	00 00 00 
  8004204d76:	ff d0                	callq  *%rax
  8004204d78:	48 ba 88 87 60 04 80 	movabs $0x8004608788,%rdx
  8004204d7f:	00 00 00 
  8004204d82:	48 8b 12             	mov    (%rdx),%rdx
  8004204d85:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004204d89:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204d90:	00 00 00 
  8004204d93:	48 39 55 d0          	cmp    %rdx,-0x30(%rbp)
  8004204d97:	77 32                	ja     8004204dcb <check_boot_pml4e+0xf3>
  8004204d99:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204d9d:	48 89 c1             	mov    %rax,%rcx
  8004204da0:	48 ba 70 86 21 04 80 	movabs $0x8004218670,%rdx
  8004204da7:	00 00 00 
  8004204daa:	be 97 04 00 00       	mov    $0x497,%esi
  8004204daf:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204db6:	00 00 00 
  8004204db9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204dbe:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204dc5:	00 00 00 
  8004204dc8:	41 ff d0             	callq  *%r8
  8004204dcb:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004204dd2:	ff ff ff 
  8004204dd5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204dd9:	48 01 d1             	add    %rdx,%rcx
  8004204ddc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204de0:	48 01 ca             	add    %rcx,%rdx
  8004204de3:	48 39 d0             	cmp    %rdx,%rax
  8004204de6:	74 35                	je     8004204e1d <check_boot_pml4e+0x145>
  8004204de8:	48 b9 60 8a 21 04 80 	movabs $0x8004218a60,%rcx
  8004204def:	00 00 00 
  8004204df2:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204df9:	00 00 00 
  8004204dfc:	be 97 04 00 00       	mov    $0x497,%esi
  8004204e01:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204e08:	00 00 00 
  8004204e0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e10:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204e17:	00 00 00 
  8004204e1a:	41 ff d0             	callq  *%r8
	uint64_t i, n;

	pml4e = boot_pml4e;
	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004204e1d:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204e24:	00 
  8004204e25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e29:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204e2d:	0f 82 1e ff ff ff    	jb     8004204d51 <check_boot_pml4e+0x79>
		 //cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004204e33:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  8004204e3a:	00 
  8004204e3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204e3f:	48 05 ff 7f 04 00    	add    $0x47fff,%rax
  8004204e45:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204e49:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204e4d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204e52:	48 f7 75 c8          	divq   -0x38(%rbp)
  8004204e56:	48 89 d0             	mov    %rdx,%rax
  8004204e59:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004204e5d:	48 29 c2             	sub    %rax,%rdx
  8004204e60:	48 89 d0             	mov    %rdx,%rax
  8004204e63:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  8004204e67:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204e6e:	00 
  8004204e6f:	e9 d4 00 00 00       	jmpq   8004204f48 <check_boot_pml4e+0x270>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  8004204e74:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8004204e7b:	00 00 00 
  8004204e7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e82:	48 01 c2             	add    %rax,%rdx
  8004204e85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204e89:	48 89 d6             	mov    %rdx,%rsi
  8004204e8c:	48 89 c7             	mov    %rax,%rdi
  8004204e8f:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  8004204e96:	00 00 00 
  8004204e99:	ff d0                	callq  *%rax
  8004204e9b:	48 ba 50 72 60 04 80 	movabs $0x8004607250,%rdx
  8004204ea2:	00 00 00 
  8004204ea5:	48 8b 12             	mov    (%rdx),%rdx
  8004204ea8:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004204eac:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204eb3:	00 00 00 
  8004204eb6:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  8004204eba:	77 32                	ja     8004204eee <check_boot_pml4e+0x216>
  8004204ebc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204ec0:	48 89 c1             	mov    %rax,%rcx
  8004204ec3:	48 ba 70 86 21 04 80 	movabs $0x8004218670,%rdx
  8004204eca:	00 00 00 
  8004204ecd:	be 9d 04 00 00       	mov    $0x49d,%esi
  8004204ed2:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204ed9:	00 00 00 
  8004204edc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ee1:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204ee8:	00 00 00 
  8004204eeb:	41 ff d0             	callq  *%r8
  8004204eee:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004204ef5:	ff ff ff 
  8004204ef8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004204efc:	48 01 d1             	add    %rdx,%rcx
  8004204eff:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204f03:	48 01 ca             	add    %rcx,%rdx
  8004204f06:	48 39 d0             	cmp    %rdx,%rax
  8004204f09:	74 35                	je     8004204f40 <check_boot_pml4e+0x268>
  8004204f0b:	48 b9 98 8a 21 04 80 	movabs $0x8004218a98,%rcx
  8004204f12:	00 00 00 
  8004204f15:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204f1c:	00 00 00 
  8004204f1f:	be 9d 04 00 00       	mov    $0x49d,%esi
  8004204f24:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204f2b:	00 00 00 
  8004204f2e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f33:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204f3a:	00 00 00 
  8004204f3d:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  8004204f40:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204f47:	00 
  8004204f48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f4c:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204f50:	0f 82 1e ff ff ff    	jb     8004204e74 <check_boot_pml4e+0x19c>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204f56:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204f5d:	00 
  8004204f5e:	eb 6a                	jmp    8004204fca <check_boot_pml4e+0x2f2>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  8004204f60:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204f67:	00 00 00 
  8004204f6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f6e:	48 01 c2             	add    %rax,%rdx
  8004204f71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204f75:	48 89 d6             	mov    %rdx,%rsi
  8004204f78:	48 89 c7             	mov    %rax,%rdi
  8004204f7b:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  8004204f82:	00 00 00 
  8004204f85:	ff d0                	callq  *%rax
  8004204f87:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204f8b:	74 35                	je     8004204fc2 <check_boot_pml4e+0x2ea>
  8004204f8d:	48 b9 d0 8a 21 04 80 	movabs $0x8004218ad0,%rcx
  8004204f94:	00 00 00 
  8004204f97:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004204f9e:	00 00 00 
  8004204fa1:	be a1 04 00 00       	mov    $0x4a1,%esi
  8004204fa6:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004204fad:	00 00 00 
  8004204fb0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fb5:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004204fbc:	00 00 00 
  8004204fbf:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204fc2:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204fc9:	00 
  8004204fca:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004204fd1:	00 00 00 
  8004204fd4:	48 8b 00             	mov    (%rax),%rax
  8004204fd7:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204fdb:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204fdf:	0f 87 7b ff ff ff    	ja     8004204f60 <check_boot_pml4e+0x288>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004204fe5:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004204fec:	00 
  8004204fed:	e9 a1 01 00 00       	jmpq   8004205193 <check_boot_pml4e+0x4bb>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004204ff2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204ff6:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004204ffa:	48 89 d0             	mov    %rdx,%rax
  8004204ffd:	48 01 c0             	add    %rax,%rax
  8004205000:	48 01 d0             	add    %rdx,%rax
  8004205003:	48 c1 e0 0f          	shl    $0xf,%rax
  8004205007:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420500e:	00 00 00 
  8004205011:	48 29 c2             	sub    %rax,%rdx
  8004205014:	48 89 d0             	mov    %rdx,%rax
  8004205017:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  800420501b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205022:	00 
  8004205023:	e9 e0 00 00 00       	jmpq   8004205108 <check_boot_pml4e+0x430>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004205028:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420502c:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004205030:	48 01 d0             	add    %rdx,%rax
  8004205033:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  800420503a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420503e:	48 89 d6             	mov    %rdx,%rsi
  8004205041:	48 89 c7             	mov    %rax,%rdi
  8004205044:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  800420504b:	00 00 00 
  800420504e:	ff d0                	callq  *%rax
  8004205050:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004205054:	48 89 d1             	mov    %rdx,%rcx
  8004205057:	48 c1 e1 10          	shl    $0x10,%rcx
  800420505b:	48 ba 00 b0 60 04 80 	movabs $0x800460b000,%rdx
  8004205062:	00 00 00 
  8004205065:	48 01 ca             	add    %rcx,%rdx
  8004205068:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420506c:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004205073:	00 00 00 
  8004205076:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  800420507a:	77 32                	ja     80042050ae <check_boot_pml4e+0x3d6>
  800420507c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205080:	48 89 c1             	mov    %rax,%rcx
  8004205083:	48 ba 70 86 21 04 80 	movabs $0x8004218670,%rdx
  800420508a:	00 00 00 
  800420508d:	be a9 04 00 00       	mov    $0x4a9,%esi
  8004205092:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205099:	00 00 00 
  800420509c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050a1:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042050a8:	00 00 00 
  80042050ab:	41 ff d0             	callq  *%r8
  80042050ae:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042050b5:	ff ff ff 
  80042050b8:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042050bc:	48 01 d1             	add    %rdx,%rcx
  80042050bf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042050c3:	48 01 ca             	add    %rcx,%rdx
  80042050c6:	48 39 d0             	cmp    %rdx,%rax
  80042050c9:	74 35                	je     8004205100 <check_boot_pml4e+0x428>
  80042050cb:	48 b9 f8 8a 21 04 80 	movabs $0x8004218af8,%rcx
  80042050d2:	00 00 00 
  80042050d5:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042050dc:	00 00 00 
  80042050df:	be a9 04 00 00       	mov    $0x4a9,%esi
  80042050e4:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042050eb:	00 00 00 
  80042050ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050f3:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042050fa:	00 00 00 
  80042050fd:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205100:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205107:	00 
  8004205108:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  800420510f:	00 
  8004205110:	0f 86 12 ff ff ff    	jbe    8004205028 <check_boot_pml4e+0x350>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004205116:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420511d:	00 
  800420511e:	eb 64                	jmp    8004205184 <check_boot_pml4e+0x4ac>
			assert(check_va2pa(pml4e, base + i) == ~0);
  8004205120:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205124:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004205128:	48 01 c2             	add    %rax,%rdx
  800420512b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420512f:	48 89 d6             	mov    %rdx,%rsi
  8004205132:	48 89 c7             	mov    %rax,%rdi
  8004205135:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  800420513c:	00 00 00 
  800420513f:	ff d0                	callq  *%rax
  8004205141:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004205145:	74 35                	je     800420517c <check_boot_pml4e+0x4a4>
  8004205147:	48 b9 40 8b 21 04 80 	movabs $0x8004218b40,%rcx
  800420514e:	00 00 00 
  8004205151:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205158:	00 00 00 
  800420515b:	be ab 04 00 00       	mov    $0x4ab,%esi
  8004205160:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205167:	00 00 00 
  800420516a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420516f:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205176:	00 00 00 
  8004205179:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  800420517c:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205183:	00 
  8004205184:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  800420518b:	00 
  800420518c:	76 92                	jbe    8004205120 <check_boot_pml4e+0x448>
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  800420518e:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004205193:	48 83 7d f0 07       	cmpq   $0x7,-0x10(%rbp)
  8004205198:	0f 86 54 fe ff ff    	jbe    8004204ff2 <check_boot_pml4e+0x31a>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  800420519e:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  80042051a5:	00 00 00 
  80042051a8:	48 8b 00             	mov    (%rax),%rax
  80042051ab:	48 83 c0 08          	add    $0x8,%rax
  80042051af:	48 8b 00             	mov    (%rax),%rax
  80042051b2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042051b8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  80042051bc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042051c0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042051c4:	89 45 9c             	mov    %eax,-0x64(%rbp)
  80042051c7:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042051ca:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  80042051d1:	00 00 00 
  80042051d4:	48 8b 00             	mov    (%rax),%rax
  80042051d7:	48 39 c2             	cmp    %rax,%rdx
  80042051da:	72 32                	jb     800420520e <check_boot_pml4e+0x536>
  80042051dc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042051e0:	48 89 c1             	mov    %rax,%rcx
  80042051e3:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  80042051ea:	00 00 00 
  80042051ed:	be ae 04 00 00       	mov    $0x4ae,%esi
  80042051f2:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042051f9:	00 00 00 
  80042051fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205201:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205208:	00 00 00 
  800420520b:	41 ff d0             	callq  *%r8
  800420520e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205215:	00 00 00 
  8004205218:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420521c:	48 01 d0             	add    %rdx,%rax
  800420521f:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004205223:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205227:	48 8b 00             	mov    (%rax),%rax
  800420522a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205230:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004205234:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205238:	48 c1 e8 0c          	shr    $0xc,%rax
  800420523c:	89 45 84             	mov    %eax,-0x7c(%rbp)
  800420523f:	8b 55 84             	mov    -0x7c(%rbp),%edx
  8004205242:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004205249:	00 00 00 
  800420524c:	48 8b 00             	mov    (%rax),%rax
  800420524f:	48 39 c2             	cmp    %rax,%rdx
  8004205252:	72 32                	jb     8004205286 <check_boot_pml4e+0x5ae>
  8004205254:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205258:	48 89 c1             	mov    %rax,%rcx
  800420525b:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004205262:	00 00 00 
  8004205265:	be af 04 00 00       	mov    $0x4af,%esi
  800420526a:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205271:	00 00 00 
  8004205274:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205279:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205280:	00 00 00 
  8004205283:	41 ff d0             	callq  *%r8
  8004205286:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420528d:	00 00 00 
  8004205290:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205294:	48 01 d0             	add    %rdx,%rax
  8004205297:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  800420529e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042052a5:	00 
  80042052a6:	e9 50 01 00 00       	jmpq   80042053fb <check_boot_pml4e+0x723>
		switch (i) {
  80042052ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052af:	48 83 f8 04          	cmp    $0x4,%rax
  80042052b3:	72 67                	jb     800420531c <check_boot_pml4e+0x644>
  80042052b5:	48 83 f8 05          	cmp    $0x5,%rax
  80042052b9:	76 06                	jbe    80042052c1 <check_boot_pml4e+0x5e9>
  80042052bb:	48 83 f8 1f          	cmp    $0x1f,%rax
  80042052bf:	75 5b                	jne    800420531c <check_boot_pml4e+0x644>
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
  80042052c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052c5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042052cc:	00 
  80042052cd:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042052d4:	48 01 d0             	add    %rdx,%rax
  80042052d7:	48 8b 00             	mov    (%rax),%rax
  80042052da:	83 e0 01             	and    $0x1,%eax
  80042052dd:	48 85 c0             	test   %rax,%rax
  80042052e0:	75 35                	jne    8004205317 <check_boot_pml4e+0x63f>
  80042052e2:	48 b9 63 8b 21 04 80 	movabs $0x8004218b63,%rcx
  80042052e9:	00 00 00 
  80042052ec:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042052f3:	00 00 00 
  80042052f6:	be b7 04 00 00       	mov    $0x4b7,%esi
  80042052fb:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205302:	00 00 00 
  8004205305:	b8 00 00 00 00       	mov    $0x0,%eax
  800420530a:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205311:	00 00 00 
  8004205314:	41 ff d0             	callq  *%r8
			break;
  8004205317:	e9 da 00 00 00       	jmpq   80042053f6 <check_boot_pml4e+0x71e>
		default:
			if (i >= PDX(KERNBASE)) {
  800420531c:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  8004205321:	0f 86 ce 00 00 00    	jbe    80042053f5 <check_boot_pml4e+0x71d>
				if (pgdir[i] & PTE_P)
  8004205327:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420532b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205332:	00 
  8004205333:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420533a:	48 01 d0             	add    %rdx,%rax
  800420533d:	48 8b 00             	mov    (%rax),%rax
  8004205340:	83 e0 01             	and    $0x1,%eax
  8004205343:	48 85 c0             	test   %rax,%rax
  8004205346:	74 5a                	je     80042053a2 <check_boot_pml4e+0x6ca>
					assert(pgdir[i] & PTE_W);
  8004205348:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420534c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205353:	00 
  8004205354:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420535b:	48 01 d0             	add    %rdx,%rax
  800420535e:	48 8b 00             	mov    (%rax),%rax
  8004205361:	83 e0 02             	and    $0x2,%eax
  8004205364:	48 85 c0             	test   %rax,%rax
  8004205367:	0f 85 88 00 00 00    	jne    80042053f5 <check_boot_pml4e+0x71d>
  800420536d:	48 b9 74 8b 21 04 80 	movabs $0x8004218b74,%rcx
  8004205374:	00 00 00 
  8004205377:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420537e:	00 00 00 
  8004205381:	be bc 04 00 00       	mov    $0x4bc,%esi
  8004205386:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420538d:	00 00 00 
  8004205390:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205395:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420539c:	00 00 00 
  800420539f:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  80042053a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042053a6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042053ad:	00 
  80042053ae:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042053b5:	48 01 d0             	add    %rdx,%rax
  80042053b8:	48 8b 00             	mov    (%rax),%rax
  80042053bb:	48 85 c0             	test   %rax,%rax
  80042053be:	74 35                	je     80042053f5 <check_boot_pml4e+0x71d>
  80042053c0:	48 b9 85 8b 21 04 80 	movabs $0x8004218b85,%rcx
  80042053c7:	00 00 00 
  80042053ca:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042053d1:	00 00 00 
  80042053d4:	be be 04 00 00       	mov    $0x4be,%esi
  80042053d9:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042053e0:	00 00 00 
  80042053e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053e8:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042053ef:	00 00 00 
  80042053f2:	41 ff d0             	callq  *%r8
			} 
			break;
  80042053f5:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  80042053f6:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042053fb:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  8004205402:	00 
  8004205403:	0f 86 a2 fe ff ff    	jbe    80042052ab <check_boot_pml4e+0x5d3>
					assert(pgdir[i] == 0);
			} 
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  8004205409:	48 bf 98 8b 21 04 80 	movabs $0x8004218b98,%rdi
  8004205410:	00 00 00 
  8004205413:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205418:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420541f:	00 00 00 
  8004205422:	ff d2                	callq  *%rdx
}
  8004205424:	c9                   	leaveq 
  8004205425:	c3                   	retq   

0000008004205426 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  8004205426:	55                   	push   %rbp
  8004205427:	48 89 e5             	mov    %rsp,%rbp
  800420542a:	48 83 ec 60          	sub    $0x60,%rsp
  800420542e:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004205432:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	pml4e = &pml4e[PML4(va)];
  8004205436:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420543a:	48 c1 e8 27          	shr    $0x27,%rax
  800420543e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205443:	48 c1 e0 03          	shl    $0x3,%rax
  8004205447:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	//cprintf("pml4e %x %x \n" , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  800420544b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420544f:	48 8b 00             	mov    (%rax),%rax
  8004205452:	83 e0 01             	and    $0x1,%eax
  8004205455:	48 85 c0             	test   %rax,%rax
  8004205458:	75 0c                	jne    8004205466 <check_va2pa+0x40>
		return ~0;
  800420545a:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205461:	e9 38 02 00 00       	jmpq   800420569e <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  8004205466:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420546a:	48 8b 00             	mov    (%rax),%rax
  800420546d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205473:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004205477:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420547b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420547f:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004205482:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004205485:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  800420548c:	00 00 00 
  800420548f:	48 8b 00             	mov    (%rax),%rax
  8004205492:	48 39 c2             	cmp    %rax,%rdx
  8004205495:	72 32                	jb     80042054c9 <check_va2pa+0xa3>
  8004205497:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420549b:	48 89 c1             	mov    %rax,%rcx
  800420549e:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  80042054a5:	00 00 00 
  80042054a8:	be d5 04 00 00       	mov    $0x4d5,%esi
  80042054ad:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042054b4:	00 00 00 
  80042054b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054bc:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042054c3:	00 00 00 
  80042054c6:	41 ff d0             	callq  *%r8
  80042054c9:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042054d0:	00 00 00 
  80042054d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054d7:	48 01 d0             	add    %rdx,%rax
  80042054da:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//cprintf("pdpe %x %x \n" , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  80042054de:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042054e2:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042054e6:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042054eb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042054f2:	00 
  80042054f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042054f7:	48 01 d0             	add    %rdx,%rax
  80042054fa:	48 8b 00             	mov    (%rax),%rax
  80042054fd:	83 e0 01             	and    $0x1,%eax
  8004205500:	48 85 c0             	test   %rax,%rax
  8004205503:	75 0c                	jne    8004205511 <check_va2pa+0xeb>
		return ~0;
  8004205505:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420550c:	e9 8d 01 00 00       	jmpq   800420569e <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004205511:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205515:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205519:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420551e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205525:	00 
  8004205526:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420552a:	48 01 d0             	add    %rdx,%rax
  800420552d:	48 8b 00             	mov    (%rax),%rax
  8004205530:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205536:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420553a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420553e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205542:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004205545:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004205548:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  800420554f:	00 00 00 
  8004205552:	48 8b 00             	mov    (%rax),%rax
  8004205555:	48 39 c2             	cmp    %rax,%rdx
  8004205558:	72 32                	jb     800420558c <check_va2pa+0x166>
  800420555a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420555e:	48 89 c1             	mov    %rax,%rcx
  8004205561:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004205568:	00 00 00 
  800420556b:	be d9 04 00 00       	mov    $0x4d9,%esi
  8004205570:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205577:	00 00 00 
  800420557a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420557f:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205586:	00 00 00 
  8004205589:	41 ff d0             	callq  *%r8
  800420558c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205593:	00 00 00 
  8004205596:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420559a:	48 01 d0             	add    %rdx,%rax
  800420559d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//cprintf("pde %x %x \n" , pde, *pde);
	pde = &pde[PDX(va)];
  80042055a1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042055a5:	48 c1 e8 15          	shr    $0x15,%rax
  80042055a9:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042055ae:	48 c1 e0 03          	shl    $0x3,%rax
  80042055b2:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  80042055b6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042055ba:	48 8b 00             	mov    (%rax),%rax
  80042055bd:	83 e0 01             	and    $0x1,%eax
  80042055c0:	48 85 c0             	test   %rax,%rax
  80042055c3:	75 0c                	jne    80042055d1 <check_va2pa+0x1ab>
		return ~0;
  80042055c5:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042055cc:	e9 cd 00 00 00       	jmpq   800420569e <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  80042055d1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042055d5:	48 8b 00             	mov    (%rax),%rax
  80042055d8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042055de:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042055e2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042055e6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042055ea:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  80042055ed:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042055f0:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  80042055f7:	00 00 00 
  80042055fa:	48 8b 00             	mov    (%rax),%rax
  80042055fd:	48 39 c2             	cmp    %rax,%rdx
  8004205600:	72 32                	jb     8004205634 <check_va2pa+0x20e>
  8004205602:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205606:	48 89 c1             	mov    %rax,%rcx
  8004205609:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004205610:	00 00 00 
  8004205613:	be de 04 00 00       	mov    $0x4de,%esi
  8004205618:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420561f:	00 00 00 
  8004205622:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205627:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420562e:	00 00 00 
  8004205631:	41 ff d0             	callq  *%r8
  8004205634:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420563b:	00 00 00 
  800420563e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205642:	48 01 d0             	add    %rdx,%rax
  8004205645:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	//cprintf("pte %x %x %x \n" , pte, *pte, pte[PTX(va)]);
	if (!(pte[PTX(va)] & PTE_P))
  8004205649:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420564d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205651:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205656:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420565d:	00 
  800420565e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205662:	48 01 d0             	add    %rdx,%rax
  8004205665:	48 8b 00             	mov    (%rax),%rax
  8004205668:	83 e0 01             	and    $0x1,%eax
  800420566b:	48 85 c0             	test   %rax,%rax
  800420566e:	75 09                	jne    8004205679 <check_va2pa+0x253>
		return ~0;
  8004205670:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205677:	eb 25                	jmp    800420569e <check_va2pa+0x278>
	//cprintf("page Tale Index %x %x \n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  8004205679:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420567d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205681:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205686:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420568d:	00 
  800420568e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205692:	48 01 d0             	add    %rdx,%rax
  8004205695:	48 8b 00             	mov    (%rax),%rax
  8004205698:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  800420569e:	c9                   	leaveq 
  800420569f:	c3                   	retq   

00000080042056a0 <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  80042056a0:	55                   	push   %rbp
  80042056a1:	48 89 e5             	mov    %rsp,%rbp
  80042056a4:	53                   	push   %rbx
  80042056a5:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  80042056ac:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042056b3:	00 
  80042056b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042056b8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042056bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042056c0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042056c4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042056c8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042056cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042056d0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042056d4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042056d8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  80042056dc:	bf 00 00 00 00       	mov    $0x0,%edi
  80042056e1:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  80042056e8:	00 00 00 
  80042056eb:	ff d0                	callq  *%rax
  80042056ed:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  80042056f1:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042056f6:	75 35                	jne    800420572d <page_check+0x8d>
  80042056f8:	48 b9 b7 8b 21 04 80 	movabs $0x8004218bb7,%rcx
  80042056ff:	00 00 00 
  8004205702:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205709:	00 00 00 
  800420570c:	be f4 04 00 00       	mov    $0x4f4,%esi
  8004205711:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205718:	00 00 00 
  800420571b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205720:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205727:	00 00 00 
  800420572a:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  800420572d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205732:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  8004205739:	00 00 00 
  800420573c:	ff d0                	callq  *%rax
  800420573e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205742:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205747:	75 35                	jne    800420577e <page_check+0xde>
  8004205749:	48 b9 cb 8b 21 04 80 	movabs $0x8004218bcb,%rcx
  8004205750:	00 00 00 
  8004205753:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420575a:	00 00 00 
  800420575d:	be f5 04 00 00       	mov    $0x4f5,%esi
  8004205762:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205769:	00 00 00 
  800420576c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205771:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205778:	00 00 00 
  800420577b:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  800420577e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205783:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  800420578a:	00 00 00 
  800420578d:	ff d0                	callq  *%rax
  800420578f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205793:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205798:	75 35                	jne    80042057cf <page_check+0x12f>
  800420579a:	48 b9 df 8b 21 04 80 	movabs $0x8004218bdf,%rcx
  80042057a1:	00 00 00 
  80042057a4:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042057ab:	00 00 00 
  80042057ae:	be f6 04 00 00       	mov    $0x4f6,%esi
  80042057b3:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042057ba:	00 00 00 
  80042057bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057c2:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042057c9:	00 00 00 
  80042057cc:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  80042057cf:	bf 00 00 00 00       	mov    $0x0,%edi
  80042057d4:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  80042057db:	00 00 00 
  80042057de:	ff d0                	callq  *%rax
  80042057e0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042057e4:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042057e9:	75 35                	jne    8004205820 <page_check+0x180>
  80042057eb:	48 b9 f3 8b 21 04 80 	movabs $0x8004218bf3,%rcx
  80042057f2:	00 00 00 
  80042057f5:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042057fc:	00 00 00 
  80042057ff:	be f7 04 00 00       	mov    $0x4f7,%esi
  8004205804:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420580b:	00 00 00 
  800420580e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205813:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420581a:	00 00 00 
  800420581d:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  8004205820:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205825:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  800420582c:	00 00 00 
  800420582f:	ff d0                	callq  *%rax
  8004205831:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205835:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420583a:	75 35                	jne    8004205871 <page_check+0x1d1>
  800420583c:	48 b9 07 8c 21 04 80 	movabs $0x8004218c07,%rcx
  8004205843:	00 00 00 
  8004205846:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420584d:	00 00 00 
  8004205850:	be f8 04 00 00       	mov    $0x4f8,%esi
  8004205855:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420585c:	00 00 00 
  800420585f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205864:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420586b:	00 00 00 
  800420586e:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  8004205871:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205876:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  800420587d:	00 00 00 
  8004205880:	ff d0                	callq  *%rax
  8004205882:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205886:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420588b:	75 35                	jne    80042058c2 <page_check+0x222>
  800420588d:	48 b9 1b 8c 21 04 80 	movabs $0x8004218c1b,%rcx
  8004205894:	00 00 00 
  8004205897:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420589e:	00 00 00 
  80042058a1:	be f9 04 00 00       	mov    $0x4f9,%esi
  80042058a6:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042058ad:	00 00 00 
  80042058b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058b5:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042058bc:	00 00 00 
  80042058bf:	41 ff d0             	callq  *%r8

	assert(pp0);
  80042058c2:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042058c7:	75 35                	jne    80042058fe <page_check+0x25e>
  80042058c9:	48 b9 69 89 21 04 80 	movabs $0x8004218969,%rcx
  80042058d0:	00 00 00 
  80042058d3:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042058da:	00 00 00 
  80042058dd:	be fb 04 00 00       	mov    $0x4fb,%esi
  80042058e2:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042058e9:	00 00 00 
  80042058ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058f1:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042058f8:	00 00 00 
  80042058fb:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  80042058fe:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205903:	74 0a                	je     800420590f <page_check+0x26f>
  8004205905:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205909:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420590d:	75 35                	jne    8004205944 <page_check+0x2a4>
  800420590f:	48 b9 6d 89 21 04 80 	movabs $0x800421896d,%rcx
  8004205916:	00 00 00 
  8004205919:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205920:	00 00 00 
  8004205923:	be fc 04 00 00       	mov    $0x4fc,%esi
  8004205928:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420592f:	00 00 00 
  8004205932:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205937:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420593e:	00 00 00 
  8004205941:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205944:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205949:	74 14                	je     800420595f <page_check+0x2bf>
  800420594b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420594f:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205953:	74 0a                	je     800420595f <page_check+0x2bf>
  8004205955:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205959:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420595d:	75 35                	jne    8004205994 <page_check+0x2f4>
  800420595f:	48 b9 80 89 21 04 80 	movabs $0x8004218980,%rcx
  8004205966:	00 00 00 
  8004205969:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205970:	00 00 00 
  8004205973:	be fd 04 00 00       	mov    $0x4fd,%esi
  8004205978:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420597f:	00 00 00 
  8004205982:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205987:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420598e:	00 00 00 
  8004205991:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  8004205994:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205999:	74 1e                	je     80042059b9 <page_check+0x319>
  800420599b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420599f:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042059a3:	74 14                	je     80042059b9 <page_check+0x319>
  80042059a5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042059a9:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042059ad:	74 0a                	je     80042059b9 <page_check+0x319>
  80042059af:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042059b3:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042059b7:	75 35                	jne    80042059ee <page_check+0x34e>
  80042059b9:	48 b9 30 8c 21 04 80 	movabs $0x8004218c30,%rcx
  80042059c0:	00 00 00 
  80042059c3:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042059ca:	00 00 00 
  80042059cd:	be fe 04 00 00       	mov    $0x4fe,%esi
  80042059d2:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042059d9:	00 00 00 
  80042059dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059e1:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042059e8:	00 00 00 
  80042059eb:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  80042059ee:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042059f3:	74 28                	je     8004205a1d <page_check+0x37d>
  80042059f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042059f9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042059fd:	74 1e                	je     8004205a1d <page_check+0x37d>
  80042059ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a03:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205a07:	74 14                	je     8004205a1d <page_check+0x37d>
  8004205a09:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a0d:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205a11:	74 0a                	je     8004205a1d <page_check+0x37d>
  8004205a13:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a17:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205a1b:	75 35                	jne    8004205a52 <page_check+0x3b2>
  8004205a1d:	48 b9 60 8c 21 04 80 	movabs $0x8004218c60,%rcx
  8004205a24:	00 00 00 
  8004205a27:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205a2e:	00 00 00 
  8004205a31:	be ff 04 00 00       	mov    $0x4ff,%esi
  8004205a36:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205a3d:	00 00 00 
  8004205a40:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a45:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205a4c:	00 00 00 
  8004205a4f:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004205a52:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205a57:	74 32                	je     8004205a8b <page_check+0x3eb>
  8004205a59:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a5d:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205a61:	74 28                	je     8004205a8b <page_check+0x3eb>
  8004205a63:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a67:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205a6b:	74 1e                	je     8004205a8b <page_check+0x3eb>
  8004205a6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a71:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205a75:	74 14                	je     8004205a8b <page_check+0x3eb>
  8004205a77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a7b:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205a7f:	74 0a                	je     8004205a8b <page_check+0x3eb>
  8004205a81:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a85:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205a89:	75 35                	jne    8004205ac0 <page_check+0x420>
  8004205a8b:	48 b9 a0 8c 21 04 80 	movabs $0x8004218ca0,%rcx
  8004205a92:	00 00 00 
  8004205a95:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205a9c:	00 00 00 
  8004205a9f:	be 00 05 00 00       	mov    $0x500,%esi
  8004205aa4:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205aab:	00 00 00 
  8004205aae:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ab3:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205aba:	00 00 00 
  8004205abd:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004205ac0:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004205ac7:	00 00 00 
  8004205aca:	48 8b 00             	mov    (%rax),%rax
  8004205acd:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004205ad1:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  8004205ad8:	00 00 00 
  8004205adb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004205ae2:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205ae7:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  8004205aee:	00 00 00 
  8004205af1:	ff d0                	callq  *%rax
  8004205af3:	48 85 c0             	test   %rax,%rax
  8004205af6:	74 35                	je     8004205b2d <page_check+0x48d>
  8004205af8:	48 b9 f7 89 21 04 80 	movabs $0x80042189f7,%rcx
  8004205aff:	00 00 00 
  8004205b02:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205b09:	00 00 00 
  8004205b0c:	be 07 05 00 00       	mov    $0x507,%esi
  8004205b11:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205b18:	00 00 00 
  8004205b1b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b20:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205b27:	00 00 00 
  8004205b2a:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004205b2d:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004205b34:	00 00 00 
  8004205b37:	48 8b 00             	mov    (%rax),%rax
  8004205b3a:	48 8d 95 e8 fe ff ff 	lea    -0x118(%rbp),%rdx
  8004205b41:	be 00 00 00 00       	mov    $0x0,%esi
  8004205b46:	48 89 c7             	mov    %rax,%rdi
  8004205b49:	48 b8 1c 39 20 04 80 	movabs $0x800420391c,%rax
  8004205b50:	00 00 00 
  8004205b53:	ff d0                	callq  *%rax
  8004205b55:	48 85 c0             	test   %rax,%rax
  8004205b58:	74 35                	je     8004205b8f <page_check+0x4ef>
  8004205b5a:	48 b9 f0 8c 21 04 80 	movabs $0x8004218cf0,%rcx
  8004205b61:	00 00 00 
  8004205b64:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205b6b:	00 00 00 
  8004205b6e:	be 0a 05 00 00       	mov    $0x50a,%esi
  8004205b73:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205b7a:	00 00 00 
  8004205b7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b82:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205b89:	00 00 00 
  8004205b8c:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205b8f:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004205b96:	00 00 00 
  8004205b99:	48 8b 00             	mov    (%rax),%rax
  8004205b9c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205ba0:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205ba5:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205baa:	48 89 c7             	mov    %rax,%rdi
  8004205bad:	48 b8 bf 37 20 04 80 	movabs $0x80042037bf,%rax
  8004205bb4:	00 00 00 
  8004205bb7:	ff d0                	callq  *%rax
  8004205bb9:	85 c0                	test   %eax,%eax
  8004205bbb:	78 35                	js     8004205bf2 <page_check+0x552>
  8004205bbd:	48 b9 28 8d 21 04 80 	movabs $0x8004218d28,%rcx
  8004205bc4:	00 00 00 
  8004205bc7:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205bce:	00 00 00 
  8004205bd1:	be 0d 05 00 00       	mov    $0x50d,%esi
  8004205bd6:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205bdd:	00 00 00 
  8004205be0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205be5:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205bec:	00 00 00 
  8004205bef:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  8004205bf2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205bf6:	48 89 c7             	mov    %rax,%rdi
  8004205bf9:	48 b8 4f 30 20 04 80 	movabs $0x800420304f,%rax
  8004205c00:	00 00 00 
  8004205c03:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205c05:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004205c0c:	00 00 00 
  8004205c0f:	48 8b 00             	mov    (%rax),%rax
  8004205c12:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205c16:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205c1b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205c20:	48 89 c7             	mov    %rax,%rdi
  8004205c23:	48 b8 bf 37 20 04 80 	movabs $0x80042037bf,%rax
  8004205c2a:	00 00 00 
  8004205c2d:	ff d0                	callq  *%rax
  8004205c2f:	85 c0                	test   %eax,%eax
  8004205c31:	78 35                	js     8004205c68 <page_check+0x5c8>
  8004205c33:	48 b9 28 8d 21 04 80 	movabs $0x8004218d28,%rcx
  8004205c3a:	00 00 00 
  8004205c3d:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205c44:	00 00 00 
  8004205c47:	be 11 05 00 00       	mov    $0x511,%esi
  8004205c4c:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205c53:	00 00 00 
  8004205c56:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c5b:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205c62:	00 00 00 
  8004205c65:	41 ff d0             	callq  *%r8
	page_free(pp2);
  8004205c68:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205c6c:	48 89 c7             	mov    %rax,%rdi
  8004205c6f:	48 b8 4f 30 20 04 80 	movabs $0x800420304f,%rax
  8004205c76:	00 00 00 
  8004205c79:	ff d0                	callq  *%rax
	page_free(pp3);
  8004205c7b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205c7f:	48 89 c7             	mov    %rax,%rdi
  8004205c82:	48 b8 4f 30 20 04 80 	movabs $0x800420304f,%rax
  8004205c89:	00 00 00 
  8004205c8c:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  8004205c8e:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004205c95:	00 00 00 
  8004205c98:	48 8b 00             	mov    (%rax),%rax
  8004205c9b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205c9f:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205ca4:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205ca9:	48 89 c7             	mov    %rax,%rdi
  8004205cac:	48 b8 bf 37 20 04 80 	movabs $0x80042037bf,%rax
  8004205cb3:	00 00 00 
  8004205cb6:	ff d0                	callq  *%rax
  8004205cb8:	85 c0                	test   %eax,%eax
  8004205cba:	74 35                	je     8004205cf1 <page_check+0x651>
  8004205cbc:	48 b9 58 8d 21 04 80 	movabs $0x8004218d58,%rcx
  8004205cc3:	00 00 00 
  8004205cc6:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205ccd:	00 00 00 
  8004205cd0:	be 17 05 00 00       	mov    $0x517,%esi
  8004205cd5:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205cdc:	00 00 00 
  8004205cdf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ce4:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205ceb:	00 00 00 
  8004205cee:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004205cf1:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004205cf8:	00 00 00 
  8004205cfb:	48 8b 00             	mov    (%rax),%rax
  8004205cfe:	48 8b 00             	mov    (%rax),%rax
  8004205d01:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d07:	48 89 c3             	mov    %rax,%rbx
  8004205d0a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205d0e:	48 89 c7             	mov    %rax,%rdi
  8004205d11:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004205d18:	00 00 00 
  8004205d1b:	ff d0                	callq  *%rax
  8004205d1d:	48 39 c3             	cmp    %rax,%rbx
  8004205d20:	0f 84 97 00 00 00    	je     8004205dbd <page_check+0x71d>
  8004205d26:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004205d2d:	00 00 00 
  8004205d30:	48 8b 00             	mov    (%rax),%rax
  8004205d33:	48 8b 00             	mov    (%rax),%rax
  8004205d36:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d3c:	48 89 c3             	mov    %rax,%rbx
  8004205d3f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205d43:	48 89 c7             	mov    %rax,%rdi
  8004205d46:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004205d4d:	00 00 00 
  8004205d50:	ff d0                	callq  *%rax
  8004205d52:	48 39 c3             	cmp    %rax,%rbx
  8004205d55:	74 66                	je     8004205dbd <page_check+0x71d>
  8004205d57:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004205d5e:	00 00 00 
  8004205d61:	48 8b 00             	mov    (%rax),%rax
  8004205d64:	48 8b 00             	mov    (%rax),%rax
  8004205d67:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d6d:	48 89 c3             	mov    %rax,%rbx
  8004205d70:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205d74:	48 89 c7             	mov    %rax,%rdi
  8004205d77:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004205d7e:	00 00 00 
  8004205d81:	ff d0                	callq  *%rax
  8004205d83:	48 39 c3             	cmp    %rax,%rbx
  8004205d86:	74 35                	je     8004205dbd <page_check+0x71d>
  8004205d88:	48 b9 88 8d 21 04 80 	movabs $0x8004218d88,%rcx
  8004205d8f:	00 00 00 
  8004205d92:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205d99:	00 00 00 
  8004205d9c:	be 18 05 00 00       	mov    $0x518,%esi
  8004205da1:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205da8:	00 00 00 
  8004205dab:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205db0:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205db7:	00 00 00 
  8004205dba:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  8004205dbd:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004205dc4:	00 00 00 
  8004205dc7:	48 8b 00             	mov    (%rax),%rax
  8004205dca:	be 00 00 00 00       	mov    $0x0,%esi
  8004205dcf:	48 89 c7             	mov    %rax,%rdi
  8004205dd2:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  8004205dd9:	00 00 00 
  8004205ddc:	ff d0                	callq  *%rax
  8004205dde:	48 89 c3             	mov    %rax,%rbx
  8004205de1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205de5:	48 89 c7             	mov    %rax,%rdi
  8004205de8:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004205def:	00 00 00 
  8004205df2:	ff d0                	callq  *%rax
  8004205df4:	48 39 c3             	cmp    %rax,%rbx
  8004205df7:	74 35                	je     8004205e2e <page_check+0x78e>
  8004205df9:	48 b9 10 8e 21 04 80 	movabs $0x8004218e10,%rcx
  8004205e00:	00 00 00 
  8004205e03:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205e0a:	00 00 00 
  8004205e0d:	be 19 05 00 00       	mov    $0x519,%esi
  8004205e12:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205e19:	00 00 00 
  8004205e1c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e21:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205e28:	00 00 00 
  8004205e2b:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004205e2e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205e32:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205e36:	66 83 f8 01          	cmp    $0x1,%ax
  8004205e3a:	74 35                	je     8004205e71 <page_check+0x7d1>
  8004205e3c:	48 b9 3d 8e 21 04 80 	movabs $0x8004218e3d,%rcx
  8004205e43:	00 00 00 
  8004205e46:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205e4d:	00 00 00 
  8004205e50:	be 1a 05 00 00       	mov    $0x51a,%esi
  8004205e55:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205e5c:	00 00 00 
  8004205e5f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e64:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205e6b:	00 00 00 
  8004205e6e:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  8004205e71:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205e75:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205e79:	66 83 f8 01          	cmp    $0x1,%ax
  8004205e7d:	74 35                	je     8004205eb4 <page_check+0x814>
  8004205e7f:	48 b9 4e 8e 21 04 80 	movabs $0x8004218e4e,%rcx
  8004205e86:	00 00 00 
  8004205e89:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205e90:	00 00 00 
  8004205e93:	be 1b 05 00 00       	mov    $0x51b,%esi
  8004205e98:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205e9f:	00 00 00 
  8004205ea2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ea7:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205eae:	00 00 00 
  8004205eb1:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004205eb4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205eb8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205ebc:	66 83 f8 01          	cmp    $0x1,%ax
  8004205ec0:	74 35                	je     8004205ef7 <page_check+0x857>
  8004205ec2:	48 b9 5f 8e 21 04 80 	movabs $0x8004218e5f,%rcx
  8004205ec9:	00 00 00 
  8004205ecc:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205ed3:	00 00 00 
  8004205ed6:	be 1c 05 00 00       	mov    $0x51c,%esi
  8004205edb:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205ee2:	00 00 00 
  8004205ee5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205eea:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205ef1:	00 00 00 
  8004205ef4:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205ef7:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004205efe:	00 00 00 
  8004205f01:	48 8b 00             	mov    (%rax),%rax
  8004205f04:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205f08:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205f0d:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205f12:	48 89 c7             	mov    %rax,%rdi
  8004205f15:	48 b8 bf 37 20 04 80 	movabs $0x80042037bf,%rax
  8004205f1c:	00 00 00 
  8004205f1f:	ff d0                	callq  *%rax
  8004205f21:	85 c0                	test   %eax,%eax
  8004205f23:	74 35                	je     8004205f5a <page_check+0x8ba>
  8004205f25:	48 b9 70 8e 21 04 80 	movabs $0x8004218e70,%rcx
  8004205f2c:	00 00 00 
  8004205f2f:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205f36:	00 00 00 
  8004205f39:	be 1e 05 00 00       	mov    $0x51e,%esi
  8004205f3e:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205f45:	00 00 00 
  8004205f48:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f4d:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205f54:	00 00 00 
  8004205f57:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205f5a:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004205f61:	00 00 00 
  8004205f64:	48 8b 00             	mov    (%rax),%rax
  8004205f67:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205f6c:	48 89 c7             	mov    %rax,%rdi
  8004205f6f:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  8004205f76:	00 00 00 
  8004205f79:	ff d0                	callq  *%rax
  8004205f7b:	48 89 c3             	mov    %rax,%rbx
  8004205f7e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205f82:	48 89 c7             	mov    %rax,%rdi
  8004205f85:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004205f8c:	00 00 00 
  8004205f8f:	ff d0                	callq  *%rax
  8004205f91:	48 39 c3             	cmp    %rax,%rbx
  8004205f94:	74 35                	je     8004205fcb <page_check+0x92b>
  8004205f96:	48 b9 a8 8e 21 04 80 	movabs $0x8004218ea8,%rcx
  8004205f9d:	00 00 00 
  8004205fa0:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205fa7:	00 00 00 
  8004205faa:	be 1f 05 00 00       	mov    $0x51f,%esi
  8004205faf:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205fb6:	00 00 00 
  8004205fb9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fbe:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004205fc5:	00 00 00 
  8004205fc8:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205fcb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205fcf:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205fd3:	66 83 f8 02          	cmp    $0x2,%ax
  8004205fd7:	74 35                	je     800420600e <page_check+0x96e>
  8004205fd9:	48 b9 d8 8e 21 04 80 	movabs $0x8004218ed8,%rcx
  8004205fe0:	00 00 00 
  8004205fe3:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004205fea:	00 00 00 
  8004205fed:	be 20 05 00 00       	mov    $0x520,%esi
  8004205ff2:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004205ff9:	00 00 00 
  8004205ffc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206001:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206008:	00 00 00 
  800420600b:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  800420600e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206013:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  800420601a:	00 00 00 
  800420601d:	ff d0                	callq  *%rax
  800420601f:	48 85 c0             	test   %rax,%rax
  8004206022:	74 35                	je     8004206059 <page_check+0x9b9>
  8004206024:	48 b9 f7 89 21 04 80 	movabs $0x80042189f7,%rcx
  800420602b:	00 00 00 
  800420602e:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206035:	00 00 00 
  8004206038:	be 23 05 00 00       	mov    $0x523,%esi
  800420603d:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206044:	00 00 00 
  8004206047:	b8 00 00 00 00       	mov    $0x0,%eax
  800420604c:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206053:	00 00 00 
  8004206056:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004206059:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206060:	00 00 00 
  8004206063:	48 8b 00             	mov    (%rax),%rax
  8004206066:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420606a:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420606f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206074:	48 89 c7             	mov    %rax,%rdi
  8004206077:	48 b8 bf 37 20 04 80 	movabs $0x80042037bf,%rax
  800420607e:	00 00 00 
  8004206081:	ff d0                	callq  *%rax
  8004206083:	85 c0                	test   %eax,%eax
  8004206085:	74 35                	je     80042060bc <page_check+0xa1c>
  8004206087:	48 b9 70 8e 21 04 80 	movabs $0x8004218e70,%rcx
  800420608e:	00 00 00 
  8004206091:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206098:	00 00 00 
  800420609b:	be 26 05 00 00       	mov    $0x526,%esi
  80042060a0:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042060a7:	00 00 00 
  80042060aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060af:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042060b6:	00 00 00 
  80042060b9:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042060bc:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  80042060c3:	00 00 00 
  80042060c6:	48 8b 00             	mov    (%rax),%rax
  80042060c9:	be 00 10 00 00       	mov    $0x1000,%esi
  80042060ce:	48 89 c7             	mov    %rax,%rdi
  80042060d1:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  80042060d8:	00 00 00 
  80042060db:	ff d0                	callq  *%rax
  80042060dd:	48 89 c3             	mov    %rax,%rbx
  80042060e0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042060e4:	48 89 c7             	mov    %rax,%rdi
  80042060e7:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  80042060ee:	00 00 00 
  80042060f1:	ff d0                	callq  *%rax
  80042060f3:	48 39 c3             	cmp    %rax,%rbx
  80042060f6:	74 35                	je     800420612d <page_check+0xa8d>
  80042060f8:	48 b9 a8 8e 21 04 80 	movabs $0x8004218ea8,%rcx
  80042060ff:	00 00 00 
  8004206102:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206109:	00 00 00 
  800420610c:	be 27 05 00 00       	mov    $0x527,%esi
  8004206111:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206118:	00 00 00 
  800420611b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206120:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206127:	00 00 00 
  800420612a:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  800420612d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206131:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206135:	66 83 f8 02          	cmp    $0x2,%ax
  8004206139:	74 35                	je     8004206170 <page_check+0xad0>
  800420613b:	48 b9 d8 8e 21 04 80 	movabs $0x8004218ed8,%rcx
  8004206142:	00 00 00 
  8004206145:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420614c:	00 00 00 
  800420614f:	be 28 05 00 00       	mov    $0x528,%esi
  8004206154:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420615b:	00 00 00 
  800420615e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206163:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420616a:	00 00 00 
  800420616d:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  8004206170:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206175:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  800420617c:	00 00 00 
  800420617f:	ff d0                	callq  *%rax
  8004206181:	48 85 c0             	test   %rax,%rax
  8004206184:	74 35                	je     80042061bb <page_check+0xb1b>
  8004206186:	48 b9 f7 89 21 04 80 	movabs $0x80042189f7,%rcx
  800420618d:	00 00 00 
  8004206190:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206197:	00 00 00 
  800420619a:	be 2c 05 00 00       	mov    $0x52c,%esi
  800420619f:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042061a6:	00 00 00 
  80042061a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061ae:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042061b5:	00 00 00 
  80042061b8:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  80042061bb:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  80042061c2:	00 00 00 
  80042061c5:	48 8b 00             	mov    (%rax),%rax
  80042061c8:	48 8b 00             	mov    (%rax),%rax
  80042061cb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042061d1:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  80042061d5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042061d9:	48 c1 e8 0c          	shr    $0xc,%rax
  80042061dd:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  80042061e0:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  80042061e3:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  80042061ea:	00 00 00 
  80042061ed:	48 8b 00             	mov    (%rax),%rax
  80042061f0:	48 39 c2             	cmp    %rax,%rdx
  80042061f3:	72 32                	jb     8004206227 <page_check+0xb87>
  80042061f5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042061f9:	48 89 c1             	mov    %rax,%rcx
  80042061fc:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004206203:	00 00 00 
  8004206206:	be 2e 05 00 00       	mov    $0x52e,%esi
  800420620b:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206212:	00 00 00 
  8004206215:	b8 00 00 00 00       	mov    $0x0,%eax
  800420621a:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206221:	00 00 00 
  8004206224:	41 ff d0             	callq  *%r8
  8004206227:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420622e:	00 00 00 
  8004206231:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206235:	48 01 d0             	add    %rdx,%rax
  8004206238:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  800420623c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206240:	48 8b 00             	mov    (%rax),%rax
  8004206243:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206249:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  800420624d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206251:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206255:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004206258:	8b 55 8c             	mov    -0x74(%rbp),%edx
  800420625b:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004206262:	00 00 00 
  8004206265:	48 8b 00             	mov    (%rax),%rax
  8004206268:	48 39 c2             	cmp    %rax,%rdx
  800420626b:	72 32                	jb     800420629f <page_check+0xbff>
  800420626d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206271:	48 89 c1             	mov    %rax,%rcx
  8004206274:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  800420627b:	00 00 00 
  800420627e:	be 2f 05 00 00       	mov    $0x52f,%esi
  8004206283:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420628a:	00 00 00 
  800420628d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206292:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206299:	00 00 00 
  800420629c:	41 ff d0             	callq  *%r8
  800420629f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042062a6:	00 00 00 
  80042062a9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042062ad:	48 01 d0             	add    %rdx,%rax
  80042062b0:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  80042062b4:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042062b8:	48 8b 00             	mov    (%rax),%rax
  80042062bb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042062c1:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042062c8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042062cf:	48 c1 e8 0c          	shr    $0xc,%rax
  80042062d3:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  80042062d9:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  80042062df:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  80042062e6:	00 00 00 
  80042062e9:	48 8b 00             	mov    (%rax),%rax
  80042062ec:	48 39 c2             	cmp    %rax,%rdx
  80042062ef:	72 35                	jb     8004206326 <page_check+0xc86>
  80042062f1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042062f8:	48 89 c1             	mov    %rax,%rcx
  80042062fb:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004206302:	00 00 00 
  8004206305:	be 30 05 00 00       	mov    $0x530,%esi
  800420630a:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206311:	00 00 00 
  8004206314:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206319:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206320:	00 00 00 
  8004206323:	41 ff d0             	callq  *%r8
  8004206326:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420632d:	00 00 00 
  8004206330:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206337:	48 01 d0             	add    %rdx,%rax
  800420633a:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  8004206341:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206348:	00 00 00 
  800420634b:	48 8b 00             	mov    (%rax),%rax
  800420634e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206353:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206358:	48 89 c7             	mov    %rax,%rdi
  800420635b:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  8004206362:	00 00 00 
  8004206365:	ff d0                	callq  *%rax
  8004206367:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  800420636e:	48 83 c2 08          	add    $0x8,%rdx
  8004206372:	48 39 d0             	cmp    %rdx,%rax
  8004206375:	74 35                	je     80042063ac <page_check+0xd0c>
  8004206377:	48 b9 f0 8e 21 04 80 	movabs $0x8004218ef0,%rcx
  800420637e:	00 00 00 
  8004206381:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206388:	00 00 00 
  800420638b:	be 31 05 00 00       	mov    $0x531,%esi
  8004206390:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206397:	00 00 00 
  800420639a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420639f:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042063a6:	00 00 00 
  80042063a9:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  80042063ac:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  80042063b3:	00 00 00 
  80042063b6:	48 8b 00             	mov    (%rax),%rax
  80042063b9:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042063bd:	b9 04 00 00 00       	mov    $0x4,%ecx
  80042063c2:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042063c7:	48 89 c7             	mov    %rax,%rdi
  80042063ca:	48 b8 bf 37 20 04 80 	movabs $0x80042037bf,%rax
  80042063d1:	00 00 00 
  80042063d4:	ff d0                	callq  *%rax
  80042063d6:	85 c0                	test   %eax,%eax
  80042063d8:	74 35                	je     800420640f <page_check+0xd6f>
  80042063da:	48 b9 30 8f 21 04 80 	movabs $0x8004218f30,%rcx
  80042063e1:	00 00 00 
  80042063e4:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042063eb:	00 00 00 
  80042063ee:	be 34 05 00 00       	mov    $0x534,%esi
  80042063f3:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042063fa:	00 00 00 
  80042063fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206402:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206409:	00 00 00 
  800420640c:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  800420640f:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206416:	00 00 00 
  8004206419:	48 8b 00             	mov    (%rax),%rax
  800420641c:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206421:	48 89 c7             	mov    %rax,%rdi
  8004206424:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  800420642b:	00 00 00 
  800420642e:	ff d0                	callq  *%rax
  8004206430:	48 89 c3             	mov    %rax,%rbx
  8004206433:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206437:	48 89 c7             	mov    %rax,%rdi
  800420643a:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004206441:	00 00 00 
  8004206444:	ff d0                	callq  *%rax
  8004206446:	48 39 c3             	cmp    %rax,%rbx
  8004206449:	74 35                	je     8004206480 <page_check+0xde0>
  800420644b:	48 b9 a8 8e 21 04 80 	movabs $0x8004218ea8,%rcx
  8004206452:	00 00 00 
  8004206455:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420645c:	00 00 00 
  800420645f:	be 35 05 00 00       	mov    $0x535,%esi
  8004206464:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420646b:	00 00 00 
  800420646e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206473:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420647a:	00 00 00 
  800420647d:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206480:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206484:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206488:	66 83 f8 02          	cmp    $0x2,%ax
  800420648c:	74 35                	je     80042064c3 <page_check+0xe23>
  800420648e:	48 b9 d8 8e 21 04 80 	movabs $0x8004218ed8,%rcx
  8004206495:	00 00 00 
  8004206498:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420649f:	00 00 00 
  80042064a2:	be 36 05 00 00       	mov    $0x536,%esi
  80042064a7:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042064ae:	00 00 00 
  80042064b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064b6:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042064bd:	00 00 00 
  80042064c0:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  80042064c3:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  80042064ca:	00 00 00 
  80042064cd:	48 8b 00             	mov    (%rax),%rax
  80042064d0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042064d5:	be 00 10 00 00       	mov    $0x1000,%esi
  80042064da:	48 89 c7             	mov    %rax,%rdi
  80042064dd:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  80042064e4:	00 00 00 
  80042064e7:	ff d0                	callq  *%rax
  80042064e9:	48 8b 00             	mov    (%rax),%rax
  80042064ec:	83 e0 04             	and    $0x4,%eax
  80042064ef:	48 85 c0             	test   %rax,%rax
  80042064f2:	75 35                	jne    8004206529 <page_check+0xe89>
  80042064f4:	48 b9 70 8f 21 04 80 	movabs $0x8004218f70,%rcx
  80042064fb:	00 00 00 
  80042064fe:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206505:	00 00 00 
  8004206508:	be 37 05 00 00       	mov    $0x537,%esi
  800420650d:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206514:	00 00 00 
  8004206517:	b8 00 00 00 00       	mov    $0x0,%eax
  800420651c:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206523:	00 00 00 
  8004206526:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  8004206529:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206530:	00 00 00 
  8004206533:	48 8b 00             	mov    (%rax),%rax
  8004206536:	48 8b 00             	mov    (%rax),%rax
  8004206539:	83 e0 04             	and    $0x4,%eax
  800420653c:	48 85 c0             	test   %rax,%rax
  800420653f:	75 35                	jne    8004206576 <page_check+0xed6>
  8004206541:	48 b9 a3 8f 21 04 80 	movabs $0x8004218fa3,%rcx
  8004206548:	00 00 00 
  800420654b:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206552:	00 00 00 
  8004206555:	be 38 05 00 00       	mov    $0x538,%esi
  800420655a:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206561:	00 00 00 
  8004206564:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206569:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206570:	00 00 00 
  8004206573:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  8004206576:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  800420657d:	00 00 00 
  8004206580:	48 8b 00             	mov    (%rax),%rax
  8004206583:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004206587:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420658c:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004206591:	48 89 c7             	mov    %rax,%rdi
  8004206594:	48 b8 bf 37 20 04 80 	movabs $0x80042037bf,%rax
  800420659b:	00 00 00 
  800420659e:	ff d0                	callq  *%rax
  80042065a0:	85 c0                	test   %eax,%eax
  80042065a2:	78 35                	js     80042065d9 <page_check+0xf39>
  80042065a4:	48 b9 c0 8f 21 04 80 	movabs $0x8004218fc0,%rcx
  80042065ab:	00 00 00 
  80042065ae:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042065b5:	00 00 00 
  80042065b8:	be 3c 05 00 00       	mov    $0x53c,%esi
  80042065bd:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042065c4:	00 00 00 
  80042065c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065cc:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042065d3:	00 00 00 
  80042065d6:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  80042065d9:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  80042065e0:	00 00 00 
  80042065e3:	48 8b 00             	mov    (%rax),%rax
  80042065e6:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042065ea:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042065ef:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042065f4:	48 89 c7             	mov    %rax,%rdi
  80042065f7:	48 b8 bf 37 20 04 80 	movabs $0x80042037bf,%rax
  80042065fe:	00 00 00 
  8004206601:	ff d0                	callq  *%rax
  8004206603:	85 c0                	test   %eax,%eax
  8004206605:	74 35                	je     800420663c <page_check+0xf9c>
  8004206607:	48 b9 f8 8f 21 04 80 	movabs $0x8004218ff8,%rcx
  800420660e:	00 00 00 
  8004206611:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206618:	00 00 00 
  800420661b:	be 3f 05 00 00       	mov    $0x53f,%esi
  8004206620:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206627:	00 00 00 
  800420662a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420662f:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206636:	00 00 00 
  8004206639:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  800420663c:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206643:	00 00 00 
  8004206646:	48 8b 00             	mov    (%rax),%rax
  8004206649:	ba 00 00 00 00       	mov    $0x0,%edx
  800420664e:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206653:	48 89 c7             	mov    %rax,%rdi
  8004206656:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  800420665d:	00 00 00 
  8004206660:	ff d0                	callq  *%rax
  8004206662:	48 8b 00             	mov    (%rax),%rax
  8004206665:	83 e0 04             	and    $0x4,%eax
  8004206668:	48 85 c0             	test   %rax,%rax
  800420666b:	74 35                	je     80042066a2 <page_check+0x1002>
  800420666d:	48 b9 30 90 21 04 80 	movabs $0x8004219030,%rcx
  8004206674:	00 00 00 
  8004206677:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420667e:	00 00 00 
  8004206681:	be 40 05 00 00       	mov    $0x540,%esi
  8004206686:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420668d:	00 00 00 
  8004206690:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206695:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420669c:	00 00 00 
  800420669f:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  80042066a2:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  80042066a9:	00 00 00 
  80042066ac:	48 8b 00             	mov    (%rax),%rax
  80042066af:	be 00 00 00 00       	mov    $0x0,%esi
  80042066b4:	48 89 c7             	mov    %rax,%rdi
  80042066b7:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  80042066be:	00 00 00 
  80042066c1:	ff d0                	callq  *%rax
  80042066c3:	48 89 c3             	mov    %rax,%rbx
  80042066c6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042066ca:	48 89 c7             	mov    %rax,%rdi
  80042066cd:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  80042066d4:	00 00 00 
  80042066d7:	ff d0                	callq  *%rax
  80042066d9:	48 39 c3             	cmp    %rax,%rbx
  80042066dc:	74 35                	je     8004206713 <page_check+0x1073>
  80042066de:	48 b9 68 90 21 04 80 	movabs $0x8004219068,%rcx
  80042066e5:	00 00 00 
  80042066e8:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042066ef:	00 00 00 
  80042066f2:	be 43 05 00 00       	mov    $0x543,%esi
  80042066f7:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042066fe:	00 00 00 
  8004206701:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206706:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420670d:	00 00 00 
  8004206710:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206713:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  800420671a:	00 00 00 
  800420671d:	48 8b 00             	mov    (%rax),%rax
  8004206720:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206725:	48 89 c7             	mov    %rax,%rdi
  8004206728:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  800420672f:	00 00 00 
  8004206732:	ff d0                	callq  *%rax
  8004206734:	48 89 c3             	mov    %rax,%rbx
  8004206737:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420673b:	48 89 c7             	mov    %rax,%rdi
  800420673e:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004206745:	00 00 00 
  8004206748:	ff d0                	callq  *%rax
  800420674a:	48 39 c3             	cmp    %rax,%rbx
  800420674d:	74 35                	je     8004206784 <page_check+0x10e4>
  800420674f:	48 b9 98 90 21 04 80 	movabs $0x8004219098,%rcx
  8004206756:	00 00 00 
  8004206759:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206760:	00 00 00 
  8004206763:	be 44 05 00 00       	mov    $0x544,%esi
  8004206768:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420676f:	00 00 00 
  8004206772:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206777:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420677e:	00 00 00 
  8004206781:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  8004206784:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206788:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420678c:	66 83 f8 02          	cmp    $0x2,%ax
  8004206790:	74 35                	je     80042067c7 <page_check+0x1127>
  8004206792:	48 b9 c8 90 21 04 80 	movabs $0x80042190c8,%rcx
  8004206799:	00 00 00 
  800420679c:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042067a3:	00 00 00 
  80042067a6:	be 46 05 00 00       	mov    $0x546,%esi
  80042067ab:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042067b2:	00 00 00 
  80042067b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067ba:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042067c1:	00 00 00 
  80042067c4:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042067c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042067cb:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042067cf:	66 83 f8 01          	cmp    $0x1,%ax
  80042067d3:	74 35                	je     800420680a <page_check+0x116a>
  80042067d5:	48 b9 d9 90 21 04 80 	movabs $0x80042190d9,%rcx
  80042067dc:	00 00 00 
  80042067df:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042067e6:	00 00 00 
  80042067e9:	be 47 05 00 00       	mov    $0x547,%esi
  80042067ee:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042067f5:	00 00 00 
  80042067f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067fd:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206804:	00 00 00 
  8004206807:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  800420680a:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206811:	00 00 00 
  8004206814:	48 8b 00             	mov    (%rax),%rax
  8004206817:	be 00 00 00 00       	mov    $0x0,%esi
  800420681c:	48 89 c7             	mov    %rax,%rdi
  800420681f:	48 b8 b6 39 20 04 80 	movabs $0x80042039b6,%rax
  8004206826:	00 00 00 
  8004206829:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  800420682b:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206832:	00 00 00 
  8004206835:	48 8b 00             	mov    (%rax),%rax
  8004206838:	be 00 00 00 00       	mov    $0x0,%esi
  800420683d:	48 89 c7             	mov    %rax,%rdi
  8004206840:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  8004206847:	00 00 00 
  800420684a:	ff d0                	callq  *%rax
  800420684c:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206850:	74 35                	je     8004206887 <page_check+0x11e7>
  8004206852:	48 b9 f0 90 21 04 80 	movabs $0x80042190f0,%rcx
  8004206859:	00 00 00 
  800420685c:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206863:	00 00 00 
  8004206866:	be 4c 05 00 00       	mov    $0x54c,%esi
  800420686b:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206872:	00 00 00 
  8004206875:	b8 00 00 00 00       	mov    $0x0,%eax
  800420687a:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206881:	00 00 00 
  8004206884:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206887:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  800420688e:	00 00 00 
  8004206891:	48 8b 00             	mov    (%rax),%rax
  8004206894:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206899:	48 89 c7             	mov    %rax,%rdi
  800420689c:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  80042068a3:	00 00 00 
  80042068a6:	ff d0                	callq  *%rax
  80042068a8:	48 89 c3             	mov    %rax,%rbx
  80042068ab:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042068af:	48 89 c7             	mov    %rax,%rdi
  80042068b2:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  80042068b9:	00 00 00 
  80042068bc:	ff d0                	callq  *%rax
  80042068be:	48 39 c3             	cmp    %rax,%rbx
  80042068c1:	74 35                	je     80042068f8 <page_check+0x1258>
  80042068c3:	48 b9 98 90 21 04 80 	movabs $0x8004219098,%rcx
  80042068ca:	00 00 00 
  80042068cd:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042068d4:	00 00 00 
  80042068d7:	be 4d 05 00 00       	mov    $0x54d,%esi
  80042068dc:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042068e3:	00 00 00 
  80042068e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068eb:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042068f2:	00 00 00 
  80042068f5:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  80042068f8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042068fc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206900:	66 83 f8 01          	cmp    $0x1,%ax
  8004206904:	74 35                	je     800420693b <page_check+0x129b>
  8004206906:	48 b9 3d 8e 21 04 80 	movabs $0x8004218e3d,%rcx
  800420690d:	00 00 00 
  8004206910:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206917:	00 00 00 
  800420691a:	be 4e 05 00 00       	mov    $0x54e,%esi
  800420691f:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206926:	00 00 00 
  8004206929:	b8 00 00 00 00       	mov    $0x0,%eax
  800420692e:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206935:	00 00 00 
  8004206938:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  800420693b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420693f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206943:	66 83 f8 01          	cmp    $0x1,%ax
  8004206947:	74 35                	je     800420697e <page_check+0x12de>
  8004206949:	48 b9 d9 90 21 04 80 	movabs $0x80042190d9,%rcx
  8004206950:	00 00 00 
  8004206953:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420695a:	00 00 00 
  800420695d:	be 4f 05 00 00       	mov    $0x54f,%esi
  8004206962:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206969:	00 00 00 
  800420696c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206971:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206978:	00 00 00 
  800420697b:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  800420697e:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206985:	00 00 00 
  8004206988:	48 8b 00             	mov    (%rax),%rax
  800420698b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420698f:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206994:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206999:	48 89 c7             	mov    %rax,%rdi
  800420699c:	48 b8 bf 37 20 04 80 	movabs $0x80042037bf,%rax
  80042069a3:	00 00 00 
  80042069a6:	ff d0                	callq  *%rax
  80042069a8:	85 c0                	test   %eax,%eax
  80042069aa:	74 35                	je     80042069e1 <page_check+0x1341>
  80042069ac:	48 b9 f8 8f 21 04 80 	movabs $0x8004218ff8,%rcx
  80042069b3:	00 00 00 
  80042069b6:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042069bd:	00 00 00 
  80042069c0:	be 53 05 00 00       	mov    $0x553,%esi
  80042069c5:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042069cc:	00 00 00 
  80042069cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069d4:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042069db:	00 00 00 
  80042069de:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  80042069e1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042069e5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042069e9:	66 85 c0             	test   %ax,%ax
  80042069ec:	75 35                	jne    8004206a23 <page_check+0x1383>
  80042069ee:	48 b9 13 91 21 04 80 	movabs $0x8004219113,%rcx
  80042069f5:	00 00 00 
  80042069f8:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042069ff:	00 00 00 
  8004206a02:	be 54 05 00 00       	mov    $0x554,%esi
  8004206a07:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206a0e:	00 00 00 
  8004206a11:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a16:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206a1d:	00 00 00 
  8004206a20:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206a23:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206a27:	48 8b 00             	mov    (%rax),%rax
  8004206a2a:	48 85 c0             	test   %rax,%rax
  8004206a2d:	74 35                	je     8004206a64 <page_check+0x13c4>
  8004206a2f:	48 b9 1f 91 21 04 80 	movabs $0x800421911f,%rcx
  8004206a36:	00 00 00 
  8004206a39:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206a40:	00 00 00 
  8004206a43:	be 55 05 00 00       	mov    $0x555,%esi
  8004206a48:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206a4f:	00 00 00 
  8004206a52:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a57:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206a5e:	00 00 00 
  8004206a61:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206a64:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206a6b:	00 00 00 
  8004206a6e:	48 8b 00             	mov    (%rax),%rax
  8004206a71:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206a76:	48 89 c7             	mov    %rax,%rdi
  8004206a79:	48 b8 b6 39 20 04 80 	movabs $0x80042039b6,%rax
  8004206a80:	00 00 00 
  8004206a83:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206a85:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206a8c:	00 00 00 
  8004206a8f:	48 8b 00             	mov    (%rax),%rax
  8004206a92:	be 00 00 00 00       	mov    $0x0,%esi
  8004206a97:	48 89 c7             	mov    %rax,%rdi
  8004206a9a:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  8004206aa1:	00 00 00 
  8004206aa4:	ff d0                	callq  *%rax
  8004206aa6:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206aaa:	74 35                	je     8004206ae1 <page_check+0x1441>
  8004206aac:	48 b9 f0 90 21 04 80 	movabs $0x80042190f0,%rcx
  8004206ab3:	00 00 00 
  8004206ab6:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206abd:	00 00 00 
  8004206ac0:	be 59 05 00 00       	mov    $0x559,%esi
  8004206ac5:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206acc:	00 00 00 
  8004206acf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ad4:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206adb:	00 00 00 
  8004206ade:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004206ae1:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206ae8:	00 00 00 
  8004206aeb:	48 8b 00             	mov    (%rax),%rax
  8004206aee:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206af3:	48 89 c7             	mov    %rax,%rdi
  8004206af6:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  8004206afd:	00 00 00 
  8004206b00:	ff d0                	callq  *%rax
  8004206b02:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206b06:	74 35                	je     8004206b3d <page_check+0x149d>
  8004206b08:	48 b9 38 91 21 04 80 	movabs $0x8004219138,%rcx
  8004206b0f:	00 00 00 
  8004206b12:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206b19:	00 00 00 
  8004206b1c:	be 5a 05 00 00       	mov    $0x55a,%esi
  8004206b21:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206b28:	00 00 00 
  8004206b2b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b30:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206b37:	00 00 00 
  8004206b3a:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206b3d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206b41:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b45:	66 85 c0             	test   %ax,%ax
  8004206b48:	74 35                	je     8004206b7f <page_check+0x14df>
  8004206b4a:	48 b9 5e 91 21 04 80 	movabs $0x800421915e,%rcx
  8004206b51:	00 00 00 
  8004206b54:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206b5b:	00 00 00 
  8004206b5e:	be 5b 05 00 00       	mov    $0x55b,%esi
  8004206b63:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206b6a:	00 00 00 
  8004206b6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b72:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206b79:	00 00 00 
  8004206b7c:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206b7f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206b83:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b87:	66 83 f8 01          	cmp    $0x1,%ax
  8004206b8b:	74 35                	je     8004206bc2 <page_check+0x1522>
  8004206b8d:	48 b9 d9 90 21 04 80 	movabs $0x80042190d9,%rcx
  8004206b94:	00 00 00 
  8004206b97:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206b9e:	00 00 00 
  8004206ba1:	be 5c 05 00 00       	mov    $0x55c,%esi
  8004206ba6:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206bad:	00 00 00 
  8004206bb0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bb5:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206bbc:	00 00 00 
  8004206bbf:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	assert(PTE_ADDR(boot_pml4e[0]) == page2pa(pp3));
  8004206bc2:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206bc9:	00 00 00 
  8004206bcc:	48 8b 00             	mov    (%rax),%rax
  8004206bcf:	48 8b 00             	mov    (%rax),%rax
  8004206bd2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206bd8:	48 89 c3             	mov    %rax,%rbx
  8004206bdb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206bdf:	48 89 c7             	mov    %rax,%rdi
  8004206be2:	48 b8 f8 1b 20 04 80 	movabs $0x8004201bf8,%rax
  8004206be9:	00 00 00 
  8004206bec:	ff d0                	callq  *%rax
  8004206bee:	48 39 c3             	cmp    %rax,%rbx
  8004206bf1:	74 35                	je     8004206c28 <page_check+0x1588>
  8004206bf3:	48 b9 70 91 21 04 80 	movabs $0x8004219170,%rcx
  8004206bfa:	00 00 00 
  8004206bfd:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206c04:	00 00 00 
  8004206c07:	be 70 05 00 00       	mov    $0x570,%esi
  8004206c0c:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206c13:	00 00 00 
  8004206c16:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c1b:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206c22:	00 00 00 
  8004206c25:	41 ff d0             	callq  *%r8
	boot_pml4e[0] = 0;
  8004206c28:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206c2f:	00 00 00 
  8004206c32:	48 8b 00             	mov    (%rax),%rax
  8004206c35:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  8004206c3c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206c40:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206c44:	66 83 f8 01          	cmp    $0x1,%ax
  8004206c48:	74 35                	je     8004206c7f <page_check+0x15df>
  8004206c4a:	48 b9 d9 90 21 04 80 	movabs $0x80042190d9,%rcx
  8004206c51:	00 00 00 
  8004206c54:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206c5b:	00 00 00 
  8004206c5e:	be 72 05 00 00       	mov    $0x572,%esi
  8004206c63:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206c6a:	00 00 00 
  8004206c6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c72:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206c79:	00 00 00 
  8004206c7c:	41 ff d0             	callq  *%r8
	page_decref(pp3);
  8004206c7f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206c83:	48 89 c7             	mov    %rax,%rdi
  8004206c86:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  8004206c8d:	00 00 00 
  8004206c90:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	page_decref(pp0);
  8004206c92:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206c96:	48 89 c7             	mov    %rax,%rdi
  8004206c99:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  8004206ca0:	00 00 00 
  8004206ca3:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004206ca5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206ca9:	48 89 c7             	mov    %rax,%rdi
  8004206cac:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  8004206cb3:	00 00 00 
  8004206cb6:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  8004206cb8:	48 c7 85 68 ff ff ff 	movq   $0x64000,-0x98(%rbp)
  8004206cbf:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004206cc3:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206cca:	00 00 00 
  8004206ccd:	48 8b 00             	mov    (%rax),%rax
  8004206cd0:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  8004206cd7:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206cdc:	48 89 ce             	mov    %rcx,%rsi
  8004206cdf:	48 89 c7             	mov    %rax,%rdi
  8004206ce2:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  8004206ce9:	00 00 00 
  8004206cec:	ff d0                	callq  *%rax
  8004206cee:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004206cf5:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206cfc:	00 00 00 
  8004206cff:	48 8b 00             	mov    (%rax),%rax
  8004206d02:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004206d09:	48 c1 ea 27          	shr    $0x27,%rdx
  8004206d0d:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004206d13:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206d17:	48 01 d0             	add    %rdx,%rax
  8004206d1a:	48 8b 00             	mov    (%rax),%rax
  8004206d1d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206d23:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004206d2a:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206d31:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206d35:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
  8004206d3b:	8b 95 5c ff ff ff    	mov    -0xa4(%rbp),%edx
  8004206d41:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004206d48:	00 00 00 
  8004206d4b:	48 8b 00             	mov    (%rax),%rax
  8004206d4e:	48 39 c2             	cmp    %rax,%rdx
  8004206d51:	72 35                	jb     8004206d88 <page_check+0x16e8>
  8004206d53:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206d5a:	48 89 c1             	mov    %rax,%rcx
  8004206d5d:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004206d64:	00 00 00 
  8004206d67:	be 79 05 00 00       	mov    $0x579,%esi
  8004206d6c:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206d73:	00 00 00 
  8004206d76:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d7b:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206d82:	00 00 00 
  8004206d85:	41 ff d0             	callq  *%r8
  8004206d88:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206d8f:	00 00 00 
  8004206d92:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206d99:	48 01 d0             	add    %rdx,%rax
  8004206d9c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004206da0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206da7:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004206dab:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206db0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206db7:	00 
  8004206db8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206dbc:	48 01 d0             	add    %rdx,%rax
  8004206dbf:	48 8b 00             	mov    (%rax),%rax
  8004206dc2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206dc8:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004206dcf:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206dd6:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206dda:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  8004206de0:	8b 95 4c ff ff ff    	mov    -0xb4(%rbp),%edx
  8004206de6:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004206ded:	00 00 00 
  8004206df0:	48 8b 00             	mov    (%rax),%rax
  8004206df3:	48 39 c2             	cmp    %rax,%rdx
  8004206df6:	72 35                	jb     8004206e2d <page_check+0x178d>
  8004206df8:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206dff:	48 89 c1             	mov    %rax,%rcx
  8004206e02:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004206e09:	00 00 00 
  8004206e0c:	be 7a 05 00 00       	mov    $0x57a,%esi
  8004206e11:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206e18:	00 00 00 
  8004206e1b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e20:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206e27:	00 00 00 
  8004206e2a:	41 ff d0             	callq  *%r8
  8004206e2d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206e34:	00 00 00 
  8004206e37:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206e3e:	48 01 d0             	add    %rdx,%rax
  8004206e41:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  8004206e45:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206e4c:	48 c1 e8 15          	shr    $0x15,%rax
  8004206e50:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206e55:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206e5c:	00 
  8004206e5d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206e61:	48 01 d0             	add    %rdx,%rax
  8004206e64:	48 8b 00             	mov    (%rax),%rax
  8004206e67:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206e6d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004206e74:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206e7b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206e7f:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
  8004206e85:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
  8004206e8b:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004206e92:	00 00 00 
  8004206e95:	48 8b 00             	mov    (%rax),%rax
  8004206e98:	48 39 c2             	cmp    %rax,%rdx
  8004206e9b:	72 35                	jb     8004206ed2 <page_check+0x1832>
  8004206e9d:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206ea4:	48 89 c1             	mov    %rax,%rcx
  8004206ea7:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004206eae:	00 00 00 
  8004206eb1:	be 7b 05 00 00       	mov    $0x57b,%esi
  8004206eb6:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206ebd:	00 00 00 
  8004206ec0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ec5:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206ecc:	00 00 00 
  8004206ecf:	41 ff d0             	callq  *%r8
  8004206ed2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206ed9:	00 00 00 
  8004206edc:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206ee3:	48 01 d0             	add    %rdx,%rax
  8004206ee6:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004206eed:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206ef4:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206ef8:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206efd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206f04:	00 
  8004206f05:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004206f0c:	48 01 c2             	add    %rax,%rdx
  8004206f0f:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206f16:	48 39 c2             	cmp    %rax,%rdx
  8004206f19:	74 35                	je     8004206f50 <page_check+0x18b0>
  8004206f1b:	48 b9 98 91 21 04 80 	movabs $0x8004219198,%rcx
  8004206f22:	00 00 00 
  8004206f25:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004206f2c:	00 00 00 
  8004206f2f:	be 7c 05 00 00       	mov    $0x57c,%esi
  8004206f34:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004206f3b:	00 00 00 
  8004206f3e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f43:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004206f4a:	00 00 00 
  8004206f4d:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	page_decref(pp4);
  8004206f50:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206f54:	48 89 c7             	mov    %rax,%rdi
  8004206f57:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  8004206f5e:	00 00 00 
  8004206f61:	ff d0                	callq  *%rax
	memset(page2kva(pp4), 0xFF, PGSIZE);
  8004206f63:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206f67:	48 89 c7             	mov    %rax,%rdi
  8004206f6a:	48 b8 8e 1c 20 04 80 	movabs $0x8004201c8e,%rax
  8004206f71:	00 00 00 
  8004206f74:	ff d0                	callq  *%rax
  8004206f76:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206f7b:	be ff 00 00 00       	mov    $0xff,%esi
  8004206f80:	48 89 c7             	mov    %rax,%rdi
  8004206f83:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004206f8a:	00 00 00 
  8004206f8d:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  8004206f8f:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206f96:	00 00 00 
  8004206f99:	48 8b 00             	mov    (%rax),%rax
  8004206f9c:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206fa1:	be 00 00 00 00       	mov    $0x0,%esi
  8004206fa6:	48 89 c7             	mov    %rax,%rdi
  8004206fa9:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  8004206fb0:	00 00 00 
  8004206fb3:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004206fb5:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004206fbc:	00 00 00 
  8004206fbf:	48 8b 00             	mov    (%rax),%rax
  8004206fc2:	48 8b 00             	mov    (%rax),%rax
  8004206fc5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206fcb:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004206fd2:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206fd9:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206fdd:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
  8004206fe3:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004206fe9:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004206ff0:	00 00 00 
  8004206ff3:	48 8b 00             	mov    (%rax),%rax
  8004206ff6:	48 39 c2             	cmp    %rax,%rdx
  8004206ff9:	72 35                	jb     8004207030 <page_check+0x1990>
  8004206ffb:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207002:	48 89 c1             	mov    %rax,%rcx
  8004207005:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  800420700c:	00 00 00 
  800420700f:	be 82 05 00 00       	mov    $0x582,%esi
  8004207014:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420701b:	00 00 00 
  800420701e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207023:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420702a:	00 00 00 
  800420702d:	41 ff d0             	callq  *%r8
  8004207030:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207037:	00 00 00 
  800420703a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207041:	48 01 d0             	add    %rdx,%rax
  8004207044:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  8004207048:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420704c:	48 8b 00             	mov    (%rax),%rax
  800420704f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207055:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  800420705c:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004207063:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207067:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
  800420706d:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  8004207073:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  800420707a:	00 00 00 
  800420707d:	48 8b 00             	mov    (%rax),%rax
  8004207080:	48 39 c2             	cmp    %rax,%rdx
  8004207083:	72 35                	jb     80042070ba <page_check+0x1a1a>
  8004207085:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800420708c:	48 89 c1             	mov    %rax,%rcx
  800420708f:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004207096:	00 00 00 
  8004207099:	be 83 05 00 00       	mov    $0x583,%esi
  800420709e:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042070a5:	00 00 00 
  80042070a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070ad:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042070b4:	00 00 00 
  80042070b7:	41 ff d0             	callq  *%r8
  80042070ba:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042070c1:	00 00 00 
  80042070c4:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042070cb:	48 01 d0             	add    %rdx,%rax
  80042070ce:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  80042070d2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042070d6:	48 8b 00             	mov    (%rax),%rax
  80042070d9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042070df:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  80042070e6:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042070ed:	48 c1 e8 0c          	shr    $0xc,%rax
  80042070f1:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  80042070f7:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  80042070fd:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004207104:	00 00 00 
  8004207107:	48 8b 00             	mov    (%rax),%rax
  800420710a:	48 39 c2             	cmp    %rax,%rdx
  800420710d:	72 35                	jb     8004207144 <page_check+0x1aa4>
  800420710f:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207116:	48 89 c1             	mov    %rax,%rcx
  8004207119:	48 ba d8 84 21 04 80 	movabs $0x80042184d8,%rdx
  8004207120:	00 00 00 
  8004207123:	be 84 05 00 00       	mov    $0x584,%esi
  8004207128:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420712f:	00 00 00 
  8004207132:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207137:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420713e:	00 00 00 
  8004207141:	41 ff d0             	callq  *%r8
  8004207144:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420714b:	00 00 00 
  800420714e:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207155:	48 01 d0             	add    %rdx,%rax
  8004207158:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  800420715f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004207166:	eb 58                	jmp    80042071c0 <page_check+0x1b20>
		assert((ptep[i] & PTE_P) == 0);
  8004207168:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  800420716f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004207172:	48 63 d2             	movslq %edx,%rdx
  8004207175:	48 c1 e2 03          	shl    $0x3,%rdx
  8004207179:	48 01 d0             	add    %rdx,%rax
  800420717c:	48 8b 00             	mov    (%rax),%rax
  800420717f:	83 e0 01             	and    $0x1,%eax
  8004207182:	48 85 c0             	test   %rax,%rax
  8004207185:	74 35                	je     80042071bc <page_check+0x1b1c>
  8004207187:	48 b9 b0 91 21 04 80 	movabs $0x80042191b0,%rcx
  800420718e:	00 00 00 
  8004207191:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004207198:	00 00 00 
  800420719b:	be 86 05 00 00       	mov    $0x586,%esi
  80042071a0:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042071a7:	00 00 00 
  80042071aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042071af:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042071b6:	00 00 00 
  80042071b9:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  80042071bc:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042071c0:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  80042071c7:	7e 9f                	jle    8004207168 <page_check+0x1ac8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  80042071c9:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  80042071d0:	00 00 00 
  80042071d3:	48 8b 00             	mov    (%rax),%rax
  80042071d6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  80042071dd:	48 b8 38 72 60 04 80 	movabs $0x8004607238,%rax
  80042071e4:	00 00 00 
  80042071e7:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042071eb:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  80042071ee:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042071f2:	48 89 c7             	mov    %rax,%rdi
  80042071f5:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  80042071fc:	00 00 00 
  80042071ff:	ff d0                	callq  *%rax
	page_decref(pp1);
  8004207201:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207205:	48 89 c7             	mov    %rax,%rdi
  8004207208:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  800420720f:	00 00 00 
  8004207212:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004207214:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207218:	48 89 c7             	mov    %rax,%rdi
  800420721b:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  8004207222:	00 00 00 
  8004207225:	ff d0                	callq  *%rax

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  8004207227:	be 01 10 00 00       	mov    $0x1001,%esi
  800420722c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207231:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  8004207238:	00 00 00 
  800420723b:	ff d0                	callq  *%rax
  800420723d:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  8004207244:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207249:	bf 00 00 00 00       	mov    $0x0,%edi
  800420724e:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  8004207255:	00 00 00 
  8004207258:	ff d0                	callq  *%rax
  800420725a:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  8004207261:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207268:	00 00 00 
  800420726b:	48 39 85 f8 fe ff ff 	cmp    %rax,-0x108(%rbp)
  8004207272:	76 1d                	jbe    8004207291 <page_check+0x1bf1>
  8004207274:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800420727b:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004207282:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004207289:	00 00 00 
  800420728c:	48 39 c2             	cmp    %rax,%rdx
  800420728f:	76 35                	jbe    80042072c6 <page_check+0x1c26>
  8004207291:	48 b9 c8 91 21 04 80 	movabs $0x80042191c8,%rcx
  8004207298:	00 00 00 
  800420729b:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042072a2:	00 00 00 
  80042072a5:	be 95 05 00 00       	mov    $0x595,%esi
  80042072aa:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042072b1:	00 00 00 
  80042072b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072b9:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042072c0:	00 00 00 
  80042072c3:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  80042072c6:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042072cd:	00 00 00 
  80042072d0:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  80042072d7:	76 1d                	jbe    80042072f6 <page_check+0x1c56>
  80042072d9:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042072e0:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  80042072e7:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042072ee:	00 00 00 
  80042072f1:	48 39 c2             	cmp    %rax,%rdx
  80042072f4:	76 35                	jbe    800420732b <page_check+0x1c8b>
  80042072f6:	48 b9 f0 91 21 04 80 	movabs $0x80042191f0,%rcx
  80042072fd:	00 00 00 
  8004207300:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004207307:	00 00 00 
  800420730a:	be 96 05 00 00       	mov    $0x596,%esi
  800420730f:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004207316:	00 00 00 
  8004207319:	b8 00 00 00 00       	mov    $0x0,%eax
  800420731e:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004207325:	00 00 00 
  8004207328:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  800420732b:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207332:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207337:	48 85 c0             	test   %rax,%rax
  800420733a:	75 11                	jne    800420734d <page_check+0x1cad>
  800420733c:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207343:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207348:	48 85 c0             	test   %rax,%rax
  800420734b:	74 35                	je     8004207382 <page_check+0x1ce2>
  800420734d:	48 b9 18 92 21 04 80 	movabs $0x8004219218,%rcx
  8004207354:	00 00 00 
  8004207357:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420735e:	00 00 00 
  8004207361:	be 98 05 00 00       	mov    $0x598,%esi
  8004207366:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420736d:	00 00 00 
  8004207370:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207375:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420737c:	00 00 00 
  800420737f:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  8004207382:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207389:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  800420738f:	48 3b 85 f0 fe ff ff 	cmp    -0x110(%rbp),%rax
  8004207396:	76 35                	jbe    80042073cd <page_check+0x1d2d>
  8004207398:	48 b9 3f 92 21 04 80 	movabs $0x800421923f,%rcx
  800420739f:	00 00 00 
  80042073a2:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042073a9:	00 00 00 
  80042073ac:	be 9a 05 00 00       	mov    $0x59a,%esi
  80042073b1:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042073b8:	00 00 00 
  80042073bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073c0:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042073c7:	00 00 00 
  80042073ca:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  80042073cd:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  80042073d4:	00 00 00 
  80042073d7:	48 8b 00             	mov    (%rax),%rax
  80042073da:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  80042073e1:	48 89 d6             	mov    %rdx,%rsi
  80042073e4:	48 89 c7             	mov    %rax,%rdi
  80042073e7:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  80042073ee:	00 00 00 
  80042073f1:	ff d0                	callq  *%rax
  80042073f3:	48 85 c0             	test   %rax,%rax
  80042073f6:	74 35                	je     800420742d <page_check+0x1d8d>
  80042073f8:	48 b9 58 92 21 04 80 	movabs $0x8004219258,%rcx
  80042073ff:	00 00 00 
  8004207402:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004207409:	00 00 00 
  800420740c:	be 9d 05 00 00       	mov    $0x59d,%esi
  8004207411:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004207418:	00 00 00 
  800420741b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207420:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004207427:	00 00 00 
  800420742a:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  800420742d:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207434:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  800420743b:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004207442:	00 00 00 
  8004207445:	48 8b 00             	mov    (%rax),%rax
  8004207448:	48 89 d6             	mov    %rdx,%rsi
  800420744b:	48 89 c7             	mov    %rax,%rdi
  800420744e:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  8004207455:	00 00 00 
  8004207458:	ff d0                	callq  *%rax
  800420745a:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  8004207460:	74 35                	je     8004207497 <page_check+0x1df7>
  8004207462:	48 b9 80 92 21 04 80 	movabs $0x8004219280,%rcx
  8004207469:	00 00 00 
  800420746c:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004207473:	00 00 00 
  8004207476:	be 9e 05 00 00       	mov    $0x59e,%esi
  800420747b:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004207482:	00 00 00 
  8004207485:	b8 00 00 00 00       	mov    $0x0,%eax
  800420748a:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004207491:	00 00 00 
  8004207494:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  8004207497:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  800420749e:	00 00 00 
  80042074a1:	48 8b 00             	mov    (%rax),%rax
  80042074a4:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  80042074ab:	48 89 d6             	mov    %rdx,%rsi
  80042074ae:	48 89 c7             	mov    %rax,%rdi
  80042074b1:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  80042074b8:	00 00 00 
  80042074bb:	ff d0                	callq  *%rax
  80042074bd:	48 85 c0             	test   %rax,%rax
  80042074c0:	74 35                	je     80042074f7 <page_check+0x1e57>
  80042074c2:	48 b9 b0 92 21 04 80 	movabs $0x80042192b0,%rcx
  80042074c9:	00 00 00 
  80042074cc:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042074d3:	00 00 00 
  80042074d6:	be 9f 05 00 00       	mov    $0x59f,%esi
  80042074db:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042074e2:	00 00 00 
  80042074e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074ea:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042074f1:	00 00 00 
  80042074f4:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  80042074f7:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042074fe:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207505:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  800420750c:	00 00 00 
  800420750f:	48 8b 00             	mov    (%rax),%rax
  8004207512:	48 89 d6             	mov    %rdx,%rsi
  8004207515:	48 89 c7             	mov    %rax,%rdi
  8004207518:	48 b8 26 54 20 04 80 	movabs $0x8004205426,%rax
  800420751f:	00 00 00 
  8004207522:	ff d0                	callq  *%rax
  8004207524:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207528:	74 35                	je     800420755f <page_check+0x1ebf>
  800420752a:	48 b9 d8 92 21 04 80 	movabs $0x80042192d8,%rcx
  8004207531:	00 00 00 
  8004207534:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  800420753b:	00 00 00 
  800420753e:	be a0 05 00 00       	mov    $0x5a0,%esi
  8004207543:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  800420754a:	00 00 00 
  800420754d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207552:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004207559:	00 00 00 
  800420755c:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  800420755f:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  8004207566:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  800420756d:	00 00 00 
  8004207570:	48 8b 00             	mov    (%rax),%rax
  8004207573:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207578:	48 89 ce             	mov    %rcx,%rsi
  800420757b:	48 89 c7             	mov    %rax,%rdi
  800420757e:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  8004207585:	00 00 00 
  8004207588:	ff d0                	callq  *%rax
  800420758a:	48 8b 00             	mov    (%rax),%rax
  800420758d:	83 e0 1a             	and    $0x1a,%eax
  8004207590:	48 85 c0             	test   %rax,%rax
  8004207593:	75 35                	jne    80042075ca <page_check+0x1f2a>
  8004207595:	48 b9 08 93 21 04 80 	movabs $0x8004219308,%rcx
  800420759c:	00 00 00 
  800420759f:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  80042075a6:	00 00 00 
  80042075a9:	be a2 05 00 00       	mov    $0x5a2,%esi
  80042075ae:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  80042075b5:	00 00 00 
  80042075b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075bd:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042075c4:	00 00 00 
  80042075c7:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  80042075ca:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  80042075d1:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  80042075d8:	00 00 00 
  80042075db:	48 8b 00             	mov    (%rax),%rax
  80042075de:	ba 00 00 00 00       	mov    $0x0,%edx
  80042075e3:	48 89 ce             	mov    %rcx,%rsi
  80042075e6:	48 89 c7             	mov    %rax,%rdi
  80042075e9:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  80042075f0:	00 00 00 
  80042075f3:	ff d0                	callq  *%rax
  80042075f5:	48 8b 00             	mov    (%rax),%rax
  80042075f8:	83 e0 04             	and    $0x4,%eax
  80042075fb:	48 85 c0             	test   %rax,%rax
  80042075fe:	74 35                	je     8004207635 <page_check+0x1f95>
  8004207600:	48 b9 50 93 21 04 80 	movabs $0x8004219350,%rcx
  8004207607:	00 00 00 
  800420760a:	48 ba 51 85 21 04 80 	movabs $0x8004218551,%rdx
  8004207611:	00 00 00 
  8004207614:	be a3 05 00 00       	mov    $0x5a3,%esi
  8004207619:	48 bf 66 85 21 04 80 	movabs $0x8004218566,%rdi
  8004207620:	00 00 00 
  8004207623:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207628:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420762f:	00 00 00 
  8004207632:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004207635:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  800420763c:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004207643:	00 00 00 
  8004207646:	48 8b 00             	mov    (%rax),%rax
  8004207649:	ba 00 00 00 00       	mov    $0x0,%edx
  800420764e:	48 89 ce             	mov    %rcx,%rsi
  8004207651:	48 89 c7             	mov    %rax,%rdi
  8004207654:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  800420765b:	00 00 00 
  800420765e:	ff d0                	callq  *%rax
  8004207660:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  8004207667:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800420766e:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207674:	48 89 c1             	mov    %rax,%rcx
  8004207677:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  800420767e:	00 00 00 
  8004207681:	48 8b 00             	mov    (%rax),%rax
  8004207684:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207689:	48 89 ce             	mov    %rcx,%rsi
  800420768c:	48 89 c7             	mov    %rax,%rdi
  800420768f:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  8004207696:	00 00 00 
  8004207699:	ff d0                	callq  *%rax
  800420769b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  80042076a2:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  80042076a9:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  80042076b0:	00 00 00 
  80042076b3:	48 8b 00             	mov    (%rax),%rax
  80042076b6:	ba 00 00 00 00       	mov    $0x0,%edx
  80042076bb:	48 89 ce             	mov    %rcx,%rsi
  80042076be:	48 89 c7             	mov    %rax,%rdi
  80042076c1:	48 b8 28 31 20 04 80 	movabs $0x8004203128,%rax
  80042076c8:	00 00 00 
  80042076cb:	ff d0                	callq  *%rax
  80042076cd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  80042076d4:	48 bf 83 93 21 04 80 	movabs $0x8004219383,%rdi
  80042076db:	00 00 00 
  80042076de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042076e3:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042076ea:	00 00 00 
  80042076ed:	ff d2                	callq  *%rdx
}
  80042076ef:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  80042076f6:	5b                   	pop    %rbx
  80042076f7:	5d                   	pop    %rbp
  80042076f8:	c3                   	retq   

00000080042076f9 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  80042076f9:	55                   	push   %rbp
  80042076fa:	48 89 e5             	mov    %rsp,%rbp
  80042076fd:	48 83 ec 08          	sub    $0x8,%rsp
  8004207701:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004207705:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207709:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004207710:	00 00 00 
  8004207713:	48 8b 00             	mov    (%rax),%rax
  8004207716:	48 29 c2             	sub    %rax,%rdx
  8004207719:	48 89 d0             	mov    %rdx,%rax
  800420771c:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004207720:	c9                   	leaveq 
  8004207721:	c3                   	retq   

0000008004207722 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004207722:	55                   	push   %rbp
  8004207723:	48 89 e5             	mov    %rsp,%rbp
  8004207726:	48 83 ec 08          	sub    $0x8,%rsp
  800420772a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800420772e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207732:	48 89 c7             	mov    %rax,%rdi
  8004207735:	48 b8 f9 76 20 04 80 	movabs $0x80042076f9,%rax
  800420773c:	00 00 00 
  800420773f:	ff d0                	callq  *%rax
  8004207741:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004207745:	c9                   	leaveq 
  8004207746:	c3                   	retq   

0000008004207747 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004207747:	55                   	push   %rbp
  8004207748:	48 89 e5             	mov    %rsp,%rbp
  800420774b:	48 83 ec 10          	sub    $0x10,%rsp
  800420774f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004207753:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207757:	48 c1 e8 0c          	shr    $0xc,%rax
  800420775b:	48 89 c2             	mov    %rax,%rdx
  800420775e:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004207765:	00 00 00 
  8004207768:	48 8b 00             	mov    (%rax),%rax
  800420776b:	48 39 c2             	cmp    %rax,%rdx
  800420776e:	72 2a                	jb     800420779a <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004207770:	48 ba a0 93 21 04 80 	movabs $0x80042193a0,%rdx
  8004207777:	00 00 00 
  800420777a:	be 54 00 00 00       	mov    $0x54,%esi
  800420777f:	48 bf bf 93 21 04 80 	movabs $0x80042193bf,%rdi
  8004207786:	00 00 00 
  8004207789:	b8 00 00 00 00       	mov    $0x0,%eax
  800420778e:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  8004207795:	00 00 00 
  8004207798:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  800420779a:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  80042077a1:	00 00 00 
  80042077a4:	48 8b 00             	mov    (%rax),%rax
  80042077a7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042077ab:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042077af:	48 c1 e2 04          	shl    $0x4,%rdx
  80042077b3:	48 01 d0             	add    %rdx,%rax
}
  80042077b6:	c9                   	leaveq 
  80042077b7:	c3                   	retq   

00000080042077b8 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  80042077b8:	55                   	push   %rbp
  80042077b9:	48 89 e5             	mov    %rsp,%rbp
  80042077bc:	48 83 ec 20          	sub    $0x20,%rsp
  80042077c0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  80042077c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042077c8:	48 89 c7             	mov    %rax,%rdi
  80042077cb:	48 b8 22 77 20 04 80 	movabs $0x8004207722,%rax
  80042077d2:	00 00 00 
  80042077d5:	ff d0                	callq  *%rax
  80042077d7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042077db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042077df:	48 c1 e8 0c          	shr    $0xc,%rax
  80042077e3:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042077e6:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042077e9:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  80042077f0:	00 00 00 
  80042077f3:	48 8b 00             	mov    (%rax),%rax
  80042077f6:	48 39 c2             	cmp    %rax,%rdx
  80042077f9:	72 32                	jb     800420782d <page2kva+0x75>
  80042077fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042077ff:	48 89 c1             	mov    %rax,%rcx
  8004207802:	48 ba d0 93 21 04 80 	movabs $0x80042193d0,%rdx
  8004207809:	00 00 00 
  800420780c:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004207811:	48 bf bf 93 21 04 80 	movabs $0x80042193bf,%rdi
  8004207818:	00 00 00 
  800420781b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207820:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004207827:	00 00 00 
  800420782a:	41 ff d0             	callq  *%r8
  800420782d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207834:	00 00 00 
  8004207837:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420783b:	48 01 d0             	add    %rdx,%rax
}
  800420783e:	c9                   	leaveq 
  800420783f:	c3                   	retq   

0000008004207840 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  8004207840:	55                   	push   %rbp
  8004207841:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  8004207844:	48 bf 80 d7 22 04 80 	movabs $0x800422d780,%rdi
  800420784b:	00 00 00 
  800420784e:	48 b8 8b 6d 21 04 80 	movabs $0x8004216d8b,%rax
  8004207855:	00 00 00 
  8004207858:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420785a:	f3 90                	pause  
}
  800420785c:	5d                   	pop    %rbp
  800420785d:	c3                   	retq   

000000800420785e <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  800420785e:	55                   	push   %rbp
  800420785f:	48 89 e5             	mov    %rsp,%rbp
  8004207862:	53                   	push   %rbx
  8004207863:	48 83 ec 28          	sub    $0x28,%rsp
  8004207867:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420786a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420786e:	89 d0                	mov    %edx,%eax
  8004207870:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  8004207873:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004207877:	75 42                	jne    80042078bb <envid2env+0x5d>
		*env_store = curenv;
  8004207879:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004207880:	00 00 00 
  8004207883:	ff d0                	callq  *%rax
  8004207885:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420788c:	00 00 00 
  800420788f:	48 98                	cltq   
  8004207891:	48 c1 e0 03          	shl    $0x3,%rax
  8004207895:	48 89 c2             	mov    %rax,%rdx
  8004207898:	48 c1 e2 04          	shl    $0x4,%rdx
  800420789c:	48 29 c2             	sub    %rax,%rdx
  800420789f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042078a3:	48 83 c0 08          	add    $0x8,%rax
  80042078a7:	48 8b 10             	mov    (%rax),%rdx
  80042078aa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042078ae:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  80042078b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078b6:	e9 09 01 00 00       	jmpq   80042079c4 <envid2env+0x166>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  80042078bb:	48 b8 50 72 60 04 80 	movabs $0x8004607250,%rax
  80042078c2:	00 00 00 
  80042078c5:	48 8b 08             	mov    (%rax),%rcx
  80042078c8:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042078cb:	48 98                	cltq   
  80042078cd:	25 ff 03 00 00       	and    $0x3ff,%eax
  80042078d2:	48 89 c2             	mov    %rax,%rdx
  80042078d5:	48 89 d0             	mov    %rdx,%rax
  80042078d8:	48 c1 e0 03          	shl    $0x3,%rax
  80042078dc:	48 01 d0             	add    %rdx,%rax
  80042078df:	48 c1 e0 05          	shl    $0x5,%rax
  80042078e3:	48 01 c8             	add    %rcx,%rax
  80042078e6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  80042078ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042078ee:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042078f4:	85 c0                	test   %eax,%eax
  80042078f6:	74 0f                	je     8004207907 <envid2env+0xa9>
  80042078f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042078fc:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207902:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004207905:	74 15                	je     800420791c <envid2env+0xbe>
		*env_store = 0;
  8004207907:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420790b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207912:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207917:	e9 a8 00 00 00       	jmpq   80042079c4 <envid2env+0x166>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  800420791c:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207920:	0f 84 8e 00 00 00    	je     80042079b4 <envid2env+0x156>
  8004207926:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420792d:	00 00 00 
  8004207930:	ff d0                	callq  *%rax
  8004207932:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  8004207939:	00 00 00 
  800420793c:	48 98                	cltq   
  800420793e:	48 c1 e0 03          	shl    $0x3,%rax
  8004207942:	48 89 c2             	mov    %rax,%rdx
  8004207945:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207949:	48 29 c2             	sub    %rax,%rdx
  800420794c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207950:	48 83 c0 08          	add    $0x8,%rax
  8004207954:	48 8b 00             	mov    (%rax),%rax
  8004207957:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420795b:	74 57                	je     80042079b4 <envid2env+0x156>
  800420795d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207961:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  8004207967:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420796e:	00 00 00 
  8004207971:	ff d0                	callq  *%rax
  8004207973:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420797a:	00 00 00 
  800420797d:	48 98                	cltq   
  800420797f:	48 c1 e0 03          	shl    $0x3,%rax
  8004207983:	48 89 c2             	mov    %rax,%rdx
  8004207986:	48 c1 e2 04          	shl    $0x4,%rdx
  800420798a:	48 29 c2             	sub    %rax,%rdx
  800420798d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004207991:	48 83 c0 08          	add    $0x8,%rax
  8004207995:	48 8b 00             	mov    (%rax),%rax
  8004207998:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420799e:	39 c3                	cmp    %eax,%ebx
  80042079a0:	74 12                	je     80042079b4 <envid2env+0x156>
		*env_store = 0;
  80042079a2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042079a6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  80042079ad:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80042079b2:	eb 10                	jmp    80042079c4 <envid2env+0x166>
	}

	*env_store = e;
  80042079b4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042079b8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042079bc:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  80042079bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042079c4:	48 83 c4 28          	add    $0x28,%rsp
  80042079c8:	5b                   	pop    %rbx
  80042079c9:	5d                   	pop    %rbp
  80042079ca:	c3                   	retq   

00000080042079cb <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  80042079cb:	55                   	push   %rbp
  80042079cc:	48 89 e5             	mov    %rsp,%rbp
  80042079cf:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.
	size_t i;
	struct Env* last = NULL;
  80042079d3:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042079da:	00 
	memset(envs, 0, NENV * sizeof(struct Env));
  80042079db:	48 b8 50 72 60 04 80 	movabs $0x8004607250,%rax
  80042079e2:	00 00 00 
  80042079e5:	48 8b 00             	mov    (%rax),%rax
  80042079e8:	ba 00 80 04 00       	mov    $0x48000,%edx
  80042079ed:	be 00 00 00 00       	mov    $0x0,%esi
  80042079f2:	48 89 c7             	mov    %rax,%rdi
  80042079f5:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  80042079fc:	00 00 00 
  80042079ff:	ff d0                	callq  *%rax
	for (i = 0; i < NENV; i++) {
  8004207a01:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207a08:	00 
  8004207a09:	e9 92 00 00 00       	jmpq   8004207aa0 <env_init+0xd5>
		if(last)
  8004207a0e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004207a13:	74 30                	je     8004207a45 <env_init+0x7a>
			last->env_link = &envs[i];
  8004207a15:	48 b8 50 72 60 04 80 	movabs $0x8004607250,%rax
  8004207a1c:	00 00 00 
  8004207a1f:	48 8b 08             	mov    (%rax),%rcx
  8004207a22:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207a26:	48 89 d0             	mov    %rdx,%rax
  8004207a29:	48 c1 e0 03          	shl    $0x3,%rax
  8004207a2d:	48 01 d0             	add    %rdx,%rax
  8004207a30:	48 c1 e0 05          	shl    $0x5,%rax
  8004207a34:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004207a38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207a3c:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
  8004207a43:	eb 30                	jmp    8004207a75 <env_init+0xaa>
		else
			env_free_list = &envs[i];
  8004207a45:	48 b8 50 72 60 04 80 	movabs $0x8004607250,%rax
  8004207a4c:	00 00 00 
  8004207a4f:	48 8b 08             	mov    (%rax),%rcx
  8004207a52:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207a56:	48 89 d0             	mov    %rdx,%rax
  8004207a59:	48 c1 e0 03          	shl    $0x3,%rax
  8004207a5d:	48 01 d0             	add    %rdx,%rax
  8004207a60:	48 c1 e0 05          	shl    $0x5,%rax
  8004207a64:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004207a68:	48 b8 58 72 60 04 80 	movabs $0x8004607258,%rax
  8004207a6f:	00 00 00 
  8004207a72:	48 89 10             	mov    %rdx,(%rax)
		last = &envs[i];
  8004207a75:	48 b8 50 72 60 04 80 	movabs $0x8004607250,%rax
  8004207a7c:	00 00 00 
  8004207a7f:	48 8b 08             	mov    (%rax),%rcx
  8004207a82:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207a86:	48 89 d0             	mov    %rdx,%rax
  8004207a89:	48 c1 e0 03          	shl    $0x3,%rax
  8004207a8d:	48 01 d0             	add    %rdx,%rax
  8004207a90:	48 c1 e0 05          	shl    $0x5,%rax
  8004207a94:	48 01 c8             	add    %rcx,%rax
  8004207a97:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// Set up envs array
	// LAB 3: Your code here.
	size_t i;
	struct Env* last = NULL;
	memset(envs, 0, NENV * sizeof(struct Env));
	for (i = 0; i < NENV; i++) {
  8004207a9b:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004207aa0:	48 81 7d f8 ff 03 00 	cmpq   $0x3ff,-0x8(%rbp)
  8004207aa7:	00 
  8004207aa8:	0f 86 60 ff ff ff    	jbe    8004207a0e <env_init+0x43>
		else
			env_free_list = &envs[i];
		last = &envs[i];
	}
	// Per-CPU part of the initialization
	env_init_percpu();
  8004207aae:	48 b8 bc 7a 20 04 80 	movabs $0x8004207abc,%rax
  8004207ab5:	00 00 00 
  8004207ab8:	ff d0                	callq  *%rax
}
  8004207aba:	c9                   	leaveq 
  8004207abb:	c3                   	retq   

0000008004207abc <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004207abc:	55                   	push   %rbp
  8004207abd:	48 89 e5             	mov    %rsp,%rbp
  8004207ac0:	53                   	push   %rbx
  8004207ac1:	48 83 ec 10          	sub    $0x10,%rsp
  8004207ac5:	48 b8 88 d6 22 04 80 	movabs $0x800422d688,%rax
  8004207acc:	00 00 00 
  8004207acf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  8004207ad3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ad7:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  8004207ada:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207adf:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004207ae1:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207ae6:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  8004207ae8:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207aed:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004207aef:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207af4:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  8004207af6:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207afb:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  8004207afd:	b8 08 00 00 00       	mov    $0x8,%eax
  8004207b02:	89 c3                	mov    %eax,%ebx
  8004207b04:	53                   	push   %rbx
  8004207b05:	48 b8 12 7b 20 04 80 	movabs $0x8004207b12,%rax
  8004207b0c:	00 00 00 
  8004207b0f:	50                   	push   %rax
  8004207b10:	48 cb                	lretq  
  8004207b12:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  8004207b18:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8004207b1c:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  8004207b1f:	48 83 c4 10          	add    $0x10,%rsp
  8004207b23:	5b                   	pop    %rbx
  8004207b24:	5d                   	pop    %rbp
  8004207b25:	c3                   	retq   

0000008004207b26 <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  8004207b26:	55                   	push   %rbp
  8004207b27:	48 89 e5             	mov    %rsp,%rbp
  8004207b2a:	48 83 ec 20          	sub    $0x20,%rsp
  8004207b2e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  8004207b32:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207b39:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  8004207b3a:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207b3f:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  8004207b46:	00 00 00 
  8004207b49:	ff d0                	callq  *%rax
  8004207b4b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207b4f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004207b54:	75 0a                	jne    8004207b60 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  8004207b56:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207b5b:	e9 98 00 00 00       	jmpq   8004207bf8 <env_setup_vm+0xd2>
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.

	//Increment page reference here
	p->pp_ref++;
  8004207b60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b64:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207b68:	8d 50 01             	lea    0x1(%rax),%edx
  8004207b6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b6f:	66 89 50 08          	mov    %dx,0x8(%rax)

	//fill structure values
	e->env_pml4e = (pml4e_t *)page2kva(p);
  8004207b73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b77:	48 89 c7             	mov    %rax,%rdi
  8004207b7a:	48 b8 b8 77 20 04 80 	movabs $0x80042077b8,%rax
  8004207b81:	00 00 00 
  8004207b84:	ff d0                	callq  *%rax
  8004207b86:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207b8a:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3= page2pa(p);
  8004207b91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b95:	48 89 c7             	mov    %rax,%rdi
  8004207b98:	48 b8 22 77 20 04 80 	movabs $0x8004207722,%rax
  8004207b9f:	00 00 00 
  8004207ba2:	ff d0                	callq  *%rax
  8004207ba4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207ba8:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)

	//copy kernel pml4e entries 
    //for (i = PML4(UTOP); i != NPDENTRIES; i++)
    //    e->env_pml4e[i] = boot_pml4e[i]|PTE_USER;
	
	e->env_pml4e[1] = boot_pml4e[1];
  8004207baf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207bb3:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207bba:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004207bbe:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  8004207bc5:	00 00 00 
  8004207bc8:	48 8b 00             	mov    (%rax),%rax
  8004207bcb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207bcf:	48 89 02             	mov    %rax,(%rdx)
	//cprintf("envpml4e[0] [%x],envpml4e[1] [%x], env cr3[%x] ,  UTOP [%x] PML4e1 [%x]",e->env_pml4e[0],e->env_pml4e[0], e->env_cr3, UTOP, PML4(UTOP));

	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 |PTE_P|PTE_W|PTE_U;
  8004207bd2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207bd6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207bdd:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8004207be1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207be5:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207bec:	48 83 c8 07          	or     $0x7,%rax
  8004207bf0:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  8004207bf3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207bf8:	c9                   	leaveq 
  8004207bf9:	c3                   	retq   

0000008004207bfa <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  8004207bfa:	55                   	push   %rbp
  8004207bfb:	48 89 e5             	mov    %rsp,%rbp
  8004207bfe:	48 83 ec 30          	sub    $0x30,%rsp
  8004207c02:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004207c06:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  8004207c09:	48 b8 58 72 60 04 80 	movabs $0x8004607258,%rax
  8004207c10:	00 00 00 
  8004207c13:	48 8b 00             	mov    (%rax),%rax
  8004207c16:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004207c1a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004207c1f:	75 0a                	jne    8004207c2b <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  8004207c21:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004207c26:	e9 76 01 00 00       	jmpq   8004207da1 <env_alloc+0x1a7>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  8004207c2b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c2f:	48 89 c7             	mov    %rax,%rdi
  8004207c32:	48 b8 26 7b 20 04 80 	movabs $0x8004207b26,%rax
  8004207c39:	00 00 00 
  8004207c3c:	ff d0                	callq  *%rax
  8004207c3e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004207c41:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004207c45:	79 08                	jns    8004207c4f <env_alloc+0x55>
		return r;
  8004207c47:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207c4a:	e9 52 01 00 00       	jmpq   8004207da1 <env_alloc+0x1a7>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004207c4f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c53:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207c59:	05 00 10 00 00       	add    $0x1000,%eax
  8004207c5e:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004207c63:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004207c66:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004207c6a:	7f 07                	jg     8004207c73 <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  8004207c6c:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  8004207c73:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207c77:	48 b8 50 72 60 04 80 	movabs $0x8004607250,%rax
  8004207c7e:	00 00 00 
  8004207c81:	48 8b 00             	mov    (%rax),%rax
  8004207c84:	48 29 c2             	sub    %rax,%rdx
  8004207c87:	48 89 d0             	mov    %rdx,%rax
  8004207c8a:	48 c1 f8 05          	sar    $0x5,%rax
  8004207c8e:	48 89 c2             	mov    %rax,%rdx
  8004207c91:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  8004207c98:	e3 38 8e 
  8004207c9b:	48 0f af c2          	imul   %rdx,%rax
  8004207c9f:	0b 45 fc             	or     -0x4(%rbp),%eax
  8004207ca2:	89 c2                	mov    %eax,%edx
  8004207ca4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ca8:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004207cae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cb2:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004207cb5:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004207cbb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cbf:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  8004207cc6:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004207cc9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ccd:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004207cd4:	00 00 00 
	e->env_runs = 0;
  8004207cd7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cdb:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004207ce2:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004207ce5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ce9:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004207cee:	be 00 00 00 00       	mov    $0x0,%esi
  8004207cf3:	48 89 c7             	mov    %rax,%rdi
  8004207cf6:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004207cfd:	00 00 00 
  8004207d00:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004207d02:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d06:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  8004207d0d:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  8004207d0f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d13:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  8004207d19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d1d:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  8004207d24:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  8004207d26:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d2a:	b9 00 e0 7f ef       	mov    $0xef7fe000,%ecx
  8004207d2f:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  8004207d36:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d3a:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  8004207d41:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags = e->env_tf.tf_eflags |FL_IF;
  8004207d43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d47:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004207d4e:	80 cc 02             	or     $0x2,%ah
  8004207d51:	48 89 c2             	mov    %rax,%rdx
  8004207d54:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d58:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	
	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  8004207d5f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d63:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004207d6a:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  8004207d6e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d72:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004207d79:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d7d:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004207d84:	48 b8 58 72 60 04 80 	movabs $0x8004607258,%rax
  8004207d8b:	00 00 00 
  8004207d8e:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004207d91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207d95:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207d99:	48 89 10             	mov    %rdx,(%rax)
	//cprintf("env.tf->rsp [%x], e->env_id [%d]\n", e->env_tf.tf_rsp, e->env_id);

	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
	return 0;
  8004207d9c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207da1:	c9                   	leaveq 
  8004207da2:	c3                   	retq   

0000008004207da3 <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  8004207da3:	55                   	push   %rbp
  8004207da4:	48 89 e5             	mov    %rsp,%rbp
  8004207da7:	48 83 ec 40          	sub    $0x40,%rsp
  8004207dab:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004207daf:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207db3:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	uint64_t temp = (uint64_t)va;
  8004207db7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207dbb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	size_t lenDown = (uint64_t)va - temp;
  8004207dbf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207dc3:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004207dc7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	int i = 0;
  8004207dcb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	struct PageInfo *p;
	// Address round down
	temp =  (temp / PGSIZE) * PGSIZE;
  8004207dd2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207dd6:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207dda:	48 c1 e0 0c          	shl    $0xc,%rax
  8004207dde:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	// size round up
	len += lenDown;
  8004207de2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207de6:	48 01 45 c8          	add    %rax,-0x38(%rbp)
	len = ((len + PGSIZE) / PGSIZE) * PGSIZE;
  8004207dea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207dee:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207df4:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207df8:	48 c1 e0 0c          	shl    $0xc,%rax
  8004207dfc:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//cprintf("region_alloc entry PML4 is [%x] va [%x], memsize [%ld]\n", e->env_pml4e[0], va, len);

	//Alloc pages and insert physical pages in page table
	for(; i < len/PGSIZE; i++)
  8004207e00:	eb 79                	jmp    8004207e7b <region_alloc+0xd8>
	{	
		p = page_alloc(ALLOC_ZERO);
  8004207e02:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207e07:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  8004207e0e:	00 00 00 
  8004207e11:	ff d0                	callq  *%rax
  8004207e13:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if(p == NULL)
  8004207e17:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004207e1c:	75 2a                	jne    8004207e48 <region_alloc+0xa5>
		    panic("Page alloc fail\n");
  8004207e1e:	48 ba f3 93 21 04 80 	movabs $0x80042193f3,%rdx
  8004207e25:	00 00 00 
  8004207e28:	be 4b 01 00 00       	mov    $0x14b,%esi
  8004207e2d:	48 bf 04 94 21 04 80 	movabs $0x8004219404,%rdi
  8004207e34:	00 00 00 
  8004207e37:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e3c:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  8004207e43:	00 00 00 
  8004207e46:	ff d1                	callq  *%rcx
		page_insert(e->env_pml4e, p, (void*)temp, PTE_U|PTE_P|PTE_W);
  8004207e48:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207e4c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207e50:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207e57:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004207e5b:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004207e60:	48 89 c7             	mov    %rax,%rdi
  8004207e63:	48 b8 bf 37 20 04 80 	movabs $0x80042037bf,%rax
  8004207e6a:	00 00 00 
  8004207e6d:	ff d0                	callq  *%rax
		temp+=PGSIZE;
  8004207e6f:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004207e76:	00 
	len += lenDown;
	len = ((len + PGSIZE) / PGSIZE) * PGSIZE;
	//cprintf("region_alloc entry PML4 is [%x] va [%x], memsize [%ld]\n", e->env_pml4e[0], va, len);

	//Alloc pages and insert physical pages in page table
	for(; i < len/PGSIZE; i++)
  8004207e77:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004207e7b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004207e7e:	48 98                	cltq   
  8004207e80:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004207e84:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207e88:	48 39 d0             	cmp    %rdx,%rax
  8004207e8b:	0f 82 71 ff ff ff    	jb     8004207e02 <region_alloc+0x5f>
		temp+=PGSIZE;
		//cprintf("region_alloc temp = [%x] , index = [%x], e->env_pml4e is [%x], PML40 is [%x]\n", temp, PML4(temp), e->env_pml4e, e->env_pml4e[0]);
	}
	//cprintf("region_alloc end temp = [%x] , index = [%x], e->env_pml4e is [%x], PML40 is [%x]\n", temp, PML4(temp), e->env_pml4e, e->env_pml4e[0]);

}
  8004207e91:	c9                   	leaveq 
  8004207e92:	c3                   	retq   

0000008004207e93 <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004207e93:	55                   	push   %rbp
  8004207e94:	48 89 e5             	mov    %rsp,%rbp
  8004207e97:	48 83 ec 40          	sub    $0x40,%rsp
  8004207e9b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004207e9f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)

	struct PageInfo *p;
	struct Elf * elfHeader;
	struct Proghdr *ph, *eph;

	if(e == NULL || binary == NULL)
  8004207ea3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004207ea8:	74 07                	je     8004207eb1 <load_icode+0x1e>
  8004207eaa:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004207eaf:	75 2a                	jne    8004207edb <load_icode+0x48>
		panic("load icode Failed due to NULL input");
  8004207eb1:	48 ba 10 94 21 04 80 	movabs $0x8004219410,%rdx
  8004207eb8:	00 00 00 
  8004207ebb:	be 95 01 00 00       	mov    $0x195,%esi
  8004207ec0:	48 bf 04 94 21 04 80 	movabs $0x8004219404,%rdi
  8004207ec7:	00 00 00 
  8004207eca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ecf:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  8004207ed6:	00 00 00 
  8004207ed9:	ff d1                	callq  *%rcx


	elfHeader = (struct Elf *) binary;	
  8004207edb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207edf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// is this a valid ELF?
	if (elfHeader->e_magic != ELF_MAGIC)
  8004207ee3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ee7:	8b 00                	mov    (%rax),%eax
  8004207ee9:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  8004207eee:	74 2a                	je     8004207f1a <load_icode+0x87>
		panic("load icode Failed due to Corrupt ELF");
  8004207ef0:	48 ba 38 94 21 04 80 	movabs $0x8004219438,%rdx
  8004207ef7:	00 00 00 
  8004207efa:	be 9b 01 00 00       	mov    $0x19b,%esi
  8004207eff:	48 bf 04 94 21 04 80 	movabs $0x8004219404,%rdi
  8004207f06:	00 00 00 
  8004207f09:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f0e:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  8004207f15:	00 00 00 
  8004207f18:	ff d1                	callq  *%rcx

  	ph = (struct Proghdr *) (binary + elfHeader->e_phoff);
  8004207f1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207f1e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207f22:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207f26:	48 01 d0             	add    %rdx,%rax
  8004207f29:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	eph = ph + elfHeader->e_phnum;
  8004207f2d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207f31:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  8004207f35:	0f b7 c0             	movzwl %ax,%eax
  8004207f38:	48 c1 e0 03          	shl    $0x3,%rax
  8004207f3c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207f43:	00 
  8004207f44:	48 29 c2             	sub    %rax,%rdx
  8004207f47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f4b:	48 01 d0             	add    %rdx,%rax
  8004207f4e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	lcr3(e->env_cr3);
  8004207f52:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f56:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207f5d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004207f61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207f65:	0f 22 d8             	mov    %rax,%cr3
	for (;ph < eph; ph++){
  8004207f68:	e9 d3 00 00 00       	jmpq   8004208040 <load_icode+0x1ad>
		if(ELF_PROG_LOAD == ph->p_type){
  8004207f6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f71:	8b 00                	mov    (%rax),%eax
  8004207f73:	83 f8 01             	cmp    $0x1,%eax
  8004207f76:	0f 85 bf 00 00 00    	jne    800420803b <load_icode+0x1a8>
			if(ph->p_filesz <= ph->p_memsz){
  8004207f7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f80:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207f84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f88:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004207f8c:	48 39 c2             	cmp    %rax,%rdx
  8004207f8f:	0f 87 a6 00 00 00    	ja     800420803b <load_icode+0x1a8>
				region_alloc(e, (void *)ph->p_va, ph->p_memsz);
  8004207f95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f99:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004207f9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fa1:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207fa5:	48 89 c1             	mov    %rax,%rcx
  8004207fa8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207fac:	48 89 ce             	mov    %rcx,%rsi
  8004207faf:	48 89 c7             	mov    %rax,%rdi
  8004207fb2:	48 b8 a3 7d 20 04 80 	movabs $0x8004207da3,%rax
  8004207fb9:	00 00 00 
  8004207fbc:	ff d0                	callq  *%rax
				size_t a = e->env_pml4e[0];
  8004207fbe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207fc2:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207fc9:	48 8b 00             	mov    (%rax),%rax
  8004207fcc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				//cprintf("load icode Inter  e->env_pml4e is [%x], PML40 is [%x], PML41 is [%x], ph->p_filesz [%ld]\n",  e->env_pml4e, e->env_pml4e[0],e->env_pml4e[1], ph->p_filesz);

				memcpy((void*)ph->p_va, binary + ph->p_offset, ph->p_filesz);
  8004207fd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fd4:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207fd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fdc:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004207fe0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207fe4:	48 01 c1             	add    %rax,%rcx
  8004207fe7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207feb:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207fef:	48 89 ce             	mov    %rcx,%rsi
  8004207ff2:	48 89 c7             	mov    %rax,%rdi
  8004207ff5:	48 b8 2a fb 20 04 80 	movabs $0x800420fb2a,%rax
  8004207ffc:	00 00 00 
  8004207fff:	ff d0                	callq  *%rax
				memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
  8004208001:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208005:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208009:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420800d:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208011:	48 29 c2             	sub    %rax,%rdx
  8004208014:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208018:	48 8b 48 10          	mov    0x10(%rax),%rcx
  800420801c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208020:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208024:	48 01 c8             	add    %rcx,%rax
  8004208027:	be 00 00 00 00       	mov    $0x0,%esi
  800420802c:	48 89 c7             	mov    %rax,%rdi
  800420802f:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004208036:	00 00 00 
  8004208039:	ff d0                	callq  *%rax
		panic("load icode Failed due to Corrupt ELF");

  	ph = (struct Proghdr *) (binary + elfHeader->e_phoff);
	eph = ph + elfHeader->e_phnum;
	lcr3(e->env_cr3);
	for (;ph < eph; ph++){
  800420803b:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  8004208040:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208044:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004208048:	0f 82 1f ff ff ff    	jb     8004207f6d <load_icode+0xda>
		}
	}
	// call the entry point from the ELF header
	// note: does not return!
	
	region_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE);
  800420804e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208052:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208057:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  800420805c:	48 89 c7             	mov    %rax,%rdi
  800420805f:	48 b8 a3 7d 20 04 80 	movabs $0x8004207da3,%rax
  8004208066:	00 00 00 
  8004208069:	ff d0                	callq  *%rax
	e->env_tf.tf_rip = (uintptr_t)(elfHeader->e_entry);
  800420806b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420806f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208073:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208077:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	e->elf = binary;
  800420807e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208082:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004208086:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
}
  800420808d:	c9                   	leaveq 
  800420808e:	c3                   	retq   

000000800420808f <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  800420808f:	55                   	push   %rbp
  8004208090:	48 89 e5             	mov    %rsp,%rbp
  8004208093:	48 83 ec 20          	sub    $0x20,%rsp
  8004208097:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420809b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.

	struct Env *e;
	envid_t parent_id;
	if(env_alloc(&e, 0) != 0)
  800420809e:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  80042080a2:	be 00 00 00 00       	mov    $0x0,%esi
  80042080a7:	48 89 c7             	mov    %rax,%rdi
  80042080aa:	48 b8 fa 7b 20 04 80 	movabs $0x8004207bfa,%rax
  80042080b1:	00 00 00 
  80042080b4:	ff d0                	callq  *%rax
  80042080b6:	85 c0                	test   %eax,%eax
  80042080b8:	74 2a                	je     80042080e4 <env_create+0x55>
	{
		panic("Failed in env_alloc");
  80042080ba:	48 ba 5d 94 21 04 80 	movabs $0x800421945d,%rdx
  80042080c1:	00 00 00 
  80042080c4:	be c8 01 00 00       	mov    $0x1c8,%esi
  80042080c9:	48 bf 04 94 21 04 80 	movabs $0x8004219404,%rdi
  80042080d0:	00 00 00 
  80042080d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042080d8:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  80042080df:	00 00 00 
  80042080e2:	ff d1                	callq  *%rcx
	}
	e->env_type = type;
  80042080e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042080e8:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042080eb:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
	if(type == ENV_TYPE_FS)
  80042080f1:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80042080f5:	75 19                	jne    8004208110 <env_create+0x81>
	{
			e->env_tf.tf_eflags |= FL_IOPL_MASK;
  80042080f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042080fb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042080ff:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  8004208106:	80 ce 30             	or     $0x30,%dh
  8004208109:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	}
	load_icode(e, binary);
  8004208110:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208114:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208118:	48 89 d6             	mov    %rdx,%rsi
  800420811b:	48 89 c7             	mov    %rax,%rdi
  800420811e:	48 b8 93 7e 20 04 80 	movabs $0x8004207e93,%rax
  8004208125:	00 00 00 
  8004208128:	ff d0                	callq  *%rax
}
  800420812a:	c9                   	leaveq 
  800420812b:	c3                   	retq   

000000800420812c <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  800420812c:	55                   	push   %rbp
  800420812d:	48 89 e5             	mov    %rsp,%rbp
  8004208130:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004208137:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)


	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  800420813e:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004208145:	00 00 00 
  8004208148:	ff d0                	callq  *%rax
  800420814a:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  8004208151:	00 00 00 
  8004208154:	48 98                	cltq   
  8004208156:	48 c1 e0 03          	shl    $0x3,%rax
  800420815a:	48 89 c2             	mov    %rax,%rdx
  800420815d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208161:	48 29 c2             	sub    %rax,%rdx
  8004208164:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208168:	48 83 c0 08          	add    $0x8,%rax
  800420816c:	48 8b 00             	mov    (%rax),%rax
  800420816f:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  8004208176:	75 18                	jne    8004208190 <env_free+0x64>
		lcr3(boot_cr3);
  8004208178:	48 b8 70 87 60 04 80 	movabs $0x8004608770,%rax
  800420817f:	00 00 00 
  8004208182:	48 8b 00             	mov    (%rax),%rax
  8004208185:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004208189:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420818d:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004208190:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208197:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420819e:	48 8b 00             	mov    (%rax),%rax
  80042081a1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042081a7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042081ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042081af:	48 c1 e8 0c          	shr    $0xc,%rax
  80042081b3:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042081b6:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042081b9:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  80042081c0:	00 00 00 
  80042081c3:	48 8b 00             	mov    (%rax),%rax
  80042081c6:	48 39 c2             	cmp    %rax,%rdx
  80042081c9:	72 32                	jb     80042081fd <env_free+0xd1>
  80042081cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042081cf:	48 89 c1             	mov    %rax,%rcx
  80042081d2:	48 ba d0 93 21 04 80 	movabs $0x80042193d0,%rdx
  80042081d9:	00 00 00 
  80042081dc:	be e7 01 00 00       	mov    $0x1e7,%esi
  80042081e1:	48 bf 04 94 21 04 80 	movabs $0x8004219404,%rdi
  80042081e8:	00 00 00 
  80042081eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042081f0:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042081f7:	00 00 00 
  80042081fa:	41 ff d0             	callq  *%r8
  80042081fd:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208204:	00 00 00 
  8004208207:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420820b:	48 01 d0             	add    %rdx,%rax
  800420820e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208212:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004208219:	00 
  800420821a:	e9 ab 02 00 00       	jmpq   80042084ca <env_free+0x39e>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  800420821f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208223:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420822a:	00 
  800420822b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420822f:	48 01 d0             	add    %rdx,%rax
  8004208232:	48 8b 00             	mov    (%rax),%rax
  8004208235:	83 e0 01             	and    $0x1,%eax
  8004208238:	48 85 c0             	test   %rax,%rax
  800420823b:	75 05                	jne    8004208242 <env_free+0x116>
			continue;
  800420823d:	e9 83 02 00 00       	jmpq   80042084c5 <env_free+0x399>
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004208242:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208246:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420824d:	00 
  800420824e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208252:	48 01 d0             	add    %rdx,%rax
  8004208255:	48 8b 00             	mov    (%rax),%rax
  8004208258:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420825e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004208262:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208266:	48 c1 e8 0c          	shr    $0xc,%rax
  800420826a:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  800420826d:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208270:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004208277:	00 00 00 
  800420827a:	48 8b 00             	mov    (%rax),%rax
  800420827d:	48 39 c2             	cmp    %rax,%rdx
  8004208280:	72 32                	jb     80042082b4 <env_free+0x188>
  8004208282:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208286:	48 89 c1             	mov    %rax,%rcx
  8004208289:	48 ba d0 93 21 04 80 	movabs $0x80042193d0,%rdx
  8004208290:	00 00 00 
  8004208293:	be ef 01 00 00       	mov    $0x1ef,%esi
  8004208298:	48 bf 04 94 21 04 80 	movabs $0x8004219404,%rdi
  800420829f:	00 00 00 
  80042082a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042082a7:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042082ae:	00 00 00 
  80042082b1:	41 ff d0             	callq  *%r8
  80042082b4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042082bb:	00 00 00 
  80042082be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042082c2:	48 01 d0             	add    %rdx,%rax
  80042082c5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  80042082c9:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  80042082ce:	75 07                	jne    80042082d7 <env_free+0x1ab>
  80042082d0:	b8 04 00 00 00       	mov    $0x4,%eax
  80042082d5:	eb 05                	jmp    80042082dc <env_free+0x1b0>
  80042082d7:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  80042082dc:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  80042082df:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042082e6:	00 
  80042082e7:	e9 6e 01 00 00       	jmpq   800420845a <env_free+0x32e>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  80042082ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042082f0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042082f7:	00 
  80042082f8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042082fc:	48 01 d0             	add    %rdx,%rax
  80042082ff:	48 8b 00             	mov    (%rax),%rax
  8004208302:	83 e0 01             	and    $0x1,%eax
  8004208305:	48 85 c0             	test   %rax,%rax
  8004208308:	75 05                	jne    800420830f <env_free+0x1e3>
				continue;
  800420830a:	e9 46 01 00 00       	jmpq   8004208455 <env_free+0x329>
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  800420830f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208313:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420831a:	00 
  800420831b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420831f:	48 01 d0             	add    %rdx,%rax
  8004208322:	48 8b 00             	mov    (%rax),%rax
  8004208325:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420832b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pt = (pte_t*) KADDR(pa);
  800420832f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208333:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004208337:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420833b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420833f:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004208342:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208345:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  800420834c:	00 00 00 
  800420834f:	48 8b 00             	mov    (%rax),%rax
  8004208352:	48 39 c2             	cmp    %rax,%rdx
  8004208355:	72 32                	jb     8004208389 <env_free+0x25d>
  8004208357:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420835b:	48 89 c1             	mov    %rax,%rcx
  800420835e:	48 ba d0 93 21 04 80 	movabs $0x80042193d0,%rdx
  8004208365:	00 00 00 
  8004208368:	be f9 01 00 00       	mov    $0x1f9,%esi
  800420836d:	48 bf 04 94 21 04 80 	movabs $0x8004219404,%rdi
  8004208374:	00 00 00 
  8004208377:	b8 00 00 00 00       	mov    $0x0,%eax
  800420837c:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004208383:	00 00 00 
  8004208386:	41 ff d0             	callq  *%r8
  8004208389:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208390:	00 00 00 
  8004208393:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208397:	48 01 d0             	add    %rdx,%rax
  800420839a:	48 89 45 90          	mov    %rax,-0x70(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  800420839e:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042083a5:	00 
  80042083a6:	eb 67                	jmp    800420840f <env_free+0x2e3>
				if (pt[pteno] & PTE_P){
  80042083a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083ac:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042083b3:	00 
  80042083b4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042083b8:	48 01 d0             	add    %rdx,%rax
  80042083bb:	48 8b 00             	mov    (%rax),%rax
  80042083be:	83 e0 01             	and    $0x1,%eax
  80042083c1:	48 85 c0             	test   %rax,%rax
  80042083c4:	74 44                	je     800420840a <env_free+0x2de>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  80042083c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042083ca:	48 c1 e0 1e          	shl    $0x1e,%rax
  80042083ce:	48 89 c2             	mov    %rax,%rdx
  80042083d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042083d5:	48 c1 e0 15          	shl    $0x15,%rax
  80042083d9:	48 09 c2             	or     %rax,%rdx
  80042083dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083e0:	48 c1 e0 0c          	shl    $0xc,%rax
  80042083e4:	48 09 d0             	or     %rdx,%rax
  80042083e7:	48 89 c2             	mov    %rax,%rdx
  80042083ea:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042083f1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042083f8:	48 89 d6             	mov    %rdx,%rsi
  80042083fb:	48 89 c7             	mov    %rax,%rdi
  80042083fe:	48 b8 b6 39 20 04 80 	movabs $0x80042039b6,%rax
  8004208405:	00 00 00 
  8004208408:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  800420840a:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  800420840f:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  8004208416:	00 
  8004208417:	76 8f                	jbe    80042083a8 <env_free+0x27c>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  8004208419:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420841d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208424:	00 
  8004208425:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208429:	48 01 d0             	add    %rdx,%rax
  800420842c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  8004208433:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208437:	48 89 c7             	mov    %rax,%rdi
  800420843a:	48 b8 47 77 20 04 80 	movabs $0x8004207747,%rax
  8004208441:	00 00 00 
  8004208444:	ff d0                	callq  *%rax
  8004208446:	48 89 c7             	mov    %rax,%rdi
  8004208449:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  8004208450:	00 00 00 
  8004208453:	ff d0                	callq  *%rax
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208455:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420845a:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420845d:	48 98                	cltq   
  800420845f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208463:	0f 87 83 fe ff ff    	ja     80042082ec <env_free+0x1c0>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  8004208469:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420846d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208474:	00 
  8004208475:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208479:	48 01 d0             	add    %rdx,%rax
  800420847c:	48 8b 00             	mov    (%rax),%rax
  800420847f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208485:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		env_pdpe[pdpe_index] = 0;
  8004208489:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420848d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208494:	00 
  8004208495:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208499:	48 01 d0             	add    %rdx,%rax
  800420849c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  80042084a3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042084a7:	48 89 c7             	mov    %rax,%rdi
  80042084aa:	48 b8 47 77 20 04 80 	movabs $0x8004207747,%rax
  80042084b1:	00 00 00 
  80042084b4:	ff d0                	callq  *%rax
  80042084b6:	48 89 c7             	mov    %rax,%rdi
  80042084b9:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  80042084c0:	00 00 00 
  80042084c3:	ff d0                	callq  *%rax
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  80042084c5:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042084ca:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  80042084cf:	0f 86 4a fd ff ff    	jbe    800420821f <env_free+0xf3>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  80042084d5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042084dc:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042084e3:	48 8b 00             	mov    (%rax),%rax
  80042084e6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042084ec:	48 89 c7             	mov    %rax,%rdi
  80042084ef:	48 b8 47 77 20 04 80 	movabs $0x8004207747,%rax
  80042084f6:	00 00 00 
  80042084f9:	ff d0                	callq  *%rax
  80042084fb:	48 89 c7             	mov    %rax,%rdi
  80042084fe:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  8004208505:	00 00 00 
  8004208508:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  800420850a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208511:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208518:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  800420851f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208526:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800420852d:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  8004208531:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208538:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  800420853f:	00 00 00 00 
	e->env_cr3 = 0;
  8004208543:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420854a:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004208551:	00 00 00 00 
	page_decref(pa2page(pa));
  8004208555:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208559:	48 89 c7             	mov    %rax,%rdi
  800420855c:	48 b8 47 77 20 04 80 	movabs $0x8004207747,%rax
  8004208563:	00 00 00 
  8004208566:	ff d0                	callq  *%rax
  8004208568:	48 89 c7             	mov    %rax,%rdi
  800420856b:	48 b8 e7 30 20 04 80 	movabs $0x80042030e7,%rax
  8004208572:	00 00 00 
  8004208575:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004208577:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420857e:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004208585:	00 00 00 
	e->env_link = env_free_list;
  8004208588:	48 b8 58 72 60 04 80 	movabs $0x8004607258,%rax
  800420858f:	00 00 00 
  8004208592:	48 8b 10             	mov    (%rax),%rdx
  8004208595:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420859c:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  80042085a3:	48 b8 58 72 60 04 80 	movabs $0x8004607258,%rax
  80042085aa:	00 00 00 
  80042085ad:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042085b4:	48 89 10             	mov    %rdx,(%rax)
}
  80042085b7:	c9                   	leaveq 
  80042085b8:	c3                   	retq   

00000080042085b9 <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  80042085b9:	55                   	push   %rbp
  80042085ba:	48 89 e5             	mov    %rsp,%rbp
  80042085bd:	48 83 ec 10          	sub    $0x10,%rsp
  80042085c1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  80042085c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042085c9:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042085cf:	83 f8 03             	cmp    $0x3,%eax
  80042085d2:	75 4a                	jne    800420861e <env_destroy+0x65>
  80042085d4:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  80042085db:	00 00 00 
  80042085de:	ff d0                	callq  *%rax
  80042085e0:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  80042085e7:	00 00 00 
  80042085ea:	48 98                	cltq   
  80042085ec:	48 c1 e0 03          	shl    $0x3,%rax
  80042085f0:	48 89 c2             	mov    %rax,%rdx
  80042085f3:	48 c1 e2 04          	shl    $0x4,%rdx
  80042085f7:	48 29 c2             	sub    %rax,%rdx
  80042085fa:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042085fe:	48 83 c0 08          	add    $0x8,%rax
  8004208602:	48 8b 00             	mov    (%rax),%rax
  8004208605:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208609:	74 13                	je     800420861e <env_destroy+0x65>
		e->env_status = ENV_DYING;
  800420860b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420860f:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  8004208616:	00 00 00 
		return;
  8004208619:	e9 8b 00 00 00       	jmpq   80042086a9 <env_destroy+0xf0>
	}

	env_free(e);
  800420861e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208622:	48 89 c7             	mov    %rax,%rdi
  8004208625:	48 b8 2c 81 20 04 80 	movabs $0x800420812c,%rax
  800420862c:	00 00 00 
  800420862f:	ff d0                	callq  *%rax
	if (curenv == e) {
  8004208631:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004208638:	00 00 00 
  800420863b:	ff d0                	callq  *%rax
  800420863d:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  8004208644:	00 00 00 
  8004208647:	48 98                	cltq   
  8004208649:	48 c1 e0 03          	shl    $0x3,%rax
  800420864d:	48 89 c2             	mov    %rax,%rdx
  8004208650:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208654:	48 29 c2             	sub    %rax,%rdx
  8004208657:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420865b:	48 83 c0 08          	add    $0x8,%rax
  800420865f:	48 8b 00             	mov    (%rax),%rax
  8004208662:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208666:	75 41                	jne    80042086a9 <env_destroy+0xf0>
		curenv = NULL;
  8004208668:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420866f:	00 00 00 
  8004208672:	ff d0                	callq  *%rax
  8004208674:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420867b:	00 00 00 
  800420867e:	48 98                	cltq   
  8004208680:	48 c1 e0 03          	shl    $0x3,%rax
  8004208684:	48 89 c2             	mov    %rax,%rdx
  8004208687:	48 c1 e2 04          	shl    $0x4,%rdx
  800420868b:	48 29 c2             	sub    %rax,%rdx
  800420868e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208692:	48 83 c0 08          	add    $0x8,%rax
  8004208696:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  800420869d:	48 b8 c9 ce 20 04 80 	movabs $0x800420cec9,%rax
  80042086a4:	00 00 00 
  80042086a7:	ff d0                	callq  *%rax
	}
}
  80042086a9:	c9                   	leaveq 
  80042086aa:	c3                   	retq   

00000080042086ab <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  80042086ab:	55                   	push   %rbp
  80042086ac:	48 89 e5             	mov    %rsp,%rbp
  80042086af:	53                   	push   %rbx
  80042086b0:	48 83 ec 18          	sub    $0x18,%rsp
  80042086b4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  80042086b8:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  80042086bf:	00 00 00 
  80042086c2:	ff d0                	callq  *%rax
  80042086c4:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  80042086cb:	00 00 00 
  80042086ce:	48 98                	cltq   
  80042086d0:	48 c1 e0 03          	shl    $0x3,%rax
  80042086d4:	48 89 c2             	mov    %rax,%rdx
  80042086d7:	48 c1 e2 04          	shl    $0x4,%rdx
  80042086db:	48 29 c2             	sub    %rax,%rdx
  80042086de:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042086e2:	48 83 c0 08          	add    $0x8,%rax
  80042086e6:	48 8b 18             	mov    (%rax),%rbx
  80042086e9:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  80042086f0:	00 00 00 
  80042086f3:	ff d0                	callq  *%rax
  80042086f5:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)

	//cprintf("tf->rsp [%x]\n", tf->tf_rsp);
	__asm __volatile("movq %0,%%rsp\n"
  80042086fb:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  80042086ff:	4c 8b 3c 24          	mov    (%rsp),%r15
  8004208703:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  8004208708:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800420870d:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  8004208712:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  8004208717:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800420871c:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  8004208721:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  8004208726:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420872b:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  8004208730:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004208735:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420873a:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420873f:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  8004208744:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  8004208749:	48 83 c4 78          	add    $0x78,%rsp
  800420874d:	8e 04 24             	mov    (%rsp),%es
  8004208750:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  8004208754:	48 83 c4 10          	add    $0x10,%rsp
  8004208758:	48 83 c4 10          	add    $0x10,%rsp
  800420875c:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  800420875e:	48 ba 71 94 21 04 80 	movabs $0x8004219471,%rdx
  8004208765:	00 00 00 
  8004208768:	be 47 02 00 00       	mov    $0x247,%esi
  800420876d:	48 bf 04 94 21 04 80 	movabs $0x8004219404,%rdi
  8004208774:	00 00 00 
  8004208777:	b8 00 00 00 00       	mov    $0x0,%eax
  800420877c:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  8004208783:	00 00 00 
  8004208786:	ff d1                	callq  *%rcx

0000008004208788 <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  8004208788:	55                   	push   %rbp
  8004208789:	48 89 e5             	mov    %rsp,%rbp
  800420878c:	48 83 ec 20          	sub    $0x20,%rsp
  8004208790:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//	and make sure you have set the relevant parts of
	//	e->env_tf to sensible values.

	// LAB 3: Your code here.
	//cprintf("ENV_RUN being called from here: e->env_id [%d]",e->env_id); 
	if(curenv == e){
  8004208794:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420879b:	00 00 00 
  800420879e:	ff d0                	callq  *%rax
  80042087a0:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  80042087a7:	00 00 00 
  80042087aa:	48 98                	cltq   
  80042087ac:	48 c1 e0 03          	shl    $0x3,%rax
  80042087b0:	48 89 c2             	mov    %rax,%rdx
  80042087b3:	48 c1 e2 04          	shl    $0x4,%rdx
  80042087b7:	48 29 c2             	sub    %rax,%rdx
  80042087ba:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042087be:	48 83 c0 08          	add    $0x8,%rax
  80042087c2:	48 8b 00             	mov    (%rax),%rax
  80042087c5:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042087c9:	0f 85 8c 00 00 00    	jne    800420885b <env_run+0xd3>
		curenv->env_runs += 1;
  80042087cf:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  80042087d6:	00 00 00 
  80042087d9:	ff d0                	callq  *%rax
  80042087db:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  80042087e2:	00 00 00 
  80042087e5:	48 98                	cltq   
  80042087e7:	48 c1 e0 03          	shl    $0x3,%rax
  80042087eb:	48 89 c2             	mov    %rax,%rdx
  80042087ee:	48 c1 e2 04          	shl    $0x4,%rdx
  80042087f2:	48 29 c2             	sub    %rax,%rdx
  80042087f5:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042087f9:	48 83 c0 08          	add    $0x8,%rax
  80042087fd:	48 8b 00             	mov    (%rax),%rax
  8004208800:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  8004208806:	83 c2 01             	add    $0x1,%edx
  8004208809:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
		unlock_kernel();
  800420880f:	48 b8 40 78 20 04 80 	movabs $0x8004207840,%rax
  8004208816:	00 00 00 
  8004208819:	ff d0                	callq  *%rax
		env_pop_tf(&curenv->env_tf);
  800420881b:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004208822:	00 00 00 
  8004208825:	ff d0                	callq  *%rax
  8004208827:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420882e:	00 00 00 
  8004208831:	48 98                	cltq   
  8004208833:	48 c1 e0 03          	shl    $0x3,%rax
  8004208837:	48 89 c2             	mov    %rax,%rdx
  800420883a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420883e:	48 29 c2             	sub    %rax,%rdx
  8004208841:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208845:	48 83 c0 08          	add    $0x8,%rax
  8004208849:	48 8b 00             	mov    (%rax),%rax
  800420884c:	48 89 c7             	mov    %rax,%rdi
  800420884f:	48 b8 ab 86 20 04 80 	movabs $0x80042086ab,%rax
  8004208856:	00 00 00 
  8004208859:	ff d0                	callq  *%rax
	}
	if(curenv) //If this is a context switch
  800420885b:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004208862:	00 00 00 
  8004208865:	ff d0                	callq  *%rax
  8004208867:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420886e:	00 00 00 
  8004208871:	48 98                	cltq   
  8004208873:	48 c1 e0 03          	shl    $0x3,%rax
  8004208877:	48 89 c2             	mov    %rax,%rdx
  800420887a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420887e:	48 29 c2             	sub    %rax,%rdx
  8004208881:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208885:	48 83 c0 08          	add    $0x8,%rax
  8004208889:	48 8b 00             	mov    (%rax),%rax
  800420888c:	48 85 c0             	test   %rax,%rax
  800420888f:	74 77                	je     8004208908 <env_run+0x180>
	{
		if(curenv->env_status == ENV_RUNNING)
  8004208891:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004208898:	00 00 00 
  800420889b:	ff d0                	callq  *%rax
  800420889d:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  80042088a4:	00 00 00 
  80042088a7:	48 98                	cltq   
  80042088a9:	48 c1 e0 03          	shl    $0x3,%rax
  80042088ad:	48 89 c2             	mov    %rax,%rdx
  80042088b0:	48 c1 e2 04          	shl    $0x4,%rdx
  80042088b4:	48 29 c2             	sub    %rax,%rdx
  80042088b7:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042088bb:	48 83 c0 08          	add    $0x8,%rax
  80042088bf:	48 8b 00             	mov    (%rax),%rax
  80042088c2:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042088c8:	83 f8 03             	cmp    $0x3,%eax
  80042088cb:	75 3b                	jne    8004208908 <env_run+0x180>
		{
			curenv->env_status = ENV_RUNNABLE;	
  80042088cd:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  80042088d4:	00 00 00 
  80042088d7:	ff d0                	callq  *%rax
  80042088d9:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  80042088e0:	00 00 00 
  80042088e3:	48 98                	cltq   
  80042088e5:	48 c1 e0 03          	shl    $0x3,%rax
  80042088e9:	48 89 c2             	mov    %rax,%rdx
  80042088ec:	48 c1 e2 04          	shl    $0x4,%rdx
  80042088f0:	48 29 c2             	sub    %rax,%rdx
  80042088f3:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042088f7:	48 83 c0 08          	add    $0x8,%rax
  80042088fb:	48 8b 00             	mov    (%rax),%rax
  80042088fe:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004208905:	00 00 00 
		}
	}
	//make new enviornment as current enviornment
	
	curenv = e;
  8004208908:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420890f:	00 00 00 
  8004208912:	ff d0                	callq  *%rax
  8004208914:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420891b:	00 00 00 
  800420891e:	48 98                	cltq   
  8004208920:	48 c1 e0 03          	shl    $0x3,%rax
  8004208924:	48 89 c2             	mov    %rax,%rdx
  8004208927:	48 c1 e2 04          	shl    $0x4,%rdx
  800420892b:	48 29 c2             	sub    %rax,%rdx
  800420892e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208932:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004208936:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420893a:	48 89 02             	mov    %rax,(%rdx)
	curenv->env_status = ENV_RUNNING;
  800420893d:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004208944:	00 00 00 
  8004208947:	ff d0                	callq  *%rax
  8004208949:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  8004208950:	00 00 00 
  8004208953:	48 98                	cltq   
  8004208955:	48 c1 e0 03          	shl    $0x3,%rax
  8004208959:	48 89 c2             	mov    %rax,%rdx
  800420895c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208960:	48 29 c2             	sub    %rax,%rdx
  8004208963:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208967:	48 83 c0 08          	add    $0x8,%rax
  800420896b:	48 8b 00             	mov    (%rax),%rax
  800420896e:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  8004208975:	00 00 00 
	curenv->env_runs += 1;
  8004208978:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420897f:	00 00 00 
  8004208982:	ff d0                	callq  *%rax
  8004208984:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420898b:	00 00 00 
  800420898e:	48 98                	cltq   
  8004208990:	48 c1 e0 03          	shl    $0x3,%rax
  8004208994:	48 89 c2             	mov    %rax,%rdx
  8004208997:	48 c1 e2 04          	shl    $0x4,%rdx
  800420899b:	48 29 c2             	sub    %rax,%rdx
  800420899e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042089a2:	48 83 c0 08          	add    $0x8,%rax
  80042089a6:	48 8b 00             	mov    (%rax),%rax
  80042089a9:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  80042089af:	83 c2 01             	add    $0x1,%edx
  80042089b2:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
	unlock_kernel();
  80042089b8:	48 b8 40 78 20 04 80 	movabs $0x8004207840,%rax
  80042089bf:	00 00 00 
  80042089c2:	ff d0                	callq  *%rax
	lcr3(curenv->env_cr3);
  80042089c4:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  80042089cb:	00 00 00 
  80042089ce:	ff d0                	callq  *%rax
  80042089d0:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  80042089d7:	00 00 00 
  80042089da:	48 98                	cltq   
  80042089dc:	48 c1 e0 03          	shl    $0x3,%rax
  80042089e0:	48 89 c2             	mov    %rax,%rdx
  80042089e3:	48 c1 e2 04          	shl    $0x4,%rdx
  80042089e7:	48 29 c2             	sub    %rax,%rdx
  80042089ea:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  80042089ee:	48 83 c0 08          	add    $0x8,%rax
  80042089f2:	48 8b 00             	mov    (%rax),%rax
  80042089f5:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042089fc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208a00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208a04:	0f 22 d8             	mov    %rax,%cr3
	//restore the environment's registers
	//if(curenv->env_runs > 0)
	{
		env_pop_tf(&curenv->env_tf);
  8004208a07:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004208a0e:	00 00 00 
  8004208a11:	ff d0                	callq  *%rax
  8004208a13:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  8004208a1a:	00 00 00 
  8004208a1d:	48 98                	cltq   
  8004208a1f:	48 c1 e0 03          	shl    $0x3,%rax
  8004208a23:	48 89 c2             	mov    %rax,%rdx
  8004208a26:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208a2a:	48 29 c2             	sub    %rax,%rdx
  8004208a2d:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  8004208a31:	48 83 c0 08          	add    $0x8,%rax
  8004208a35:	48 8b 00             	mov    (%rax),%rax
  8004208a38:	48 89 c7             	mov    %rax,%rdi
  8004208a3b:	48 b8 ab 86 20 04 80 	movabs $0x80042086ab,%rax
  8004208a42:	00 00 00 
  8004208a45:	ff d0                	callq  *%rax

0000008004208a47 <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004208a47:	55                   	push   %rbp
  8004208a48:	48 89 e5             	mov    %rsp,%rbp
  8004208a4b:	48 83 ec 14          	sub    $0x14,%rsp
  8004208a4f:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  8004208a52:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208a55:	0f b6 c0             	movzbl %al,%eax
  8004208a58:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208a5f:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208a62:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208a66:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208a69:	ee                   	out    %al,(%dx)
  8004208a6a:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004208a71:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004208a74:	89 c2                	mov    %eax,%edx
  8004208a76:	ec                   	in     (%dx),%al
  8004208a77:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004208a7a:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  8004208a7e:	0f b6 c0             	movzbl %al,%eax
}
  8004208a81:	c9                   	leaveq 
  8004208a82:	c3                   	retq   

0000008004208a83 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  8004208a83:	55                   	push   %rbp
  8004208a84:	48 89 e5             	mov    %rsp,%rbp
  8004208a87:	48 83 ec 18          	sub    $0x18,%rsp
  8004208a8b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004208a8e:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  8004208a91:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208a94:	0f b6 c0             	movzbl %al,%eax
  8004208a97:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208a9e:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208aa1:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208aa5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208aa8:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004208aa9:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004208aac:	0f b6 c0             	movzbl %al,%eax
  8004208aaf:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  8004208ab6:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004208ab9:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208abd:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208ac0:	ee                   	out    %al,(%dx)
}
  8004208ac1:	c9                   	leaveq 
  8004208ac2:	c3                   	retq   

0000008004208ac3 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  8004208ac3:	55                   	push   %rbp
  8004208ac4:	48 89 e5             	mov    %rsp,%rbp
  8004208ac7:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  8004208acb:	48 b8 60 72 60 04 80 	movabs $0x8004607260,%rax
  8004208ad2:	00 00 00 
  8004208ad5:	c6 00 01             	movb   $0x1,(%rax)
  8004208ad8:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004208adf:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  8004208ae3:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208ae7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208aea:	ee                   	out    %al,(%dx)
  8004208aeb:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004208af2:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  8004208af6:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208afa:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208afd:	ee                   	out    %al,(%dx)
  8004208afe:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  8004208b05:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  8004208b09:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004208b0d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004208b10:	ee                   	out    %al,(%dx)
  8004208b11:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  8004208b18:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  8004208b1c:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004208b20:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004208b23:	ee                   	out    %al,(%dx)
  8004208b24:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  8004208b2b:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  8004208b2f:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004208b33:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004208b36:	ee                   	out    %al,(%dx)
  8004208b37:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  8004208b3e:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  8004208b42:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004208b46:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208b49:	ee                   	out    %al,(%dx)
  8004208b4a:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  8004208b51:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  8004208b55:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004208b59:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004208b5c:	ee                   	out    %al,(%dx)
  8004208b5d:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  8004208b64:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  8004208b68:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004208b6c:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208b6f:	ee                   	out    %al,(%dx)
  8004208b70:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  8004208b77:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  8004208b7b:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004208b7f:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004208b82:	ee                   	out    %al,(%dx)
  8004208b83:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  8004208b8a:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  8004208b8e:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  8004208b92:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004208b95:	ee                   	out    %al,(%dx)
  8004208b96:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  8004208b9d:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  8004208ba1:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  8004208ba5:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004208ba8:	ee                   	out    %al,(%dx)
  8004208ba9:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  8004208bb0:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  8004208bb4:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  8004208bb8:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004208bbb:	ee                   	out    %al,(%dx)
  8004208bbc:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  8004208bc3:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  8004208bc7:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  8004208bcb:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208bce:	ee                   	out    %al,(%dx)
  8004208bcf:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  8004208bd6:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004208bda:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  8004208bde:	8b 55 94             	mov    -0x6c(%rbp),%edx
  8004208be1:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004208be2:	48 b8 92 d6 22 04 80 	movabs $0x800422d692,%rax
  8004208be9:	00 00 00 
  8004208bec:	0f b7 00             	movzwl (%rax),%eax
  8004208bef:	66 83 f8 ff          	cmp    $0xffff,%ax
  8004208bf3:	74 1e                	je     8004208c13 <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  8004208bf5:	48 b8 92 d6 22 04 80 	movabs $0x800422d692,%rax
  8004208bfc:	00 00 00 
  8004208bff:	0f b7 00             	movzwl (%rax),%eax
  8004208c02:	0f b7 c0             	movzwl %ax,%eax
  8004208c05:	89 c7                	mov    %eax,%edi
  8004208c07:	48 b8 15 8c 20 04 80 	movabs $0x8004208c15,%rax
  8004208c0e:	00 00 00 
  8004208c11:	ff d0                	callq  *%rax
}
  8004208c13:	c9                   	leaveq 
  8004208c14:	c3                   	retq   

0000008004208c15 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  8004208c15:	55                   	push   %rbp
  8004208c16:	48 89 e5             	mov    %rsp,%rbp
  8004208c19:	48 83 ec 30          	sub    $0x30,%rsp
  8004208c1d:	89 f8                	mov    %edi,%eax
  8004208c1f:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  8004208c23:	48 b8 92 d6 22 04 80 	movabs $0x800422d692,%rax
  8004208c2a:	00 00 00 
  8004208c2d:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8004208c31:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  8004208c34:	48 b8 60 72 60 04 80 	movabs $0x8004607260,%rax
  8004208c3b:	00 00 00 
  8004208c3e:	0f b6 00             	movzbl (%rax),%eax
  8004208c41:	83 f0 01             	xor    $0x1,%eax
  8004208c44:	84 c0                	test   %al,%al
  8004208c46:	74 05                	je     8004208c4d <irq_setmask_8259A+0x38>
		return;
  8004208c48:	e9 b7 00 00 00       	jmpq   8004208d04 <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  8004208c4d:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208c51:	0f b6 c0             	movzbl %al,%eax
  8004208c54:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  8004208c5b:	88 45 f7             	mov    %al,-0x9(%rbp)
  8004208c5e:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004208c62:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004208c65:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  8004208c66:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208c6a:	66 c1 e8 08          	shr    $0x8,%ax
  8004208c6e:	0f b6 c0             	movzbl %al,%eax
  8004208c71:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  8004208c78:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004208c7b:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004208c7f:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004208c82:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  8004208c83:	48 bf 7d 94 21 04 80 	movabs $0x800421947d,%rdi
  8004208c8a:	00 00 00 
  8004208c8d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208c92:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004208c99:	00 00 00 
  8004208c9c:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  8004208c9e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004208ca5:	eb 3c                	jmp    8004208ce3 <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  8004208ca7:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208cab:	f7 d0                	not    %eax
  8004208cad:	89 c2                	mov    %eax,%edx
  8004208caf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208cb2:	89 c1                	mov    %eax,%ecx
  8004208cb4:	d3 fa                	sar    %cl,%edx
  8004208cb6:	89 d0                	mov    %edx,%eax
  8004208cb8:	83 e0 01             	and    $0x1,%eax
  8004208cbb:	85 c0                	test   %eax,%eax
  8004208cbd:	74 20                	je     8004208cdf <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  8004208cbf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208cc2:	89 c6                	mov    %eax,%esi
  8004208cc4:	48 bf 91 94 21 04 80 	movabs $0x8004219491,%rdi
  8004208ccb:	00 00 00 
  8004208cce:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208cd3:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004208cda:	00 00 00 
  8004208cdd:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  8004208cdf:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004208ce3:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004208ce7:	7e be                	jle    8004208ca7 <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004208ce9:	48 bf 95 94 21 04 80 	movabs $0x8004219495,%rdi
  8004208cf0:	00 00 00 
  8004208cf3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208cf8:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004208cff:	00 00 00 
  8004208d02:	ff d2                	callq  *%rdx
}
  8004208d04:	c9                   	leaveq 
  8004208d05:	c3                   	retq   

0000008004208d06 <irq_eoi>:

void
irq_eoi(void)
{
  8004208d06:	55                   	push   %rbp
  8004208d07:	48 89 e5             	mov    %rsp,%rbp
  8004208d0a:	48 83 ec 10          	sub    $0x10,%rsp
  8004208d0e:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%rbp)
  8004208d15:	c6 45 fb 20          	movb   $0x20,-0x5(%rbp)
  8004208d19:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208d1d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208d20:	ee                   	out    %al,(%dx)
  8004208d21:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%rbp)
  8004208d28:	c6 45 f3 20          	movb   $0x20,-0xd(%rbp)
  8004208d2c:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208d30:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208d33:	ee                   	out    %al,(%dx)
	//   s: specific
	//   e: end-of-interrupt
	// xxx: specific interrupt line
	outb(IO_PIC1, 0x20);
	outb(IO_PIC2, 0x20);
}
  8004208d34:	c9                   	leaveq 
  8004208d35:	c3                   	retq   

0000008004208d36 <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004208d36:	55                   	push   %rbp
  8004208d37:	48 89 e5             	mov    %rsp,%rbp
  8004208d3a:	48 83 ec 10          	sub    $0x10,%rsp
  8004208d3e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004208d41:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004208d45:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208d48:	89 c7                	mov    %eax,%edi
  8004208d4a:	48 b8 4d 12 20 04 80 	movabs $0x800420124d,%rax
  8004208d51:	00 00 00 
  8004208d54:	ff d0                	callq  *%rax
	*cnt++;
  8004208d56:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208d5a:	48 83 c0 04          	add    $0x4,%rax
  8004208d5e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  8004208d62:	c9                   	leaveq 
  8004208d63:	c3                   	retq   

0000008004208d64 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004208d64:	55                   	push   %rbp
  8004208d65:	48 89 e5             	mov    %rsp,%rbp
  8004208d68:	48 83 ec 30          	sub    $0x30,%rsp
  8004208d6c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208d70:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  8004208d74:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004208d7b:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004208d7f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208d83:	48 8b 0a             	mov    (%rdx),%rcx
  8004208d86:	48 89 08             	mov    %rcx,(%rax)
  8004208d89:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208d8d:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208d91:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208d95:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004208d99:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004208d9d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004208da1:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004208da5:	48 89 c6             	mov    %rax,%rsi
  8004208da8:	48 bf 36 8d 20 04 80 	movabs $0x8004208d36,%rdi
  8004208daf:	00 00 00 
  8004208db2:	48 b8 98 ed 20 04 80 	movabs $0x800420ed98,%rax
  8004208db9:	00 00 00 
  8004208dbc:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  8004208dbe:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8004208dc1:	c9                   	leaveq 
  8004208dc2:	c3                   	retq   

0000008004208dc3 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8004208dc3:	55                   	push   %rbp
  8004208dc4:	48 89 e5             	mov    %rsp,%rbp
  8004208dc7:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004208dce:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004208dd5:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004208ddc:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004208de3:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004208dea:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004208df1:	84 c0                	test   %al,%al
  8004208df3:	74 20                	je     8004208e15 <cprintf+0x52>
  8004208df5:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004208df9:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004208dfd:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004208e01:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004208e05:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004208e09:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004208e0d:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004208e11:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004208e15:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004208e1c:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8004208e23:	00 00 00 
  8004208e26:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004208e2d:	00 00 00 
  8004208e30:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004208e34:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004208e3b:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004208e42:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004208e49:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004208e50:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004208e57:	48 8b 0a             	mov    (%rdx),%rcx
  8004208e5a:	48 89 08             	mov    %rcx,(%rax)
  8004208e5d:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208e61:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208e65:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208e69:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004208e6d:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004208e74:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004208e7b:	48 89 d6             	mov    %rdx,%rsi
  8004208e7e:	48 89 c7             	mov    %rax,%rdi
  8004208e81:	48 b8 64 8d 20 04 80 	movabs $0x8004208d64,%rax
  8004208e88:	00 00 00 
  8004208e8b:	ff d0                	callq  *%rax
  8004208e8d:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  8004208e93:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004208e99:	c9                   	leaveq 
  8004208e9a:	c3                   	retq   

0000008004208e9b <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004208e9b:	55                   	push   %rbp
  8004208e9c:	48 89 e5             	mov    %rsp,%rbp
  8004208e9f:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004208ea3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004208ea7:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004208eaa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208eae:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004208eb1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004208eb5:	f0 87 02             	lock xchg %eax,(%rdx)
  8004208eb8:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004208ebb:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004208ebe:	c9                   	leaveq 
  8004208ebf:	c3                   	retq   

0000008004208ec0 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  8004208ec0:	55                   	push   %rbp
  8004208ec1:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004208ec4:	48 bf 80 d7 22 04 80 	movabs $0x800422d780,%rdi
  8004208ecb:	00 00 00 
  8004208ece:	48 b8 b4 6c 21 04 80 	movabs $0x8004216cb4,%rax
  8004208ed5:	00 00 00 
  8004208ed8:	ff d0                	callq  *%rax
}
  8004208eda:	5d                   	pop    %rbp
  8004208edb:	c3                   	retq   

0000008004208edc <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004208edc:	55                   	push   %rbp
  8004208edd:	48 89 e5             	mov    %rsp,%rbp
  8004208ee0:	48 83 ec 04          	sub    $0x4,%rsp
  8004208ee4:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  8004208ee7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208eea:	83 f8 13             	cmp    $0x13,%eax
  8004208eed:	77 16                	ja     8004208f05 <trapname+0x29>
		return excnames[trapno];
  8004208eef:	48 b8 e0 98 21 04 80 	movabs $0x80042198e0,%rax
  8004208ef6:	00 00 00 
  8004208ef9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208efc:	48 63 d2             	movslq %edx,%rdx
  8004208eff:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004208f03:	eb 34                	jmp    8004208f39 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  8004208f05:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004208f09:	75 0c                	jne    8004208f17 <trapname+0x3b>
		return "System call";
  8004208f0b:	48 b8 a0 94 21 04 80 	movabs $0x80042194a0,%rax
  8004208f12:	00 00 00 
  8004208f15:	eb 22                	jmp    8004208f39 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  8004208f17:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8004208f1b:	7e 12                	jle    8004208f2f <trapname+0x53>
  8004208f1d:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  8004208f21:	7f 0c                	jg     8004208f2f <trapname+0x53>
		return "Hardware Interrupt";
  8004208f23:	48 b8 ac 94 21 04 80 	movabs $0x80042194ac,%rax
  8004208f2a:	00 00 00 
  8004208f2d:	eb 0a                	jmp    8004208f39 <trapname+0x5d>
	return "(unknown trap)";
  8004208f2f:	48 b8 bf 94 21 04 80 	movabs $0x80042194bf,%rax
  8004208f36:	00 00 00 
}
  8004208f39:	c9                   	leaveq 
  8004208f3a:	c3                   	retq   

0000008004208f3b <trap_init>:


void
trap_init(void)
{
  8004208f3b:	55                   	push   %rbp
  8004208f3c:	48 89 e5             	mov    %rsp,%rbp
	extern struct Segdesc gdt[];

	// LAB 3: Your code here.
    SETGATE(idt[T_DIVIDE], 0, GD_KT, XTRPX_divzero, 0);  
  8004208f3f:	48 b8 ac cc 20 04 80 	movabs $0x800420ccac,%rax
  8004208f46:	00 00 00 
  8004208f49:	89 c2                	mov    %eax,%edx
  8004208f4b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004208f52:	00 00 00 
  8004208f55:	66 89 10             	mov    %dx,(%rax)
  8004208f58:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004208f5f:	00 00 00 
  8004208f62:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  8004208f68:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004208f6f:	00 00 00 
  8004208f72:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004208f76:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208f79:	88 50 04             	mov    %dl,0x4(%rax)
  8004208f7c:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004208f83:	00 00 00 
  8004208f86:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004208f8a:	83 e2 07             	and    $0x7,%edx
  8004208f8d:	88 50 04             	mov    %dl,0x4(%rax)
  8004208f90:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004208f97:	00 00 00 
  8004208f9a:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208f9e:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208fa1:	83 ca 0e             	or     $0xe,%edx
  8004208fa4:	88 50 05             	mov    %dl,0x5(%rax)
  8004208fa7:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004208fae:	00 00 00 
  8004208fb1:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208fb5:	83 e2 ef             	and    $0xffffffef,%edx
  8004208fb8:	88 50 05             	mov    %dl,0x5(%rax)
  8004208fbb:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004208fc2:	00 00 00 
  8004208fc5:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208fc9:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208fcc:	88 50 05             	mov    %dl,0x5(%rax)
  8004208fcf:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004208fd6:	00 00 00 
  8004208fd9:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208fdd:	83 ca 80             	or     $0xffffff80,%edx
  8004208fe0:	88 50 05             	mov    %dl,0x5(%rax)
  8004208fe3:	48 b8 ac cc 20 04 80 	movabs $0x800420ccac,%rax
  8004208fea:	00 00 00 
  8004208fed:	48 c1 e8 10          	shr    $0x10,%rax
  8004208ff1:	89 c2                	mov    %eax,%edx
  8004208ff3:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004208ffa:	00 00 00 
  8004208ffd:	66 89 50 06          	mov    %dx,0x6(%rax)
  8004209001:	48 b8 ac cc 20 04 80 	movabs $0x800420ccac,%rax
  8004209008:	00 00 00 
  800420900b:	48 c1 e8 20          	shr    $0x20,%rax
  800420900f:	89 c2                	mov    %eax,%edx
  8004209011:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209018:	00 00 00 
  800420901b:	89 50 08             	mov    %edx,0x8(%rax)
  800420901e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209025:	00 00 00 
  8004209028:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
    SETGATE(idt[T_DEBUG], 0, GD_KT, XTRPX_Debug, 0);  
  800420902f:	48 b8 b6 cc 20 04 80 	movabs $0x800420ccb6,%rax
  8004209036:	00 00 00 
  8004209039:	89 c2                	mov    %eax,%edx
  800420903b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209042:	00 00 00 
  8004209045:	66 89 50 10          	mov    %dx,0x10(%rax)
  8004209049:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209050:	00 00 00 
  8004209053:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  8004209059:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209060:	00 00 00 
  8004209063:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004209067:	83 e2 f8             	and    $0xfffffff8,%edx
  800420906a:	88 50 14             	mov    %dl,0x14(%rax)
  800420906d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209074:	00 00 00 
  8004209077:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  800420907b:	83 e2 07             	and    $0x7,%edx
  800420907e:	88 50 14             	mov    %dl,0x14(%rax)
  8004209081:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209088:	00 00 00 
  800420908b:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420908f:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209092:	83 ca 0e             	or     $0xe,%edx
  8004209095:	88 50 15             	mov    %dl,0x15(%rax)
  8004209098:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420909f:	00 00 00 
  80042090a2:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042090a6:	83 e2 ef             	and    $0xffffffef,%edx
  80042090a9:	88 50 15             	mov    %dl,0x15(%rax)
  80042090ac:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042090b3:	00 00 00 
  80042090b6:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042090ba:	83 e2 9f             	and    $0xffffff9f,%edx
  80042090bd:	88 50 15             	mov    %dl,0x15(%rax)
  80042090c0:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042090c7:	00 00 00 
  80042090ca:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042090ce:	83 ca 80             	or     $0xffffff80,%edx
  80042090d1:	88 50 15             	mov    %dl,0x15(%rax)
  80042090d4:	48 b8 b6 cc 20 04 80 	movabs $0x800420ccb6,%rax
  80042090db:	00 00 00 
  80042090de:	48 c1 e8 10          	shr    $0x10,%rax
  80042090e2:	89 c2                	mov    %eax,%edx
  80042090e4:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042090eb:	00 00 00 
  80042090ee:	66 89 50 16          	mov    %dx,0x16(%rax)
  80042090f2:	48 b8 b6 cc 20 04 80 	movabs $0x800420ccb6,%rax
  80042090f9:	00 00 00 
  80042090fc:	48 c1 e8 20          	shr    $0x20,%rax
  8004209100:	89 c2                	mov    %eax,%edx
  8004209102:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209109:	00 00 00 
  800420910c:	89 50 18             	mov    %edx,0x18(%rax)
  800420910f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209116:	00 00 00 
  8004209119:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
    SETGATE(idt[T_NMI], 0, GD_KT, XTRPX_NonMaskI, 0);  
  8004209120:	48 b8 c0 cc 20 04 80 	movabs $0x800420ccc0,%rax
  8004209127:	00 00 00 
  800420912a:	89 c2                	mov    %eax,%edx
  800420912c:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209133:	00 00 00 
  8004209136:	66 89 50 20          	mov    %dx,0x20(%rax)
  800420913a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209141:	00 00 00 
  8004209144:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  800420914a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209151:	00 00 00 
  8004209154:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004209158:	83 e2 f8             	and    $0xfffffff8,%edx
  800420915b:	88 50 24             	mov    %dl,0x24(%rax)
  800420915e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209165:	00 00 00 
  8004209168:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  800420916c:	83 e2 07             	and    $0x7,%edx
  800420916f:	88 50 24             	mov    %dl,0x24(%rax)
  8004209172:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209179:	00 00 00 
  800420917c:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209180:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209183:	83 ca 0e             	or     $0xe,%edx
  8004209186:	88 50 25             	mov    %dl,0x25(%rax)
  8004209189:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209190:	00 00 00 
  8004209193:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209197:	83 e2 ef             	and    $0xffffffef,%edx
  800420919a:	88 50 25             	mov    %dl,0x25(%rax)
  800420919d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042091a4:	00 00 00 
  80042091a7:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042091ab:	83 e2 9f             	and    $0xffffff9f,%edx
  80042091ae:	88 50 25             	mov    %dl,0x25(%rax)
  80042091b1:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042091b8:	00 00 00 
  80042091bb:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042091bf:	83 ca 80             	or     $0xffffff80,%edx
  80042091c2:	88 50 25             	mov    %dl,0x25(%rax)
  80042091c5:	48 b8 c0 cc 20 04 80 	movabs $0x800420ccc0,%rax
  80042091cc:	00 00 00 
  80042091cf:	48 c1 e8 10          	shr    $0x10,%rax
  80042091d3:	89 c2                	mov    %eax,%edx
  80042091d5:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042091dc:	00 00 00 
  80042091df:	66 89 50 26          	mov    %dx,0x26(%rax)
  80042091e3:	48 b8 c0 cc 20 04 80 	movabs $0x800420ccc0,%rax
  80042091ea:	00 00 00 
  80042091ed:	48 c1 e8 20          	shr    $0x20,%rax
  80042091f1:	89 c2                	mov    %eax,%edx
  80042091f3:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042091fa:	00 00 00 
  80042091fd:	89 50 28             	mov    %edx,0x28(%rax)
  8004209200:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209207:	00 00 00 
  800420920a:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
    SETGATE(idt[T_BRKPT], 0, GD_KT, XTRPX_Brkpt, 3);  
  8004209211:	48 b8 ca cc 20 04 80 	movabs $0x800420ccca,%rax
  8004209218:	00 00 00 
  800420921b:	89 c2                	mov    %eax,%edx
  800420921d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209224:	00 00 00 
  8004209227:	66 89 50 30          	mov    %dx,0x30(%rax)
  800420922b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209232:	00 00 00 
  8004209235:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  800420923b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209242:	00 00 00 
  8004209245:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004209249:	83 e2 f8             	and    $0xfffffff8,%edx
  800420924c:	88 50 34             	mov    %dl,0x34(%rax)
  800420924f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209256:	00 00 00 
  8004209259:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  800420925d:	83 e2 07             	and    $0x7,%edx
  8004209260:	88 50 34             	mov    %dl,0x34(%rax)
  8004209263:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420926a:	00 00 00 
  800420926d:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209271:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209274:	83 ca 0e             	or     $0xe,%edx
  8004209277:	88 50 35             	mov    %dl,0x35(%rax)
  800420927a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209281:	00 00 00 
  8004209284:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209288:	83 e2 ef             	and    $0xffffffef,%edx
  800420928b:	88 50 35             	mov    %dl,0x35(%rax)
  800420928e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209295:	00 00 00 
  8004209298:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420929c:	83 ca 60             	or     $0x60,%edx
  800420929f:	88 50 35             	mov    %dl,0x35(%rax)
  80042092a2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042092a9:	00 00 00 
  80042092ac:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  80042092b0:	83 ca 80             	or     $0xffffff80,%edx
  80042092b3:	88 50 35             	mov    %dl,0x35(%rax)
  80042092b6:	48 b8 ca cc 20 04 80 	movabs $0x800420ccca,%rax
  80042092bd:	00 00 00 
  80042092c0:	48 c1 e8 10          	shr    $0x10,%rax
  80042092c4:	89 c2                	mov    %eax,%edx
  80042092c6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042092cd:	00 00 00 
  80042092d0:	66 89 50 36          	mov    %dx,0x36(%rax)
  80042092d4:	48 b8 ca cc 20 04 80 	movabs $0x800420ccca,%rax
  80042092db:	00 00 00 
  80042092de:	48 c1 e8 20          	shr    $0x20,%rax
  80042092e2:	89 c2                	mov    %eax,%edx
  80042092e4:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042092eb:	00 00 00 
  80042092ee:	89 50 38             	mov    %edx,0x38(%rax)
  80042092f1:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042092f8:	00 00 00 
  80042092fb:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
    SETGATE(idt[T_OFLOW], 0, GD_KT, XTRPX_OFlow, 0);  
  8004209302:	48 b8 d4 cc 20 04 80 	movabs $0x800420ccd4,%rax
  8004209309:	00 00 00 
  800420930c:	89 c2                	mov    %eax,%edx
  800420930e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209315:	00 00 00 
  8004209318:	66 89 50 40          	mov    %dx,0x40(%rax)
  800420931c:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209323:	00 00 00 
  8004209326:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  800420932c:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209333:	00 00 00 
  8004209336:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  800420933a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420933d:	88 50 44             	mov    %dl,0x44(%rax)
  8004209340:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209347:	00 00 00 
  800420934a:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  800420934e:	83 e2 07             	and    $0x7,%edx
  8004209351:	88 50 44             	mov    %dl,0x44(%rax)
  8004209354:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420935b:	00 00 00 
  800420935e:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209362:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209365:	83 ca 0e             	or     $0xe,%edx
  8004209368:	88 50 45             	mov    %dl,0x45(%rax)
  800420936b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209372:	00 00 00 
  8004209375:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209379:	83 e2 ef             	and    $0xffffffef,%edx
  800420937c:	88 50 45             	mov    %dl,0x45(%rax)
  800420937f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209386:	00 00 00 
  8004209389:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420938d:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209390:	88 50 45             	mov    %dl,0x45(%rax)
  8004209393:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420939a:	00 00 00 
  800420939d:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  80042093a1:	83 ca 80             	or     $0xffffff80,%edx
  80042093a4:	88 50 45             	mov    %dl,0x45(%rax)
  80042093a7:	48 b8 d4 cc 20 04 80 	movabs $0x800420ccd4,%rax
  80042093ae:	00 00 00 
  80042093b1:	48 c1 e8 10          	shr    $0x10,%rax
  80042093b5:	89 c2                	mov    %eax,%edx
  80042093b7:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042093be:	00 00 00 
  80042093c1:	66 89 50 46          	mov    %dx,0x46(%rax)
  80042093c5:	48 b8 d4 cc 20 04 80 	movabs $0x800420ccd4,%rax
  80042093cc:	00 00 00 
  80042093cf:	48 c1 e8 20          	shr    $0x20,%rax
  80042093d3:	89 c2                	mov    %eax,%edx
  80042093d5:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042093dc:	00 00 00 
  80042093df:	89 50 48             	mov    %edx,0x48(%rax)
  80042093e2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042093e9:	00 00 00 
  80042093ec:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
    SETGATE(idt[T_BOUND], 0, GD_KT, XTRPX_Bound, 0);  
  80042093f3:	48 b8 de cc 20 04 80 	movabs $0x800420ccde,%rax
  80042093fa:	00 00 00 
  80042093fd:	89 c2                	mov    %eax,%edx
  80042093ff:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209406:	00 00 00 
  8004209409:	66 89 50 50          	mov    %dx,0x50(%rax)
  800420940d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209414:	00 00 00 
  8004209417:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  800420941d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209424:	00 00 00 
  8004209427:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  800420942b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420942e:	88 50 54             	mov    %dl,0x54(%rax)
  8004209431:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209438:	00 00 00 
  800420943b:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  800420943f:	83 e2 07             	and    $0x7,%edx
  8004209442:	88 50 54             	mov    %dl,0x54(%rax)
  8004209445:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420944c:	00 00 00 
  800420944f:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209453:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209456:	83 ca 0e             	or     $0xe,%edx
  8004209459:	88 50 55             	mov    %dl,0x55(%rax)
  800420945c:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209463:	00 00 00 
  8004209466:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420946a:	83 e2 ef             	and    $0xffffffef,%edx
  800420946d:	88 50 55             	mov    %dl,0x55(%rax)
  8004209470:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209477:	00 00 00 
  800420947a:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420947e:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209481:	88 50 55             	mov    %dl,0x55(%rax)
  8004209484:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420948b:	00 00 00 
  800420948e:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209492:	83 ca 80             	or     $0xffffff80,%edx
  8004209495:	88 50 55             	mov    %dl,0x55(%rax)
  8004209498:	48 b8 de cc 20 04 80 	movabs $0x800420ccde,%rax
  800420949f:	00 00 00 
  80042094a2:	48 c1 e8 10          	shr    $0x10,%rax
  80042094a6:	89 c2                	mov    %eax,%edx
  80042094a8:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042094af:	00 00 00 
  80042094b2:	66 89 50 56          	mov    %dx,0x56(%rax)
  80042094b6:	48 b8 de cc 20 04 80 	movabs $0x800420ccde,%rax
  80042094bd:	00 00 00 
  80042094c0:	48 c1 e8 20          	shr    $0x20,%rax
  80042094c4:	89 c2                	mov    %eax,%edx
  80042094c6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042094cd:	00 00 00 
  80042094d0:	89 50 58             	mov    %edx,0x58(%rax)
  80042094d3:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042094da:	00 00 00 
  80042094dd:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
    SETGATE(idt[T_ILLOP], 0, GD_KT, XTRPX_Illop, 0);  
  80042094e4:	48 b8 e8 cc 20 04 80 	movabs $0x800420cce8,%rax
  80042094eb:	00 00 00 
  80042094ee:	89 c2                	mov    %eax,%edx
  80042094f0:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042094f7:	00 00 00 
  80042094fa:	66 89 50 60          	mov    %dx,0x60(%rax)
  80042094fe:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209505:	00 00 00 
  8004209508:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  800420950e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209515:	00 00 00 
  8004209518:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  800420951c:	83 e2 f8             	and    $0xfffffff8,%edx
  800420951f:	88 50 64             	mov    %dl,0x64(%rax)
  8004209522:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209529:	00 00 00 
  800420952c:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004209530:	83 e2 07             	and    $0x7,%edx
  8004209533:	88 50 64             	mov    %dl,0x64(%rax)
  8004209536:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420953d:	00 00 00 
  8004209540:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209544:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209547:	83 ca 0e             	or     $0xe,%edx
  800420954a:	88 50 65             	mov    %dl,0x65(%rax)
  800420954d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209554:	00 00 00 
  8004209557:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420955b:	83 e2 ef             	and    $0xffffffef,%edx
  800420955e:	88 50 65             	mov    %dl,0x65(%rax)
  8004209561:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209568:	00 00 00 
  800420956b:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420956f:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209572:	88 50 65             	mov    %dl,0x65(%rax)
  8004209575:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420957c:	00 00 00 
  800420957f:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209583:	83 ca 80             	or     $0xffffff80,%edx
  8004209586:	88 50 65             	mov    %dl,0x65(%rax)
  8004209589:	48 b8 e8 cc 20 04 80 	movabs $0x800420cce8,%rax
  8004209590:	00 00 00 
  8004209593:	48 c1 e8 10          	shr    $0x10,%rax
  8004209597:	89 c2                	mov    %eax,%edx
  8004209599:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042095a0:	00 00 00 
  80042095a3:	66 89 50 66          	mov    %dx,0x66(%rax)
  80042095a7:	48 b8 e8 cc 20 04 80 	movabs $0x800420cce8,%rax
  80042095ae:	00 00 00 
  80042095b1:	48 c1 e8 20          	shr    $0x20,%rax
  80042095b5:	89 c2                	mov    %eax,%edx
  80042095b7:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042095be:	00 00 00 
  80042095c1:	89 50 68             	mov    %edx,0x68(%rax)
  80042095c4:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042095cb:	00 00 00 
  80042095ce:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
    SETGATE(idt[T_DEVICE], 0, GD_KT, XTRPX_Device, 0);  
  80042095d5:	48 b8 f2 cc 20 04 80 	movabs $0x800420ccf2,%rax
  80042095dc:	00 00 00 
  80042095df:	89 c2                	mov    %eax,%edx
  80042095e1:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042095e8:	00 00 00 
  80042095eb:	66 89 50 70          	mov    %dx,0x70(%rax)
  80042095ef:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042095f6:	00 00 00 
  80042095f9:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  80042095ff:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209606:	00 00 00 
  8004209609:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  800420960d:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209610:	88 50 74             	mov    %dl,0x74(%rax)
  8004209613:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420961a:	00 00 00 
  800420961d:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209621:	83 e2 07             	and    $0x7,%edx
  8004209624:	88 50 74             	mov    %dl,0x74(%rax)
  8004209627:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420962e:	00 00 00 
  8004209631:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209635:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209638:	83 ca 0e             	or     $0xe,%edx
  800420963b:	88 50 75             	mov    %dl,0x75(%rax)
  800420963e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209645:	00 00 00 
  8004209648:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420964c:	83 e2 ef             	and    $0xffffffef,%edx
  800420964f:	88 50 75             	mov    %dl,0x75(%rax)
  8004209652:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209659:	00 00 00 
  800420965c:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209660:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209663:	88 50 75             	mov    %dl,0x75(%rax)
  8004209666:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420966d:	00 00 00 
  8004209670:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209674:	83 ca 80             	or     $0xffffff80,%edx
  8004209677:	88 50 75             	mov    %dl,0x75(%rax)
  800420967a:	48 b8 f2 cc 20 04 80 	movabs $0x800420ccf2,%rax
  8004209681:	00 00 00 
  8004209684:	48 c1 e8 10          	shr    $0x10,%rax
  8004209688:	89 c2                	mov    %eax,%edx
  800420968a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209691:	00 00 00 
  8004209694:	66 89 50 76          	mov    %dx,0x76(%rax)
  8004209698:	48 b8 f2 cc 20 04 80 	movabs $0x800420ccf2,%rax
  800420969f:	00 00 00 
  80042096a2:	48 c1 e8 20          	shr    $0x20,%rax
  80042096a6:	89 c2                	mov    %eax,%edx
  80042096a8:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042096af:	00 00 00 
  80042096b2:	89 50 78             	mov    %edx,0x78(%rax)
  80042096b5:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042096bc:	00 00 00 
  80042096bf:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
    SETGATE(idt[T_DBLFLT], 0, GD_KT, XTRPX_DblFlt, 0);  
  80042096c6:	48 b8 fc cc 20 04 80 	movabs $0x800420ccfc,%rax
  80042096cd:	00 00 00 
  80042096d0:	89 c2                	mov    %eax,%edx
  80042096d2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042096d9:	00 00 00 
  80042096dc:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  80042096e3:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042096ea:	00 00 00 
  80042096ed:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  80042096f4:	08 00 
  80042096f6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042096fd:	00 00 00 
  8004209700:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209707:	83 e2 f8             	and    $0xfffffff8,%edx
  800420970a:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209710:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209717:	00 00 00 
  800420971a:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209721:	83 e2 07             	and    $0x7,%edx
  8004209724:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  800420972a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209731:	00 00 00 
  8004209734:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420973b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420973e:	83 ca 0e             	or     $0xe,%edx
  8004209741:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209747:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420974e:	00 00 00 
  8004209751:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209758:	83 e2 ef             	and    $0xffffffef,%edx
  800420975b:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209761:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209768:	00 00 00 
  800420976b:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209772:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209775:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420977b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209782:	00 00 00 
  8004209785:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420978c:	83 ca 80             	or     $0xffffff80,%edx
  800420978f:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209795:	48 b8 fc cc 20 04 80 	movabs $0x800420ccfc,%rax
  800420979c:	00 00 00 
  800420979f:	48 c1 e8 10          	shr    $0x10,%rax
  80042097a3:	89 c2                	mov    %eax,%edx
  80042097a5:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042097ac:	00 00 00 
  80042097af:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  80042097b6:	48 b8 fc cc 20 04 80 	movabs $0x800420ccfc,%rax
  80042097bd:	00 00 00 
  80042097c0:	48 c1 e8 20          	shr    $0x20,%rax
  80042097c4:	89 c2                	mov    %eax,%edx
  80042097c6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042097cd:	00 00 00 
  80042097d0:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  80042097d6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042097dd:	00 00 00 
  80042097e0:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  80042097e7:	00 00 00 
    SETGATE(idt[T_TSS], 0, GD_KT, XTRPX_Tss, 0);  
  80042097ea:	48 b8 04 cd 20 04 80 	movabs $0x800420cd04,%rax
  80042097f1:	00 00 00 
  80042097f4:	89 c2                	mov    %eax,%edx
  80042097f6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042097fd:	00 00 00 
  8004209800:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  8004209807:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420980e:	00 00 00 
  8004209811:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  8004209818:	08 00 
  800420981a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209821:	00 00 00 
  8004209824:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420982b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420982e:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  8004209834:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420983b:	00 00 00 
  800420983e:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004209845:	83 e2 07             	and    $0x7,%edx
  8004209848:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420984e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209855:	00 00 00 
  8004209858:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420985f:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209862:	83 ca 0e             	or     $0xe,%edx
  8004209865:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420986b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209872:	00 00 00 
  8004209875:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420987c:	83 e2 ef             	and    $0xffffffef,%edx
  800420987f:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209885:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420988c:	00 00 00 
  800420988f:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209896:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209899:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420989f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042098a6:	00 00 00 
  80042098a9:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042098b0:	83 ca 80             	or     $0xffffff80,%edx
  80042098b3:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042098b9:	48 b8 04 cd 20 04 80 	movabs $0x800420cd04,%rax
  80042098c0:	00 00 00 
  80042098c3:	48 c1 e8 10          	shr    $0x10,%rax
  80042098c7:	89 c2                	mov    %eax,%edx
  80042098c9:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042098d0:	00 00 00 
  80042098d3:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  80042098da:	48 b8 04 cd 20 04 80 	movabs $0x800420cd04,%rax
  80042098e1:	00 00 00 
  80042098e4:	48 c1 e8 20          	shr    $0x20,%rax
  80042098e8:	89 c2                	mov    %eax,%edx
  80042098ea:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042098f1:	00 00 00 
  80042098f4:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  80042098fa:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209901:	00 00 00 
  8004209904:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  800420990b:	00 00 00 
    SETGATE(idt[T_SEGNP], 0, GD_KT, XTRPX_Segnp, 0);  
  800420990e:	48 b8 0c cd 20 04 80 	movabs $0x800420cd0c,%rax
  8004209915:	00 00 00 
  8004209918:	89 c2                	mov    %eax,%edx
  800420991a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209921:	00 00 00 
  8004209924:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  800420992b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209932:	00 00 00 
  8004209935:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  800420993c:	08 00 
  800420993e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209945:	00 00 00 
  8004209948:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420994f:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209952:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  8004209958:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420995f:	00 00 00 
  8004209962:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004209969:	83 e2 07             	and    $0x7,%edx
  800420996c:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  8004209972:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209979:	00 00 00 
  800420997c:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209983:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209986:	83 ca 0e             	or     $0xe,%edx
  8004209989:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420998f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209996:	00 00 00 
  8004209999:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042099a0:	83 e2 ef             	and    $0xffffffef,%edx
  80042099a3:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042099a9:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042099b0:	00 00 00 
  80042099b3:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042099ba:	83 e2 9f             	and    $0xffffff9f,%edx
  80042099bd:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042099c3:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042099ca:	00 00 00 
  80042099cd:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042099d4:	83 ca 80             	or     $0xffffff80,%edx
  80042099d7:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042099dd:	48 b8 0c cd 20 04 80 	movabs $0x800420cd0c,%rax
  80042099e4:	00 00 00 
  80042099e7:	48 c1 e8 10          	shr    $0x10,%rax
  80042099eb:	89 c2                	mov    %eax,%edx
  80042099ed:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  80042099f4:	00 00 00 
  80042099f7:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  80042099fe:	48 b8 0c cd 20 04 80 	movabs $0x800420cd0c,%rax
  8004209a05:	00 00 00 
  8004209a08:	48 c1 e8 20          	shr    $0x20,%rax
  8004209a0c:	89 c2                	mov    %eax,%edx
  8004209a0e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209a15:	00 00 00 
  8004209a18:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  8004209a1e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209a25:	00 00 00 
  8004209a28:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  8004209a2f:	00 00 00 
    SETGATE(idt[T_STACK], 0, GD_KT, XTRPX_Stack, 0);  
  8004209a32:	48 b8 14 cd 20 04 80 	movabs $0x800420cd14,%rax
  8004209a39:	00 00 00 
  8004209a3c:	89 c2                	mov    %eax,%edx
  8004209a3e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209a45:	00 00 00 
  8004209a48:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  8004209a4f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209a56:	00 00 00 
  8004209a59:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  8004209a60:	08 00 
  8004209a62:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209a69:	00 00 00 
  8004209a6c:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209a73:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209a76:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209a7c:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209a83:	00 00 00 
  8004209a86:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209a8d:	83 e2 07             	and    $0x7,%edx
  8004209a90:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209a96:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209a9d:	00 00 00 
  8004209aa0:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209aa7:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209aaa:	83 ca 0e             	or     $0xe,%edx
  8004209aad:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209ab3:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209aba:	00 00 00 
  8004209abd:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209ac4:	83 e2 ef             	and    $0xffffffef,%edx
  8004209ac7:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209acd:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209ad4:	00 00 00 
  8004209ad7:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209ade:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209ae1:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209ae7:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209aee:	00 00 00 
  8004209af1:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209af8:	83 ca 80             	or     $0xffffff80,%edx
  8004209afb:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209b01:	48 b8 14 cd 20 04 80 	movabs $0x800420cd14,%rax
  8004209b08:	00 00 00 
  8004209b0b:	48 c1 e8 10          	shr    $0x10,%rax
  8004209b0f:	89 c2                	mov    %eax,%edx
  8004209b11:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209b18:	00 00 00 
  8004209b1b:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  8004209b22:	48 b8 14 cd 20 04 80 	movabs $0x800420cd14,%rax
  8004209b29:	00 00 00 
  8004209b2c:	48 c1 e8 20          	shr    $0x20,%rax
  8004209b30:	89 c2                	mov    %eax,%edx
  8004209b32:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209b39:	00 00 00 
  8004209b3c:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  8004209b42:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209b49:	00 00 00 
  8004209b4c:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  8004209b53:	00 00 00 
    SETGATE(idt[T_GPFLT], 0, GD_KT, XTRPX_Gpflt, 0);  
  8004209b56:	48 b8 1c cd 20 04 80 	movabs $0x800420cd1c,%rax
  8004209b5d:	00 00 00 
  8004209b60:	89 c2                	mov    %eax,%edx
  8004209b62:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209b69:	00 00 00 
  8004209b6c:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  8004209b73:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209b7a:	00 00 00 
  8004209b7d:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  8004209b84:	08 00 
  8004209b86:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209b8d:	00 00 00 
  8004209b90:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  8004209b97:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209b9a:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209ba0:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209ba7:	00 00 00 
  8004209baa:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  8004209bb1:	83 e2 07             	and    $0x7,%edx
  8004209bb4:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209bba:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209bc1:	00 00 00 
  8004209bc4:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209bcb:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209bce:	83 ca 0e             	or     $0xe,%edx
  8004209bd1:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209bd7:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209bde:	00 00 00 
  8004209be1:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209be8:	83 e2 ef             	and    $0xffffffef,%edx
  8004209beb:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209bf1:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209bf8:	00 00 00 
  8004209bfb:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209c02:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209c05:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209c0b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209c12:	00 00 00 
  8004209c15:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209c1c:	83 ca 80             	or     $0xffffff80,%edx
  8004209c1f:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209c25:	48 b8 1c cd 20 04 80 	movabs $0x800420cd1c,%rax
  8004209c2c:	00 00 00 
  8004209c2f:	48 c1 e8 10          	shr    $0x10,%rax
  8004209c33:	89 c2                	mov    %eax,%edx
  8004209c35:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209c3c:	00 00 00 
  8004209c3f:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  8004209c46:	48 b8 1c cd 20 04 80 	movabs $0x800420cd1c,%rax
  8004209c4d:	00 00 00 
  8004209c50:	48 c1 e8 20          	shr    $0x20,%rax
  8004209c54:	89 c2                	mov    %eax,%edx
  8004209c56:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209c5d:	00 00 00 
  8004209c60:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  8004209c66:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209c6d:	00 00 00 
  8004209c70:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  8004209c77:	00 00 00 
    SETGATE(idt[T_PGFLT], 0, GD_KT, XTRPX_Pgflt, 0);  
  8004209c7a:	48 b8 24 cd 20 04 80 	movabs $0x800420cd24,%rax
  8004209c81:	00 00 00 
  8004209c84:	89 c2                	mov    %eax,%edx
  8004209c86:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209c8d:	00 00 00 
  8004209c90:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  8004209c97:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209c9e:	00 00 00 
  8004209ca1:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  8004209ca8:	08 00 
  8004209caa:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209cb1:	00 00 00 
  8004209cb4:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209cbb:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209cbe:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209cc4:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209ccb:	00 00 00 
  8004209cce:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209cd5:	83 e2 07             	and    $0x7,%edx
  8004209cd8:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209cde:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209ce5:	00 00 00 
  8004209ce8:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209cef:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209cf2:	83 ca 0e             	or     $0xe,%edx
  8004209cf5:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209cfb:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209d02:	00 00 00 
  8004209d05:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209d0c:	83 e2 ef             	and    $0xffffffef,%edx
  8004209d0f:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d15:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209d1c:	00 00 00 
  8004209d1f:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209d26:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209d29:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d2f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209d36:	00 00 00 
  8004209d39:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209d40:	83 ca 80             	or     $0xffffff80,%edx
  8004209d43:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d49:	48 b8 24 cd 20 04 80 	movabs $0x800420cd24,%rax
  8004209d50:	00 00 00 
  8004209d53:	48 c1 e8 10          	shr    $0x10,%rax
  8004209d57:	89 c2                	mov    %eax,%edx
  8004209d59:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209d60:	00 00 00 
  8004209d63:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  8004209d6a:	48 b8 24 cd 20 04 80 	movabs $0x800420cd24,%rax
  8004209d71:	00 00 00 
  8004209d74:	48 c1 e8 20          	shr    $0x20,%rax
  8004209d78:	89 c2                	mov    %eax,%edx
  8004209d7a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209d81:	00 00 00 
  8004209d84:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  8004209d8a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209d91:	00 00 00 
  8004209d94:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  8004209d9b:	00 00 00 
    SETGATE(idt[T_FPERR], 0, GD_KT, XTRPX_FpErr, 0);  
  8004209d9e:	48 b8 2c cd 20 04 80 	movabs $0x800420cd2c,%rax
  8004209da5:	00 00 00 
  8004209da8:	89 c2                	mov    %eax,%edx
  8004209daa:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209db1:	00 00 00 
  8004209db4:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  8004209dbb:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209dc2:	00 00 00 
  8004209dc5:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  8004209dcc:	08 00 
  8004209dce:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209dd5:	00 00 00 
  8004209dd8:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209ddf:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209de2:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209de8:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209def:	00 00 00 
  8004209df2:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209df9:	83 e2 07             	and    $0x7,%edx
  8004209dfc:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209e02:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209e09:	00 00 00 
  8004209e0c:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e13:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209e16:	83 ca 0e             	or     $0xe,%edx
  8004209e19:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e1f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209e26:	00 00 00 
  8004209e29:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e30:	83 e2 ef             	and    $0xffffffef,%edx
  8004209e33:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e39:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209e40:	00 00 00 
  8004209e43:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e4a:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209e4d:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e53:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209e5a:	00 00 00 
  8004209e5d:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e64:	83 ca 80             	or     $0xffffff80,%edx
  8004209e67:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e6d:	48 b8 2c cd 20 04 80 	movabs $0x800420cd2c,%rax
  8004209e74:	00 00 00 
  8004209e77:	48 c1 e8 10          	shr    $0x10,%rax
  8004209e7b:	89 c2                	mov    %eax,%edx
  8004209e7d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209e84:	00 00 00 
  8004209e87:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  8004209e8e:	48 b8 2c cd 20 04 80 	movabs $0x800420cd2c,%rax
  8004209e95:	00 00 00 
  8004209e98:	48 c1 e8 20          	shr    $0x20,%rax
  8004209e9c:	89 c2                	mov    %eax,%edx
  8004209e9e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209ea5:	00 00 00 
  8004209ea8:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  8004209eae:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209eb5:	00 00 00 
  8004209eb8:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  8004209ebf:	00 00 00 
    SETGATE(idt[T_ALIGN], 0, GD_KT, XTRPX_Align, 0);  
  8004209ec2:	48 b8 36 cd 20 04 80 	movabs $0x800420cd36,%rax
  8004209ec9:	00 00 00 
  8004209ecc:	89 c2                	mov    %eax,%edx
  8004209ece:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209ed5:	00 00 00 
  8004209ed8:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  8004209edf:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209ee6:	00 00 00 
  8004209ee9:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  8004209ef0:	08 00 
  8004209ef2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209ef9:	00 00 00 
  8004209efc:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209f03:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209f06:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209f0c:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209f13:	00 00 00 
  8004209f16:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209f1d:	83 e2 07             	and    $0x7,%edx
  8004209f20:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209f26:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209f2d:	00 00 00 
  8004209f30:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f37:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f3a:	83 ca 0e             	or     $0xe,%edx
  8004209f3d:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209f43:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209f4a:	00 00 00 
  8004209f4d:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f54:	83 e2 ef             	and    $0xffffffef,%edx
  8004209f57:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209f5d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209f64:	00 00 00 
  8004209f67:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f6e:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209f71:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209f77:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209f7e:	00 00 00 
  8004209f81:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f88:	83 ca 80             	or     $0xffffff80,%edx
  8004209f8b:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209f91:	48 b8 36 cd 20 04 80 	movabs $0x800420cd36,%rax
  8004209f98:	00 00 00 
  8004209f9b:	48 c1 e8 10          	shr    $0x10,%rax
  8004209f9f:	89 c2                	mov    %eax,%edx
  8004209fa1:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209fa8:	00 00 00 
  8004209fab:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  8004209fb2:	48 b8 36 cd 20 04 80 	movabs $0x800420cd36,%rax
  8004209fb9:	00 00 00 
  8004209fbc:	48 c1 e8 20          	shr    $0x20,%rax
  8004209fc0:	89 c2                	mov    %eax,%edx
  8004209fc2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209fc9:	00 00 00 
  8004209fcc:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  8004209fd2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209fd9:	00 00 00 
  8004209fdc:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  8004209fe3:	00 00 00 
    SETGATE(idt[T_MCHK], 0, GD_KT, XTRPX_Mchk, 0);  
  8004209fe6:	48 b8 3a cd 20 04 80 	movabs $0x800420cd3a,%rax
  8004209fed:	00 00 00 
  8004209ff0:	89 c2                	mov    %eax,%edx
  8004209ff2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  8004209ff9:	00 00 00 
  8004209ffc:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  800420a003:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a00a:	00 00 00 
  800420a00d:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  800420a014:	08 00 
  800420a016:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a01d:	00 00 00 
  800420a020:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a027:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a02a:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a030:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a037:	00 00 00 
  800420a03a:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a041:	83 e2 07             	and    $0x7,%edx
  800420a044:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a04a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a051:	00 00 00 
  800420a054:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a05b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a05e:	83 ca 0e             	or     $0xe,%edx
  800420a061:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a067:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a06e:	00 00 00 
  800420a071:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a078:	83 e2 ef             	and    $0xffffffef,%edx
  800420a07b:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a081:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a088:	00 00 00 
  800420a08b:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a092:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a095:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a09b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a0a2:	00 00 00 
  800420a0a5:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a0ac:	83 ca 80             	or     $0xffffff80,%edx
  800420a0af:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a0b5:	48 b8 3a cd 20 04 80 	movabs $0x800420cd3a,%rax
  800420a0bc:	00 00 00 
  800420a0bf:	48 c1 e8 10          	shr    $0x10,%rax
  800420a0c3:	89 c2                	mov    %eax,%edx
  800420a0c5:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a0cc:	00 00 00 
  800420a0cf:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  800420a0d6:	48 b8 3a cd 20 04 80 	movabs $0x800420cd3a,%rax
  800420a0dd:	00 00 00 
  800420a0e0:	48 c1 e8 20          	shr    $0x20,%rax
  800420a0e4:	89 c2                	mov    %eax,%edx
  800420a0e6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a0ed:	00 00 00 
  800420a0f0:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  800420a0f6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a0fd:	00 00 00 
  800420a100:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  800420a107:	00 00 00 
    SETGATE(idt[T_SIMDERR], 0, GD_KT, XTRPX_SimdErr, 0);  
  800420a10a:	48 b8 40 cd 20 04 80 	movabs $0x800420cd40,%rax
  800420a111:	00 00 00 
  800420a114:	89 c2                	mov    %eax,%edx
  800420a116:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a11d:	00 00 00 
  800420a120:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  800420a127:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a12e:	00 00 00 
  800420a131:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  800420a138:	08 00 
  800420a13a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a141:	00 00 00 
  800420a144:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a14b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a14e:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a154:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a15b:	00 00 00 
  800420a15e:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a165:	83 e2 07             	and    $0x7,%edx
  800420a168:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a16e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a175:	00 00 00 
  800420a178:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a17f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a182:	83 ca 0e             	or     $0xe,%edx
  800420a185:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a18b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a192:	00 00 00 
  800420a195:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a19c:	83 e2 ef             	and    $0xffffffef,%edx
  800420a19f:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a1a5:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a1ac:	00 00 00 
  800420a1af:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a1b6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a1b9:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a1bf:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a1c6:	00 00 00 
  800420a1c9:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a1d0:	83 ca 80             	or     $0xffffff80,%edx
  800420a1d3:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a1d9:	48 b8 40 cd 20 04 80 	movabs $0x800420cd40,%rax
  800420a1e0:	00 00 00 
  800420a1e3:	48 c1 e8 10          	shr    $0x10,%rax
  800420a1e7:	89 c2                	mov    %eax,%edx
  800420a1e9:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a1f0:	00 00 00 
  800420a1f3:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  800420a1fa:	48 b8 40 cd 20 04 80 	movabs $0x800420cd40,%rax
  800420a201:	00 00 00 
  800420a204:	48 c1 e8 20          	shr    $0x20,%rax
  800420a208:	89 c2                	mov    %eax,%edx
  800420a20a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a211:	00 00 00 
  800420a214:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  800420a21a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a221:	00 00 00 
  800420a224:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  800420a22b:	00 00 00 
    SETGATE(idt[T_SYSCALL], 0, GD_KT, XTRPX_Syscall, 3);
  800420a22e:	48 b8 46 cd 20 04 80 	movabs $0x800420cd46,%rax
  800420a235:	00 00 00 
  800420a238:	89 c2                	mov    %eax,%edx
  800420a23a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a241:	00 00 00 
  800420a244:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  800420a24b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a252:	00 00 00 
  800420a255:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  800420a25c:	08 00 
  800420a25e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a265:	00 00 00 
  800420a268:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420a26f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a272:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420a278:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a27f:	00 00 00 
  800420a282:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420a289:	83 e2 07             	and    $0x7,%edx
  800420a28c:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420a292:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a299:	00 00 00 
  800420a29c:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a2a3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a2a6:	83 ca 0e             	or     $0xe,%edx
  800420a2a9:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a2af:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a2b6:	00 00 00 
  800420a2b9:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a2c0:	83 e2 ef             	and    $0xffffffef,%edx
  800420a2c3:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a2c9:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a2d0:	00 00 00 
  800420a2d3:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a2da:	83 ca 60             	or     $0x60,%edx
  800420a2dd:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a2e3:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a2ea:	00 00 00 
  800420a2ed:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a2f4:	83 ca 80             	or     $0xffffff80,%edx
  800420a2f7:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a2fd:	48 b8 46 cd 20 04 80 	movabs $0x800420cd46,%rax
  800420a304:	00 00 00 
  800420a307:	48 c1 e8 10          	shr    $0x10,%rax
  800420a30b:	89 c2                	mov    %eax,%edx
  800420a30d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a314:	00 00 00 
  800420a317:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  800420a31e:	48 b8 46 cd 20 04 80 	movabs $0x800420cd46,%rax
  800420a325:	00 00 00 
  800420a328:	48 c1 e8 20          	shr    $0x20,%rax
  800420a32c:	89 c2                	mov    %eax,%edx
  800420a32e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a335:	00 00 00 
  800420a338:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  800420a33e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a345:	00 00 00 
  800420a348:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420a34f:	00 00 00 
    SETGATE(idt[T_DEFAULT], 0, GD_KT, XTRPX_Default, 0);
  800420a352:	48 b8 4c cd 20 04 80 	movabs $0x800420cd4c,%rax
  800420a359:	00 00 00 
  800420a35c:	89 c2                	mov    %eax,%edx
  800420a35e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a365:	00 00 00 
  800420a368:	66 89 90 40 1f 00 00 	mov    %dx,0x1f40(%rax)
  800420a36f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a376:	00 00 00 
  800420a379:	66 c7 80 42 1f 00 00 	movw   $0x8,0x1f42(%rax)
  800420a380:	08 00 
  800420a382:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a389:	00 00 00 
  800420a38c:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420a393:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a396:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  800420a39c:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a3a3:	00 00 00 
  800420a3a6:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420a3ad:	83 e2 07             	and    $0x7,%edx
  800420a3b0:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  800420a3b6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a3bd:	00 00 00 
  800420a3c0:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a3c7:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a3ca:	83 ca 0e             	or     $0xe,%edx
  800420a3cd:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a3d3:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a3da:	00 00 00 
  800420a3dd:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a3e4:	83 e2 ef             	and    $0xffffffef,%edx
  800420a3e7:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a3ed:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a3f4:	00 00 00 
  800420a3f7:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a3fe:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a401:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a407:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a40e:	00 00 00 
  800420a411:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a418:	83 ca 80             	or     $0xffffff80,%edx
  800420a41b:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a421:	48 b8 4c cd 20 04 80 	movabs $0x800420cd4c,%rax
  800420a428:	00 00 00 
  800420a42b:	48 c1 e8 10          	shr    $0x10,%rax
  800420a42f:	89 c2                	mov    %eax,%edx
  800420a431:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a438:	00 00 00 
  800420a43b:	66 89 90 46 1f 00 00 	mov    %dx,0x1f46(%rax)
  800420a442:	48 b8 4c cd 20 04 80 	movabs $0x800420cd4c,%rax
  800420a449:	00 00 00 
  800420a44c:	48 c1 e8 20          	shr    $0x20,%rax
  800420a450:	89 c2                	mov    %eax,%edx
  800420a452:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a459:	00 00 00 
  800420a45c:	89 90 48 1f 00 00    	mov    %edx,0x1f48(%rax)
  800420a462:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a469:	00 00 00 
  800420a46c:	c7 80 4c 1f 00 00 00 	movl   $0x0,0x1f4c(%rax)
  800420a473:	00 00 00 
	
    SETGATE(idt[IRQ_OFFSET+IRQ_TIMER], 0, GD_KT, XTRPX_IRQ0, 0);
  800420a476:	48 b8 56 cd 20 04 80 	movabs $0x800420cd56,%rax
  800420a47d:	00 00 00 
  800420a480:	89 c2                	mov    %eax,%edx
  800420a482:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a489:	00 00 00 
  800420a48c:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  800420a493:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a49a:	00 00 00 
  800420a49d:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  800420a4a4:	08 00 
  800420a4a6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a4ad:	00 00 00 
  800420a4b0:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a4b7:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a4ba:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a4c0:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a4c7:	00 00 00 
  800420a4ca:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a4d1:	83 e2 07             	and    $0x7,%edx
  800420a4d4:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a4da:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a4e1:	00 00 00 
  800420a4e4:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a4eb:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a4ee:	83 ca 0e             	or     $0xe,%edx
  800420a4f1:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a4f7:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a4fe:	00 00 00 
  800420a501:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a508:	83 e2 ef             	and    $0xffffffef,%edx
  800420a50b:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a511:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a518:	00 00 00 
  800420a51b:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a522:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a525:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a52b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a532:	00 00 00 
  800420a535:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a53c:	83 ca 80             	or     $0xffffff80,%edx
  800420a53f:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a545:	48 b8 56 cd 20 04 80 	movabs $0x800420cd56,%rax
  800420a54c:	00 00 00 
  800420a54f:	48 c1 e8 10          	shr    $0x10,%rax
  800420a553:	89 c2                	mov    %eax,%edx
  800420a555:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a55c:	00 00 00 
  800420a55f:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420a566:	48 b8 56 cd 20 04 80 	movabs $0x800420cd56,%rax
  800420a56d:	00 00 00 
  800420a570:	48 c1 e8 20          	shr    $0x20,%rax
  800420a574:	89 c2                	mov    %eax,%edx
  800420a576:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a57d:	00 00 00 
  800420a580:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420a586:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a58d:	00 00 00 
  800420a590:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420a597:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_KBD], 0, GD_KT, XTRPX_IRQ1, 0);
  800420a59a:	48 b8 5c cd 20 04 80 	movabs $0x800420cd5c,%rax
  800420a5a1:	00 00 00 
  800420a5a4:	89 c2                	mov    %eax,%edx
  800420a5a6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a5ad:	00 00 00 
  800420a5b0:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420a5b7:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a5be:	00 00 00 
  800420a5c1:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420a5c8:	08 00 
  800420a5ca:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a5d1:	00 00 00 
  800420a5d4:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a5db:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a5de:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a5e4:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a5eb:	00 00 00 
  800420a5ee:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a5f5:	83 e2 07             	and    $0x7,%edx
  800420a5f8:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a5fe:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a605:	00 00 00 
  800420a608:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a60f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a612:	83 ca 0e             	or     $0xe,%edx
  800420a615:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a61b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a622:	00 00 00 
  800420a625:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a62c:	83 e2 ef             	and    $0xffffffef,%edx
  800420a62f:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a635:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a63c:	00 00 00 
  800420a63f:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a646:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a649:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a64f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a656:	00 00 00 
  800420a659:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a660:	83 ca 80             	or     $0xffffff80,%edx
  800420a663:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a669:	48 b8 5c cd 20 04 80 	movabs $0x800420cd5c,%rax
  800420a670:	00 00 00 
  800420a673:	48 c1 e8 10          	shr    $0x10,%rax
  800420a677:	89 c2                	mov    %eax,%edx
  800420a679:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a680:	00 00 00 
  800420a683:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420a68a:	48 b8 5c cd 20 04 80 	movabs $0x800420cd5c,%rax
  800420a691:	00 00 00 
  800420a694:	48 c1 e8 20          	shr    $0x20,%rax
  800420a698:	89 c2                	mov    %eax,%edx
  800420a69a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a6a1:	00 00 00 
  800420a6a4:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420a6aa:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a6b1:	00 00 00 
  800420a6b4:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420a6bb:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+2], 0, GD_KT, XTRPX_IRQ2, 0);
  800420a6be:	48 b8 62 cd 20 04 80 	movabs $0x800420cd62,%rax
  800420a6c5:	00 00 00 
  800420a6c8:	89 c2                	mov    %eax,%edx
  800420a6ca:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a6d1:	00 00 00 
  800420a6d4:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  800420a6db:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a6e2:	00 00 00 
  800420a6e5:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  800420a6ec:	08 00 
  800420a6ee:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a6f5:	00 00 00 
  800420a6f8:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420a6ff:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a702:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420a708:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a70f:	00 00 00 
  800420a712:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420a719:	83 e2 07             	and    $0x7,%edx
  800420a71c:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420a722:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a729:	00 00 00 
  800420a72c:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a733:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a736:	83 ca 0e             	or     $0xe,%edx
  800420a739:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a73f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a746:	00 00 00 
  800420a749:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a750:	83 e2 ef             	and    $0xffffffef,%edx
  800420a753:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a759:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a760:	00 00 00 
  800420a763:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a76a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a76d:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a773:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a77a:	00 00 00 
  800420a77d:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a784:	83 ca 80             	or     $0xffffff80,%edx
  800420a787:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a78d:	48 b8 62 cd 20 04 80 	movabs $0x800420cd62,%rax
  800420a794:	00 00 00 
  800420a797:	48 c1 e8 10          	shr    $0x10,%rax
  800420a79b:	89 c2                	mov    %eax,%edx
  800420a79d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a7a4:	00 00 00 
  800420a7a7:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  800420a7ae:	48 b8 62 cd 20 04 80 	movabs $0x800420cd62,%rax
  800420a7b5:	00 00 00 
  800420a7b8:	48 c1 e8 20          	shr    $0x20,%rax
  800420a7bc:	89 c2                	mov    %eax,%edx
  800420a7be:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a7c5:	00 00 00 
  800420a7c8:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  800420a7ce:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a7d5:	00 00 00 
  800420a7d8:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  800420a7df:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+3], 0, GD_KT, XTRPX_IRQ3, 0);
  800420a7e2:	48 b8 68 cd 20 04 80 	movabs $0x800420cd68,%rax
  800420a7e9:	00 00 00 
  800420a7ec:	89 c2                	mov    %eax,%edx
  800420a7ee:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a7f5:	00 00 00 
  800420a7f8:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  800420a7ff:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a806:	00 00 00 
  800420a809:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  800420a810:	08 00 
  800420a812:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a819:	00 00 00 
  800420a81c:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420a823:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a826:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420a82c:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a833:	00 00 00 
  800420a836:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420a83d:	83 e2 07             	and    $0x7,%edx
  800420a840:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420a846:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a84d:	00 00 00 
  800420a850:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a857:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a85a:	83 ca 0e             	or     $0xe,%edx
  800420a85d:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a863:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a86a:	00 00 00 
  800420a86d:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a874:	83 e2 ef             	and    $0xffffffef,%edx
  800420a877:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a87d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a884:	00 00 00 
  800420a887:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a88e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a891:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a897:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a89e:	00 00 00 
  800420a8a1:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a8a8:	83 ca 80             	or     $0xffffff80,%edx
  800420a8ab:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a8b1:	48 b8 68 cd 20 04 80 	movabs $0x800420cd68,%rax
  800420a8b8:	00 00 00 
  800420a8bb:	48 c1 e8 10          	shr    $0x10,%rax
  800420a8bf:	89 c2                	mov    %eax,%edx
  800420a8c1:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a8c8:	00 00 00 
  800420a8cb:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420a8d2:	48 b8 68 cd 20 04 80 	movabs $0x800420cd68,%rax
  800420a8d9:	00 00 00 
  800420a8dc:	48 c1 e8 20          	shr    $0x20,%rax
  800420a8e0:	89 c2                	mov    %eax,%edx
  800420a8e2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a8e9:	00 00 00 
  800420a8ec:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420a8f2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a8f9:	00 00 00 
  800420a8fc:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420a903:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_SERIAL], 0, GD_KT, XTRPX_IRQ4, 0);
  800420a906:	48 b8 6e cd 20 04 80 	movabs $0x800420cd6e,%rax
  800420a90d:	00 00 00 
  800420a910:	89 c2                	mov    %eax,%edx
  800420a912:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a919:	00 00 00 
  800420a91c:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420a923:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a92a:	00 00 00 
  800420a92d:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420a934:	08 00 
  800420a936:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a93d:	00 00 00 
  800420a940:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a947:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a94a:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a950:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a957:	00 00 00 
  800420a95a:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a961:	83 e2 07             	and    $0x7,%edx
  800420a964:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a96a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a971:	00 00 00 
  800420a974:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a97b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a97e:	83 ca 0e             	or     $0xe,%edx
  800420a981:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a987:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a98e:	00 00 00 
  800420a991:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a998:	83 e2 ef             	and    $0xffffffef,%edx
  800420a99b:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a9a1:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a9a8:	00 00 00 
  800420a9ab:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a9b2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a9b5:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a9bb:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a9c2:	00 00 00 
  800420a9c5:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a9cc:	83 ca 80             	or     $0xffffff80,%edx
  800420a9cf:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a9d5:	48 b8 6e cd 20 04 80 	movabs $0x800420cd6e,%rax
  800420a9dc:	00 00 00 
  800420a9df:	48 c1 e8 10          	shr    $0x10,%rax
  800420a9e3:	89 c2                	mov    %eax,%edx
  800420a9e5:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420a9ec:	00 00 00 
  800420a9ef:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420a9f6:	48 b8 6e cd 20 04 80 	movabs $0x800420cd6e,%rax
  800420a9fd:	00 00 00 
  800420aa00:	48 c1 e8 20          	shr    $0x20,%rax
  800420aa04:	89 c2                	mov    %eax,%edx
  800420aa06:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aa0d:	00 00 00 
  800420aa10:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420aa16:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aa1d:	00 00 00 
  800420aa20:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420aa27:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+5], 0, GD_KT, XTRPX_IRQ5, 0);
  800420aa2a:	48 b8 74 cd 20 04 80 	movabs $0x800420cd74,%rax
  800420aa31:	00 00 00 
  800420aa34:	89 c2                	mov    %eax,%edx
  800420aa36:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aa3d:	00 00 00 
  800420aa40:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420aa47:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aa4e:	00 00 00 
  800420aa51:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420aa58:	08 00 
  800420aa5a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aa61:	00 00 00 
  800420aa64:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420aa6b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aa6e:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420aa74:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aa7b:	00 00 00 
  800420aa7e:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420aa85:	83 e2 07             	and    $0x7,%edx
  800420aa88:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420aa8e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aa95:	00 00 00 
  800420aa98:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420aa9f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aaa2:	83 ca 0e             	or     $0xe,%edx
  800420aaa5:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420aaab:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aab2:	00 00 00 
  800420aab5:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420aabc:	83 e2 ef             	and    $0xffffffef,%edx
  800420aabf:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420aac5:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aacc:	00 00 00 
  800420aacf:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420aad6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aad9:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420aadf:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aae6:	00 00 00 
  800420aae9:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420aaf0:	83 ca 80             	or     $0xffffff80,%edx
  800420aaf3:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420aaf9:	48 b8 74 cd 20 04 80 	movabs $0x800420cd74,%rax
  800420ab00:	00 00 00 
  800420ab03:	48 c1 e8 10          	shr    $0x10,%rax
  800420ab07:	89 c2                	mov    %eax,%edx
  800420ab09:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ab10:	00 00 00 
  800420ab13:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420ab1a:	48 b8 74 cd 20 04 80 	movabs $0x800420cd74,%rax
  800420ab21:	00 00 00 
  800420ab24:	48 c1 e8 20          	shr    $0x20,%rax
  800420ab28:	89 c2                	mov    %eax,%edx
  800420ab2a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ab31:	00 00 00 
  800420ab34:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420ab3a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ab41:	00 00 00 
  800420ab44:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420ab4b:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+6], 0, GD_KT, XTRPX_IRQ6, 0);
  800420ab4e:	48 b8 7a cd 20 04 80 	movabs $0x800420cd7a,%rax
  800420ab55:	00 00 00 
  800420ab58:	89 c2                	mov    %eax,%edx
  800420ab5a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ab61:	00 00 00 
  800420ab64:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420ab6b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ab72:	00 00 00 
  800420ab75:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420ab7c:	08 00 
  800420ab7e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ab85:	00 00 00 
  800420ab88:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420ab8f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ab92:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420ab98:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ab9f:	00 00 00 
  800420aba2:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420aba9:	83 e2 07             	and    $0x7,%edx
  800420abac:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420abb2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420abb9:	00 00 00 
  800420abbc:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420abc3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420abc6:	83 ca 0e             	or     $0xe,%edx
  800420abc9:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420abcf:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420abd6:	00 00 00 
  800420abd9:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420abe0:	83 e2 ef             	and    $0xffffffef,%edx
  800420abe3:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420abe9:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420abf0:	00 00 00 
  800420abf3:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420abfa:	83 e2 9f             	and    $0xffffff9f,%edx
  800420abfd:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420ac03:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ac0a:	00 00 00 
  800420ac0d:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420ac14:	83 ca 80             	or     $0xffffff80,%edx
  800420ac17:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420ac1d:	48 b8 7a cd 20 04 80 	movabs $0x800420cd7a,%rax
  800420ac24:	00 00 00 
  800420ac27:	48 c1 e8 10          	shr    $0x10,%rax
  800420ac2b:	89 c2                	mov    %eax,%edx
  800420ac2d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ac34:	00 00 00 
  800420ac37:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420ac3e:	48 b8 7a cd 20 04 80 	movabs $0x800420cd7a,%rax
  800420ac45:	00 00 00 
  800420ac48:	48 c1 e8 20          	shr    $0x20,%rax
  800420ac4c:	89 c2                	mov    %eax,%edx
  800420ac4e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ac55:	00 00 00 
  800420ac58:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420ac5e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ac65:	00 00 00 
  800420ac68:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420ac6f:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_SPURIOUS], 0, GD_KT, XTRPX_IRQ7, 0);
  800420ac72:	48 b8 80 cd 20 04 80 	movabs $0x800420cd80,%rax
  800420ac79:	00 00 00 
  800420ac7c:	89 c2                	mov    %eax,%edx
  800420ac7e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ac85:	00 00 00 
  800420ac88:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420ac8f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ac96:	00 00 00 
  800420ac99:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420aca0:	08 00 
  800420aca2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aca9:	00 00 00 
  800420acac:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420acb3:	83 e2 f8             	and    $0xfffffff8,%edx
  800420acb6:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420acbc:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420acc3:	00 00 00 
  800420acc6:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420accd:	83 e2 07             	and    $0x7,%edx
  800420acd0:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420acd6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420acdd:	00 00 00 
  800420ace0:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ace7:	83 e2 f0             	and    $0xfffffff0,%edx
  800420acea:	83 ca 0e             	or     $0xe,%edx
  800420aced:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420acf3:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420acfa:	00 00 00 
  800420acfd:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ad04:	83 e2 ef             	and    $0xffffffef,%edx
  800420ad07:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ad0d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ad14:	00 00 00 
  800420ad17:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ad1e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ad21:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ad27:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ad2e:	00 00 00 
  800420ad31:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ad38:	83 ca 80             	or     $0xffffff80,%edx
  800420ad3b:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ad41:	48 b8 80 cd 20 04 80 	movabs $0x800420cd80,%rax
  800420ad48:	00 00 00 
  800420ad4b:	48 c1 e8 10          	shr    $0x10,%rax
  800420ad4f:	89 c2                	mov    %eax,%edx
  800420ad51:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ad58:	00 00 00 
  800420ad5b:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420ad62:	48 b8 80 cd 20 04 80 	movabs $0x800420cd80,%rax
  800420ad69:	00 00 00 
  800420ad6c:	48 c1 e8 20          	shr    $0x20,%rax
  800420ad70:	89 c2                	mov    %eax,%edx
  800420ad72:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ad79:	00 00 00 
  800420ad7c:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420ad82:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ad89:	00 00 00 
  800420ad8c:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420ad93:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+8], 0, GD_KT, XTRPX_IRQ8, 0);
  800420ad96:	48 b8 86 cd 20 04 80 	movabs $0x800420cd86,%rax
  800420ad9d:	00 00 00 
  800420ada0:	89 c2                	mov    %eax,%edx
  800420ada2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ada9:	00 00 00 
  800420adac:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420adb3:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420adba:	00 00 00 
  800420adbd:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420adc4:	08 00 
  800420adc6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420adcd:	00 00 00 
  800420add0:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420add7:	83 e2 f8             	and    $0xfffffff8,%edx
  800420adda:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420ade0:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ade7:	00 00 00 
  800420adea:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420adf1:	83 e2 07             	and    $0x7,%edx
  800420adf4:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420adfa:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ae01:	00 00 00 
  800420ae04:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420ae0b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ae0e:	83 ca 0e             	or     $0xe,%edx
  800420ae11:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420ae17:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ae1e:	00 00 00 
  800420ae21:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420ae28:	83 e2 ef             	and    $0xffffffef,%edx
  800420ae2b:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420ae31:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ae38:	00 00 00 
  800420ae3b:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420ae42:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ae45:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420ae4b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ae52:	00 00 00 
  800420ae55:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420ae5c:	83 ca 80             	or     $0xffffff80,%edx
  800420ae5f:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420ae65:	48 b8 86 cd 20 04 80 	movabs $0x800420cd86,%rax
  800420ae6c:	00 00 00 
  800420ae6f:	48 c1 e8 10          	shr    $0x10,%rax
  800420ae73:	89 c2                	mov    %eax,%edx
  800420ae75:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ae7c:	00 00 00 
  800420ae7f:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420ae86:	48 b8 86 cd 20 04 80 	movabs $0x800420cd86,%rax
  800420ae8d:	00 00 00 
  800420ae90:	48 c1 e8 20          	shr    $0x20,%rax
  800420ae94:	89 c2                	mov    %eax,%edx
  800420ae96:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420ae9d:	00 00 00 
  800420aea0:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420aea6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aead:	00 00 00 
  800420aeb0:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420aeb7:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+9], 0, GD_KT, XTRPX_IRQ9, 0);
  800420aeba:	48 b8 8c cd 20 04 80 	movabs $0x800420cd8c,%rax
  800420aec1:	00 00 00 
  800420aec4:	89 c2                	mov    %eax,%edx
  800420aec6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aecd:	00 00 00 
  800420aed0:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420aed7:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aede:	00 00 00 
  800420aee1:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420aee8:	08 00 
  800420aeea:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aef1:	00 00 00 
  800420aef4:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420aefb:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aefe:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420af04:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420af0b:	00 00 00 
  800420af0e:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420af15:	83 e2 07             	and    $0x7,%edx
  800420af18:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420af1e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420af25:	00 00 00 
  800420af28:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420af2f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420af32:	83 ca 0e             	or     $0xe,%edx
  800420af35:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420af3b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420af42:	00 00 00 
  800420af45:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420af4c:	83 e2 ef             	and    $0xffffffef,%edx
  800420af4f:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420af55:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420af5c:	00 00 00 
  800420af5f:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420af66:	83 e2 9f             	and    $0xffffff9f,%edx
  800420af69:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420af6f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420af76:	00 00 00 
  800420af79:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420af80:	83 ca 80             	or     $0xffffff80,%edx
  800420af83:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420af89:	48 b8 8c cd 20 04 80 	movabs $0x800420cd8c,%rax
  800420af90:	00 00 00 
  800420af93:	48 c1 e8 10          	shr    $0x10,%rax
  800420af97:	89 c2                	mov    %eax,%edx
  800420af99:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420afa0:	00 00 00 
  800420afa3:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420afaa:	48 b8 8c cd 20 04 80 	movabs $0x800420cd8c,%rax
  800420afb1:	00 00 00 
  800420afb4:	48 c1 e8 20          	shr    $0x20,%rax
  800420afb8:	89 c2                	mov    %eax,%edx
  800420afba:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420afc1:	00 00 00 
  800420afc4:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420afca:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420afd1:	00 00 00 
  800420afd4:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420afdb:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+10], 0, GD_KT, XTRPX_IRQa, 0);
  800420afde:	48 b8 92 cd 20 04 80 	movabs $0x800420cd92,%rax
  800420afe5:	00 00 00 
  800420afe8:	89 c2                	mov    %eax,%edx
  800420afea:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420aff1:	00 00 00 
  800420aff4:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420affb:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b002:	00 00 00 
  800420b005:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420b00c:	08 00 
  800420b00e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b015:	00 00 00 
  800420b018:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b01f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b022:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b028:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b02f:	00 00 00 
  800420b032:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b039:	83 e2 07             	and    $0x7,%edx
  800420b03c:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b042:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b049:	00 00 00 
  800420b04c:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b053:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b056:	83 ca 0e             	or     $0xe,%edx
  800420b059:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b05f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b066:	00 00 00 
  800420b069:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b070:	83 e2 ef             	and    $0xffffffef,%edx
  800420b073:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b079:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b080:	00 00 00 
  800420b083:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b08a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b08d:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b093:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b09a:	00 00 00 
  800420b09d:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b0a4:	83 ca 80             	or     $0xffffff80,%edx
  800420b0a7:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b0ad:	48 b8 92 cd 20 04 80 	movabs $0x800420cd92,%rax
  800420b0b4:	00 00 00 
  800420b0b7:	48 c1 e8 10          	shr    $0x10,%rax
  800420b0bb:	89 c2                	mov    %eax,%edx
  800420b0bd:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b0c4:	00 00 00 
  800420b0c7:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420b0ce:	48 b8 92 cd 20 04 80 	movabs $0x800420cd92,%rax
  800420b0d5:	00 00 00 
  800420b0d8:	48 c1 e8 20          	shr    $0x20,%rax
  800420b0dc:	89 c2                	mov    %eax,%edx
  800420b0de:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b0e5:	00 00 00 
  800420b0e8:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420b0ee:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b0f5:	00 00 00 
  800420b0f8:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420b0ff:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+11], 0, GD_KT, XTRPX_IRQb, 0);
  800420b102:	48 b8 98 cd 20 04 80 	movabs $0x800420cd98,%rax
  800420b109:	00 00 00 
  800420b10c:	89 c2                	mov    %eax,%edx
  800420b10e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b115:	00 00 00 
  800420b118:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420b11f:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b126:	00 00 00 
  800420b129:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420b130:	08 00 
  800420b132:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b139:	00 00 00 
  800420b13c:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b143:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b146:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b14c:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b153:	00 00 00 
  800420b156:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b15d:	83 e2 07             	and    $0x7,%edx
  800420b160:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b166:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b16d:	00 00 00 
  800420b170:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b177:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b17a:	83 ca 0e             	or     $0xe,%edx
  800420b17d:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b183:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b18a:	00 00 00 
  800420b18d:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b194:	83 e2 ef             	and    $0xffffffef,%edx
  800420b197:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b19d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b1a4:	00 00 00 
  800420b1a7:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b1ae:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b1b1:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b1b7:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b1be:	00 00 00 
  800420b1c1:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b1c8:	83 ca 80             	or     $0xffffff80,%edx
  800420b1cb:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b1d1:	48 b8 98 cd 20 04 80 	movabs $0x800420cd98,%rax
  800420b1d8:	00 00 00 
  800420b1db:	48 c1 e8 10          	shr    $0x10,%rax
  800420b1df:	89 c2                	mov    %eax,%edx
  800420b1e1:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b1e8:	00 00 00 
  800420b1eb:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420b1f2:	48 b8 98 cd 20 04 80 	movabs $0x800420cd98,%rax
  800420b1f9:	00 00 00 
  800420b1fc:	48 c1 e8 20          	shr    $0x20,%rax
  800420b200:	89 c2                	mov    %eax,%edx
  800420b202:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b209:	00 00 00 
  800420b20c:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420b212:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b219:	00 00 00 
  800420b21c:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420b223:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+12], 0, GD_KT, XTRPX_IRQc, 0);
  800420b226:	48 b8 9e cd 20 04 80 	movabs $0x800420cd9e,%rax
  800420b22d:	00 00 00 
  800420b230:	89 c2                	mov    %eax,%edx
  800420b232:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b239:	00 00 00 
  800420b23c:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420b243:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b24a:	00 00 00 
  800420b24d:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420b254:	08 00 
  800420b256:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b25d:	00 00 00 
  800420b260:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b267:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b26a:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b270:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b277:	00 00 00 
  800420b27a:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b281:	83 e2 07             	and    $0x7,%edx
  800420b284:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b28a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b291:	00 00 00 
  800420b294:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b29b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b29e:	83 ca 0e             	or     $0xe,%edx
  800420b2a1:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b2a7:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b2ae:	00 00 00 
  800420b2b1:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b2b8:	83 e2 ef             	and    $0xffffffef,%edx
  800420b2bb:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b2c1:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b2c8:	00 00 00 
  800420b2cb:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b2d2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b2d5:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b2db:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b2e2:	00 00 00 
  800420b2e5:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b2ec:	83 ca 80             	or     $0xffffff80,%edx
  800420b2ef:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b2f5:	48 b8 9e cd 20 04 80 	movabs $0x800420cd9e,%rax
  800420b2fc:	00 00 00 
  800420b2ff:	48 c1 e8 10          	shr    $0x10,%rax
  800420b303:	89 c2                	mov    %eax,%edx
  800420b305:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b30c:	00 00 00 
  800420b30f:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420b316:	48 b8 9e cd 20 04 80 	movabs $0x800420cd9e,%rax
  800420b31d:	00 00 00 
  800420b320:	48 c1 e8 20          	shr    $0x20,%rax
  800420b324:	89 c2                	mov    %eax,%edx
  800420b326:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b32d:	00 00 00 
  800420b330:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420b336:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b33d:	00 00 00 
  800420b340:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420b347:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+13], 0, GD_KT, XTRPX_IRQd, 0);
  800420b34a:	48 b8 a4 cd 20 04 80 	movabs $0x800420cda4,%rax
  800420b351:	00 00 00 
  800420b354:	89 c2                	mov    %eax,%edx
  800420b356:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b35d:	00 00 00 
  800420b360:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420b367:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b36e:	00 00 00 
  800420b371:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420b378:	08 00 
  800420b37a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b381:	00 00 00 
  800420b384:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420b38b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b38e:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420b394:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b39b:	00 00 00 
  800420b39e:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420b3a5:	83 e2 07             	and    $0x7,%edx
  800420b3a8:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420b3ae:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b3b5:	00 00 00 
  800420b3b8:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b3bf:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b3c2:	83 ca 0e             	or     $0xe,%edx
  800420b3c5:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b3cb:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b3d2:	00 00 00 
  800420b3d5:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b3dc:	83 e2 ef             	and    $0xffffffef,%edx
  800420b3df:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b3e5:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b3ec:	00 00 00 
  800420b3ef:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b3f6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b3f9:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b3ff:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b406:	00 00 00 
  800420b409:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b410:	83 ca 80             	or     $0xffffff80,%edx
  800420b413:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b419:	48 b8 a4 cd 20 04 80 	movabs $0x800420cda4,%rax
  800420b420:	00 00 00 
  800420b423:	48 c1 e8 10          	shr    $0x10,%rax
  800420b427:	89 c2                	mov    %eax,%edx
  800420b429:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b430:	00 00 00 
  800420b433:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420b43a:	48 b8 a4 cd 20 04 80 	movabs $0x800420cda4,%rax
  800420b441:	00 00 00 
  800420b444:	48 c1 e8 20          	shr    $0x20,%rax
  800420b448:	89 c2                	mov    %eax,%edx
  800420b44a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b451:	00 00 00 
  800420b454:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420b45a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b461:	00 00 00 
  800420b464:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420b46b:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_IDE], 0, GD_KT, XTRPX_IRQe, 0);
  800420b46e:	48 b8 aa cd 20 04 80 	movabs $0x800420cdaa,%rax
  800420b475:	00 00 00 
  800420b478:	89 c2                	mov    %eax,%edx
  800420b47a:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b481:	00 00 00 
  800420b484:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420b48b:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b492:	00 00 00 
  800420b495:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420b49c:	08 00 
  800420b49e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b4a5:	00 00 00 
  800420b4a8:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420b4af:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b4b2:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420b4b8:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b4bf:	00 00 00 
  800420b4c2:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420b4c9:	83 e2 07             	and    $0x7,%edx
  800420b4cc:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420b4d2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b4d9:	00 00 00 
  800420b4dc:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b4e3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b4e6:	83 ca 0e             	or     $0xe,%edx
  800420b4e9:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b4ef:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b4f6:	00 00 00 
  800420b4f9:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b500:	83 e2 ef             	and    $0xffffffef,%edx
  800420b503:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b509:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b510:	00 00 00 
  800420b513:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b51a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b51d:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b523:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b52a:	00 00 00 
  800420b52d:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b534:	83 ca 80             	or     $0xffffff80,%edx
  800420b537:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b53d:	48 b8 aa cd 20 04 80 	movabs $0x800420cdaa,%rax
  800420b544:	00 00 00 
  800420b547:	48 c1 e8 10          	shr    $0x10,%rax
  800420b54b:	89 c2                	mov    %eax,%edx
  800420b54d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b554:	00 00 00 
  800420b557:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420b55e:	48 b8 aa cd 20 04 80 	movabs $0x800420cdaa,%rax
  800420b565:	00 00 00 
  800420b568:	48 c1 e8 20          	shr    $0x20,%rax
  800420b56c:	89 c2                	mov    %eax,%edx
  800420b56e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b575:	00 00 00 
  800420b578:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420b57e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b585:	00 00 00 
  800420b588:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420b58f:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+15], 0, GD_KT, XTRPX_IRQf, 0);
  800420b592:	48 b8 b0 cd 20 04 80 	movabs $0x800420cdb0,%rax
  800420b599:	00 00 00 
  800420b59c:	89 c2                	mov    %eax,%edx
  800420b59e:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b5a5:	00 00 00 
  800420b5a8:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420b5af:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b5b6:	00 00 00 
  800420b5b9:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420b5c0:	08 00 
  800420b5c2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b5c9:	00 00 00 
  800420b5cc:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420b5d3:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b5d6:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420b5dc:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b5e3:	00 00 00 
  800420b5e6:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420b5ed:	83 e2 07             	and    $0x7,%edx
  800420b5f0:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420b5f6:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b5fd:	00 00 00 
  800420b600:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b607:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b60a:	83 ca 0e             	or     $0xe,%edx
  800420b60d:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b613:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b61a:	00 00 00 
  800420b61d:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b624:	83 e2 ef             	and    $0xffffffef,%edx
  800420b627:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b62d:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b634:	00 00 00 
  800420b637:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b63e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b641:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b647:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b64e:	00 00 00 
  800420b651:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b658:	83 ca 80             	or     $0xffffff80,%edx
  800420b65b:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b661:	48 b8 b0 cd 20 04 80 	movabs $0x800420cdb0,%rax
  800420b668:	00 00 00 
  800420b66b:	48 c1 e8 10          	shr    $0x10,%rax
  800420b66f:	89 c2                	mov    %eax,%edx
  800420b671:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b678:	00 00 00 
  800420b67b:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420b682:	48 b8 b0 cd 20 04 80 	movabs $0x800420cdb0,%rax
  800420b689:	00 00 00 
  800420b68c:	48 c1 e8 20          	shr    $0x20,%rax
  800420b690:	89 c2                	mov    %eax,%edx
  800420b692:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b699:	00 00 00 
  800420b69c:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420b6a2:	48 b8 80 72 60 04 80 	movabs $0x8004607280,%rax
  800420b6a9:	00 00 00 
  800420b6ac:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420b6b3:	00 00 00 
	
    idt_pd.pd_lim = sizeof(idt)-1;
  800420b6b6:	48 b8 80 82 60 04 80 	movabs $0x8004608280,%rax
  800420b6bd:	00 00 00 
  800420b6c0:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
    idt_pd.pd_base = (uint64_t)idt;
  800420b6c5:	48 ba 80 72 60 04 80 	movabs $0x8004607280,%rdx
  800420b6cc:	00 00 00 
  800420b6cf:	48 b8 80 82 60 04 80 	movabs $0x8004608280,%rax
  800420b6d6:	00 00 00 
  800420b6d9:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420b6dd:	48 b8 eb b6 20 04 80 	movabs $0x800420b6eb,%rax
  800420b6e4:	00 00 00 
  800420b6e7:	ff d0                	callq  *%rax
}
  800420b6e9:	5d                   	pop    %rbp
  800420b6ea:	c3                   	retq   

000000800420b6eb <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420b6eb:	55                   	push   %rbp
  800420b6ec:	48 89 e5             	mov    %rsp,%rbp
  800420b6ef:	53                   	push   %rbx
  800420b6f0:	48 83 ec 18          	sub    $0x18,%rsp
	// LAB 4: Your code here:


	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP + thiscpu->cpu_id * (KSTKSIZE+KSTKGAP);
  800420b6f4:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420b6fb:	00 00 00 
  800420b6fe:	ff d0                	callq  *%rax
  800420b700:	89 c3                	mov    %eax,%ebx
  800420b702:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420b709:	00 00 00 
  800420b70c:	ff d0                	callq  *%rax
  800420b70e:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420b715:	00 00 00 
  800420b718:	48 98                	cltq   
  800420b71a:	48 c1 e0 03          	shl    $0x3,%rax
  800420b71e:	48 89 c2             	mov    %rax,%rdx
  800420b721:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b725:	48 29 c2             	sub    %rax,%rdx
  800420b728:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b72c:	0f b6 00             	movzbl (%rax),%eax
  800420b72f:	0f b6 d0             	movzbl %al,%edx
  800420b732:	89 d0                	mov    %edx,%eax
  800420b734:	01 c0                	add    %eax,%eax
  800420b736:	01 d0                	add    %edx,%eax
  800420b738:	c1 e0 0f             	shl    $0xf,%eax
  800420b73b:	48 63 d0             	movslq %eax,%rdx
  800420b73e:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420b745:	00 00 00 
  800420b748:	48 01 d0             	add    %rdx,%rax
  800420b74b:	48 89 c1             	mov    %rax,%rcx
  800420b74e:	48 be 20 a0 60 04 80 	movabs $0x800460a020,%rsi
  800420b755:	00 00 00 
  800420b758:	48 63 c3             	movslq %ebx,%rax
  800420b75b:	48 c1 e0 03          	shl    $0x3,%rax
  800420b75f:	48 89 c2             	mov    %rax,%rdx
  800420b762:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b766:	48 29 c2             	sub    %rax,%rdx
  800420b769:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  800420b76d:	48 83 c0 10          	add    $0x10,%rax
  800420b771:	48 89 48 04          	mov    %rcx,0x4(%rax)
	//	thiscpu->cpu_ts.ts_ss0 = GD_KD;
	// Initialize the TSS slot of the gdt.
	SETTSS((struct SystemSegdesc64 *) (&gdt[(GD_TSS0>>3) + (thiscpu->cpu_id*2)]),STS_T64A,
  800420b775:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420b77c:	00 00 00 
  800420b77f:	ff d0                	callq  *%rax
  800420b781:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420b788:	00 00 00 
  800420b78b:	48 98                	cltq   
  800420b78d:	48 c1 e0 03          	shl    $0x3,%rax
  800420b791:	48 89 c2             	mov    %rax,%rdx
  800420b794:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b798:	48 29 c2             	sub    %rax,%rdx
  800420b79b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b79f:	0f b6 00             	movzbl (%rax),%eax
  800420b7a2:	0f b6 c0             	movzbl %al,%eax
  800420b7a5:	01 c0                	add    %eax,%eax
  800420b7a7:	83 c0 05             	add    $0x5,%eax
  800420b7aa:	48 98                	cltq   
  800420b7ac:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b7b3:	00 
  800420b7b4:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420b7bb:	00 00 00 
  800420b7be:	48 01 d0             	add    %rdx,%rax
  800420b7c1:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420b7c6:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420b7cd:	00 00 00 
  800420b7d0:	ff d0                	callq  *%rax
  800420b7d2:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420b7d9:	00 00 00 
  800420b7dc:	48 98                	cltq   
  800420b7de:	48 c1 e0 03          	shl    $0x3,%rax
  800420b7e2:	48 89 c2             	mov    %rax,%rdx
  800420b7e5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b7e9:	48 29 c2             	sub    %rax,%rdx
  800420b7ec:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b7f0:	0f b6 00             	movzbl (%rax),%eax
  800420b7f3:	0f b6 c0             	movzbl %al,%eax
  800420b7f6:	01 c0                	add    %eax,%eax
  800420b7f8:	83 c0 05             	add    $0x5,%eax
  800420b7fb:	48 98                	cltq   
  800420b7fd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b804:	00 
  800420b805:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420b80c:	00 00 00 
  800420b80f:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420b813:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420b81a:	00 00 00 
  800420b81d:	ff d0                	callq  *%rax
  800420b81f:	48 98                	cltq   
  800420b821:	48 c1 e0 03          	shl    $0x3,%rax
  800420b825:	48 89 c2             	mov    %rax,%rdx
  800420b828:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b82c:	48 29 c2             	sub    %rax,%rdx
  800420b82f:	48 83 c2 10          	add    $0x10,%rdx
  800420b833:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  800420b83a:	00 00 00 
  800420b83d:	48 01 d0             	add    %rdx,%rax
  800420b840:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420b844:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420b84b:	00 00 00 
  800420b84e:	ff d0                	callq  *%rax
  800420b850:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420b857:	00 00 00 
  800420b85a:	48 98                	cltq   
  800420b85c:	48 c1 e0 03          	shl    $0x3,%rax
  800420b860:	48 89 c2             	mov    %rax,%rdx
  800420b863:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b867:	48 29 c2             	sub    %rax,%rdx
  800420b86a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b86e:	0f b6 00             	movzbl (%rax),%eax
  800420b871:	0f b6 c0             	movzbl %al,%eax
  800420b874:	01 c0                	add    %eax,%eax
  800420b876:	83 c0 05             	add    $0x5,%eax
  800420b879:	48 98                	cltq   
  800420b87b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b882:	00 
  800420b883:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420b88a:	00 00 00 
  800420b88d:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420b891:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420b898:	00 00 00 
  800420b89b:	ff d0                	callq  *%rax
  800420b89d:	48 98                	cltq   
  800420b89f:	48 c1 e0 03          	shl    $0x3,%rax
  800420b8a3:	48 89 c2             	mov    %rax,%rdx
  800420b8a6:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b8aa:	48 29 c2             	sub    %rax,%rdx
  800420b8ad:	48 83 c2 10          	add    $0x10,%rdx
  800420b8b1:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  800420b8b8:	00 00 00 
  800420b8bb:	48 01 d0             	add    %rdx,%rax
  800420b8be:	48 c1 e8 10          	shr    $0x10,%rax
  800420b8c2:	88 43 04             	mov    %al,0x4(%rbx)
  800420b8c5:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420b8cc:	00 00 00 
  800420b8cf:	ff d0                	callq  *%rax
  800420b8d1:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420b8d8:	00 00 00 
  800420b8db:	48 98                	cltq   
  800420b8dd:	48 c1 e0 03          	shl    $0x3,%rax
  800420b8e1:	48 89 c2             	mov    %rax,%rdx
  800420b8e4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b8e8:	48 29 c2             	sub    %rax,%rdx
  800420b8eb:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b8ef:	0f b6 00             	movzbl (%rax),%eax
  800420b8f2:	0f b6 c0             	movzbl %al,%eax
  800420b8f5:	01 c0                	add    %eax,%eax
  800420b8f7:	83 c0 05             	add    $0x5,%eax
  800420b8fa:	48 98                	cltq   
  800420b8fc:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b903:	00 
  800420b904:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420b90b:	00 00 00 
  800420b90e:	48 01 d0             	add    %rdx,%rax
  800420b911:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b915:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b918:	83 ca 09             	or     $0x9,%edx
  800420b91b:	88 50 05             	mov    %dl,0x5(%rax)
  800420b91e:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420b925:	00 00 00 
  800420b928:	ff d0                	callq  *%rax
  800420b92a:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420b931:	00 00 00 
  800420b934:	48 98                	cltq   
  800420b936:	48 c1 e0 03          	shl    $0x3,%rax
  800420b93a:	48 89 c2             	mov    %rax,%rdx
  800420b93d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b941:	48 29 c2             	sub    %rax,%rdx
  800420b944:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b948:	0f b6 00             	movzbl (%rax),%eax
  800420b94b:	0f b6 c0             	movzbl %al,%eax
  800420b94e:	01 c0                	add    %eax,%eax
  800420b950:	83 c0 05             	add    $0x5,%eax
  800420b953:	48 98                	cltq   
  800420b955:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b95c:	00 
  800420b95d:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420b964:	00 00 00 
  800420b967:	48 01 d0             	add    %rdx,%rax
  800420b96a:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b96e:	83 e2 ef             	and    $0xffffffef,%edx
  800420b971:	88 50 05             	mov    %dl,0x5(%rax)
  800420b974:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420b97b:	00 00 00 
  800420b97e:	ff d0                	callq  *%rax
  800420b980:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420b987:	00 00 00 
  800420b98a:	48 98                	cltq   
  800420b98c:	48 c1 e0 03          	shl    $0x3,%rax
  800420b990:	48 89 c2             	mov    %rax,%rdx
  800420b993:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b997:	48 29 c2             	sub    %rax,%rdx
  800420b99a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b99e:	0f b6 00             	movzbl (%rax),%eax
  800420b9a1:	0f b6 c0             	movzbl %al,%eax
  800420b9a4:	01 c0                	add    %eax,%eax
  800420b9a6:	83 c0 05             	add    $0x5,%eax
  800420b9a9:	48 98                	cltq   
  800420b9ab:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b9b2:	00 
  800420b9b3:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420b9ba:	00 00 00 
  800420b9bd:	48 01 d0             	add    %rdx,%rax
  800420b9c0:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b9c4:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b9c7:	88 50 05             	mov    %dl,0x5(%rax)
  800420b9ca:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420b9d1:	00 00 00 
  800420b9d4:	ff d0                	callq  *%rax
  800420b9d6:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420b9dd:	00 00 00 
  800420b9e0:	48 98                	cltq   
  800420b9e2:	48 c1 e0 03          	shl    $0x3,%rax
  800420b9e6:	48 89 c2             	mov    %rax,%rdx
  800420b9e9:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b9ed:	48 29 c2             	sub    %rax,%rdx
  800420b9f0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420b9f4:	0f b6 00             	movzbl (%rax),%eax
  800420b9f7:	0f b6 c0             	movzbl %al,%eax
  800420b9fa:	01 c0                	add    %eax,%eax
  800420b9fc:	83 c0 05             	add    $0x5,%eax
  800420b9ff:	48 98                	cltq   
  800420ba01:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ba08:	00 
  800420ba09:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420ba10:	00 00 00 
  800420ba13:	48 01 d0             	add    %rdx,%rax
  800420ba16:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420ba1a:	83 ca 80             	or     $0xffffff80,%edx
  800420ba1d:	88 50 05             	mov    %dl,0x5(%rax)
  800420ba20:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420ba27:	00 00 00 
  800420ba2a:	ff d0                	callq  *%rax
  800420ba2c:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420ba33:	00 00 00 
  800420ba36:	48 98                	cltq   
  800420ba38:	48 c1 e0 03          	shl    $0x3,%rax
  800420ba3c:	48 89 c2             	mov    %rax,%rdx
  800420ba3f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ba43:	48 29 c2             	sub    %rax,%rdx
  800420ba46:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ba4a:	0f b6 00             	movzbl (%rax),%eax
  800420ba4d:	0f b6 c0             	movzbl %al,%eax
  800420ba50:	01 c0                	add    %eax,%eax
  800420ba52:	83 c0 05             	add    $0x5,%eax
  800420ba55:	48 98                	cltq   
  800420ba57:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ba5e:	00 
  800420ba5f:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420ba66:	00 00 00 
  800420ba69:	48 01 d0             	add    %rdx,%rax
  800420ba6c:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420ba70:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ba73:	88 50 06             	mov    %dl,0x6(%rax)
  800420ba76:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420ba7d:	00 00 00 
  800420ba80:	ff d0                	callq  *%rax
  800420ba82:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420ba89:	00 00 00 
  800420ba8c:	48 98                	cltq   
  800420ba8e:	48 c1 e0 03          	shl    $0x3,%rax
  800420ba92:	48 89 c2             	mov    %rax,%rdx
  800420ba95:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ba99:	48 29 c2             	sub    %rax,%rdx
  800420ba9c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420baa0:	0f b6 00             	movzbl (%rax),%eax
  800420baa3:	0f b6 c0             	movzbl %al,%eax
  800420baa6:	01 c0                	add    %eax,%eax
  800420baa8:	83 c0 05             	add    $0x5,%eax
  800420baab:	48 98                	cltq   
  800420baad:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bab4:	00 
  800420bab5:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420babc:	00 00 00 
  800420babf:	48 01 d0             	add    %rdx,%rax
  800420bac2:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420bac6:	83 e2 ef             	and    $0xffffffef,%edx
  800420bac9:	88 50 06             	mov    %dl,0x6(%rax)
  800420bacc:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420bad3:	00 00 00 
  800420bad6:	ff d0                	callq  *%rax
  800420bad8:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420badf:	00 00 00 
  800420bae2:	48 98                	cltq   
  800420bae4:	48 c1 e0 03          	shl    $0x3,%rax
  800420bae8:	48 89 c2             	mov    %rax,%rdx
  800420baeb:	48 c1 e2 04          	shl    $0x4,%rdx
  800420baef:	48 29 c2             	sub    %rax,%rdx
  800420baf2:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420baf6:	0f b6 00             	movzbl (%rax),%eax
  800420baf9:	0f b6 c0             	movzbl %al,%eax
  800420bafc:	01 c0                	add    %eax,%eax
  800420bafe:	83 c0 05             	add    $0x5,%eax
  800420bb01:	48 98                	cltq   
  800420bb03:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bb0a:	00 
  800420bb0b:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420bb12:	00 00 00 
  800420bb15:	48 01 d0             	add    %rdx,%rax
  800420bb18:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420bb1c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bb1f:	88 50 06             	mov    %dl,0x6(%rax)
  800420bb22:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420bb29:	00 00 00 
  800420bb2c:	ff d0                	callq  *%rax
  800420bb2e:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420bb35:	00 00 00 
  800420bb38:	48 98                	cltq   
  800420bb3a:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb3e:	48 89 c2             	mov    %rax,%rdx
  800420bb41:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bb45:	48 29 c2             	sub    %rax,%rdx
  800420bb48:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bb4c:	0f b6 00             	movzbl (%rax),%eax
  800420bb4f:	0f b6 c0             	movzbl %al,%eax
  800420bb52:	01 c0                	add    %eax,%eax
  800420bb54:	83 c0 05             	add    $0x5,%eax
  800420bb57:	48 98                	cltq   
  800420bb59:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bb60:	00 
  800420bb61:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420bb68:	00 00 00 
  800420bb6b:	48 01 d0             	add    %rdx,%rax
  800420bb6e:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420bb72:	83 e2 7f             	and    $0x7f,%edx
  800420bb75:	88 50 06             	mov    %dl,0x6(%rax)
  800420bb78:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420bb7f:	00 00 00 
  800420bb82:	ff d0                	callq  *%rax
  800420bb84:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420bb8b:	00 00 00 
  800420bb8e:	48 98                	cltq   
  800420bb90:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb94:	48 89 c2             	mov    %rax,%rdx
  800420bb97:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bb9b:	48 29 c2             	sub    %rax,%rdx
  800420bb9e:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bba2:	0f b6 00             	movzbl (%rax),%eax
  800420bba5:	0f b6 c0             	movzbl %al,%eax
  800420bba8:	01 c0                	add    %eax,%eax
  800420bbaa:	83 c0 05             	add    $0x5,%eax
  800420bbad:	48 98                	cltq   
  800420bbaf:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bbb6:	00 
  800420bbb7:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420bbbe:	00 00 00 
  800420bbc1:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420bbc5:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420bbcc:	00 00 00 
  800420bbcf:	ff d0                	callq  *%rax
  800420bbd1:	48 98                	cltq   
  800420bbd3:	48 c1 e0 03          	shl    $0x3,%rax
  800420bbd7:	48 89 c2             	mov    %rax,%rdx
  800420bbda:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bbde:	48 29 c2             	sub    %rax,%rdx
  800420bbe1:	48 83 c2 10          	add    $0x10,%rdx
  800420bbe5:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  800420bbec:	00 00 00 
  800420bbef:	48 01 d0             	add    %rdx,%rax
  800420bbf2:	48 c1 e8 18          	shr    $0x18,%rax
  800420bbf6:	88 43 07             	mov    %al,0x7(%rbx)
  800420bbf9:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420bc00:	00 00 00 
  800420bc03:	ff d0                	callq  *%rax
  800420bc05:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420bc0c:	00 00 00 
  800420bc0f:	48 98                	cltq   
  800420bc11:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc15:	48 89 c2             	mov    %rax,%rdx
  800420bc18:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc1c:	48 29 c2             	sub    %rax,%rdx
  800420bc1f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bc23:	0f b6 00             	movzbl (%rax),%eax
  800420bc26:	0f b6 c0             	movzbl %al,%eax
  800420bc29:	01 c0                	add    %eax,%eax
  800420bc2b:	83 c0 05             	add    $0x5,%eax
  800420bc2e:	48 98                	cltq   
  800420bc30:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bc37:	00 
  800420bc38:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420bc3f:	00 00 00 
  800420bc42:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420bc46:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420bc4d:	00 00 00 
  800420bc50:	ff d0                	callq  *%rax
  800420bc52:	48 98                	cltq   
  800420bc54:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc58:	48 89 c2             	mov    %rax,%rdx
  800420bc5b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc5f:	48 29 c2             	sub    %rax,%rdx
  800420bc62:	48 83 c2 10          	add    $0x10,%rdx
  800420bc66:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  800420bc6d:	00 00 00 
  800420bc70:	48 01 d0             	add    %rdx,%rax
  800420bc73:	48 c1 e8 20          	shr    $0x20,%rax
  800420bc77:	89 43 08             	mov    %eax,0x8(%rbx)
  800420bc7a:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420bc81:	00 00 00 
  800420bc84:	ff d0                	callq  *%rax
  800420bc86:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420bc8d:	00 00 00 
  800420bc90:	48 98                	cltq   
  800420bc92:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc96:	48 89 c2             	mov    %rax,%rdx
  800420bc99:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bc9d:	48 29 c2             	sub    %rax,%rdx
  800420bca0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bca4:	0f b6 00             	movzbl (%rax),%eax
  800420bca7:	0f b6 c0             	movzbl %al,%eax
  800420bcaa:	01 c0                	add    %eax,%eax
  800420bcac:	83 c0 05             	add    $0x5,%eax
  800420bcaf:	48 98                	cltq   
  800420bcb1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bcb8:	00 
  800420bcb9:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420bcc0:	00 00 00 
  800420bcc3:	48 01 d0             	add    %rdx,%rax
  800420bcc6:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420bcca:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420bcd1:	00 00 00 
  800420bcd4:	ff d0                	callq  *%rax
  800420bcd6:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420bcdd:	00 00 00 
  800420bce0:	48 98                	cltq   
  800420bce2:	48 c1 e0 03          	shl    $0x3,%rax
  800420bce6:	48 89 c2             	mov    %rax,%rdx
  800420bce9:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bced:	48 29 c2             	sub    %rax,%rdx
  800420bcf0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bcf4:	0f b6 00             	movzbl (%rax),%eax
  800420bcf7:	0f b6 c0             	movzbl %al,%eax
  800420bcfa:	01 c0                	add    %eax,%eax
  800420bcfc:	83 c0 05             	add    $0x5,%eax
  800420bcff:	48 98                	cltq   
  800420bd01:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bd08:	00 
  800420bd09:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420bd10:	00 00 00 
  800420bd13:	48 01 d0             	add    %rdx,%rax
  800420bd16:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420bd1a:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420bd21:	00 00 00 
  800420bd24:	ff d0                	callq  *%rax
  800420bd26:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420bd2d:	00 00 00 
  800420bd30:	48 98                	cltq   
  800420bd32:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd36:	48 89 c2             	mov    %rax,%rdx
  800420bd39:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd3d:	48 29 c2             	sub    %rax,%rdx
  800420bd40:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bd44:	0f b6 00             	movzbl (%rax),%eax
  800420bd47:	0f b6 c0             	movzbl %al,%eax
  800420bd4a:	01 c0                	add    %eax,%eax
  800420bd4c:	83 c0 05             	add    $0x5,%eax
  800420bd4f:	48 98                	cltq   
  800420bd51:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bd58:	00 
  800420bd59:	48 b8 e0 d5 22 04 80 	movabs $0x800422d5e0,%rax
  800420bd60:	00 00 00 
  800420bd63:	48 01 d0             	add    %rdx,%rax
  800420bd66:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
				(uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)
	ltr(((GD_TSS0>>3) + (thiscpu->cpu_id*2))*8);
  800420bd6c:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420bd73:	00 00 00 
  800420bd76:	ff d0                	callq  *%rax
  800420bd78:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420bd7f:	00 00 00 
  800420bd82:	48 98                	cltq   
  800420bd84:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd88:	48 89 c2             	mov    %rax,%rdx
  800420bd8b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd8f:	48 29 c2             	sub    %rax,%rdx
  800420bd92:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420bd96:	0f b6 00             	movzbl (%rax),%eax
  800420bd99:	0f b6 c0             	movzbl %al,%eax
  800420bd9c:	c1 e0 04             	shl    $0x4,%eax
  800420bd9f:	83 c0 28             	add    $0x28,%eax
  800420bda2:	0f b7 c0             	movzwl %ax,%eax
  800420bda5:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420bda9:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  800420bdad:	0f 00 d8             	ltr    %ax
  800420bdb0:	48 b8 80 82 60 04 80 	movabs $0x8004608280,%rax
  800420bdb7:	00 00 00 
  800420bdba:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420bdbe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420bdc2:	0f 01 18             	lidt   (%rax)

	// Load the IDT
	lidt(&idt_pd);
}
  800420bdc5:	48 83 c4 18          	add    $0x18,%rsp
  800420bdc9:	5b                   	pop    %rbx
  800420bdca:	5d                   	pop    %rbp
  800420bdcb:	c3                   	retq   

000000800420bdcc <print_trapframe>:
void
print_trapframe(struct Trapframe *tf)
{
  800420bdcc:	55                   	push   %rbp
  800420bdcd:	48 89 e5             	mov    %rsp,%rbp
  800420bdd0:	48 83 ec 20          	sub    $0x20,%rsp
  800420bdd4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420bdd8:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420bddf:	00 00 00 
  800420bde2:	ff d0                	callq  *%rax
  800420bde4:	89 c2                	mov    %eax,%edx
  800420bde6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bdea:	48 89 c6             	mov    %rax,%rsi
  800420bded:	48 bf ce 94 21 04 80 	movabs $0x80042194ce,%rdi
  800420bdf4:	00 00 00 
  800420bdf7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bdfc:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  800420be03:	00 00 00 
  800420be06:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420be08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be0c:	48 89 c7             	mov    %rax,%rdi
  800420be0f:	48 b8 dd c0 20 04 80 	movabs $0x800420c0dd,%rax
  800420be16:	00 00 00 
  800420be19:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420be1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be1f:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420be23:	0f b7 c0             	movzwl %ax,%eax
  800420be26:	89 c6                	mov    %eax,%esi
  800420be28:	48 bf ec 94 21 04 80 	movabs $0x80042194ec,%rdi
  800420be2f:	00 00 00 
  800420be32:	b8 00 00 00 00       	mov    $0x0,%eax
  800420be37:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420be3e:	00 00 00 
  800420be41:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420be43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be47:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420be4e:	0f b7 c0             	movzwl %ax,%eax
  800420be51:	89 c6                	mov    %eax,%esi
  800420be53:	48 bf ff 94 21 04 80 	movabs $0x80042194ff,%rdi
  800420be5a:	00 00 00 
  800420be5d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420be62:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420be69:	00 00 00 
  800420be6c:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420be6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be72:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420be79:	89 c7                	mov    %eax,%edi
  800420be7b:	48 b8 dc 8e 20 04 80 	movabs $0x8004208edc,%rax
  800420be82:	00 00 00 
  800420be85:	ff d0                	callq  *%rax
  800420be87:	48 89 c2             	mov    %rax,%rdx
  800420be8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420be8e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420be95:	48 89 c6             	mov    %rax,%rsi
  800420be98:	48 bf 12 95 21 04 80 	movabs $0x8004219512,%rdi
  800420be9f:	00 00 00 
  800420bea2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bea7:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  800420beae:	00 00 00 
  800420beb1:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420beb3:	48 b8 90 82 60 04 80 	movabs $0x8004608290,%rax
  800420beba:	00 00 00 
  800420bebd:	48 8b 00             	mov    (%rax),%rax
  800420bec0:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420bec4:	75 3a                	jne    800420bf00 <print_trapframe+0x134>
  800420bec6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420beca:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420bed1:	48 83 f8 0e          	cmp    $0xe,%rax
  800420bed5:	75 29                	jne    800420bf00 <print_trapframe+0x134>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420bed7:	0f 20 d0             	mov    %cr2,%rax
  800420beda:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800420bede:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420bee2:	48 89 c6             	mov    %rax,%rsi
  800420bee5:	48 bf 24 95 21 04 80 	movabs $0x8004219524,%rdi
  800420beec:	00 00 00 
  800420beef:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bef4:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420befb:	00 00 00 
  800420befe:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420bf00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf04:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420bf0b:	48 89 c6             	mov    %rax,%rsi
  800420bf0e:	48 bf 33 95 21 04 80 	movabs $0x8004219533,%rdi
  800420bf15:	00 00 00 
  800420bf18:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bf1d:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420bf24:	00 00 00 
  800420bf27:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420bf29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf2d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420bf34:	48 83 f8 0e          	cmp    $0xe,%rax
  800420bf38:	0f 85 9c 00 00 00    	jne    800420bfda <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420bf3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf42:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420bf49:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420bf4c:	48 85 c0             	test   %rax,%rax
  800420bf4f:	74 0c                	je     800420bf5d <print_trapframe+0x191>
  800420bf51:	48 b9 41 95 21 04 80 	movabs $0x8004219541,%rcx
  800420bf58:	00 00 00 
  800420bf5b:	eb 0a                	jmp    800420bf67 <print_trapframe+0x19b>
  800420bf5d:	48 b9 4c 95 21 04 80 	movabs $0x800421954c,%rcx
  800420bf64:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420bf67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf6b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420bf72:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420bf75:	48 85 c0             	test   %rax,%rax
  800420bf78:	74 0c                	je     800420bf86 <print_trapframe+0x1ba>
  800420bf7a:	48 ba 58 95 21 04 80 	movabs $0x8004219558,%rdx
  800420bf81:	00 00 00 
  800420bf84:	eb 0a                	jmp    800420bf90 <print_trapframe+0x1c4>
  800420bf86:	48 ba 5e 95 21 04 80 	movabs $0x800421955e,%rdx
  800420bf8d:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420bf90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf94:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420bf9b:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420bf9e:	48 85 c0             	test   %rax,%rax
  800420bfa1:	74 0c                	je     800420bfaf <print_trapframe+0x1e3>
  800420bfa3:	48 b8 63 95 21 04 80 	movabs $0x8004219563,%rax
  800420bfaa:	00 00 00 
  800420bfad:	eb 0a                	jmp    800420bfb9 <print_trapframe+0x1ed>
  800420bfaf:	48 b8 68 95 21 04 80 	movabs $0x8004219568,%rax
  800420bfb6:	00 00 00 
  800420bfb9:	48 89 c6             	mov    %rax,%rsi
  800420bfbc:	48 bf 6f 95 21 04 80 	movabs $0x800421956f,%rdi
  800420bfc3:	00 00 00 
  800420bfc6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bfcb:	49 b8 c3 8d 20 04 80 	movabs $0x8004208dc3,%r8
  800420bfd2:	00 00 00 
  800420bfd5:	41 ff d0             	callq  *%r8
  800420bfd8:	eb 1b                	jmp    800420bff5 <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420bfda:	48 bf 7e 95 21 04 80 	movabs $0x800421957e,%rdi
  800420bfe1:	00 00 00 
  800420bfe4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bfe9:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420bff0:	00 00 00 
  800420bff3:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420bff5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bff9:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420c000:	48 89 c6             	mov    %rax,%rsi
  800420c003:	48 bf 80 95 21 04 80 	movabs $0x8004219580,%rdi
  800420c00a:	00 00 00 
  800420c00d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c012:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c019:	00 00 00 
  800420c01c:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420c01e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c022:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c029:	0f b7 c0             	movzwl %ax,%eax
  800420c02c:	89 c6                	mov    %eax,%esi
  800420c02e:	48 bf 8f 95 21 04 80 	movabs $0x800421958f,%rdi
  800420c035:	00 00 00 
  800420c038:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c03d:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c044:	00 00 00 
  800420c047:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420c049:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c04d:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420c054:	48 89 c6             	mov    %rax,%rsi
  800420c057:	48 bf a2 95 21 04 80 	movabs $0x80042195a2,%rdi
  800420c05e:	00 00 00 
  800420c061:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c066:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c06d:	00 00 00 
  800420c070:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420c072:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c076:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c07d:	0f b7 c0             	movzwl %ax,%eax
  800420c080:	83 e0 03             	and    $0x3,%eax
  800420c083:	85 c0                	test   %eax,%eax
  800420c085:	74 54                	je     800420c0db <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420c087:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c08b:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420c092:	48 89 c6             	mov    %rax,%rsi
  800420c095:	48 bf b1 95 21 04 80 	movabs $0x80042195b1,%rdi
  800420c09c:	00 00 00 
  800420c09f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c0a4:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c0ab:	00 00 00 
  800420c0ae:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420c0b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c0b4:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420c0bb:	0f b7 c0             	movzwl %ax,%eax
  800420c0be:	89 c6                	mov    %eax,%esi
  800420c0c0:	48 bf c0 95 21 04 80 	movabs $0x80042195c0,%rdi
  800420c0c7:	00 00 00 
  800420c0ca:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c0cf:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c0d6:	00 00 00 
  800420c0d9:	ff d2                	callq  *%rdx
	}
}
  800420c0db:	c9                   	leaveq 
  800420c0dc:	c3                   	retq   

000000800420c0dd <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420c0dd:	55                   	push   %rbp
  800420c0de:	48 89 e5             	mov    %rsp,%rbp
  800420c0e1:	48 83 ec 10          	sub    $0x10,%rsp
  800420c0e5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420c0e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c0ed:	48 8b 00             	mov    (%rax),%rax
  800420c0f0:	48 89 c6             	mov    %rax,%rsi
  800420c0f3:	48 bf d3 95 21 04 80 	movabs $0x80042195d3,%rdi
  800420c0fa:	00 00 00 
  800420c0fd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c102:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c109:	00 00 00 
  800420c10c:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420c10e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c112:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c116:	48 89 c6             	mov    %rax,%rsi
  800420c119:	48 bf e2 95 21 04 80 	movabs $0x80042195e2,%rdi
  800420c120:	00 00 00 
  800420c123:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c128:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c12f:	00 00 00 
  800420c132:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420c134:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c138:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420c13c:	48 89 c6             	mov    %rax,%rsi
  800420c13f:	48 bf f1 95 21 04 80 	movabs $0x80042195f1,%rdi
  800420c146:	00 00 00 
  800420c149:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c14e:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c155:	00 00 00 
  800420c158:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420c15a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c15e:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420c162:	48 89 c6             	mov    %rax,%rsi
  800420c165:	48 bf 00 96 21 04 80 	movabs $0x8004219600,%rdi
  800420c16c:	00 00 00 
  800420c16f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c174:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c17b:	00 00 00 
  800420c17e:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420c180:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c184:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420c188:	48 89 c6             	mov    %rax,%rsi
  800420c18b:	48 bf 0f 96 21 04 80 	movabs $0x800421960f,%rdi
  800420c192:	00 00 00 
  800420c195:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c19a:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c1a1:	00 00 00 
  800420c1a4:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420c1a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c1aa:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c1ae:	48 89 c6             	mov    %rax,%rsi
  800420c1b1:	48 bf 1e 96 21 04 80 	movabs $0x800421961e,%rdi
  800420c1b8:	00 00 00 
  800420c1bb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c1c0:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c1c7:	00 00 00 
  800420c1ca:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420c1cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c1d0:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420c1d4:	48 89 c6             	mov    %rax,%rsi
  800420c1d7:	48 bf 2d 96 21 04 80 	movabs $0x800421962d,%rdi
  800420c1de:	00 00 00 
  800420c1e1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c1e6:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c1ed:	00 00 00 
  800420c1f0:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420c1f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c1f6:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420c1fa:	48 89 c6             	mov    %rax,%rsi
  800420c1fd:	48 bf 3b 96 21 04 80 	movabs $0x800421963b,%rdi
  800420c204:	00 00 00 
  800420c207:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c20c:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c213:	00 00 00 
  800420c216:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420c218:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c21c:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420c220:	48 89 c6             	mov    %rax,%rsi
  800420c223:	48 bf 49 96 21 04 80 	movabs $0x8004219649,%rdi
  800420c22a:	00 00 00 
  800420c22d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c232:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c239:	00 00 00 
  800420c23c:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420c23e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c242:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420c246:	48 89 c6             	mov    %rax,%rsi
  800420c249:	48 bf 58 96 21 04 80 	movabs $0x8004219658,%rdi
  800420c250:	00 00 00 
  800420c253:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c258:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c25f:	00 00 00 
  800420c262:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420c264:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c268:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420c26c:	48 89 c6             	mov    %rax,%rsi
  800420c26f:	48 bf 67 96 21 04 80 	movabs $0x8004219667,%rdi
  800420c276:	00 00 00 
  800420c279:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c27e:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c285:	00 00 00 
  800420c288:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420c28a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c28e:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420c292:	48 89 c6             	mov    %rax,%rsi
  800420c295:	48 bf 76 96 21 04 80 	movabs $0x8004219676,%rdi
  800420c29c:	00 00 00 
  800420c29f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2a4:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c2ab:	00 00 00 
  800420c2ae:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420c2b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c2b4:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420c2b8:	48 89 c6             	mov    %rax,%rsi
  800420c2bb:	48 bf 85 96 21 04 80 	movabs $0x8004219685,%rdi
  800420c2c2:	00 00 00 
  800420c2c5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2ca:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c2d1:	00 00 00 
  800420c2d4:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420c2d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c2da:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420c2de:	48 89 c6             	mov    %rax,%rsi
  800420c2e1:	48 bf 94 96 21 04 80 	movabs $0x8004219694,%rdi
  800420c2e8:	00 00 00 
  800420c2eb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2f0:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c2f7:	00 00 00 
  800420c2fa:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420c2fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c300:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c304:	48 89 c6             	mov    %rax,%rsi
  800420c307:	48 bf a3 96 21 04 80 	movabs $0x80042196a3,%rdi
  800420c30e:	00 00 00 
  800420c311:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c316:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c31d:	00 00 00 
  800420c320:	ff d2                	callq  *%rdx
}
  800420c322:	c9                   	leaveq 
  800420c323:	c3                   	retq   

000000800420c324 <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420c324:	55                   	push   %rbp
  800420c325:	48 89 e5             	mov    %rsp,%rbp
  800420c328:	48 83 ec 10          	sub    $0x10,%rsp
  800420c32c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Handle processor exceptions.
	// LAB 3: Your code here.
	//print_trapframe(tf);
	if(tf->tf_trapno == T_PGFLT)
  800420c330:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c334:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c33b:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c33f:	75 18                	jne    800420c359 <trap_dispatch+0x35>
    {
        page_fault_handler(tf);
  800420c341:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c345:	48 89 c7             	mov    %rax,%rdi
  800420c348:	48 b8 ab c8 20 04 80 	movabs $0x800420c8ab,%rax
  800420c34f:	00 00 00 
  800420c352:	ff d0                	callq  *%rax
  800420c354:	e9 8c 00 00 00       	jmpq   800420c3e5 <trap_dispatch+0xc1>
    }
    else if(tf->tf_trapno == T_BRKPT)
  800420c359:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c35d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c364:	48 83 f8 03          	cmp    $0x3,%rax
  800420c368:	75 15                	jne    800420c37f <trap_dispatch+0x5b>
    {
        monitor(tf);
  800420c36a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c36e:	48 89 c7             	mov    %rax,%rdi
  800420c371:	48 b8 2e 1b 20 04 80 	movabs $0x8004201b2e,%rax
  800420c378:	00 00 00 
  800420c37b:	ff d0                	callq  *%rax
  800420c37d:	eb 66                	jmp    800420c3e5 <trap_dispatch+0xc1>
    }
    else if(tf->tf_trapno == T_SYSCALL)
  800420c37f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c383:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c38a:	48 83 f8 30          	cmp    $0x30,%rax
  800420c38e:	75 55                	jne    800420c3e5 <trap_dispatch+0xc1>
    {
        tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, tf->tf_regs.reg_rdx,
  800420c390:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c394:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420c398:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c39c:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420c3a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3a4:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420c3a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3ac:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420c3b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3b4:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420c3b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3bc:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c3c0:	4d 89 c1             	mov    %r8,%r9
  800420c3c3:	49 89 f8             	mov    %rdi,%r8
  800420c3c6:	48 89 c7             	mov    %rax,%rdi
  800420c3c9:	48 b8 2c dc 20 04 80 	movabs $0x800420dc2c,%rax
  800420c3d0:	00 00 00 
  800420c3d3:	ff d0                	callq  *%rax
  800420c3d5:	48 89 c2             	mov    %rax,%rdx
  800420c3d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3dc:	48 89 50 70          	mov    %rdx,0x70(%rax)
                        tf->tf_regs.reg_rcx, tf->tf_regs.reg_rbx,
                        tf->tf_regs.reg_rdi, tf->tf_regs.reg_rsi);
        return;
  800420c3e0:	e9 5a 01 00 00       	jmpq   800420c53f <trap_dispatch+0x21b>
    }

	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420c3e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3e9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c3f0:	48 83 f8 27          	cmp    $0x27,%rax
  800420c3f4:	75 33                	jne    800420c429 <trap_dispatch+0x105>
		cprintf("Spurious interrupt on irq 7\n");
  800420c3f6:	48 bf b2 96 21 04 80 	movabs $0x80042196b2,%rdi
  800420c3fd:	00 00 00 
  800420c400:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c405:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c40c:	00 00 00 
  800420c40f:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420c411:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c415:	48 89 c7             	mov    %rax,%rdi
  800420c418:	48 b8 cc bd 20 04 80 	movabs $0x800420bdcc,%rax
  800420c41f:	00 00 00 
  800420c422:	ff d0                	callq  *%rax
		return;
  800420c424:	e9 16 01 00 00       	jmpq   800420c53f <trap_dispatch+0x21b>
	// triggered on every CPU.
	// LAB 6: Your code here.

	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_TIMER))
  800420c429:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c42d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c434:	48 83 f8 20          	cmp    $0x20,%rax
  800420c438:	75 24                	jne    800420c45e <trap_dispatch+0x13a>
	{
		time_tick();
  800420c43a:	48 b8 41 80 21 04 80 	movabs $0x8004218041,%rax
  800420c441:	00 00 00 
  800420c444:	ff d0                	callq  *%rax
		lapic_eoi();
  800420c446:	48 b8 5e 69 21 04 80 	movabs $0x800421695e,%rax
  800420c44d:	00 00 00 
  800420c450:	ff d0                	callq  *%rax
		sched_yield();
  800420c452:	48 b8 c9 ce 20 04 80 	movabs $0x800420cec9,%rax
  800420c459:	00 00 00 
  800420c45c:	ff d0                	callq  *%rax
	}
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_KBD))
  800420c45e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c462:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c469:	48 83 f8 21          	cmp    $0x21,%rax
  800420c46d:	75 18                	jne    800420c487 <trap_dispatch+0x163>
	{
		kbd_intr();
  800420c46f:	48 b8 26 10 20 04 80 	movabs $0x8004201026,%rax
  800420c476:	00 00 00 
  800420c479:	ff d0                	callq  *%rax
		sched_yield();
  800420c47b:	48 b8 c9 ce 20 04 80 	movabs $0x800420cec9,%rax
  800420c482:	00 00 00 
  800420c485:	ff d0                	callq  *%rax
	}
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_SERIAL))
  800420c487:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c48b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c492:	48 83 f8 24          	cmp    $0x24,%rax
  800420c496:	75 18                	jne    800420c4b0 <trap_dispatch+0x18c>
	{
		serial_intr();
  800420c498:	48 b8 d7 07 20 04 80 	movabs $0x80042007d7,%rax
  800420c49f:	00 00 00 
  800420c4a2:	ff d0                	callq  *%rax
		sched_yield();
  800420c4a4:	48 b8 c9 ce 20 04 80 	movabs $0x800420cec9,%rax
  800420c4ab:	00 00 00 
  800420c4ae:	ff d0                	callq  *%rax
	}
	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420c4b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4b4:	48 89 c7             	mov    %rax,%rdi
  800420c4b7:	48 b8 cc bd 20 04 80 	movabs $0x800420bdcc,%rax
  800420c4be:	00 00 00 
  800420c4c1:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420c4c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4c7:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c4ce:	66 83 f8 08          	cmp    $0x8,%ax
  800420c4d2:	75 2a                	jne    800420c4fe <trap_dispatch+0x1da>
		panic("unhandled trap in kernel");
  800420c4d4:	48 ba cf 96 21 04 80 	movabs $0x80042196cf,%rdx
  800420c4db:	00 00 00 
  800420c4de:	be 15 01 00 00       	mov    $0x115,%esi
  800420c4e3:	48 bf e8 96 21 04 80 	movabs $0x80042196e8,%rdi
  800420c4ea:	00 00 00 
  800420c4ed:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c4f2:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  800420c4f9:	00 00 00 
  800420c4fc:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420c4fe:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c505:	00 00 00 
  800420c508:	ff d0                	callq  *%rax
  800420c50a:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420c511:	00 00 00 
  800420c514:	48 98                	cltq   
  800420c516:	48 c1 e0 03          	shl    $0x3,%rax
  800420c51a:	48 89 c2             	mov    %rax,%rdx
  800420c51d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c521:	48 29 c2             	sub    %rax,%rdx
  800420c524:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c528:	48 83 c0 08          	add    $0x8,%rax
  800420c52c:	48 8b 00             	mov    (%rax),%rax
  800420c52f:	48 89 c7             	mov    %rax,%rdi
  800420c532:	48 b8 b9 85 20 04 80 	movabs $0x80042085b9,%rax
  800420c539:	00 00 00 
  800420c53c:	ff d0                	callq  *%rax
		return;
  800420c53e:	90                   	nop
	}
}
  800420c53f:	c9                   	leaveq 
  800420c540:	c3                   	retq   

000000800420c541 <trap>:

void
trap(struct Trapframe *tf)
{
  800420c541:	55                   	push   %rbp
  800420c542:	48 89 e5             	mov    %rsp,%rbp
  800420c545:	48 83 ec 20          	sub    $0x20,%rsp
  800420c549:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    //struct Trapframe *tf = &tf_;
	// The environmentmay have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420c54d:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420c54e:	48 b8 60 87 60 04 80 	movabs $0x8004608760,%rax
  800420c555:	00 00 00 
  800420c558:	48 8b 00             	mov    (%rax),%rax
  800420c55b:	48 85 c0             	test   %rax,%rax
  800420c55e:	74 01                	je     800420c561 <trap+0x20>
		asm volatile("hlt");
  800420c560:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420c561:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c568:	00 00 00 
  800420c56b:	ff d0                	callq  *%rax
  800420c56d:	48 98                	cltq   
  800420c56f:	48 c1 e0 03          	shl    $0x3,%rax
  800420c573:	48 89 c2             	mov    %rax,%rdx
  800420c576:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c57a:	48 29 c2             	sub    %rax,%rdx
  800420c57d:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  800420c584:	00 00 00 
  800420c587:	48 01 d0             	add    %rdx,%rax
  800420c58a:	48 83 c0 04          	add    $0x4,%rax
  800420c58e:	be 01 00 00 00       	mov    $0x1,%esi
  800420c593:	48 89 c7             	mov    %rax,%rdi
  800420c596:	48 b8 9b 8e 20 04 80 	movabs $0x8004208e9b,%rax
  800420c59d:	00 00 00 
  800420c5a0:	ff d0                	callq  *%rax
  800420c5a2:	83 f8 02             	cmp    $0x2,%eax
  800420c5a5:	75 0c                	jne    800420c5b3 <trap+0x72>
		lock_kernel();
  800420c5a7:	48 b8 c0 8e 20 04 80 	movabs $0x8004208ec0,%rax
  800420c5ae:	00 00 00 
  800420c5b1:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
	uint64_t rflags;
	__asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420c5b3:	9c                   	pushfq 
  800420c5b4:	58                   	pop    %rax
  800420c5b5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return rflags;
  800420c5b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420c5bd:	25 00 02 00 00       	and    $0x200,%eax
  800420c5c2:	48 85 c0             	test   %rax,%rax
  800420c5c5:	74 35                	je     800420c5fc <trap+0xbb>
  800420c5c7:	48 b9 f4 96 21 04 80 	movabs $0x80042196f4,%rcx
  800420c5ce:	00 00 00 
  800420c5d1:	48 ba 0d 97 21 04 80 	movabs $0x800421970d,%rdx
  800420c5d8:	00 00 00 
  800420c5db:	be 30 01 00 00       	mov    $0x130,%esi
  800420c5e0:	48 bf e8 96 21 04 80 	movabs $0x80042196e8,%rdi
  800420c5e7:	00 00 00 
  800420c5ea:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c5ef:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420c5f6:	00 00 00 
  800420c5f9:	41 ff d0             	callq  *%r8

	if ((tf->tf_cs & 3) == 3) {
  800420c5fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c600:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c607:	0f b7 c0             	movzwl %ax,%eax
  800420c60a:	83 e0 03             	and    $0x3,%eax
  800420c60d:	83 f8 03             	cmp    $0x3,%eax
  800420c610:	0f 85 b3 01 00 00    	jne    800420c7c9 <trap+0x288>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420c616:	48 b8 c0 8e 20 04 80 	movabs $0x8004208ec0,%rax
  800420c61d:	00 00 00 
  800420c620:	ff d0                	callq  *%rax
		assert(curenv);
  800420c622:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c629:	00 00 00 
  800420c62c:	ff d0                	callq  *%rax
  800420c62e:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420c635:	00 00 00 
  800420c638:	48 98                	cltq   
  800420c63a:	48 c1 e0 03          	shl    $0x3,%rax
  800420c63e:	48 89 c2             	mov    %rax,%rdx
  800420c641:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c645:	48 29 c2             	sub    %rax,%rdx
  800420c648:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c64c:	48 83 c0 08          	add    $0x8,%rax
  800420c650:	48 8b 00             	mov    (%rax),%rax
  800420c653:	48 85 c0             	test   %rax,%rax
  800420c656:	75 35                	jne    800420c68d <trap+0x14c>
  800420c658:	48 b9 22 97 21 04 80 	movabs $0x8004219722,%rcx
  800420c65f:	00 00 00 
  800420c662:	48 ba 0d 97 21 04 80 	movabs $0x800421970d,%rdx
  800420c669:	00 00 00 
  800420c66c:	be 38 01 00 00       	mov    $0x138,%esi
  800420c671:	48 bf e8 96 21 04 80 	movabs $0x80042196e8,%rdi
  800420c678:	00 00 00 
  800420c67b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c680:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420c687:	00 00 00 
  800420c68a:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420c68d:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c694:	00 00 00 
  800420c697:	ff d0                	callq  *%rax
  800420c699:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420c6a0:	00 00 00 
  800420c6a3:	48 98                	cltq   
  800420c6a5:	48 c1 e0 03          	shl    $0x3,%rax
  800420c6a9:	48 89 c2             	mov    %rax,%rdx
  800420c6ac:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c6b0:	48 29 c2             	sub    %rax,%rdx
  800420c6b3:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c6b7:	48 83 c0 08          	add    $0x8,%rax
  800420c6bb:	48 8b 00             	mov    (%rax),%rax
  800420c6be:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c6c4:	83 f8 01             	cmp    $0x1,%eax
  800420c6c7:	0f 85 81 00 00 00    	jne    800420c74e <trap+0x20d>
			env_free(curenv);
  800420c6cd:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c6d4:	00 00 00 
  800420c6d7:	ff d0                	callq  *%rax
  800420c6d9:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420c6e0:	00 00 00 
  800420c6e3:	48 98                	cltq   
  800420c6e5:	48 c1 e0 03          	shl    $0x3,%rax
  800420c6e9:	48 89 c2             	mov    %rax,%rdx
  800420c6ec:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c6f0:	48 29 c2             	sub    %rax,%rdx
  800420c6f3:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c6f7:	48 83 c0 08          	add    $0x8,%rax
  800420c6fb:	48 8b 00             	mov    (%rax),%rax
  800420c6fe:	48 89 c7             	mov    %rax,%rdi
  800420c701:	48 b8 2c 81 20 04 80 	movabs $0x800420812c,%rax
  800420c708:	00 00 00 
  800420c70b:	ff d0                	callq  *%rax
			curenv = NULL;
  800420c70d:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c714:	00 00 00 
  800420c717:	ff d0                	callq  *%rax
  800420c719:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420c720:	00 00 00 
  800420c723:	48 98                	cltq   
  800420c725:	48 c1 e0 03          	shl    $0x3,%rax
  800420c729:	48 89 c2             	mov    %rax,%rdx
  800420c72c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c730:	48 29 c2             	sub    %rax,%rdx
  800420c733:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c737:	48 83 c0 08          	add    $0x8,%rax
  800420c73b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420c742:	48 b8 c9 ce 20 04 80 	movabs $0x800420cec9,%rax
  800420c749:	00 00 00 
  800420c74c:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420c74e:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c755:	00 00 00 
  800420c758:	ff d0                	callq  *%rax
  800420c75a:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420c761:	00 00 00 
  800420c764:	48 98                	cltq   
  800420c766:	48 c1 e0 03          	shl    $0x3,%rax
  800420c76a:	48 89 c2             	mov    %rax,%rdx
  800420c76d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c771:	48 29 c2             	sub    %rax,%rdx
  800420c774:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c778:	48 83 c0 08          	add    $0x8,%rax
  800420c77c:	48 8b 10             	mov    (%rax),%rdx
  800420c77f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c783:	48 89 c6             	mov    %rax,%rsi
  800420c786:	b8 18 00 00 00       	mov    $0x18,%eax
  800420c78b:	48 89 d7             	mov    %rdx,%rdi
  800420c78e:	48 89 c1             	mov    %rax,%rcx
  800420c791:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420c794:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c79b:	00 00 00 
  800420c79e:	ff d0                	callq  *%rax
  800420c7a0:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420c7a7:	00 00 00 
  800420c7aa:	48 98                	cltq   
  800420c7ac:	48 c1 e0 03          	shl    $0x3,%rax
  800420c7b0:	48 89 c2             	mov    %rax,%rdx
  800420c7b3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c7b7:	48 29 c2             	sub    %rax,%rdx
  800420c7ba:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c7be:	48 83 c0 08          	add    $0x8,%rax
  800420c7c2:	48 8b 00             	mov    (%rax),%rax
  800420c7c5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420c7c9:	48 b8 90 82 60 04 80 	movabs $0x8004608290,%rax
  800420c7d0:	00 00 00 
  800420c7d3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c7d7:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420c7da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c7de:	48 89 c7             	mov    %rax,%rdi
  800420c7e1:	48 b8 24 c3 20 04 80 	movabs $0x800420c324,%rax
  800420c7e8:	00 00 00 
  800420c7eb:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420c7ed:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c7f4:	00 00 00 
  800420c7f7:	ff d0                	callq  *%rax
  800420c7f9:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420c800:	00 00 00 
  800420c803:	48 98                	cltq   
  800420c805:	48 c1 e0 03          	shl    $0x3,%rax
  800420c809:	48 89 c2             	mov    %rax,%rdx
  800420c80c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c810:	48 29 c2             	sub    %rax,%rdx
  800420c813:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c817:	48 83 c0 08          	add    $0x8,%rax
  800420c81b:	48 8b 00             	mov    (%rax),%rax
  800420c81e:	48 85 c0             	test   %rax,%rax
  800420c821:	74 7c                	je     800420c89f <trap+0x35e>
  800420c823:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c82a:	00 00 00 
  800420c82d:	ff d0                	callq  *%rax
  800420c82f:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420c836:	00 00 00 
  800420c839:	48 98                	cltq   
  800420c83b:	48 c1 e0 03          	shl    $0x3,%rax
  800420c83f:	48 89 c2             	mov    %rax,%rdx
  800420c842:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c846:	48 29 c2             	sub    %rax,%rdx
  800420c849:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c84d:	48 83 c0 08          	add    $0x8,%rax
  800420c851:	48 8b 00             	mov    (%rax),%rax
  800420c854:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c85a:	83 f8 03             	cmp    $0x3,%eax
  800420c85d:	75 40                	jne    800420c89f <trap+0x35e>
		env_run(curenv);
  800420c85f:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c866:	00 00 00 
  800420c869:	ff d0                	callq  *%rax
  800420c86b:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420c872:	00 00 00 
  800420c875:	48 98                	cltq   
  800420c877:	48 c1 e0 03          	shl    $0x3,%rax
  800420c87b:	48 89 c2             	mov    %rax,%rdx
  800420c87e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c882:	48 29 c2             	sub    %rax,%rdx
  800420c885:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c889:	48 83 c0 08          	add    $0x8,%rax
  800420c88d:	48 8b 00             	mov    (%rax),%rax
  800420c890:	48 89 c7             	mov    %rax,%rdi
  800420c893:	48 b8 88 87 20 04 80 	movabs $0x8004208788,%rax
  800420c89a:	00 00 00 
  800420c89d:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420c89f:	48 b8 c9 ce 20 04 80 	movabs $0x800420cec9,%rax
  800420c8a6:	00 00 00 
  800420c8a9:	ff d0                	callq  *%rax

000000800420c8ab <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420c8ab:	55                   	push   %rbp
  800420c8ac:	48 89 e5             	mov    %rsp,%rbp
  800420c8af:	53                   	push   %rbx
  800420c8b0:	48 83 ec 38          	sub    $0x38,%rsp
  800420c8b4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420c8b8:	0f 20 d0             	mov    %cr2,%rax
  800420c8bb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	return val;
  800420c8bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420c8c3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	struct PageInfo *pp;

	// Handle kernel-mode page faults.
	
	// LAB 3: Your code here.
	if((tf->tf_cs & 3) == 0)
  800420c8c7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c8cb:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c8d2:	0f b7 c0             	movzwl %ax,%eax
  800420c8d5:	83 e0 03             	and    $0x3,%eax
  800420c8d8:	85 c0                	test   %eax,%eax
  800420c8da:	75 5f                	jne    800420c93b <page_fault_handler+0x90>
	{
		cprintf("fault_va is [%x]",fault_va);
  800420c8dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c8e0:	48 89 c6             	mov    %rax,%rsi
  800420c8e3:	48 bf 29 97 21 04 80 	movabs $0x8004219729,%rdi
  800420c8ea:	00 00 00 
  800420c8ed:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c8f2:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420c8f9:	00 00 00 
  800420c8fc:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420c8fe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c902:	48 89 c7             	mov    %rax,%rdi
  800420c905:	48 b8 cc bd 20 04 80 	movabs $0x800420bdcc,%rax
  800420c90c:	00 00 00 
  800420c90f:	ff d0                	callq  *%rax
		panic("Page fault hapened in kernel mode");
  800420c911:	48 ba 40 97 21 04 80 	movabs $0x8004219740,%rdx
  800420c918:	00 00 00 
  800420c91b:	be 6b 01 00 00       	mov    $0x16b,%esi
  800420c920:	48 bf e8 96 21 04 80 	movabs $0x80042196e8,%rdi
  800420c927:	00 00 00 
  800420c92a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c92f:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  800420c936:	00 00 00 
  800420c939:	ff d1                	callq  *%rcx
	// LAB 4: Your code here.
	
	/*check if user env has registered a pg fault upcall.*/
		//cprintf("hello1");
	//cprintf("hello2");
    if(curenv->env_pgfault_upcall){
  800420c93b:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c942:	00 00 00 
  800420c945:	ff d0                	callq  *%rax
  800420c947:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420c94e:	00 00 00 
  800420c951:	48 98                	cltq   
  800420c953:	48 c1 e0 03          	shl    $0x3,%rax
  800420c957:	48 89 c2             	mov    %rax,%rdx
  800420c95a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c95e:	48 29 c2             	sub    %rax,%rdx
  800420c961:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c965:	48 83 c0 08          	add    $0x8,%rax
  800420c969:	48 8b 00             	mov    (%rax),%rax
  800420c96c:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420c973:	48 85 c0             	test   %rax,%rax
  800420c976:	0f 84 6e 02 00 00    	je     800420cbea <page_fault_handler+0x33f>
		//user_mem_assert(curenv,(const void *)curenv->env_pgfault_upcall,8,PTE_P|PTE_U);
		user_mem_assert(curenv,(const void *)UXSTACKTOP-PGSIZE,PGSIZE, PTE_W | PTE_U | PTE_P);
  800420c97c:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420c983:	00 00 00 
  800420c986:	ff d0                	callq  *%rax
  800420c988:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420c98f:	00 00 00 
  800420c992:	48 98                	cltq   
  800420c994:	48 c1 e0 03          	shl    $0x3,%rax
  800420c998:	48 89 c2             	mov    %rax,%rdx
  800420c99b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c99f:	48 29 c2             	sub    %rax,%rdx
  800420c9a2:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420c9a6:	48 83 c0 08          	add    $0x8,%rax
  800420c9aa:	48 8b 00             	mov    (%rax),%rax
  800420c9ad:	b9 07 00 00 00       	mov    $0x7,%ecx
  800420c9b2:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420c9b7:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  800420c9bc:	48 89 c7             	mov    %rax,%rdi
  800420c9bf:	48 b8 38 3d 20 04 80 	movabs $0x8004203d38,%rax
  800420c9c6:	00 00 00 
  800420c9c9:	ff d0                	callq  *%rax
		/*If user mem assert returns , then the address is valid for the env*/	
		if(!(tf->tf_rsp < UXSTACKTOP && tf->tf_rsp > UXSTACKTOP-PGSIZE)){
  800420c9cb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c9cf:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420c9d6:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420c9db:	48 39 c2             	cmp    %rax,%rdx
  800420c9de:	77 15                	ja     800420c9f5 <page_fault_handler+0x14a>
  800420c9e0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c9e4:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420c9eb:	b8 00 f0 7f ef       	mov    $0xef7ff000,%eax
  800420c9f0:	48 39 c2             	cmp    %rax,%rdx
  800420c9f3:	77 0b                	ja     800420ca00 <page_fault_handler+0x155>
			/*1st Page Fault*/
			utf = (struct UTrapframe *)(UXSTACKTOP - sizeof(struct UTrapframe));
  800420c9f5:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420c9fa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420c9fe:	eb 73                	jmp    800420ca73 <page_fault_handler+0x1c8>
		}else{
			if(tf->tf_rsp - sizeof(struct UTrapframe) - 8 < (UXSTACKTOP-PGSIZE)){
  800420ca00:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca04:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420ca0b:	48 8d 90 58 ff ff ff 	lea    -0xa8(%rax),%rdx
  800420ca12:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420ca17:	48 39 c2             	cmp    %rax,%rdx
  800420ca1a:	77 42                	ja     800420ca5e <page_fault_handler+0x1b3>
				env_destroy(curenv);
  800420ca1c:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420ca23:	00 00 00 
  800420ca26:	ff d0                	callq  *%rax
  800420ca28:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420ca2f:	00 00 00 
  800420ca32:	48 98                	cltq   
  800420ca34:	48 c1 e0 03          	shl    $0x3,%rax
  800420ca38:	48 89 c2             	mov    %rax,%rdx
  800420ca3b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ca3f:	48 29 c2             	sub    %rax,%rdx
  800420ca42:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420ca46:	48 83 c0 08          	add    $0x8,%rax
  800420ca4a:	48 8b 00             	mov    (%rax),%rax
  800420ca4d:	48 89 c7             	mov    %rax,%rdi
  800420ca50:	48 b8 b9 85 20 04 80 	movabs $0x80042085b9,%rax
  800420ca57:	00 00 00 
  800420ca5a:	ff d0                	callq  *%rax
  800420ca5c:	eb 15                	jmp    800420ca73 <page_fault_handler+0x1c8>
			}
			else
			{
				utf = (struct UTrapframe *)(tf->tf_rsp - sizeof(struct UTrapframe) - 8);
  800420ca5e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca62:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420ca69:	48 2d a8 00 00 00    	sub    $0xa8,%rax
  800420ca6f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			/*Nested Page Fault*/
			
		}
		/*Populate the Utrapframe*/
		//user_mem_assert(curenv,(const void *)utf,sizeof(struct UTrapframe),PTE_W|PTE_U);
		utf->utf_eflags = tf->tf_eflags;
  800420ca73:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca77:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420ca7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca82:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
		utf->utf_err = tf->tf_err;
  800420ca89:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca8d:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420ca94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca98:	48 89 50 08          	mov    %rdx,0x8(%rax)
		utf->utf_fault_va = fault_va;
  800420ca9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420caa0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420caa4:	48 89 10             	mov    %rdx,(%rax)
		utf->utf_regs = tf->tf_regs;
  800420caa7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420caab:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420caaf:	48 8b 0a             	mov    (%rdx),%rcx
  800420cab2:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420cab6:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420caba:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420cabe:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420cac2:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420cac6:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420caca:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420cace:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420cad2:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420cad6:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420cada:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420cade:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420cae2:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420cae6:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420caea:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420caee:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420caf2:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420caf6:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420cafa:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420cafe:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420cb02:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420cb06:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420cb0a:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420cb0e:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420cb12:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420cb16:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420cb1a:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420cb1e:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420cb22:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		utf->utf_rip = tf->tf_rip;
  800420cb29:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cb2d:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420cb34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb38:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		utf->utf_rsp = tf->tf_rsp;
  800420cb3f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cb43:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420cb4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb4e:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rip = (uint64_t)curenv->env_pgfault_upcall;
  800420cb55:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420cb5c:	00 00 00 
  800420cb5f:	ff d0                	callq  *%rax
  800420cb61:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420cb68:	00 00 00 
  800420cb6b:	48 98                	cltq   
  800420cb6d:	48 c1 e0 03          	shl    $0x3,%rax
  800420cb71:	48 89 c2             	mov    %rax,%rdx
  800420cb74:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cb78:	48 29 c2             	sub    %rax,%rdx
  800420cb7b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cb7f:	48 83 c0 08          	add    $0x8,%rax
  800420cb83:	48 8b 00             	mov    (%rax),%rax
  800420cb86:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420cb8d:	48 89 c2             	mov    %rax,%rdx
  800420cb90:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cb94:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rsp = (uint64_t)utf;
  800420cb9b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cb9f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cba3:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
		

		
		env_run(curenv);
  800420cbaa:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420cbb1:	00 00 00 
  800420cbb4:	ff d0                	callq  *%rax
  800420cbb6:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420cbbd:	00 00 00 
  800420cbc0:	48 98                	cltq   
  800420cbc2:	48 c1 e0 03          	shl    $0x3,%rax
  800420cbc6:	48 89 c2             	mov    %rax,%rdx
  800420cbc9:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cbcd:	48 29 c2             	sub    %rax,%rdx
  800420cbd0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cbd4:	48 83 c0 08          	add    $0x8,%rax
  800420cbd8:	48 8b 00             	mov    (%rax),%rax
  800420cbdb:	48 89 c7             	mov    %rax,%rdi
  800420cbde:	48 b8 88 87 20 04 80 	movabs $0x8004208788,%rax
  800420cbe5:	00 00 00 
  800420cbe8:	ff d0                	callq  *%rax
	
    }else{
		// Destroy the environment that caused the fault.
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420cbea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cbee:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
			curenv->env_id, fault_va, tf->tf_rip);
  800420cbf5:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420cbfc:	00 00 00 
  800420cbff:	ff d0                	callq  *%rax
  800420cc01:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420cc08:	00 00 00 
  800420cc0b:	48 98                	cltq   
  800420cc0d:	48 c1 e0 03          	shl    $0x3,%rax
  800420cc11:	48 89 c2             	mov    %rax,%rdx
  800420cc14:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cc18:	48 29 c2             	sub    %rax,%rdx
  800420cc1b:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cc1f:	48 83 c0 08          	add    $0x8,%rax
  800420cc23:	48 8b 00             	mov    (%rax),%rax
		
		env_run(curenv);
	
    }else{
		// Destroy the environment that caused the fault.
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420cc26:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420cc2c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cc30:	48 89 d9             	mov    %rbx,%rcx
  800420cc33:	89 c6                	mov    %eax,%esi
  800420cc35:	48 bf 68 97 21 04 80 	movabs $0x8004219768,%rdi
  800420cc3c:	00 00 00 
  800420cc3f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc44:	49 b8 c3 8d 20 04 80 	movabs $0x8004208dc3,%r8
  800420cc4b:	00 00 00 
  800420cc4e:	41 ff d0             	callq  *%r8
			curenv->env_id, fault_va, tf->tf_rip);
		print_trapframe(tf);
  800420cc51:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cc55:	48 89 c7             	mov    %rax,%rdi
  800420cc58:	48 b8 cc bd 20 04 80 	movabs $0x800420bdcc,%rax
  800420cc5f:	00 00 00 
  800420cc62:	ff d0                	callq  *%rax
		env_destroy(curenv);
  800420cc64:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420cc6b:	00 00 00 
  800420cc6e:	ff d0                	callq  *%rax
  800420cc70:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420cc77:	00 00 00 
  800420cc7a:	48 98                	cltq   
  800420cc7c:	48 c1 e0 03          	shl    $0x3,%rax
  800420cc80:	48 89 c2             	mov    %rax,%rdx
  800420cc83:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cc87:	48 29 c2             	sub    %rax,%rdx
  800420cc8a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cc8e:	48 83 c0 08          	add    $0x8,%rax
  800420cc92:	48 8b 00             	mov    (%rax),%rax
  800420cc95:	48 89 c7             	mov    %rax,%rdi
  800420cc98:	48 b8 b9 85 20 04 80 	movabs $0x80042085b9,%rax
  800420cc9f:	00 00 00 
  800420cca2:	ff d0                	callq  *%rax
    }
}
  800420cca4:	48 83 c4 38          	add    $0x38,%rsp
  800420cca8:	5b                   	pop    %rbx
  800420cca9:	5d                   	pop    %rbp
  800420ccaa:	c3                   	retq   
  800420ccab:	90                   	nop

000000800420ccac <XTRPX_divzero>:
 * Lab 3: Your code here for generating entry points for the different traps.
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */

	TRAPHANDLER_NOEC(XTRPX_divzero, T_DIVIDE)
  800420ccac:	6a 00                	pushq  $0x0
  800420ccae:	6a 00                	pushq  $0x0
  800420ccb0:	e9 01 01 00 00       	jmpq   800420cdb6 <_alltraps>
  800420ccb5:	90                   	nop

000000800420ccb6 <XTRPX_Debug>:
	TRAPHANDLER_NOEC(XTRPX_Debug, T_DEBUG)
  800420ccb6:	6a 00                	pushq  $0x0
  800420ccb8:	6a 01                	pushq  $0x1
  800420ccba:	e9 f7 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420ccbf:	90                   	nop

000000800420ccc0 <XTRPX_NonMaskI>:
	TRAPHANDLER_NOEC(XTRPX_NonMaskI, T_NMI)
  800420ccc0:	6a 00                	pushq  $0x0
  800420ccc2:	6a 02                	pushq  $0x2
  800420ccc4:	e9 ed 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420ccc9:	90                   	nop

000000800420ccca <XTRPX_Brkpt>:
	TRAPHANDLER_NOEC(XTRPX_Brkpt, T_BRKPT)
  800420ccca:	6a 00                	pushq  $0x0
  800420cccc:	6a 03                	pushq  $0x3
  800420ccce:	e9 e3 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420ccd3:	90                   	nop

000000800420ccd4 <XTRPX_OFlow>:
	TRAPHANDLER_NOEC(XTRPX_OFlow, T_OFLOW)
  800420ccd4:	6a 00                	pushq  $0x0
  800420ccd6:	6a 04                	pushq  $0x4
  800420ccd8:	e9 d9 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420ccdd:	90                   	nop

000000800420ccde <XTRPX_Bound>:
	TRAPHANDLER_NOEC(XTRPX_Bound, T_BOUND)
  800420ccde:	6a 00                	pushq  $0x0
  800420cce0:	6a 05                	pushq  $0x5
  800420cce2:	e9 cf 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420cce7:	90                   	nop

000000800420cce8 <XTRPX_Illop>:
	TRAPHANDLER_NOEC(XTRPX_Illop, T_ILLOP)
  800420cce8:	6a 00                	pushq  $0x0
  800420ccea:	6a 06                	pushq  $0x6
  800420ccec:	e9 c5 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420ccf1:	90                   	nop

000000800420ccf2 <XTRPX_Device>:
	TRAPHANDLER_NOEC(XTRPX_Device, T_DEVICE)
  800420ccf2:	6a 00                	pushq  $0x0
  800420ccf4:	6a 07                	pushq  $0x7
  800420ccf6:	e9 bb 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420ccfb:	90                   	nop

000000800420ccfc <XTRPX_DblFlt>:
	TRAPHANDLER(XTRPX_DblFlt, T_DBLFLT)
  800420ccfc:	6a 08                	pushq  $0x8
  800420ccfe:	e9 b3 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420cd03:	90                   	nop

000000800420cd04 <XTRPX_Tss>:
	TRAPHANDLER(XTRPX_Tss, T_TSS)
  800420cd04:	6a 0a                	pushq  $0xa
  800420cd06:	e9 ab 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420cd0b:	90                   	nop

000000800420cd0c <XTRPX_Segnp>:
	TRAPHANDLER(XTRPX_Segnp, T_SEGNP)
  800420cd0c:	6a 0b                	pushq  $0xb
  800420cd0e:	e9 a3 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420cd13:	90                   	nop

000000800420cd14 <XTRPX_Stack>:
	TRAPHANDLER(XTRPX_Stack, T_STACK)
  800420cd14:	6a 0c                	pushq  $0xc
  800420cd16:	e9 9b 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420cd1b:	90                   	nop

000000800420cd1c <XTRPX_Gpflt>:
	TRAPHANDLER(XTRPX_Gpflt, T_GPFLT)
  800420cd1c:	6a 0d                	pushq  $0xd
  800420cd1e:	e9 93 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420cd23:	90                   	nop

000000800420cd24 <XTRPX_Pgflt>:
	TRAPHANDLER(XTRPX_Pgflt, T_PGFLT)
  800420cd24:	6a 0e                	pushq  $0xe
  800420cd26:	e9 8b 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420cd2b:	90                   	nop

000000800420cd2c <XTRPX_FpErr>:
	TRAPHANDLER_NOEC(XTRPX_FpErr, T_FPERR)
  800420cd2c:	6a 00                	pushq  $0x0
  800420cd2e:	6a 10                	pushq  $0x10
  800420cd30:	e9 81 00 00 00       	jmpq   800420cdb6 <_alltraps>
  800420cd35:	90                   	nop

000000800420cd36 <XTRPX_Align>:
	TRAPHANDLER(XTRPX_Align, T_ALIGN)
  800420cd36:	6a 11                	pushq  $0x11
  800420cd38:	eb 7c                	jmp    800420cdb6 <_alltraps>

000000800420cd3a <XTRPX_Mchk>:
	TRAPHANDLER_NOEC(XTRPX_Mchk, T_MCHK)
  800420cd3a:	6a 00                	pushq  $0x0
  800420cd3c:	6a 12                	pushq  $0x12
  800420cd3e:	eb 76                	jmp    800420cdb6 <_alltraps>

000000800420cd40 <XTRPX_SimdErr>:
	TRAPHANDLER_NOEC(XTRPX_SimdErr, T_SIMDERR)
  800420cd40:	6a 00                	pushq  $0x0
  800420cd42:	6a 13                	pushq  $0x13
  800420cd44:	eb 70                	jmp    800420cdb6 <_alltraps>

000000800420cd46 <XTRPX_Syscall>:
	TRAPHANDLER_NOEC(XTRPX_Syscall, T_SYSCALL)
  800420cd46:	6a 00                	pushq  $0x0
  800420cd48:	6a 30                	pushq  $0x30
  800420cd4a:	eb 6a                	jmp    800420cdb6 <_alltraps>

000000800420cd4c <XTRPX_Default>:
	TRAPHANDLER_NOEC(XTRPX_Default, T_DEFAULT)
  800420cd4c:	6a 00                	pushq  $0x0
  800420cd4e:	68 f4 01 00 00       	pushq  $0x1f4
  800420cd53:	eb 61                	jmp    800420cdb6 <_alltraps>
  800420cd55:	90                   	nop

000000800420cd56 <XTRPX_IRQ0>:
	TRAPHANDLER_NOEC(XTRPX_IRQ0, IRQ_OFFSET+IRQ_TIMER)
  800420cd56:	6a 00                	pushq  $0x0
  800420cd58:	6a 20                	pushq  $0x20
  800420cd5a:	eb 5a                	jmp    800420cdb6 <_alltraps>

000000800420cd5c <XTRPX_IRQ1>:
	TRAPHANDLER_NOEC(XTRPX_IRQ1, IRQ_OFFSET+IRQ_KBD)
  800420cd5c:	6a 00                	pushq  $0x0
  800420cd5e:	6a 21                	pushq  $0x21
  800420cd60:	eb 54                	jmp    800420cdb6 <_alltraps>

000000800420cd62 <XTRPX_IRQ2>:
	TRAPHANDLER_NOEC(XTRPX_IRQ2, IRQ_OFFSET+2)
  800420cd62:	6a 00                	pushq  $0x0
  800420cd64:	6a 22                	pushq  $0x22
  800420cd66:	eb 4e                	jmp    800420cdb6 <_alltraps>

000000800420cd68 <XTRPX_IRQ3>:
	TRAPHANDLER_NOEC(XTRPX_IRQ3, IRQ_OFFSET+3)
  800420cd68:	6a 00                	pushq  $0x0
  800420cd6a:	6a 23                	pushq  $0x23
  800420cd6c:	eb 48                	jmp    800420cdb6 <_alltraps>

000000800420cd6e <XTRPX_IRQ4>:
	TRAPHANDLER_NOEC(XTRPX_IRQ4, IRQ_OFFSET+IRQ_SERIAL)
  800420cd6e:	6a 00                	pushq  $0x0
  800420cd70:	6a 24                	pushq  $0x24
  800420cd72:	eb 42                	jmp    800420cdb6 <_alltraps>

000000800420cd74 <XTRPX_IRQ5>:
	TRAPHANDLER_NOEC(XTRPX_IRQ5, IRQ_OFFSET+5)
  800420cd74:	6a 00                	pushq  $0x0
  800420cd76:	6a 25                	pushq  $0x25
  800420cd78:	eb 3c                	jmp    800420cdb6 <_alltraps>

000000800420cd7a <XTRPX_IRQ6>:
	TRAPHANDLER_NOEC(XTRPX_IRQ6, IRQ_OFFSET+6)
  800420cd7a:	6a 00                	pushq  $0x0
  800420cd7c:	6a 26                	pushq  $0x26
  800420cd7e:	eb 36                	jmp    800420cdb6 <_alltraps>

000000800420cd80 <XTRPX_IRQ7>:
	TRAPHANDLER_NOEC(XTRPX_IRQ7, IRQ_OFFSET+IRQ_SPURIOUS)
  800420cd80:	6a 00                	pushq  $0x0
  800420cd82:	6a 27                	pushq  $0x27
  800420cd84:	eb 30                	jmp    800420cdb6 <_alltraps>

000000800420cd86 <XTRPX_IRQ8>:
	TRAPHANDLER_NOEC(XTRPX_IRQ8, IRQ_OFFSET+8)
  800420cd86:	6a 00                	pushq  $0x0
  800420cd88:	6a 28                	pushq  $0x28
  800420cd8a:	eb 2a                	jmp    800420cdb6 <_alltraps>

000000800420cd8c <XTRPX_IRQ9>:
	TRAPHANDLER_NOEC(XTRPX_IRQ9, IRQ_OFFSET+9)
  800420cd8c:	6a 00                	pushq  $0x0
  800420cd8e:	6a 29                	pushq  $0x29
  800420cd90:	eb 24                	jmp    800420cdb6 <_alltraps>

000000800420cd92 <XTRPX_IRQa>:
	TRAPHANDLER_NOEC(XTRPX_IRQa, IRQ_OFFSET+10)
  800420cd92:	6a 00                	pushq  $0x0
  800420cd94:	6a 2a                	pushq  $0x2a
  800420cd96:	eb 1e                	jmp    800420cdb6 <_alltraps>

000000800420cd98 <XTRPX_IRQb>:
	TRAPHANDLER_NOEC(XTRPX_IRQb, IRQ_OFFSET+11)
  800420cd98:	6a 00                	pushq  $0x0
  800420cd9a:	6a 2b                	pushq  $0x2b
  800420cd9c:	eb 18                	jmp    800420cdb6 <_alltraps>

000000800420cd9e <XTRPX_IRQc>:
	TRAPHANDLER_NOEC(XTRPX_IRQc, IRQ_OFFSET+12)
  800420cd9e:	6a 00                	pushq  $0x0
  800420cda0:	6a 2c                	pushq  $0x2c
  800420cda2:	eb 12                	jmp    800420cdb6 <_alltraps>

000000800420cda4 <XTRPX_IRQd>:
	TRAPHANDLER_NOEC(XTRPX_IRQd, IRQ_OFFSET+13)
  800420cda4:	6a 00                	pushq  $0x0
  800420cda6:	6a 2d                	pushq  $0x2d
  800420cda8:	eb 0c                	jmp    800420cdb6 <_alltraps>

000000800420cdaa <XTRPX_IRQe>:
	TRAPHANDLER_NOEC(XTRPX_IRQe, IRQ_OFFSET+IRQ_IDE)
  800420cdaa:	6a 00                	pushq  $0x0
  800420cdac:	6a 2e                	pushq  $0x2e
  800420cdae:	eb 06                	jmp    800420cdb6 <_alltraps>

000000800420cdb0 <XTRPX_IRQf>:
	TRAPHANDLER_NOEC(XTRPX_IRQf, IRQ_OFFSET+15)
  800420cdb0:	6a 00                	pushq  $0x0
  800420cdb2:	6a 2f                	pushq  $0x2f
  800420cdb4:	eb 00                	jmp    800420cdb6 <_alltraps>

000000800420cdb6 <_alltraps>:
 * Hint: Be sure to review the x64 calling convention from lab1
 *       for how to pass a pointer to the trapframe.
 */
    _alltraps:
    	/* Since ES and DS registers can't be pushed in x86-64. So moving them to r15 first */
		xor %r15, %r15
  800420cdb6:	4d 31 ff             	xor    %r15,%r15
		movw %ds,%r15 
  800420cdb9:	66 41 8c df          	mov    %ds,%r15w
		pushq %r15
  800420cdbd:	41 57                	push   %r15
		movw %es, %r15
  800420cdbf:	66 41 8c c7          	mov    %es,%r15w
		pushq %r15
  800420cdc3:	41 57                	push   %r15
		/* Now push all registers onto the stack */
		PUSHA
  800420cdc5:	48 83 ec 78          	sub    $0x78,%rsp
  800420cdc9:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420cdce:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420cdd3:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420cdd8:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420cddd:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420cde2:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420cde7:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420cdec:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420cdf1:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420cdf6:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420cdfb:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420ce00:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420ce05:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420ce0a:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420ce0f:	4c 89 3c 24          	mov    %r15,(%rsp)
		/* Far pointer addressing*/
		mov %rsp, %rdi
  800420ce13:	48 89 e7             	mov    %rsp,%rdi
		/* filling es and ds now */
		xor %r15, %r15
  800420ce16:	4d 31 ff             	xor    %r15,%r15
		movw $(GD_KD), %r15
  800420ce19:	66 41 c7 c7 10 00    	mov    $0x10,%r15w
		movw %r15, %es
  800420ce1f:	41 8e c7             	mov    %r15d,%es
		movw %r15, %ds
  800420ce22:	41 8e df             	mov    %r15d,%ds
		call trap
  800420ce25:	e8 17 f7 ff ff       	callq  800420c541 <trap>
		POPA_
  800420ce2a:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420ce2e:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420ce33:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800420ce38:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420ce3d:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420ce42:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800420ce47:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420ce4c:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420ce51:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420ce56:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420ce5b:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420ce60:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420ce65:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420ce6a:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420ce6f:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420ce74:	48 83 c4 78          	add    $0x78,%rsp
		/*Now make the stack same as we got from CPU*/
		xor %r15, %r15
  800420ce78:	4d 31 ff             	xor    %r15,%r15
		popq %r15
  800420ce7b:	41 5f                	pop    %r15
		movw %r15, %es
  800420ce7d:	41 8e c7             	mov    %r15d,%es
		popq %r15
  800420ce80:	41 5f                	pop    %r15
		movw %r15, %ds
  800420ce82:	41 8e df             	mov    %r15d,%ds
		iret 
  800420ce85:	cf                   	iret   

000000800420ce86 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420ce86:	55                   	push   %rbp
  800420ce87:	48 89 e5             	mov    %rsp,%rbp
  800420ce8a:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ce8e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ce92:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420ce95:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ce99:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420ce9c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420cea0:	f0 87 02             	lock xchg %eax,(%rdx)
  800420cea3:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420cea6:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420cea9:	c9                   	leaveq 
  800420ceaa:	c3                   	retq   

000000800420ceab <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420ceab:	55                   	push   %rbp
  800420ceac:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420ceaf:	48 bf 80 d7 22 04 80 	movabs $0x800422d780,%rdi
  800420ceb6:	00 00 00 
  800420ceb9:	48 b8 8b 6d 21 04 80 	movabs $0x8004216d8b,%rax
  800420cec0:	00 00 00 
  800420cec3:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420cec5:	f3 90                	pause  
}
  800420cec7:	5d                   	pop    %rbp
  800420cec8:	c3                   	retq   

000000800420cec9 <sched_yield>:


// Choose a user environment to run and run it.
void
sched_yield(void)
	{
  800420cec9:	55                   	push   %rbp
  800420ceca:	48 89 e5             	mov    %rsp,%rbp
  800420cecd:	48 83 ec 10          	sub    $0x10,%rsp
		// no runnable environments, simply drop through to the code
		// below to halt the cpu.	
	
		// LAB 4: Your code here.
		static uint32_t env_counter = 0;
		uint32_t i = 0;
  800420ced1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		//cprintf("envcounter1 = [%d]\n",env_counter);
		for(i=1;i<= NENV;i++){
  800420ced8:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  800420cedf:	e9 a7 00 00 00       	jmpq   800420cf8b <sched_yield+0xc2>
			if(envs[(env_counter+i)%NENV].env_status == ENV_RUNNABLE){
  800420cee4:	48 b8 50 72 60 04 80 	movabs $0x8004607250,%rax
  800420ceeb:	00 00 00 
  800420ceee:	48 8b 08             	mov    (%rax),%rcx
  800420cef1:	48 b8 98 82 60 04 80 	movabs $0x8004608298,%rax
  800420cef8:	00 00 00 
  800420cefb:	8b 10                	mov    (%rax),%edx
  800420cefd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cf00:	01 d0                	add    %edx,%eax
  800420cf02:	89 c0                	mov    %eax,%eax
  800420cf04:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420cf09:	48 89 c2             	mov    %rax,%rdx
  800420cf0c:	48 89 d0             	mov    %rdx,%rax
  800420cf0f:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf13:	48 01 d0             	add    %rdx,%rax
  800420cf16:	48 c1 e0 05          	shl    $0x5,%rax
  800420cf1a:	48 01 c8             	add    %rcx,%rax
  800420cf1d:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420cf23:	83 f8 02             	cmp    $0x2,%eax
  800420cf26:	75 5f                	jne    800420cf87 <sched_yield+0xbe>
				env_counter = (env_counter+i)%NENV;
  800420cf28:	48 b8 98 82 60 04 80 	movabs $0x8004608298,%rax
  800420cf2f:	00 00 00 
  800420cf32:	8b 10                	mov    (%rax),%edx
  800420cf34:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cf37:	01 d0                	add    %edx,%eax
  800420cf39:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420cf3e:	89 c2                	mov    %eax,%edx
  800420cf40:	48 b8 98 82 60 04 80 	movabs $0x8004608298,%rax
  800420cf47:	00 00 00 
  800420cf4a:	89 10                	mov    %edx,(%rax)
				//cprintf("going to run now = [%d],status is [%d]\n",env_counter,envs[env_counter].env_status);
				env_run(&envs[env_counter]);
  800420cf4c:	48 b8 50 72 60 04 80 	movabs $0x8004607250,%rax
  800420cf53:	00 00 00 
  800420cf56:	48 8b 08             	mov    (%rax),%rcx
  800420cf59:	48 b8 98 82 60 04 80 	movabs $0x8004608298,%rax
  800420cf60:	00 00 00 
  800420cf63:	8b 00                	mov    (%rax),%eax
  800420cf65:	89 c2                	mov    %eax,%edx
  800420cf67:	48 89 d0             	mov    %rdx,%rax
  800420cf6a:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf6e:	48 01 d0             	add    %rdx,%rax
  800420cf71:	48 c1 e0 05          	shl    $0x5,%rax
  800420cf75:	48 01 c8             	add    %rcx,%rax
  800420cf78:	48 89 c7             	mov    %rax,%rdi
  800420cf7b:	48 b8 88 87 20 04 80 	movabs $0x8004208788,%rax
  800420cf82:	00 00 00 
  800420cf85:	ff d0                	callq  *%rax
	
		// LAB 4: Your code here.
		static uint32_t env_counter = 0;
		uint32_t i = 0;
		//cprintf("envcounter1 = [%d]\n",env_counter);
		for(i=1;i<= NENV;i++){
  800420cf87:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420cf8b:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420cf92:	0f 86 4c ff ff ff    	jbe    800420cee4 <sched_yield+0x1b>
				env_run(&envs[env_counter]);
				break;
			}
		}
		//cprintf("envcounter2 = [%d]\n",env_counter);
		if(curenv && curenv->env_status == ENV_RUNNING){
  800420cf98:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420cf9f:	00 00 00 
  800420cfa2:	ff d0                	callq  *%rax
  800420cfa4:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420cfab:	00 00 00 
  800420cfae:	48 98                	cltq   
  800420cfb0:	48 c1 e0 03          	shl    $0x3,%rax
  800420cfb4:	48 89 c2             	mov    %rax,%rdx
  800420cfb7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cfbb:	48 29 c2             	sub    %rax,%rdx
  800420cfbe:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cfc2:	48 83 c0 08          	add    $0x8,%rax
  800420cfc6:	48 8b 00             	mov    (%rax),%rax
  800420cfc9:	48 85 c0             	test   %rax,%rax
  800420cfcc:	74 7c                	je     800420d04a <sched_yield+0x181>
  800420cfce:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420cfd5:	00 00 00 
  800420cfd8:	ff d0                	callq  *%rax
  800420cfda:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420cfe1:	00 00 00 
  800420cfe4:	48 98                	cltq   
  800420cfe6:	48 c1 e0 03          	shl    $0x3,%rax
  800420cfea:	48 89 c2             	mov    %rax,%rdx
  800420cfed:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cff1:	48 29 c2             	sub    %rax,%rdx
  800420cff4:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420cff8:	48 83 c0 08          	add    $0x8,%rax
  800420cffc:	48 8b 00             	mov    (%rax),%rax
  800420cfff:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d005:	83 f8 03             	cmp    $0x3,%eax
  800420d008:	75 40                	jne    800420d04a <sched_yield+0x181>
			env_run(curenv);
  800420d00a:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420d011:	00 00 00 
  800420d014:	ff d0                	callq  *%rax
  800420d016:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420d01d:	00 00 00 
  800420d020:	48 98                	cltq   
  800420d022:	48 c1 e0 03          	shl    $0x3,%rax
  800420d026:	48 89 c2             	mov    %rax,%rdx
  800420d029:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d02d:	48 29 c2             	sub    %rax,%rdx
  800420d030:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d034:	48 83 c0 08          	add    $0x8,%rax
  800420d038:	48 8b 00             	mov    (%rax),%rax
  800420d03b:	48 89 c7             	mov    %rax,%rdi
  800420d03e:	48 b8 88 87 20 04 80 	movabs $0x8004208788,%rax
  800420d045:	00 00 00 
  800420d048:	ff d0                	callq  *%rax
			
		}else{
			sched_halt();	
  800420d04a:	48 b8 58 d0 20 04 80 	movabs $0x800420d058,%rax
  800420d051:	00 00 00 
  800420d054:	ff d0                	callq  *%rax
		}
	}
  800420d056:	c9                   	leaveq 
  800420d057:	c3                   	retq   

000000800420d058 <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
	{
  800420d058:	55                   	push   %rbp
  800420d059:	48 89 e5             	mov    %rsp,%rbp
  800420d05c:	48 83 ec 20          	sub    $0x20,%rsp
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
  800420d060:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420d067:	e9 91 00 00 00       	jmpq   800420d0fd <sched_halt+0xa5>
			if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d06c:	48 b8 50 72 60 04 80 	movabs $0x8004607250,%rax
  800420d073:	00 00 00 
  800420d076:	48 8b 08             	mov    (%rax),%rcx
  800420d079:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d07c:	48 63 d0             	movslq %eax,%rdx
  800420d07f:	48 89 d0             	mov    %rdx,%rax
  800420d082:	48 c1 e0 03          	shl    $0x3,%rax
  800420d086:	48 01 d0             	add    %rdx,%rax
  800420d089:	48 c1 e0 05          	shl    $0x5,%rax
  800420d08d:	48 01 c8             	add    %rcx,%rax
  800420d090:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d096:	83 f8 02             	cmp    $0x2,%eax
  800420d099:	74 6f                	je     800420d10a <sched_halt+0xb2>
				 envs[i].env_status == ENV_RUNNING ||
  800420d09b:	48 b8 50 72 60 04 80 	movabs $0x8004607250,%rax
  800420d0a2:	00 00 00 
  800420d0a5:	48 8b 08             	mov    (%rax),%rcx
  800420d0a8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d0ab:	48 63 d0             	movslq %eax,%rdx
  800420d0ae:	48 89 d0             	mov    %rdx,%rax
  800420d0b1:	48 c1 e0 03          	shl    $0x3,%rax
  800420d0b5:	48 01 d0             	add    %rdx,%rax
  800420d0b8:	48 c1 e0 05          	shl    $0x5,%rax
  800420d0bc:	48 01 c8             	add    %rcx,%rax
  800420d0bf:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
			if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d0c5:	83 f8 03             	cmp    $0x3,%eax
  800420d0c8:	74 40                	je     800420d10a <sched_halt+0xb2>
				 envs[i].env_status == ENV_RUNNING ||
				 envs[i].env_status == ENV_DYING))
  800420d0ca:	48 b8 50 72 60 04 80 	movabs $0x8004607250,%rax
  800420d0d1:	00 00 00 
  800420d0d4:	48 8b 08             	mov    (%rax),%rcx
  800420d0d7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d0da:	48 63 d0             	movslq %eax,%rdx
  800420d0dd:	48 89 d0             	mov    %rdx,%rax
  800420d0e0:	48 c1 e0 03          	shl    $0x3,%rax
  800420d0e4:	48 01 d0             	add    %rdx,%rax
  800420d0e7:	48 c1 e0 05          	shl    $0x5,%rax
  800420d0eb:	48 01 c8             	add    %rcx,%rax
  800420d0ee:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
			if ((envs[i].env_status == ENV_RUNNABLE ||
				 envs[i].env_status == ENV_RUNNING ||
  800420d0f4:	83 f8 01             	cmp    $0x1,%eax
  800420d0f7:	74 11                	je     800420d10a <sched_halt+0xb2>
	{
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
  800420d0f9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420d0fd:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420d104:	0f 8e 62 ff ff ff    	jle    800420d06c <sched_halt+0x14>
			if ((envs[i].env_status == ENV_RUNNABLE ||
				 envs[i].env_status == ENV_RUNNING ||
				 envs[i].env_status == ENV_DYING))
				break;
		}
		if (i == NENV) {
  800420d10a:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420d111:	75 2e                	jne    800420d141 <sched_halt+0xe9>
			cprintf("No runnable environments in the system!\n");
  800420d113:	48 bf 80 99 21 04 80 	movabs $0x8004219980,%rdi
  800420d11a:	00 00 00 
  800420d11d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d122:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420d129:	00 00 00 
  800420d12c:	ff d2                	callq  *%rdx
			while (1)
				monitor(NULL);
  800420d12e:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d133:	48 b8 2e 1b 20 04 80 	movabs $0x8004201b2e,%rax
  800420d13a:	00 00 00 
  800420d13d:	ff d0                	callq  *%rax
  800420d13f:	eb ed                	jmp    800420d12e <sched_halt+0xd6>
		}
	
		// Mark that no environment is running on this CPU
		curenv = NULL;
  800420d141:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420d148:	00 00 00 
  800420d14b:	ff d0                	callq  *%rax
  800420d14d:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420d154:	00 00 00 
  800420d157:	48 98                	cltq   
  800420d159:	48 c1 e0 03          	shl    $0x3,%rax
  800420d15d:	48 89 c2             	mov    %rax,%rdx
  800420d160:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d164:	48 29 c2             	sub    %rax,%rdx
  800420d167:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d16b:	48 83 c0 08          	add    $0x8,%rax
  800420d16f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		lcr3(PADDR(boot_pml4e));
  800420d176:	48 b8 78 87 60 04 80 	movabs $0x8004608778,%rax
  800420d17d:	00 00 00 
  800420d180:	48 8b 00             	mov    (%rax),%rax
  800420d183:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420d187:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420d18e:	00 00 00 
  800420d191:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420d195:	77 32                	ja     800420d1c9 <sched_halt+0x171>
  800420d197:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d19b:	48 89 c1             	mov    %rax,%rcx
  800420d19e:	48 ba b0 99 21 04 80 	movabs $0x80042199b0,%rdx
  800420d1a5:	00 00 00 
  800420d1a8:	be 4e 00 00 00       	mov    $0x4e,%esi
  800420d1ad:	48 bf d4 99 21 04 80 	movabs $0x80042199d4,%rdi
  800420d1b4:	00 00 00 
  800420d1b7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d1bc:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420d1c3:	00 00 00 
  800420d1c6:	41 ff d0             	callq  *%r8
  800420d1c9:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420d1d0:	ff ff ff 
  800420d1d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d1d7:	48 01 d0             	add    %rdx,%rax
  800420d1da:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420d1de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d1e2:	0f 22 d8             	mov    %rax,%cr3
	
		// Mark that this CPU is in the HALT state, so that when
		// timer interupts come in, we know we should re-acquire the
		// big kernel lock
		xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420d1e5:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420d1ec:	00 00 00 
  800420d1ef:	ff d0                	callq  *%rax
  800420d1f1:	48 98                	cltq   
  800420d1f3:	48 c1 e0 03          	shl    $0x3,%rax
  800420d1f7:	48 89 c2             	mov    %rax,%rdx
  800420d1fa:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d1fe:	48 29 c2             	sub    %rax,%rdx
  800420d201:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  800420d208:	00 00 00 
  800420d20b:	48 01 d0             	add    %rdx,%rax
  800420d20e:	48 83 c0 04          	add    $0x4,%rax
  800420d212:	be 02 00 00 00       	mov    $0x2,%esi
  800420d217:	48 89 c7             	mov    %rax,%rdi
  800420d21a:	48 b8 86 ce 20 04 80 	movabs $0x800420ce86,%rax
  800420d221:	00 00 00 
  800420d224:	ff d0                	callq  *%rax
	
		// Release the big kernel lock as if we were "leaving" the kernel
		unlock_kernel();
  800420d226:	48 b8 ab ce 20 04 80 	movabs $0x800420ceab,%rax
  800420d22d:	00 00 00 
  800420d230:	ff d0                	callq  *%rax
			"movq %0, %%rsp\n"
			"pushq $0\n"
			"pushq $0\n"
			"sti\n"
			"hlt\n"
			: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420d232:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420d239:	00 00 00 
  800420d23c:	ff d0                	callq  *%rax
  800420d23e:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420d245:	00 00 00 
  800420d248:	48 98                	cltq   
  800420d24a:	48 c1 e0 03          	shl    $0x3,%rax
  800420d24e:	48 89 c2             	mov    %rax,%rdx
  800420d251:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d255:	48 29 c2             	sub    %rax,%rdx
  800420d258:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d25c:	48 83 c0 10          	add    $0x10,%rax
  800420d260:	48 8b 40 04          	mov    0x4(%rax),%rax
	
		// Release the big kernel lock as if we were "leaving" the kernel
		unlock_kernel();
	
		// Reset stack pointer, enable interrupts and then halt.
		asm volatile (
  800420d264:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420d26b:	48 89 c4             	mov    %rax,%rsp
  800420d26e:	6a 00                	pushq  $0x0
  800420d270:	6a 00                	pushq  $0x0
  800420d272:	fb                   	sti    
  800420d273:	f4                   	hlt    
			"pushq $0\n"
			"pushq $0\n"
			"sti\n"
			"hlt\n"
			: : "a" (thiscpu->cpu_ts.ts_esp0));
	}
  800420d274:	c9                   	leaveq 
  800420d275:	c3                   	retq   

000000800420d276 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420d276:	55                   	push   %rbp
  800420d277:	48 89 e5             	mov    %rsp,%rbp
  800420d27a:	48 83 ec 10          	sub    $0x10,%rsp
  800420d27e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420d282:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, (const void *)s, len, PTE_U );
  800420d286:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420d28d:	00 00 00 
  800420d290:	ff d0                	callq  *%rax
  800420d292:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420d299:	00 00 00 
  800420d29c:	48 98                	cltq   
  800420d29e:	48 c1 e0 03          	shl    $0x3,%rax
  800420d2a2:	48 89 c2             	mov    %rax,%rdx
  800420d2a5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d2a9:	48 29 c2             	sub    %rax,%rdx
  800420d2ac:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d2b0:	48 83 c0 08          	add    $0x8,%rax
  800420d2b4:	48 8b 00             	mov    (%rax),%rax
  800420d2b7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d2bb:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420d2bf:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420d2c4:	48 89 c7             	mov    %rax,%rdi
  800420d2c7:	48 b8 38 3d 20 04 80 	movabs $0x8004203d38,%rax
  800420d2ce:	00 00 00 
  800420d2d1:	ff d0                	callq  *%rax
	
	// Print the string supplied by the user.
	
	cprintf("%.*s", len, s);
  800420d2d3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d2d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d2db:	48 89 c6             	mov    %rax,%rsi
  800420d2de:	48 bf e8 99 21 04 80 	movabs $0x80042199e8,%rdi
  800420d2e5:	00 00 00 
  800420d2e8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d2ed:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  800420d2f4:	00 00 00 
  800420d2f7:	ff d1                	callq  *%rcx
}
  800420d2f9:	c9                   	leaveq 
  800420d2fa:	c3                   	retq   

000000800420d2fb <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420d2fb:	55                   	push   %rbp
  800420d2fc:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420d2ff:	48 b8 00 11 20 04 80 	movabs $0x8004201100,%rax
  800420d306:	00 00 00 
  800420d309:	ff d0                	callq  *%rax
}
  800420d30b:	5d                   	pop    %rbp
  800420d30c:	c3                   	retq   

000000800420d30d <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420d30d:	55                   	push   %rbp
  800420d30e:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420d311:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420d318:	00 00 00 
  800420d31b:	ff d0                	callq  *%rax
  800420d31d:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420d324:	00 00 00 
  800420d327:	48 98                	cltq   
  800420d329:	48 c1 e0 03          	shl    $0x3,%rax
  800420d32d:	48 89 c2             	mov    %rax,%rdx
  800420d330:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d334:	48 29 c2             	sub    %rax,%rdx
  800420d337:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d33b:	48 83 c0 08          	add    $0x8,%rax
  800420d33f:	48 8b 00             	mov    (%rax),%rax
  800420d342:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420d348:	5d                   	pop    %rbp
  800420d349:	c3                   	retq   

000000800420d34a <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420d34a:	55                   	push   %rbp
  800420d34b:	48 89 e5             	mov    %rsp,%rbp
  800420d34e:	48 83 ec 20          	sub    $0x20,%rsp
  800420d352:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420d355:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d359:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d35c:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d361:	48 89 ce             	mov    %rcx,%rsi
  800420d364:	89 c7                	mov    %eax,%edi
  800420d366:	48 b8 5e 78 20 04 80 	movabs $0x800420785e,%rax
  800420d36d:	00 00 00 
  800420d370:	ff d0                	callq  *%rax
  800420d372:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420d375:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d379:	79 05                	jns    800420d380 <sys_env_destroy+0x36>
		return r;
  800420d37b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d37e:	eb 18                	jmp    800420d398 <sys_env_destroy+0x4e>
	env_destroy(e);
  800420d380:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d384:	48 89 c7             	mov    %rax,%rdi
  800420d387:	48 b8 b9 85 20 04 80 	movabs $0x80042085b9,%rax
  800420d38e:	00 00 00 
  800420d391:	ff d0                	callq  *%rax
	return 0;
  800420d393:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d398:	c9                   	leaveq 
  800420d399:	c3                   	retq   

000000800420d39a <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420d39a:	55                   	push   %rbp
  800420d39b:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420d39e:	48 b8 c9 ce 20 04 80 	movabs $0x800420cec9,%rax
  800420d3a5:	00 00 00 
  800420d3a8:	ff d0                	callq  *%rax

000000800420d3aa <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420d3aa:	55                   	push   %rbp
  800420d3ab:	48 89 e5             	mov    %rsp,%rbp
  800420d3ae:	53                   	push   %rbx
  800420d3af:	48 83 ec 18          	sub    $0x18,%rsp
	// from the current environment -- but tweaked so sys_exofork
	// will appear to return 0.

	// LAB 4: Your code here.
	struct Env *newenv_store;
	uint32_t  result = 0;
  800420d3b3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	result= env_alloc(&newenv_store, curenv->env_id);
  800420d3ba:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420d3c1:	00 00 00 
  800420d3c4:	ff d0                	callq  *%rax
  800420d3c6:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420d3cd:	00 00 00 
  800420d3d0:	48 98                	cltq   
  800420d3d2:	48 c1 e0 03          	shl    $0x3,%rax
  800420d3d6:	48 89 c2             	mov    %rax,%rdx
  800420d3d9:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d3dd:	48 29 c2             	sub    %rax,%rdx
  800420d3e0:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d3e4:	48 83 c0 08          	add    $0x8,%rax
  800420d3e8:	48 8b 00             	mov    (%rax),%rax
  800420d3eb:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420d3f1:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420d3f5:	89 d6                	mov    %edx,%esi
  800420d3f7:	48 89 c7             	mov    %rax,%rdi
  800420d3fa:	48 b8 fa 7b 20 04 80 	movabs $0x8004207bfa,%rax
  800420d401:	00 00 00 
  800420d404:	ff d0                	callq  *%rax
  800420d406:	89 45 ec             	mov    %eax,-0x14(%rbp)

	if(result != 0)
  800420d409:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420d40d:	74 05                	je     800420d414 <sys_exofork+0x6a>
		return result;
  800420d40f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d412:	eb 6d                	jmp    800420d481 <sys_exofork+0xd7>
	//cprintf("curenv->env_id [%d], newenv_store->env_parent_id [%d],  newenv_store->env_id [%d]\n",curenv->env_id, newenv_store->env_parent_id,newenv_store->env_id);

	newenv_store->env_status = ENV_NOT_RUNNABLE;
  800420d414:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d418:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420d41f:	00 00 00 
	newenv_store->env_tf = curenv->env_tf;
  800420d422:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420d426:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420d42d:	00 00 00 
  800420d430:	ff d0                	callq  *%rax
  800420d432:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420d439:	00 00 00 
  800420d43c:	48 98                	cltq   
  800420d43e:	48 c1 e0 03          	shl    $0x3,%rax
  800420d442:	48 89 c2             	mov    %rax,%rdx
  800420d445:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d449:	48 29 c2             	sub    %rax,%rdx
  800420d44c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420d450:	48 83 c0 08          	add    $0x8,%rax
  800420d454:	48 8b 00             	mov    (%rax),%rax
  800420d457:	48 89 da             	mov    %rbx,%rdx
  800420d45a:	48 89 c6             	mov    %rax,%rsi
  800420d45d:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d462:	48 89 d7             	mov    %rdx,%rdi
  800420d465:	48 89 c1             	mov    %rax,%rcx
  800420d468:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	newenv_store->env_tf.tf_regs.reg_rax = 0x00;
  800420d46b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d46f:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420d476:	00 
	return newenv_store->env_id;
  800420d477:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d47b:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax

	//panic("sys_exofork not implemented");
}
  800420d481:	48 83 c4 18          	add    $0x18,%rsp
  800420d485:	5b                   	pop    %rbx
  800420d486:	5d                   	pop    %rbp
  800420d487:	c3                   	retq   

000000800420d488 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420d488:	55                   	push   %rbp
  800420d489:	48 89 e5             	mov    %rsp,%rbp
  800420d48c:	48 83 ec 20          	sub    $0x20,%rsp
  800420d490:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d493:	89 75 e8             	mov    %esi,-0x18(%rbp)
	// You should set envid2env's third argument to 1, which will
	// check whether the current environment has permission to set
	// envid's status.

	// LAB 4: Your code here.
	uint32_t  result =0;
  800420d496:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	result = envid2env(envid,&env_store,1);
  800420d49d:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d4a1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d4a4:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d4a9:	48 89 ce             	mov    %rcx,%rsi
  800420d4ac:	89 c7                	mov    %eax,%edi
  800420d4ae:	48 b8 5e 78 20 04 80 	movabs $0x800420785e,%rax
  800420d4b5:	00 00 00 
  800420d4b8:	ff d0                	callq  *%rax
  800420d4ba:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420d4bd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d4c1:	74 05                	je     800420d4c8 <sys_env_set_status+0x40>
		return result;
  800420d4c3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d4c6:	eb 23                	jmp    800420d4eb <sys_env_set_status+0x63>
	if(status< 0 || status >4)
  800420d4c8:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800420d4cc:	78 06                	js     800420d4d4 <sys_env_set_status+0x4c>
  800420d4ce:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420d4d2:	7e 07                	jle    800420d4db <sys_env_set_status+0x53>
		return -E_INVAL;
  800420d4d4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d4d9:	eb 10                	jmp    800420d4eb <sys_env_set_status+0x63>
	
	env_store->env_status = status;
  800420d4db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d4df:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420d4e2:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return result;
  800420d4e8:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_env_set_status not implemented");
}
  800420d4eb:	c9                   	leaveq 
  800420d4ec:	c3                   	retq   

000000800420d4ed <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
	{
  800420d4ed:	55                   	push   %rbp
  800420d4ee:	48 89 e5             	mov    %rsp,%rbp
  800420d4f1:	48 83 ec 20          	sub    $0x20,%rsp
  800420d4f5:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d4f8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
		// LAB 5: Your code here.
		// Remember to check whether the user has supplied us with a good
		// address!
		//panic("sys_env_set_trapframe not implemented");
		uint32_t  result = 0;
  800420d4fc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		struct Env *env_store;
		if(!tf)
  800420d503:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420d508:	75 07                	jne    800420d511 <sys_env_set_trapframe+0x24>
			return -E_BAD_ENV;
  800420d50a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d50f:	eb 73                	jmp    800420d584 <sys_env_set_trapframe+0x97>
		result = envid2env(envid,&env_store,1);
  800420d511:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d515:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d518:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d51d:	48 89 ce             	mov    %rcx,%rsi
  800420d520:	89 c7                	mov    %eax,%edi
  800420d522:	48 b8 5e 78 20 04 80 	movabs $0x800420785e,%rax
  800420d529:	00 00 00 
  800420d52c:	ff d0                	callq  *%rax
  800420d52e:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(result < 0)
			return result;
		//user_mem_assert(env_store, tf, sizeof(struct Trapframe), PTE_U|PTE_P);
		tf->tf_cs |= 0x3;
  800420d531:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d535:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420d53c:	83 c8 03             	or     $0x3,%eax
  800420d53f:	89 c2                	mov    %eax,%edx
  800420d541:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d545:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
		tf->tf_eflags |= FL_IF;
  800420d54c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d550:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420d557:	80 cc 02             	or     $0x2,%ah
  800420d55a:	48 89 c2             	mov    %rax,%rdx
  800420d55d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d561:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
		env_store->env_tf = *tf;
  800420d568:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d56c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d570:	48 89 c6             	mov    %rax,%rsi
  800420d573:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d578:	48 89 d7             	mov    %rdx,%rdi
  800420d57b:	48 89 c1             	mov    %rax,%rcx
  800420d57e:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		return result;
  800420d581:	8b 45 fc             	mov    -0x4(%rbp),%eax
	}
  800420d584:	c9                   	leaveq 
  800420d585:	c3                   	retq   

000000800420d586 <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420d586:	55                   	push   %rbp
  800420d587:	48 89 e5             	mov    %rsp,%rbp
  800420d58a:	48 83 ec 20          	sub    $0x20,%rsp
  800420d58e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d591:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 4: Your code here.
	
	uint32_t  result =0;
  800420d595:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	result = envid2env(envid,&env_store,1);
  800420d59c:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d5a0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d5a3:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d5a8:	48 89 ce             	mov    %rcx,%rsi
  800420d5ab:	89 c7                	mov    %eax,%edi
  800420d5ad:	48 b8 5e 78 20 04 80 	movabs $0x800420785e,%rax
  800420d5b4:	00 00 00 
  800420d5b7:	ff d0                	callq  *%rax
  800420d5b9:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420d5bc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d5c0:	74 05                	je     800420d5c7 <sys_env_set_pgfault_upcall+0x41>
		return result;
  800420d5c2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d5c5:	eb 14                	jmp    800420d5db <sys_env_set_pgfault_upcall+0x55>

	env_store->env_pgfault_upcall = func;
  800420d5c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d5cb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d5cf:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420d5d6:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_env_set_pgfault_upcall not implemented");
}
  800420d5db:	c9                   	leaveq 
  800420d5dc:	c3                   	retq   

000000800420d5dd <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420d5dd:	55                   	push   %rbp
  800420d5de:	48 89 e5             	mov    %rsp,%rbp
  800420d5e1:	48 83 ec 30          	sub    $0x30,%rsp
  800420d5e5:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420d5e8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420d5ec:	89 55 d8             	mov    %edx,-0x28(%rbp)
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	// LAB 4: Your code here.
	uint32_t  result =0;
  800420d5ef:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	struct PageInfo * pp;
	pte_t *pte_store;
	//cprintf("sys page alloc [%d]",result);
	result = envid2env(envid,&env_store,1);
  800420d5f6:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420d5fa:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420d5fd:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d602:	48 89 ce             	mov    %rcx,%rsi
  800420d605:	89 c7                	mov    %eax,%edi
  800420d607:	48 b8 5e 78 20 04 80 	movabs $0x800420785e,%rax
  800420d60e:	00 00 00 
  800420d611:	ff d0                	callq  *%rax
  800420d613:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420d616:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d61a:	74 08                	je     800420d624 <sys_page_alloc+0x47>
		return result;
  800420d61c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d61f:	e9 a2 00 00 00       	jmpq   800420d6c6 <sys_page_alloc+0xe9>

	if(!(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL))
  800420d624:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d627:	83 e0 04             	and    $0x4,%eax
  800420d62a:	85 c0                	test   %eax,%eax
  800420d62c:	74 16                	je     800420d644 <sys_page_alloc+0x67>
  800420d62e:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d631:	83 e0 01             	and    $0x1,%eax
  800420d634:	85 c0                	test   %eax,%eax
  800420d636:	74 0c                	je     800420d644 <sys_page_alloc+0x67>
  800420d638:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d63b:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420d640:	85 c0                	test   %eax,%eax
  800420d642:	74 07                	je     800420d64b <sys_page_alloc+0x6e>
		return -E_INVAL;
  800420d644:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d649:	eb 7b                	jmp    800420d6c6 <sys_page_alloc+0xe9>

	if(((uint64_t)va%PGSIZE !=0) ||((uint64_t)va> UTOP))
  800420d64b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d64f:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d654:	48 85 c0             	test   %rax,%rax
  800420d657:	75 13                	jne    800420d66c <sys_page_alloc+0x8f>
  800420d659:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420d65d:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420d664:	00 00 00 
  800420d667:	48 39 c2             	cmp    %rax,%rdx
  800420d66a:	76 07                	jbe    800420d673 <sys_page_alloc+0x96>
		return -E_INVAL;
  800420d66c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d671:	eb 53                	jmp    800420d6c6 <sys_page_alloc+0xe9>
	
    pp = page_alloc(0);
  800420d673:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d678:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  800420d67f:	00 00 00 
  800420d682:	ff d0                	callq  *%rax
  800420d684:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(!pp)
  800420d688:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d68d:	75 07                	jne    800420d696 <sys_page_alloc+0xb9>
		return -E_NO_MEM;
  800420d68f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420d694:	eb 30                	jmp    800420d6c6 <sys_page_alloc+0xe9>
	

	result = page_insert(env_store->env_pml4e,pp,va,perm|PTE_P);
  800420d696:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d699:	83 c8 01             	or     $0x1,%eax
  800420d69c:	89 c1                	mov    %eax,%ecx
  800420d69e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d6a2:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d6a9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420d6ad:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420d6b1:	48 89 c7             	mov    %rax,%rdi
  800420d6b4:	48 b8 bf 37 20 04 80 	movabs $0x80042037bf,%rax
  800420d6bb:	00 00 00 
  800420d6be:	ff d0                	callq  *%rax
  800420d6c0:	89 45 fc             	mov    %eax,-0x4(%rbp)
	//cprintf("sys page alloc [%d]",result);
	return result;
  800420d6c3:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_page_alloc not implemented");
}
  800420d6c6:	c9                   	leaveq 
  800420d6c7:	c3                   	retq   

000000800420d6c8 <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420d6c8:	55                   	push   %rbp
  800420d6c9:	48 89 e5             	mov    %rsp,%rbp
  800420d6cc:	48 83 ec 50          	sub    $0x50,%rsp
  800420d6d0:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420d6d3:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420d6d7:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420d6da:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420d6de:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
	//   check the current permissions on the page.

	// LAB 4: Your code here.

	
	uint32_t  result =0;
  800420d6e2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store_src;
	struct Env *env_store_dst;
	struct PageInfo * pp;
	pte_t *pte_store;
	result = envid2env(srcenvid,&env_store_src,1);
  800420d6e9:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420d6ed:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420d6f0:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d6f5:	48 89 ce             	mov    %rcx,%rsi
  800420d6f8:	89 c7                	mov    %eax,%edi
  800420d6fa:	48 b8 5e 78 20 04 80 	movabs $0x800420785e,%rax
  800420d701:	00 00 00 
  800420d704:	ff d0                	callq  *%rax
  800420d706:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0){
  800420d709:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d70d:	74 08                	je     800420d717 <sys_page_map+0x4f>
		//cprintf("need 1stcheckperm to be 0\n");
		return result;
  800420d70f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d712:	e9 1c 01 00 00       	jmpq   800420d833 <sys_page_map+0x16b>
	}
	result = envid2env(dstenvid,&env_store_dst,0);
  800420d717:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420d71b:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420d71e:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d723:	48 89 ce             	mov    %rcx,%rsi
  800420d726:	89 c7                	mov    %eax,%edi
  800420d728:	48 b8 5e 78 20 04 80 	movabs $0x800420785e,%rax
  800420d72f:	00 00 00 
  800420d732:	ff d0                	callq  *%rax
  800420d734:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result != 0){
  800420d737:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d73b:	74 08                	je     800420d745 <sys_page_map+0x7d>
		//cprintf("need 2ndcheckperm to be 0\n");
		return result;
  800420d73d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d740:	e9 ee 00 00 00       	jmpq   800420d833 <sys_page_map+0x16b>
	}

	if(!(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL))
  800420d745:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d748:	83 e0 04             	and    $0x4,%eax
  800420d74b:	85 c0                	test   %eax,%eax
  800420d74d:	74 16                	je     800420d765 <sys_page_map+0x9d>
  800420d74f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d752:	83 e0 01             	and    $0x1,%eax
  800420d755:	85 c0                	test   %eax,%eax
  800420d757:	74 0c                	je     800420d765 <sys_page_map+0x9d>
  800420d759:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d75c:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420d761:	85 c0                	test   %eax,%eax
  800420d763:	74 0a                	je     800420d76f <sys_page_map+0xa7>
		return -E_INVAL;
  800420d765:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d76a:	e9 c4 00 00 00       	jmpq   800420d833 <sys_page_map+0x16b>

	
	if(((uint64_t)dstva%PGSIZE !=0 || (uint64_t)dstva> UTOP)||((uint64_t)srcva%PGSIZE !=0 || (uint64_t)srcva> UTOP))
  800420d76f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420d773:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d778:	48 85 c0             	test   %rax,%rax
  800420d77b:	75 34                	jne    800420d7b1 <sys_page_map+0xe9>
  800420d77d:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420d781:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420d788:	00 00 00 
  800420d78b:	48 39 c2             	cmp    %rax,%rdx
  800420d78e:	77 21                	ja     800420d7b1 <sys_page_map+0xe9>
  800420d790:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420d794:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d799:	48 85 c0             	test   %rax,%rax
  800420d79c:	75 13                	jne    800420d7b1 <sys_page_map+0xe9>
  800420d79e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420d7a2:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420d7a9:	00 00 00 
  800420d7ac:	48 39 c2             	cmp    %rax,%rdx
  800420d7af:	76 07                	jbe    800420d7b8 <sys_page_map+0xf0>
		return -E_INVAL;
  800420d7b1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d7b6:	eb 7b                	jmp    800420d833 <sys_page_map+0x16b>
	pp = page_lookup(env_store_src->env_pml4e, srcva, &pte_store);
  800420d7b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d7bc:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d7c3:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800420d7c7:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420d7cb:	48 89 ce             	mov    %rcx,%rsi
  800420d7ce:	48 89 c7             	mov    %rax,%rdi
  800420d7d1:	48 b8 1c 39 20 04 80 	movabs $0x800420391c,%rax
  800420d7d8:	00 00 00 
  800420d7db:	ff d0                	callq  *%rax
  800420d7dd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(NULL == pp || (((*(pte_store) & PTE_W) == 0) && ((perm & PTE_W) != 0)))
  800420d7e1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d7e6:	74 19                	je     800420d801 <sys_page_map+0x139>
  800420d7e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d7ec:	48 8b 00             	mov    (%rax),%rax
  800420d7ef:	83 e0 02             	and    $0x2,%eax
  800420d7f2:	48 85 c0             	test   %rax,%rax
  800420d7f5:	75 11                	jne    800420d808 <sys_page_map+0x140>
  800420d7f7:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d7fa:	83 e0 02             	and    $0x2,%eax
  800420d7fd:	85 c0                	test   %eax,%eax
  800420d7ff:	74 07                	je     800420d808 <sys_page_map+0x140>
		return -E_INVAL;	
  800420d801:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d806:	eb 2b                	jmp    800420d833 <sys_page_map+0x16b>

	
	result = page_insert(env_store_dst->env_pml4e,pp,dstva,perm);
  800420d808:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d80c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d813:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420d816:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420d81a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420d81e:	48 89 c7             	mov    %rax,%rdi
  800420d821:	48 b8 bf 37 20 04 80 	movabs $0x80042037bf,%rax
  800420d828:	00 00 00 
  800420d82b:	ff d0                	callq  *%rax
  800420d82d:	89 45 fc             	mov    %eax,-0x4(%rbp)
	
	return result;
  800420d830:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_page_map not implemented");
}
  800420d833:	c9                   	leaveq 
  800420d834:	c3                   	retq   

000000800420d835 <sys_page_unmap>:
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.

static int
sys_page_unmap(envid_t envid, void *va)
{
  800420d835:	55                   	push   %rbp
  800420d836:	48 89 e5             	mov    %rsp,%rbp
  800420d839:	48 83 ec 20          	sub    $0x20,%rsp
  800420d83d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d840:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Hint: This function is a wrapper around page_remove().
	
	// LAB 4: Your code here.
	struct Env* env;
	if(envid2env(envid, &env,1) != 0)
  800420d844:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  800420d848:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d84b:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d850:	48 89 ce             	mov    %rcx,%rsi
  800420d853:	89 c7                	mov    %eax,%edi
  800420d855:	48 b8 5e 78 20 04 80 	movabs $0x800420785e,%rax
  800420d85c:	00 00 00 
  800420d85f:	ff d0                	callq  *%rax
  800420d861:	85 c0                	test   %eax,%eax
  800420d863:	74 07                	je     800420d86c <sys_page_unmap+0x37>
	{
		return -E_BAD_ENV;
  800420d865:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d86a:	eb 55                	jmp    800420d8c1 <sys_page_unmap+0x8c>
	}
	if(va == NULL || (uint64_t)va >= UTOP || (uint64_t)va  % PGSIZE != 0)
  800420d86c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420d871:	74 21                	je     800420d894 <sys_page_unmap+0x5f>
  800420d873:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d877:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d87e:	00 00 00 
  800420d881:	48 39 c2             	cmp    %rax,%rdx
  800420d884:	77 0e                	ja     800420d894 <sys_page_unmap+0x5f>
  800420d886:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d88a:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d88f:	48 85 c0             	test   %rax,%rax
  800420d892:	74 07                	je     800420d89b <sys_page_unmap+0x66>
	{
		return -E_INVAL;
  800420d894:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d899:	eb 26                	jmp    800420d8c1 <sys_page_unmap+0x8c>
	}
	page_remove(env->env_pml4e, va);
  800420d89b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d89f:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d8a6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d8aa:	48 89 d6             	mov    %rdx,%rsi
  800420d8ad:	48 89 c7             	mov    %rax,%rdi
  800420d8b0:	48 b8 b6 39 20 04 80 	movabs $0x80042039b6,%rax
  800420d8b7:	00 00 00 
  800420d8ba:	ff d0                	callq  *%rax
	return 0;
  800420d8bc:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_page_unmap not implemented");
}
  800420d8c1:	c9                   	leaveq 
  800420d8c2:	c3                   	retq   

000000800420d8c3 <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420d8c3:	55                   	push   %rbp
  800420d8c4:	48 89 e5             	mov    %rsp,%rbp
  800420d8c7:	48 83 ec 40          	sub    $0x40,%rsp
  800420d8cb:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420d8ce:	89 75 d8             	mov    %esi,-0x28(%rbp)
  800420d8d1:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420d8d5:	89 4d cc             	mov    %ecx,-0x34(%rbp)
	// LAB 4: Your code here.
	struct Env* dstenv;
	struct Env* srcenv;
	pte_t* pte_store;
	int srcperm;
	perm|= PTE_P;
  800420d8d8:	83 4d cc 01          	orl    $0x1,-0x34(%rbp)
	if(envid2env(envid, &dstenv,0) != 0)
  800420d8dc:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d8e0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420d8e3:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d8e8:	48 89 ce             	mov    %rcx,%rsi
  800420d8eb:	89 c7                	mov    %eax,%edi
  800420d8ed:	48 b8 5e 78 20 04 80 	movabs $0x800420785e,%rax
  800420d8f4:	00 00 00 
  800420d8f7:	ff d0                	callq  *%rax
  800420d8f9:	85 c0                	test   %eax,%eax
  800420d8fb:	74 0a                	je     800420d907 <sys_ipc_try_send+0x44>
		return -E_BAD_ENV;
  800420d8fd:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d902:	e9 19 02 00 00       	jmpq   800420db20 <sys_ipc_try_send+0x25d>

	if(envid2env(0, &srcenv,0) != 0)
  800420d907:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420d90b:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d910:	48 89 c6             	mov    %rax,%rsi
  800420d913:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d918:	48 b8 5e 78 20 04 80 	movabs $0x800420785e,%rax
  800420d91f:	00 00 00 
  800420d922:	ff d0                	callq  *%rax
  800420d924:	85 c0                	test   %eax,%eax
  800420d926:	74 0a                	je     800420d932 <sys_ipc_try_send+0x6f>
		return -E_BAD_ENV;
  800420d928:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d92d:	e9 ee 01 00 00       	jmpq   800420db20 <sys_ipc_try_send+0x25d>
	
	if(!dstenv->env_ipc_recving)
  800420d932:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d936:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420d93d:	83 f0 01             	xor    $0x1,%eax
  800420d940:	84 c0                	test   %al,%al
  800420d942:	74 0a                	je     800420d94e <sys_ipc_try_send+0x8b>
		return -E_IPC_NOT_RECV;
  800420d944:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420d949:	e9 d2 01 00 00       	jmpq   800420db20 <sys_ipc_try_send+0x25d>

	if(!page_lookup(srcenv->env_pml4e,srcva,&pte_store))
  800420d94e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d952:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d959:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  800420d95d:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420d961:	48 89 ce             	mov    %rcx,%rsi
  800420d964:	48 89 c7             	mov    %rax,%rdi
  800420d967:	48 b8 1c 39 20 04 80 	movabs $0x800420391c,%rax
  800420d96e:	00 00 00 
  800420d971:	ff d0                	callq  *%rax
  800420d973:	48 85 c0             	test   %rax,%rax
  800420d976:	75 1a                	jne    800420d992 <sys_ipc_try_send+0xcf>
		if(srcva <(void*)UTOP)
  800420d978:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d97f:	00 00 00 
  800420d982:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420d986:	77 0a                	ja     800420d992 <sys_ipc_try_send+0xcf>
			return -E_INVAL;
  800420d988:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d98d:	e9 8e 01 00 00       	jmpq   800420db20 <sys_ipc_try_send+0x25d>
	srcperm = *pte_store&PTE_SYSCALL;
  800420d992:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d996:	48 8b 00             	mov    (%rax),%rax
  800420d999:	25 07 0e 00 00       	and    $0xe07,%eax
  800420d99e:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(srcva <(void*)UTOP)
  800420d9a1:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d9a8:	00 00 00 
  800420d9ab:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420d9af:	77 23                	ja     800420d9d4 <sys_ipc_try_send+0x111>
		if((((uint64_t)srcva)%PGSIZE!=0) || ((srcperm & (PTE_U | PTE_P))!=(PTE_U | PTE_P)))
  800420d9b1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d9b5:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d9ba:	48 85 c0             	test   %rax,%rax
  800420d9bd:	75 0b                	jne    800420d9ca <sys_ipc_try_send+0x107>
  800420d9bf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d9c2:	83 e0 05             	and    $0x5,%eax
  800420d9c5:	83 f8 05             	cmp    $0x5,%eax
  800420d9c8:	74 0a                	je     800420d9d4 <sys_ipc_try_send+0x111>
			return -E_INVAL;
  800420d9ca:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d9cf:	e9 4c 01 00 00       	jmpq   800420db20 <sys_ipc_try_send+0x25d>
	if((srcva <(void*)UTOP) && ((perm & PTE_W) !=0) &&(((srcperm& PTE_W) == 0)))
  800420d9d4:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d9db:	00 00 00 
  800420d9de:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420d9e2:	77 1e                	ja     800420da02 <sys_ipc_try_send+0x13f>
  800420d9e4:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420d9e7:	83 e0 02             	and    $0x2,%eax
  800420d9ea:	85 c0                	test   %eax,%eax
  800420d9ec:	74 14                	je     800420da02 <sys_ipc_try_send+0x13f>
  800420d9ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d9f1:	83 e0 02             	and    $0x2,%eax
  800420d9f4:	85 c0                	test   %eax,%eax
  800420d9f6:	75 0a                	jne    800420da02 <sys_ipc_try_send+0x13f>
		return -E_INVAL;
  800420d9f8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d9fd:	e9 1e 01 00 00       	jmpq   800420db20 <sys_ipc_try_send+0x25d>

	if(envid == curenv->env_id)
  800420da02:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420da09:	00 00 00 
  800420da0c:	ff d0                	callq  *%rax
  800420da0e:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420da15:	00 00 00 
  800420da18:	48 98                	cltq   
  800420da1a:	48 c1 e0 03          	shl    $0x3,%rax
  800420da1e:	48 89 c2             	mov    %rax,%rdx
  800420da21:	48 c1 e2 04          	shl    $0x4,%rdx
  800420da25:	48 29 c2             	sub    %rax,%rdx
  800420da28:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420da2c:	48 83 c0 08          	add    $0x8,%rax
  800420da30:	48 8b 00             	mov    (%rax),%rax
  800420da33:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420da39:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  800420da3c:	75 2a                	jne    800420da68 <sys_ipc_try_send+0x1a5>
		panic("what the hell. how can this be????");
  800420da3e:	48 ba f0 99 21 04 80 	movabs $0x80042199f0,%rdx
  800420da45:	00 00 00 
  800420da48:	be 96 01 00 00       	mov    $0x196,%esi
  800420da4d:	48 bf 13 9a 21 04 80 	movabs $0x8004219a13,%rdi
  800420da54:	00 00 00 
  800420da57:	b8 00 00 00 00       	mov    $0x0,%eax
  800420da5c:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  800420da63:	00 00 00 
  800420da66:	ff d1                	callq  *%rcx

	dstenv->env_ipc_recving = 0;
  800420da68:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da6c:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
	dstenv->env_ipc_from = srcenv->env_id;
  800420da73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da77:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da7b:	8b 92 c8 00 00 00    	mov    0xc8(%rdx),%edx
  800420da81:	89 90 0c 01 00 00    	mov    %edx,0x10c(%rax)
	dstenv->env_ipc_value = value;
  800420da87:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da8b:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420da8e:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
	//cprintf("dstenv -> envID is:[%d]\n",dstenv->env_id);
	if(srcva <(void*)UTOP && dstenv->env_ipc_dstva <(void*)UTOP){
  800420da94:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420da9b:	00 00 00 
  800420da9e:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420daa2:	77 69                	ja     800420db0d <sys_ipc_try_send+0x24a>
  800420daa4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420daa8:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420daaf:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dab6:	00 00 00 
  800420dab9:	48 39 c2             	cmp    %rax,%rdx
  800420dabc:	77 4f                	ja     800420db0d <sys_ipc_try_send+0x24a>
		dstenv->env_ipc_perm = perm;
  800420dabe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dac2:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420dac5:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
		if(0< sys_page_map(srcenv->env_id,srcva,dstenv->env_id,dstenv->env_ipc_dstva,perm))
  800420dacb:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420dace:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dad2:	48 8b 88 00 01 00 00 	mov    0x100(%rax),%rcx
  800420dad9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dadd:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420dae3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dae7:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420daed:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420daf1:	41 89 f8             	mov    %edi,%r8d
  800420daf4:	89 c7                	mov    %eax,%edi
  800420daf6:	48 b8 c8 d6 20 04 80 	movabs $0x800420d6c8,%rax
  800420dafd:	00 00 00 
  800420db00:	ff d0                	callq  *%rax
  800420db02:	85 c0                	test   %eax,%eax
  800420db04:	7e 07                	jle    800420db0d <sys_ipc_try_send+0x24a>
			return -E_NO_MEM;
  800420db06:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420db0b:	eb 13                	jmp    800420db20 <sys_ipc_try_send+0x25d>
	}
	dstenv->env_status = ENV_RUNNABLE;
  800420db0d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420db11:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420db18:	00 00 00 
	return 0;
  800420db1b:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_ipc_try_send not implemented");
}
  800420db20:	c9                   	leaveq 
  800420db21:	c3                   	retq   

000000800420db22 <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420db22:	55                   	push   %rbp
  800420db23:	48 89 e5             	mov    %rsp,%rbp
  800420db26:	48 83 ec 20          	sub    $0x20,%rsp
  800420db2a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// LAB 4: Your code here.
	struct Env* env;
	if(envid2env(0, &env,0) != 0)
  800420db2e:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  800420db32:	ba 00 00 00 00       	mov    $0x0,%edx
  800420db37:	48 89 c6             	mov    %rax,%rsi
  800420db3a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420db3f:	48 b8 5e 78 20 04 80 	movabs $0x800420785e,%rax
  800420db46:	00 00 00 
  800420db49:	ff d0                	callq  *%rax
  800420db4b:	85 c0                	test   %eax,%eax
  800420db4d:	74 07                	je     800420db56 <sys_ipc_recv+0x34>
	{
		return -E_BAD_ENV;
  800420db4f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420db54:	eb 7a                	jmp    800420dbd0 <sys_ipc_recv+0xae>
	}
	if(dstva <(void*)UTOP && (uint64_t)dstva%PGSIZE!=0)
  800420db56:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420db5d:	00 00 00 
  800420db60:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420db64:	77 15                	ja     800420db7b <sys_ipc_recv+0x59>
  800420db66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420db6a:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420db6f:	48 85 c0             	test   %rax,%rax
  800420db72:	74 07                	je     800420db7b <sys_ipc_recv+0x59>
		return -E_INVAL;
  800420db74:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420db79:	eb 55                	jmp    800420dbd0 <sys_ipc_recv+0xae>
	if(dstva <(void*)UTOP)
  800420db7b:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420db82:	00 00 00 
  800420db85:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420db89:	77 0f                	ja     800420db9a <sys_ipc_recv+0x78>
		env->env_ipc_dstva = dstva;
  800420db8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420db8f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420db93:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)

	env->env_ipc_recving = 1;
  800420db9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420db9e:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)

	env->env_status = ENV_NOT_RUNNABLE;
  800420dba5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dba9:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420dbb0:	00 00 00 
	env->env_tf.tf_regs.reg_rax = 0;
  800420dbb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dbb7:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420dbbe:	00 
	sys_yield();
  800420dbbf:	48 b8 9a d3 20 04 80 	movabs $0x800420d39a,%rax
  800420dbc6:	00 00 00 
  800420dbc9:	ff d0                	callq  *%rax
	
	//panic("sys_ipc_recv not implemented");
	return 0;
  800420dbcb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420dbd0:	c9                   	leaveq 
  800420dbd1:	c3                   	retq   

000000800420dbd2 <sys_time_msec>:

// Return the current time.
static int
sys_time_msec(void)
{
  800420dbd2:	55                   	push   %rbp
  800420dbd3:	48 89 e5             	mov    %rsp,%rbp
        // LAB 6: Your code here.
        return time_msec();
  800420dbd6:	48 b8 b3 80 21 04 80 	movabs $0x80042180b3,%rax
  800420dbdd:	00 00 00 
  800420dbe0:	ff d0                	callq  *%rax
        panic("sys_time_msec not implemented");
}
  800420dbe2:	5d                   	pop    %rbp
  800420dbe3:	c3                   	retq   

000000800420dbe4 <sys_net_rx>:

static int
sys_net_rx(void * buf, size_t size)
{
  800420dbe4:	55                   	push   %rbp
  800420dbe5:	48 89 e5             	mov    %rsp,%rbp
  800420dbe8:	48 83 ec 10          	sub    $0x10,%rsp
  800420dbec:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420dbf0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return 0;
  800420dbf4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420dbf9:	c9                   	leaveq 
  800420dbfa:	c3                   	retq   

000000800420dbfb <sys_net_tx>:

static int
sys_net_tx(void * buf, size_t size)
{
  800420dbfb:	55                   	push   %rbp
  800420dbfc:	48 89 e5             	mov    %rsp,%rbp
  800420dbff:	48 83 ec 10          	sub    $0x10,%rsp
  800420dc03:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420dc07:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	//int i = 0;
	//for(; i < 10; i++)
	pci_transmit_packet(buf ,size);
  800420dc0b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420dc0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dc13:	48 89 d6             	mov    %rdx,%rsi
  800420dc16:	48 89 c7             	mov    %rax,%rdi
  800420dc19:	48 b8 d5 71 21 04 80 	movabs $0x80042171d5,%rax
  800420dc20:	00 00 00 
  800420dc23:	ff d0                	callq  *%rax
	return 0;
  800420dc25:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420dc2a:	c9                   	leaveq 
  800420dc2b:	c3                   	retq   

000000800420dc2c <syscall>:

// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420dc2c:	55                   	push   %rbp
  800420dc2d:	48 89 e5             	mov    %rsp,%rbp
  800420dc30:	48 83 ec 40          	sub    $0x40,%rsp
  800420dc34:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420dc38:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420dc3c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420dc40:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420dc44:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  800420dc48:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.

	//panic("syscall not implemented");
	int64_t result = -E_NO_SYS;
  800420dc4c:	48 c7 45 f8 f9 ff ff 	movq   $0xfffffffffffffff9,-0x8(%rbp)
  800420dc53:	ff 

	switch (syscallno) 
  800420dc54:	48 83 7d e8 10       	cmpq   $0x10,-0x18(%rbp)
  800420dc59:	0f 87 1c 02 00 00    	ja     800420de7b <syscall+0x24f>
  800420dc5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dc63:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420dc6a:	00 
  800420dc6b:	48 b8 28 9a 21 04 80 	movabs $0x8004219a28,%rax
  800420dc72:	00 00 00 
  800420dc75:	48 01 d0             	add    %rdx,%rax
  800420dc78:	48 8b 00             	mov    (%rax),%rax
  800420dc7b:	ff e0                	jmpq   *%rax
	{
		case SYS_cputs:
			sys_cputs((const char *)a1, a2);
  800420dc7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dc81:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420dc85:	48 89 d6             	mov    %rdx,%rsi
  800420dc88:	48 89 c7             	mov    %rax,%rdi
  800420dc8b:	48 b8 76 d2 20 04 80 	movabs $0x800420d276,%rax
  800420dc92:	00 00 00 
  800420dc95:	ff d0                	callq  *%rax
			result = 0;
  800420dc97:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420dc9e:	00 
			break;
  800420dc9f:	e9 e0 01 00 00       	jmpq   800420de84 <syscall+0x258>
		case SYS_cgetc:
			result = sys_cgetc();
  800420dca4:	48 b8 fb d2 20 04 80 	movabs $0x800420d2fb,%rax
  800420dcab:	00 00 00 
  800420dcae:	ff d0                	callq  *%rax
  800420dcb0:	48 98                	cltq   
  800420dcb2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420dcb6:	e9 c9 01 00 00       	jmpq   800420de84 <syscall+0x258>
		case SYS_getenvid:
			result = sys_getenvid();
  800420dcbb:	48 b8 0d d3 20 04 80 	movabs $0x800420d30d,%rax
  800420dcc2:	00 00 00 
  800420dcc5:	ff d0                	callq  *%rax
  800420dcc7:	48 98                	cltq   
  800420dcc9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420dccd:	e9 b2 01 00 00       	jmpq   800420de84 <syscall+0x258>
		case SYS_env_destroy:
			result = sys_env_destroy(a1);
  800420dcd2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dcd6:	89 c7                	mov    %eax,%edi
  800420dcd8:	48 b8 4a d3 20 04 80 	movabs $0x800420d34a,%rax
  800420dcdf:	00 00 00 
  800420dce2:	ff d0                	callq  *%rax
  800420dce4:	48 98                	cltq   
  800420dce6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420dcea:	e9 95 01 00 00       	jmpq   800420de84 <syscall+0x258>
		case SYS_yield:
			sys_yield();
  800420dcef:	48 b8 9a d3 20 04 80 	movabs $0x800420d39a,%rax
  800420dcf6:	00 00 00 
  800420dcf9:	ff d0                	callq  *%rax
			result = 0;
  800420dcfb:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420dd02:	00 
			break;
  800420dd03:	e9 7c 01 00 00       	jmpq   800420de84 <syscall+0x258>
		case SYS_exofork:
			return sys_exofork();
  800420dd08:	48 b8 aa d3 20 04 80 	movabs $0x800420d3aa,%rax
  800420dd0f:	00 00 00 
  800420dd12:	ff d0                	callq  *%rax
  800420dd14:	48 98                	cltq   
  800420dd16:	e9 6d 01 00 00       	jmpq   800420de88 <syscall+0x25c>
			break;
		case SYS_env_set_status:
			return sys_env_set_status(a1, a2);
  800420dd1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dd1f:	89 c2                	mov    %eax,%edx
  800420dd21:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dd25:	89 d6                	mov    %edx,%esi
  800420dd27:	89 c7                	mov    %eax,%edi
  800420dd29:	48 b8 88 d4 20 04 80 	movabs $0x800420d488,%rax
  800420dd30:	00 00 00 
  800420dd33:	ff d0                	callq  *%rax
  800420dd35:	48 98                	cltq   
  800420dd37:	e9 4c 01 00 00       	jmpq   800420de88 <syscall+0x25c>
			break;
		case SYS_env_set_pgfault_upcall:
			return sys_env_set_pgfault_upcall(a1, (void*)a2);
  800420dd3c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420dd40:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dd44:	48 89 d6             	mov    %rdx,%rsi
  800420dd47:	89 c7                	mov    %eax,%edi
  800420dd49:	48 b8 86 d5 20 04 80 	movabs $0x800420d586,%rax
  800420dd50:	00 00 00 
  800420dd53:	ff d0                	callq  *%rax
  800420dd55:	48 98                	cltq   
  800420dd57:	e9 2c 01 00 00       	jmpq   800420de88 <syscall+0x25c>
			break;
		case SYS_ipc_try_send:
			return sys_ipc_try_send(a1, a2, (void*)a3, a4);
  800420dd5c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420dd60:	89 c1                	mov    %eax,%ecx
  800420dd62:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420dd66:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dd6a:	89 c6                	mov    %eax,%esi
  800420dd6c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dd70:	89 c7                	mov    %eax,%edi
  800420dd72:	48 b8 c3 d8 20 04 80 	movabs $0x800420d8c3,%rax
  800420dd79:	00 00 00 
  800420dd7c:	ff d0                	callq  *%rax
  800420dd7e:	48 98                	cltq   
  800420dd80:	e9 03 01 00 00       	jmpq   800420de88 <syscall+0x25c>
			break;
		case SYS_ipc_recv:
			return sys_ipc_recv((void*)a1);
  800420dd85:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dd89:	48 89 c7             	mov    %rax,%rdi
  800420dd8c:	48 b8 22 db 20 04 80 	movabs $0x800420db22,%rax
  800420dd93:	00 00 00 
  800420dd96:	ff d0                	callq  *%rax
  800420dd98:	48 98                	cltq   
  800420dd9a:	e9 e9 00 00 00       	jmpq   800420de88 <syscall+0x25c>
			break;
		case SYS_page_alloc:
			return sys_page_alloc(a1, (void*)a2, a3);
  800420dd9f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dda3:	89 c2                	mov    %eax,%edx
  800420dda5:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420dda9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ddad:	48 89 ce             	mov    %rcx,%rsi
  800420ddb0:	89 c7                	mov    %eax,%edi
  800420ddb2:	48 b8 dd d5 20 04 80 	movabs $0x800420d5dd,%rax
  800420ddb9:	00 00 00 
  800420ddbc:	ff d0                	callq  *%rax
  800420ddbe:	48 98                	cltq   
  800420ddc0:	e9 c3 00 00 00       	jmpq   800420de88 <syscall+0x25c>
			break;	
		case SYS_page_map:
			return sys_page_map(a1, (void*)a2, a3, (void*)a4, a5);
  800420ddc5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420ddc9:	89 c7                	mov    %eax,%edi
  800420ddcb:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800420ddcf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ddd3:	89 c2                	mov    %eax,%edx
  800420ddd5:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420ddd9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dddd:	41 89 f8             	mov    %edi,%r8d
  800420dde0:	89 c7                	mov    %eax,%edi
  800420dde2:	48 b8 c8 d6 20 04 80 	movabs $0x800420d6c8,%rax
  800420dde9:	00 00 00 
  800420ddec:	ff d0                	callq  *%rax
  800420ddee:	48 98                	cltq   
  800420ddf0:	e9 93 00 00 00       	jmpq   800420de88 <syscall+0x25c>
			break;
		case SYS_page_unmap:
			return sys_page_unmap(a1, (void*)a2);
  800420ddf5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420ddf9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ddfd:	48 89 d6             	mov    %rdx,%rsi
  800420de00:	89 c7                	mov    %eax,%edi
  800420de02:	48 b8 35 d8 20 04 80 	movabs $0x800420d835,%rax
  800420de09:	00 00 00 
  800420de0c:	ff d0                	callq  *%rax
  800420de0e:	48 98                	cltq   
  800420de10:	eb 76                	jmp    800420de88 <syscall+0x25c>
			break;
		case SYS_env_set_trapframe:
			return sys_env_set_trapframe(a1, (struct Trapframe *)a2);
  800420de12:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420de16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420de1a:	48 89 d6             	mov    %rdx,%rsi
  800420de1d:	89 c7                	mov    %eax,%edi
  800420de1f:	48 b8 ed d4 20 04 80 	movabs $0x800420d4ed,%rax
  800420de26:	00 00 00 
  800420de29:	ff d0                	callq  *%rax
  800420de2b:	48 98                	cltq   
  800420de2d:	eb 59                	jmp    800420de88 <syscall+0x25c>
		case SYS_net_rx:
			return sys_net_rx((void *)a1, (size_t)a2);
  800420de2f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420de33:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420de37:	48 89 d6             	mov    %rdx,%rsi
  800420de3a:	48 89 c7             	mov    %rax,%rdi
  800420de3d:	48 b8 e4 db 20 04 80 	movabs $0x800420dbe4,%rax
  800420de44:	00 00 00 
  800420de47:	ff d0                	callq  *%rax
  800420de49:	48 98                	cltq   
  800420de4b:	eb 3b                	jmp    800420de88 <syscall+0x25c>
		case SYS_net_tx:
			return sys_net_tx((void *)a1, (size_t)a2);
  800420de4d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420de51:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420de55:	48 89 d6             	mov    %rdx,%rsi
  800420de58:	48 89 c7             	mov    %rax,%rdi
  800420de5b:	48 b8 fb db 20 04 80 	movabs $0x800420dbfb,%rax
  800420de62:	00 00 00 
  800420de65:	ff d0                	callq  *%rax
  800420de67:	48 98                	cltq   
  800420de69:	eb 1d                	jmp    800420de88 <syscall+0x25c>
		case SYS_time_msec:
			return sys_time_msec();
  800420de6b:	48 b8 d2 db 20 04 80 	movabs $0x800420dbd2,%rax
  800420de72:	00 00 00 
  800420de75:	ff d0                	callq  *%rax
  800420de77:	48 98                	cltq   
  800420de79:	eb 0d                	jmp    800420de88 <syscall+0x25c>
		default:		
			return -E_NO_SYS;
  800420de7b:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
  800420de82:	eb 04                	jmp    800420de88 <syscall+0x25c>
	}
	return result;	
  800420de84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420de88:	c9                   	leaveq 
  800420de89:	c3                   	retq   

000000800420de8a <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420de8a:	55                   	push   %rbp
  800420de8b:	48 89 e5             	mov    %rsp,%rbp
  800420de8e:	48 81 ec f0 61 00 00 	sub    $0x61f0,%rsp
  800420de95:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420de9c:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420dea3:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420deaa:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420deb1:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420deb8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420debc:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420dec3:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420deca:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420dece:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420ded5:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420dedc:	48 89 d1             	mov    %rdx,%rcx
  800420dedf:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420dee4:	48 89 ce             	mov    %rcx,%rsi
  800420dee7:	48 89 c7             	mov    %rax,%rdi
  800420deea:	48 b8 2a fb 20 04 80 	movabs $0x800420fb2a,%rax
  800420def1:	00 00 00 
  800420def4:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420def6:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420defd:	00 
	uint64_t ret_offset=0;
  800420defe:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420df05:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420df06:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420df0d:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420df11:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420df15:	74 0a                	je     800420df21 <list_func_die+0x97>
		return 0;
  800420df17:	b8 00 00 00 00       	mov    $0x0,%eax
  800420df1c:	e9 cd 06 00 00       	jmpq   800420e5ee <list_func_die+0x764>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420df21:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420df28:	ba 38 00 00 00       	mov    $0x38,%edx
  800420df2d:	be 00 00 00 00       	mov    $0x0,%esi
  800420df32:	48 89 c7             	mov    %rax,%rdi
  800420df35:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  800420df3c:	00 00 00 
  800420df3f:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420df41:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420df48:	be 11 00 00 00       	mov    $0x11,%esi
  800420df4d:	48 89 c7             	mov    %rax,%rdi
  800420df50:	48 b8 bd 18 21 04 80 	movabs $0x80042118bd,%rax
  800420df57:	00 00 00 
  800420df5a:	ff d0                	callq  *%rax
  800420df5c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420df60:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420df67:	be 12 00 00 00       	mov    $0x12,%esi
  800420df6c:	48 89 c7             	mov    %rax,%rdi
  800420df6f:	48 b8 bd 18 21 04 80 	movabs $0x80042118bd,%rax
  800420df76:	00 00 00 
  800420df79:	ff d0                	callq  *%rax
  800420df7b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420df7f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420df84:	0f 84 5f 06 00 00    	je     800420e5e9 <list_func_die+0x75f>
  800420df8a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420df8e:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420df92:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420df99:	0f 83 4a 06 00 00    	jae    800420e5e9 <list_func_die+0x75f>
  800420df9f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420dfa4:	0f 84 3f 06 00 00    	je     800420e5e9 <list_func_die+0x75f>
  800420dfaa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420dfae:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420dfb2:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420dfb9:	0f 86 2a 06 00 00    	jbe    800420e5e9 <list_func_die+0x75f>
	{
		info->rip_file = die->cu_die->die_name;
  800420dfbf:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420dfc6:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420dfcd:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420dfd4:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420dfdb:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420dfde:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420dfe5:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420dfec:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420dff3:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420dff7:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420dffe:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420e005:	48 89 c7             	mov    %rax,%rdi
  800420e008:	48 b8 83 f6 20 04 80 	movabs $0x800420f683,%rax
  800420e00f:	00 00 00 
  800420e012:	ff d0                	callq  *%rax
  800420e014:	48 8b 95 58 9e ff ff 	mov    -0x61a8(%rbp),%rdx
  800420e01b:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420e01e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e022:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420e026:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e02d:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420e031:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e038:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e03f:	48 85 c0             	test   %rax,%rax
  800420e042:	75 35                	jne    800420e079 <list_func_die+0x1ef>
  800420e044:	48 b9 e0 9d 21 04 80 	movabs $0x8004219de0,%rcx
  800420e04b:	00 00 00 
  800420e04e:	48 ba ec 9d 21 04 80 	movabs $0x8004219dec,%rdx
  800420e055:	00 00 00 
  800420e058:	be 91 00 00 00       	mov    $0x91,%esi
  800420e05d:	48 bf 01 9e 21 04 80 	movabs $0x8004219e01,%rdi
  800420e064:	00 00 00 
  800420e067:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e06c:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420e073:	00 00 00 
  800420e076:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420e079:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e080:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e087:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420e08e:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420e095:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420e09a:	48 89 c7             	mov    %rax,%rdi
  800420e09d:	48 b8 e4 4e 21 04 80 	movabs $0x8004214ee4,%rax
  800420e0a4:	00 00 00 
  800420e0a7:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420e0a9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420e0b0:	89 c2                	mov    %eax,%edx
  800420e0b2:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e0b9:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420e0bc:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e0c3:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420e0ca:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e0d1:	00 00 00 
  800420e0d4:	48 8b 00             	mov    (%rax),%rax
  800420e0d7:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420e0de:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420e0e5:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420e0e9:	48 89 c7             	mov    %rax,%rdi
  800420e0ec:	48 b8 94 1b 21 04 80 	movabs $0x8004211b94,%rax
  800420e0f3:	00 00 00 
  800420e0f6:	ff d0                	callq  *%rax
  800420e0f8:	83 f8 04             	cmp    $0x4,%eax
  800420e0fb:	0f 84 e1 04 00 00    	je     800420e5e2 <list_func_die+0x758>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420e101:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420e108:	48 83 f8 05          	cmp    $0x5,%rax
  800420e10c:	74 05                	je     800420e113 <list_func_die+0x289>
				goto last;
  800420e10e:	e9 cf 04 00 00       	jmpq   800420e5e2 <list_func_die+0x758>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420e113:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e11a:	be 49 00 00 00       	mov    $0x49,%esi
  800420e11f:	48 89 c7             	mov    %rax,%rdi
  800420e122:	48 b8 bd 18 21 04 80 	movabs $0x80042118bd,%rax
  800420e129:	00 00 00 
  800420e12c:	ff d0                	callq  *%rax
  800420e12e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420e132:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e137:	0f 84 d7 00 00 00    	je     800420e214 <list_func_die+0x38a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420e13d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e141:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420e145:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e149:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e14d:	48 01 d0             	add    %rdx,%rax
  800420e150:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420e154:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e15b:	00 00 00 
  800420e15e:	48 8b 08             	mov    (%rax),%rcx
  800420e161:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420e168:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420e16c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e170:	48 8b 38             	mov    (%rax),%rdi
  800420e173:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420e177:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420e17b:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420e180:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420e184:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420e189:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420e18d:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420e192:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420e196:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420e19b:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420e19f:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420e1a4:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420e1a8:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420e1ad:	48 89 cf             	mov    %rcx,%rdi
  800420e1b0:	48 b8 ba 17 21 04 80 	movabs $0x80042117ba,%rax
  800420e1b7:	00 00 00 
  800420e1ba:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420e1bc:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e1c3:	be 0b 00 00 00       	mov    $0xb,%esi
  800420e1c8:	48 89 c7             	mov    %rax,%rdi
  800420e1cb:	48 b8 bd 18 21 04 80 	movabs $0x80042118bd,%rax
  800420e1d2:	00 00 00 
  800420e1d5:	ff d0                	callq  *%rax
  800420e1d7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420e1db:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e1e0:	74 0e                	je     800420e1f0 <list_func_die+0x366>
				{
					ret_val = attr->u[0].u64;
  800420e1e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e1e6:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e1ea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e1ee:	eb 24                	jmp    800420e214 <list_func_die+0x38a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420e1f0:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e1f7:	be 49 00 00 00       	mov    $0x49,%esi
  800420e1fc:	48 89 c7             	mov    %rax,%rdi
  800420e1ff:	48 b8 bd 18 21 04 80 	movabs $0x80042118bd,%rax
  800420e206:	00 00 00 
  800420e209:	ff d0                	callq  *%rax
  800420e20b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420e20f:	e9 1e ff ff ff       	jmpq   800420e132 <list_func_die+0x2a8>
				}
			}

			ret_offset = 0;
  800420e214:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420e21b:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420e21c:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e223:	be 02 00 00 00       	mov    $0x2,%esi
  800420e228:	48 89 c7             	mov    %rax,%rdi
  800420e22b:	48 b8 bd 18 21 04 80 	movabs $0x80042118bd,%rax
  800420e232:	00 00 00 
  800420e235:	ff d0                	callq  *%rax
  800420e237:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420e23b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e240:	0f 84 a2 00 00 00    	je     800420e2e8 <list_func_die+0x45e>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420e246:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e24a:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420e24e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420e252:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e256:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420e25a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420e25e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e262:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420e266:	48 83 f8 03          	cmp    $0x3,%rax
  800420e26a:	72 7c                	jb     800420e2e8 <list_func_die+0x45e>
  800420e26c:	48 83 f8 04          	cmp    $0x4,%rax
  800420e270:	76 06                	jbe    800420e278 <list_func_die+0x3ee>
  800420e272:	48 83 f8 0a          	cmp    $0xa,%rax
  800420e276:	75 70                	jne    800420e2e8 <list_func_die+0x45e>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420e278:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420e27f:	00 
						atom = *(loc_ptr++);
  800420e280:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e284:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e288:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420e28c:	0f b6 00             	movzbl (%rax),%eax
  800420e28f:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420e292:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420e297:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420e29b:	75 4a                	jne    800420e2e7 <list_func_die+0x45d>
							uint8_t *p = loc_ptr;
  800420e29d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e2a1:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420e2a8:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420e2af:	48 89 c7             	mov    %rax,%rdi
  800420e2b2:	48 b8 19 05 21 04 80 	movabs $0x8004210519,%rax
  800420e2b9:	00 00 00 
  800420e2bc:	ff d0                	callq  *%rax
  800420e2be:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420e2c2:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420e2c9:	48 89 c2             	mov    %rax,%rdx
  800420e2cc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e2d0:	48 29 c2             	sub    %rax,%rdx
  800420e2d3:	48 89 d0             	mov    %rdx,%rax
  800420e2d6:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420e2da:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420e2e1:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420e2e5:	eb 00                	jmp    800420e2e7 <list_func_die+0x45d>
  800420e2e7:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420e2e8:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e2ef:	8b 48 28             	mov    0x28(%rax),%ecx
  800420e2f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e2f6:	89 c2                	mov    %eax,%edx
  800420e2f8:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e2ff:	48 63 c9             	movslq %ecx,%rcx
  800420e302:	48 83 c1 08          	add    $0x8,%rcx
  800420e306:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420e30a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e311:	8b 50 28             	mov    0x28(%rax),%edx
  800420e314:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e31b:	48 63 d2             	movslq %edx,%rdx
  800420e31e:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420e322:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e326:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420e32b:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e332:	8b 40 28             	mov    0x28(%rax),%eax
  800420e335:	8d 50 01             	lea    0x1(%rax),%edx
  800420e338:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e33f:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420e342:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e349:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420e350:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e355:	48 89 ce             	mov    %rcx,%rsi
  800420e358:	48 89 c7             	mov    %rax,%rdi
  800420e35b:	48 b8 2a fb 20 04 80 	movabs $0x800420fb2a,%rax
  800420e362:	00 00 00 
  800420e365:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420e367:	e9 40 02 00 00       	jmpq   800420e5ac <list_func_die+0x722>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420e36c:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420e373:	48 83 f8 05          	cmp    $0x5,%rax
  800420e377:	74 05                	je     800420e37e <list_func_die+0x4f4>
					break;
  800420e379:	e9 64 02 00 00       	jmpq   800420e5e2 <list_func_die+0x758>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420e37e:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e385:	be 49 00 00 00       	mov    $0x49,%esi
  800420e38a:	48 89 c7             	mov    %rax,%rdi
  800420e38d:	48 b8 bd 18 21 04 80 	movabs $0x80042118bd,%rax
  800420e394:	00 00 00 
  800420e397:	ff d0                	callq  *%rax
  800420e399:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420e39d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e3a2:	0f 84 b1 00 00 00    	je     800420e459 <list_func_die+0x5cf>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420e3a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e3ac:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420e3b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e3b4:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e3b8:	48 01 d0             	add    %rdx,%rax
  800420e3bb:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420e3bf:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e3c6:	00 00 00 
  800420e3c9:	48 8b 08             	mov    (%rax),%rcx
  800420e3cc:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420e3d3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420e3d7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e3db:	48 8b 38             	mov    (%rax),%rdi
  800420e3de:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420e3e2:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420e3e6:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420e3eb:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420e3ef:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420e3f4:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420e3f8:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420e3fd:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420e401:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420e406:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420e40a:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420e40f:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420e413:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420e418:	48 89 cf             	mov    %rcx,%rdi
  800420e41b:	48 b8 ba 17 21 04 80 	movabs $0x80042117ba,%rax
  800420e422:	00 00 00 
  800420e425:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420e427:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e42e:	be 0b 00 00 00       	mov    $0xb,%esi
  800420e433:	48 89 c7             	mov    %rax,%rdi
  800420e436:	48 b8 bd 18 21 04 80 	movabs $0x80042118bd,%rax
  800420e43d:	00 00 00 
  800420e440:	ff d0                	callq  *%rax
  800420e442:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420e446:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e44b:	74 0c                	je     800420e459 <list_func_die+0x5cf>
					{
						ret_val = attr->u[0].u64;
  800420e44d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e451:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e455:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420e459:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420e460:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420e461:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e468:	be 02 00 00 00       	mov    $0x2,%esi
  800420e46d:	48 89 c7             	mov    %rax,%rdi
  800420e470:	48 b8 bd 18 21 04 80 	movabs $0x80042118bd,%rax
  800420e477:	00 00 00 
  800420e47a:	ff d0                	callq  *%rax
  800420e47c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420e480:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e485:	0f 84 a2 00 00 00    	je     800420e52d <list_func_die+0x6a3>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420e48b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e48f:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420e493:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420e497:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e49b:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420e49f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420e4a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e4a7:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420e4ab:	48 83 f8 03          	cmp    $0x3,%rax
  800420e4af:	72 7c                	jb     800420e52d <list_func_die+0x6a3>
  800420e4b1:	48 83 f8 04          	cmp    $0x4,%rax
  800420e4b5:	76 06                	jbe    800420e4bd <list_func_die+0x633>
  800420e4b7:	48 83 f8 0a          	cmp    $0xa,%rax
  800420e4bb:	75 70                	jne    800420e52d <list_func_die+0x6a3>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420e4bd:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420e4c4:	00 
							atom = *(loc_ptr++);
  800420e4c5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e4c9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e4cd:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e4d1:	0f b6 00             	movzbl (%rax),%eax
  800420e4d4:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420e4d7:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420e4dc:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420e4e0:	75 4a                	jne    800420e52c <list_func_die+0x6a2>
								uint8_t *p = loc_ptr;
  800420e4e2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e4e6:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420e4ed:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420e4f4:	48 89 c7             	mov    %rax,%rdi
  800420e4f7:	48 b8 19 05 21 04 80 	movabs $0x8004210519,%rax
  800420e4fe:	00 00 00 
  800420e501:	ff d0                	callq  *%rax
  800420e503:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420e507:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420e50e:	48 89 c2             	mov    %rax,%rdx
  800420e511:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e515:	48 29 c2             	sub    %rax,%rdx
  800420e518:	48 89 d0             	mov    %rdx,%rax
  800420e51b:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420e51f:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420e526:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420e52a:	eb 00                	jmp    800420e52c <list_func_die+0x6a2>
  800420e52c:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420e52d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e534:	8b 48 28             	mov    0x28(%rax),%ecx
  800420e537:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e53b:	89 c2                	mov    %eax,%edx
  800420e53d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e544:	48 63 c9             	movslq %ecx,%rcx
  800420e547:	48 83 c1 08          	add    $0x8,%rcx
  800420e54b:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420e54f:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e556:	8b 50 28             	mov    0x28(%rax),%edx
  800420e559:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e560:	48 63 d2             	movslq %edx,%rdx
  800420e563:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420e567:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e56b:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420e570:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e577:	8b 40 28             	mov    0x28(%rax),%eax
  800420e57a:	8d 50 01             	lea    0x1(%rax),%edx
  800420e57d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e584:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420e587:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e58e:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420e595:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e59a:	48 89 ce             	mov    %rcx,%rsi
  800420e59d:	48 89 c7             	mov    %rax,%rdi
  800420e5a0:	48 b8 2a fb 20 04 80 	movabs $0x800420fb2a,%rax
  800420e5a7:	00 00 00 
  800420e5aa:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420e5ac:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e5b3:	00 00 00 
  800420e5b6:	48 8b 00             	mov    (%rax),%rax
  800420e5b9:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420e5bd:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420e5c4:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420e5cb:	48 89 c7             	mov    %rax,%rdi
  800420e5ce:	48 b8 50 19 21 04 80 	movabs $0x8004211950,%rax
  800420e5d5:	00 00 00 
  800420e5d8:	ff d0                	callq  *%rax
  800420e5da:	85 c0                	test   %eax,%eax
  800420e5dc:	0f 84 8a fd ff ff    	je     800420e36c <list_func_die+0x4e2>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420e5e2:	b8 01 00 00 00       	mov    $0x1,%eax
  800420e5e7:	eb 05                	jmp    800420e5ee <list_func_die+0x764>
	}

	return 0;
  800420e5e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e5ee:	c9                   	leaveq 
  800420e5ef:	c3                   	retq   

000000800420e5f0 <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420e5f0:	55                   	push   %rbp
  800420e5f1:	48 89 e5             	mov    %rsp,%rbp
  800420e5f4:	53                   	push   %rbx
  800420e5f5:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420e5fc:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420e603:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420e60a:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420e611:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420e612:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420e619:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420e61d:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e624:	48 bb 0f 9e 21 04 80 	movabs $0x8004219e0f,%rbx
  800420e62b:	00 00 00 
  800420e62e:	48 89 18             	mov    %rbx,(%rax)
	info->rip_line = 0;
  800420e631:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e638:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420e63f:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e646:	48 bb 0f 9e 21 04 80 	movabs $0x8004219e0f,%rbx
  800420e64d:	00 00 00 
  800420e650:	48 89 58 10          	mov    %rbx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420e654:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e65b:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420e662:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e669:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420e670:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420e674:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e67b:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420e682:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420e689:	00 00 00 
  800420e68c:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420e693:	76 13                	jbe    800420e6a8 <debuginfo_rip+0xb8>
		elf = (void *)0x10000 + KERNBASE;
  800420e695:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420e69c:	00 00 00 
  800420e69f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420e6a3:	e9 08 01 00 00       	jmpq   800420e7b0 <debuginfo_rip+0x1c0>
	} else {
		if(curenv != lastenv) {
  800420e6a8:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420e6af:	00 00 00 
  800420e6b2:	ff d0                	callq  *%rax
  800420e6b4:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420e6bb:	00 00 00 
  800420e6be:	48 98                	cltq   
  800420e6c0:	48 c1 e0 03          	shl    $0x3,%rax
  800420e6c4:	48 89 c2             	mov    %rax,%rdx
  800420e6c7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e6cb:	48 29 c2             	sub    %rax,%rdx
  800420e6ce:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e6d2:	48 83 c0 08          	add    $0x8,%rax
  800420e6d6:	48 8b 10             	mov    (%rax),%rdx
  800420e6d9:	48 b8 a0 82 60 04 80 	movabs $0x80046082a0,%rax
  800420e6e0:	00 00 00 
  800420e6e3:	48 8b 00             	mov    (%rax),%rax
  800420e6e6:	48 39 c2             	cmp    %rax,%rdx
  800420e6e9:	0f 84 85 00 00 00    	je     800420e774 <debuginfo_rip+0x184>
			find_debug_sections((uintptr_t)curenv->elf);
  800420e6ef:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420e6f6:	00 00 00 
  800420e6f9:	ff d0                	callq  *%rax
  800420e6fb:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420e702:	00 00 00 
  800420e705:	48 98                	cltq   
  800420e707:	48 c1 e0 03          	shl    $0x3,%rax
  800420e70b:	48 89 c2             	mov    %rax,%rdx
  800420e70e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e712:	48 29 c2             	sub    %rax,%rdx
  800420e715:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e719:	48 83 c0 08          	add    $0x8,%rax
  800420e71d:	48 8b 00             	mov    (%rax),%rax
  800420e720:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420e727:	48 89 c7             	mov    %rax,%rdi
  800420e72a:	48 b8 df 50 21 04 80 	movabs $0x80042150df,%rax
  800420e731:	00 00 00 
  800420e734:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420e736:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420e73d:	00 00 00 
  800420e740:	ff d0                	callq  *%rax
  800420e742:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420e749:	00 00 00 
  800420e74c:	48 98                	cltq   
  800420e74e:	48 c1 e0 03          	shl    $0x3,%rax
  800420e752:	48 89 c2             	mov    %rax,%rdx
  800420e755:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e759:	48 29 c2             	sub    %rax,%rdx
  800420e75c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e760:	48 83 c0 08          	add    $0x8,%rax
  800420e764:	48 8b 10             	mov    (%rax),%rdx
  800420e767:	48 b8 a0 82 60 04 80 	movabs $0x80046082a0,%rax
  800420e76e:	00 00 00 
  800420e771:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420e774:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  800420e77b:	00 00 00 
  800420e77e:	ff d0                	callq  *%rax
  800420e780:	48 b9 20 a0 60 04 80 	movabs $0x800460a020,%rcx
  800420e787:	00 00 00 
  800420e78a:	48 98                	cltq   
  800420e78c:	48 c1 e0 03          	shl    $0x3,%rax
  800420e790:	48 89 c2             	mov    %rax,%rdx
  800420e793:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e797:	48 29 c2             	sub    %rax,%rdx
  800420e79a:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
  800420e79e:	48 83 c0 08          	add    $0x8,%rax
  800420e7a2:	48 8b 00             	mov    (%rax),%rax
  800420e7a5:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420e7ac:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}
	_dwarf_init(dbg, elf);
  800420e7b0:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e7b7:	00 00 00 
  800420e7ba:	48 8b 00             	mov    (%rax),%rax
  800420e7bd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e7c1:	48 89 d6             	mov    %rdx,%rsi
  800420e7c4:	48 89 c7             	mov    %rax,%rdi
  800420e7c7:	48 b8 c8 07 21 04 80 	movabs $0x80042107c8,%rax
  800420e7ce:	00 00 00 
  800420e7d1:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420e7d3:	48 bf 19 9e 21 04 80 	movabs $0x8004219e19,%rdi
  800420e7da:	00 00 00 
  800420e7dd:	48 b8 5f 50 21 04 80 	movabs $0x800421505f,%rax
  800420e7e4:	00 00 00 
  800420e7e7:	ff d0                	callq  *%rax
  800420e7e9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420e7ed:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e7f4:	00 00 00 
  800420e7f7:	48 8b 00             	mov    (%rax),%rax
  800420e7fa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e7fe:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420e802:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420e806:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e80d:	00 00 00 
  800420e810:	48 8b 00             	mov    (%rax),%rax
  800420e813:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e817:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420e81b:	48 89 50 10          	mov    %rdx,0x10(%rax)

	assert(dbg->dbg_info_size);
  800420e81f:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e826:	00 00 00 
  800420e829:	48 8b 00             	mov    (%rax),%rax
  800420e82c:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420e830:	48 85 c0             	test   %rax,%rax
  800420e833:	75 35                	jne    800420e86a <debuginfo_rip+0x27a>
  800420e835:	48 b9 25 9e 21 04 80 	movabs $0x8004219e25,%rcx
  800420e83c:	00 00 00 
  800420e83f:	48 ba ec 9d 21 04 80 	movabs $0x8004219dec,%rdx
  800420e846:	00 00 00 
  800420e849:	be 37 01 00 00       	mov    $0x137,%esi
  800420e84e:	48 bf 01 9e 21 04 80 	movabs $0x8004219e01,%rdi
  800420e855:	00 00 00 
  800420e858:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e85d:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800420e864:	00 00 00 
  800420e867:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
  800420e86a:	e9 6f 01 00 00       	jmpq   800420e9de <debuginfo_rip+0x3ee>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420e86f:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e876:	00 00 00 
  800420e879:	48 8b 00             	mov    (%rax),%rax
  800420e87c:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420e880:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420e887:	be 00 00 00 00       	mov    $0x0,%esi
  800420e88c:	48 89 c7             	mov    %rax,%rdi
  800420e88f:	48 b8 50 19 21 04 80 	movabs $0x8004211950,%rax
  800420e896:	00 00 00 
  800420e899:	ff d0                	callq  *%rax
  800420e89b:	83 f8 04             	cmp    $0x4,%eax
  800420e89e:	75 05                	jne    800420e8a5 <debuginfo_rip+0x2b5>
			continue;
  800420e8a0:	e9 39 01 00 00       	jmpq   800420e9de <debuginfo_rip+0x3ee>

		cudie.cu_header = &cu;
  800420e8a5:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420e8a9:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
		cudie.cu_die = NULL;
  800420e8b0:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420e8b7:	00 00 00 00 

		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420e8bb:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e8c2:	00 00 00 
  800420e8c5:	48 8b 00             	mov    (%rax),%rax
  800420e8c8:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420e8cf:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420e8d6:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420e8da:	48 89 c7             	mov    %rax,%rdi
  800420e8dd:	48 b8 94 1b 21 04 80 	movabs $0x8004211b94,%rax
  800420e8e4:	00 00 00 
  800420e8e7:	ff d0                	callq  *%rax
  800420e8e9:	83 f8 04             	cmp    $0x4,%eax
  800420e8ec:	75 05                	jne    800420e8f3 <debuginfo_rip+0x303>
			continue;
  800420e8ee:	e9 eb 00 00 00       	jmpq   800420e9de <debuginfo_rip+0x3ee>

		die.cu_header = &cu;
  800420e8f3:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420e8f7:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		die.cu_die = &cudie;
  800420e8fe:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420e905:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420e90c:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420e913:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420e91a:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e921:	48 89 ce             	mov    %rcx,%rsi
  800420e924:	48 89 c7             	mov    %rax,%rdi
  800420e927:	48 b8 8a de 20 04 80 	movabs $0x800420de8a,%rax
  800420e92e:	00 00 00 
  800420e931:	ff d0                	callq  *%rax
  800420e933:	85 c0                	test   %eax,%eax
  800420e935:	74 30                	je     800420e967 <debuginfo_rip+0x377>
				goto find_done;
  800420e937:	90                   	nop

	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420e938:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e93f:	00 00 00 
  800420e942:	48 8b 00             	mov    (%rax),%rax
  800420e945:	be 00 00 00 00       	mov    $0x0,%esi
  800420e94a:	48 89 c7             	mov    %rax,%rdi
  800420e94d:	48 b8 6c 42 21 04 80 	movabs $0x800421426c,%rax
  800420e954:	00 00 00 
  800420e957:	ff d0                	callq  *%rax
  800420e959:	83 f8 01             	cmp    $0x1,%eax
  800420e95c:	0f 85 bb 00 00 00    	jne    800420ea1d <debuginfo_rip+0x42d>
  800420e962:	e9 ac 00 00 00       	jmpq   800420ea13 <debuginfo_rip+0x423>
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420e967:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e96e:	00 00 00 
  800420e971:	48 8b 00             	mov    (%rax),%rax
  800420e974:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420e978:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420e97f:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420e986:	48 89 c7             	mov    %rax,%rdi
  800420e989:	48 b8 50 19 21 04 80 	movabs $0x8004211950,%rax
  800420e990:	00 00 00 
  800420e993:	ff d0                	callq  *%rax
  800420e995:	85 c0                	test   %eax,%eax
  800420e997:	79 02                	jns    800420e99b <debuginfo_rip+0x3ab>
				break; 
  800420e999:	eb 43                	jmp    800420e9de <debuginfo_rip+0x3ee>
			die = die2;
  800420e99b:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420e9a2:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420e9a9:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e9ae:	48 89 ce             	mov    %rcx,%rsi
  800420e9b1:	48 89 c7             	mov    %rax,%rdi
  800420e9b4:	48 b8 2a fb 20 04 80 	movabs $0x800420fb2a,%rax
  800420e9bb:	00 00 00 
  800420e9be:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420e9c0:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420e9c4:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
			die.cu_die = &cudie;
  800420e9cb:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420e9d2:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		}
  800420e9d9:	e9 2e ff ff ff       	jmpq   800420e90c <debuginfo_rip+0x31c>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;

	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420e9de:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420e9e5:	00 00 00 
  800420e9e8:	48 8b 00             	mov    (%rax),%rax
  800420e9eb:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420e9ef:	48 89 d6             	mov    %rdx,%rsi
  800420e9f2:	48 89 c7             	mov    %rax,%rdi
  800420e9f5:	48 b8 aa 08 21 04 80 	movabs $0x80042108aa,%rax
  800420e9fc:	00 00 00 
  800420e9ff:	ff d0                	callq  *%rax
  800420ea01:	85 c0                	test   %eax,%eax
  800420ea03:	0f 84 66 fe ff ff    	je     800420e86f <debuginfo_rip+0x27f>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}

	return -1;
  800420ea09:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420ea0e:	e9 a0 00 00 00       	jmpq   800420eab3 <debuginfo_rip+0x4c3>

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
		return -1;
  800420ea13:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420ea18:	e9 96 00 00 00       	jmpq   800420eab3 <debuginfo_rip+0x4c3>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420ea1d:	48 b8 a0 d6 22 04 80 	movabs $0x800422d6a0,%rax
  800420ea24:	00 00 00 
  800420ea27:	48 8b 08             	mov    (%rax),%rcx
  800420ea2a:	48 b8 98 d6 22 04 80 	movabs $0x800422d698,%rax
  800420ea31:	00 00 00 
  800420ea34:	48 8b 10             	mov    (%rax),%rdx
  800420ea37:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420ea3e:	00 00 00 
  800420ea41:	48 8b 00             	mov    (%rax),%rax
  800420ea44:	48 8b b5 38 6e ff ff 	mov    -0x91c8(%rbp),%rsi
  800420ea4b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420ea51:	48 89 c7             	mov    %rax,%rdi
  800420ea54:	48 b8 d5 1d 21 04 80 	movabs $0x8004211dd5,%rax
  800420ea5b:	00 00 00 
  800420ea5e:	ff d0                	callq  *%rax
  800420ea60:	85 c0                	test   %eax,%eax
  800420ea62:	75 4a                	jne    800420eaae <debuginfo_rip+0x4be>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr,
  800420ea64:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420ea6b:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420ea72:	48 b8 98 d6 22 04 80 	movabs $0x800422d698,%rax
  800420ea79:	00 00 00 
  800420ea7c:	48 8b 30             	mov    (%rax),%rsi
  800420ea7f:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  800420ea86:	00 00 00 
  800420ea89:	48 8b 00             	mov    (%rax),%rax
  800420ea8c:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420ea93:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420ea99:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420ea9f:	48 89 c7             	mov    %rax,%rdi
  800420eaa2:	48 b8 e1 30 21 04 80 	movabs $0x80042130e1,%rax
  800420eaa9:	00 00 00 
  800420eaac:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420eaae:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420eab3:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420eaba:	5b                   	pop    %rbx
  800420eabb:	5d                   	pop    %rbp
  800420eabc:	c3                   	retq   

000000800420eabd <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420eabd:	55                   	push   %rbp
  800420eabe:	48 89 e5             	mov    %rsp,%rbp
  800420eac1:	53                   	push   %rbx
  800420eac2:	48 83 ec 38          	sub    $0x38,%rsp
  800420eac6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eaca:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420eace:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420ead2:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420ead5:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420ead9:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420eadd:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420eae0:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420eae4:	77 3b                	ja     800420eb21 <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420eae6:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420eae9:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420eaed:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420eaf0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eaf4:	ba 00 00 00 00       	mov    $0x0,%edx
  800420eaf9:	48 f7 f3             	div    %rbx
  800420eafc:	48 89 c2             	mov    %rax,%rdx
  800420eaff:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420eb02:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420eb05:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420eb09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb0d:	41 89 f9             	mov    %edi,%r9d
  800420eb10:	48 89 c7             	mov    %rax,%rdi
  800420eb13:	48 b8 bd ea 20 04 80 	movabs $0x800420eabd,%rax
  800420eb1a:	00 00 00 
  800420eb1d:	ff d0                	callq  *%rax
  800420eb1f:	eb 1e                	jmp    800420eb3f <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420eb21:	eb 12                	jmp    800420eb35 <printnum+0x78>
			putch(padc, putdat);
  800420eb23:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420eb27:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420eb2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb2e:	48 89 ce             	mov    %rcx,%rsi
  800420eb31:	89 d7                	mov    %edx,%edi
  800420eb33:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420eb35:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420eb39:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420eb3d:	7f e4                	jg     800420eb23 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420eb3f:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420eb42:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eb46:	ba 00 00 00 00       	mov    $0x0,%edx
  800420eb4b:	48 f7 f1             	div    %rcx
  800420eb4e:	48 89 d0             	mov    %rdx,%rax
  800420eb51:	48 ba 30 a0 21 04 80 	movabs $0x800421a030,%rdx
  800420eb58:	00 00 00 
  800420eb5b:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420eb5f:	0f be d0             	movsbl %al,%edx
  800420eb62:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420eb66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb6a:	48 89 ce             	mov    %rcx,%rsi
  800420eb6d:	89 d7                	mov    %edx,%edi
  800420eb6f:	ff d0                	callq  *%rax
}
  800420eb71:	48 83 c4 38          	add    $0x38,%rsp
  800420eb75:	5b                   	pop    %rbx
  800420eb76:	5d                   	pop    %rbp
  800420eb77:	c3                   	retq   

000000800420eb78 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420eb78:	55                   	push   %rbp
  800420eb79:	48 89 e5             	mov    %rsp,%rbp
  800420eb7c:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420eb80:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eb84:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420eb87:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420eb8b:	7e 52                	jle    800420ebdf <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420eb8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb91:	8b 00                	mov    (%rax),%eax
  800420eb93:	83 f8 30             	cmp    $0x30,%eax
  800420eb96:	73 24                	jae    800420ebbc <getuint+0x44>
  800420eb98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb9c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420eba0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eba4:	8b 00                	mov    (%rax),%eax
  800420eba6:	89 c0                	mov    %eax,%eax
  800420eba8:	48 01 d0             	add    %rdx,%rax
  800420ebab:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ebaf:	8b 12                	mov    (%rdx),%edx
  800420ebb1:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ebb4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ebb8:	89 0a                	mov    %ecx,(%rdx)
  800420ebba:	eb 17                	jmp    800420ebd3 <getuint+0x5b>
  800420ebbc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebc0:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ebc4:	48 89 d0             	mov    %rdx,%rax
  800420ebc7:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ebcb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ebcf:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ebd3:	48 8b 00             	mov    (%rax),%rax
  800420ebd6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ebda:	e9 a3 00 00 00       	jmpq   800420ec82 <getuint+0x10a>
	else if (lflag)
  800420ebdf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420ebe3:	74 4f                	je     800420ec34 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420ebe5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebe9:	8b 00                	mov    (%rax),%eax
  800420ebeb:	83 f8 30             	cmp    $0x30,%eax
  800420ebee:	73 24                	jae    800420ec14 <getuint+0x9c>
  800420ebf0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebf4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ebf8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebfc:	8b 00                	mov    (%rax),%eax
  800420ebfe:	89 c0                	mov    %eax,%eax
  800420ec00:	48 01 d0             	add    %rdx,%rax
  800420ec03:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec07:	8b 12                	mov    (%rdx),%edx
  800420ec09:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ec0c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec10:	89 0a                	mov    %ecx,(%rdx)
  800420ec12:	eb 17                	jmp    800420ec2b <getuint+0xb3>
  800420ec14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec18:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ec1c:	48 89 d0             	mov    %rdx,%rax
  800420ec1f:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ec23:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec27:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ec2b:	48 8b 00             	mov    (%rax),%rax
  800420ec2e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ec32:	eb 4e                	jmp    800420ec82 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420ec34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec38:	8b 00                	mov    (%rax),%eax
  800420ec3a:	83 f8 30             	cmp    $0x30,%eax
  800420ec3d:	73 24                	jae    800420ec63 <getuint+0xeb>
  800420ec3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec43:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ec47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec4b:	8b 00                	mov    (%rax),%eax
  800420ec4d:	89 c0                	mov    %eax,%eax
  800420ec4f:	48 01 d0             	add    %rdx,%rax
  800420ec52:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec56:	8b 12                	mov    (%rdx),%edx
  800420ec58:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ec5b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec5f:	89 0a                	mov    %ecx,(%rdx)
  800420ec61:	eb 17                	jmp    800420ec7a <getuint+0x102>
  800420ec63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec67:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ec6b:	48 89 d0             	mov    %rdx,%rax
  800420ec6e:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ec72:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ec76:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ec7a:	8b 00                	mov    (%rax),%eax
  800420ec7c:	89 c0                	mov    %eax,%eax
  800420ec7e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420ec82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ec86:	c9                   	leaveq 
  800420ec87:	c3                   	retq   

000000800420ec88 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420ec88:	55                   	push   %rbp
  800420ec89:	48 89 e5             	mov    %rsp,%rbp
  800420ec8c:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ec90:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ec94:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420ec97:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420ec9b:	7e 52                	jle    800420ecef <getint+0x67>
		x=va_arg(*ap, long long);
  800420ec9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eca1:	8b 00                	mov    (%rax),%eax
  800420eca3:	83 f8 30             	cmp    $0x30,%eax
  800420eca6:	73 24                	jae    800420eccc <getint+0x44>
  800420eca8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecac:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ecb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecb4:	8b 00                	mov    (%rax),%eax
  800420ecb6:	89 c0                	mov    %eax,%eax
  800420ecb8:	48 01 d0             	add    %rdx,%rax
  800420ecbb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ecbf:	8b 12                	mov    (%rdx),%edx
  800420ecc1:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ecc4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ecc8:	89 0a                	mov    %ecx,(%rdx)
  800420ecca:	eb 17                	jmp    800420ece3 <getint+0x5b>
  800420eccc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecd0:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ecd4:	48 89 d0             	mov    %rdx,%rax
  800420ecd7:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ecdb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ecdf:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ece3:	48 8b 00             	mov    (%rax),%rax
  800420ece6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ecea:	e9 a3 00 00 00       	jmpq   800420ed92 <getint+0x10a>
	else if (lflag)
  800420ecef:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420ecf3:	74 4f                	je     800420ed44 <getint+0xbc>
		x=va_arg(*ap, long);
  800420ecf5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecf9:	8b 00                	mov    (%rax),%eax
  800420ecfb:	83 f8 30             	cmp    $0x30,%eax
  800420ecfe:	73 24                	jae    800420ed24 <getint+0x9c>
  800420ed00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed04:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ed08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed0c:	8b 00                	mov    (%rax),%eax
  800420ed0e:	89 c0                	mov    %eax,%eax
  800420ed10:	48 01 d0             	add    %rdx,%rax
  800420ed13:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed17:	8b 12                	mov    (%rdx),%edx
  800420ed19:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ed1c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed20:	89 0a                	mov    %ecx,(%rdx)
  800420ed22:	eb 17                	jmp    800420ed3b <getint+0xb3>
  800420ed24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed28:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ed2c:	48 89 d0             	mov    %rdx,%rax
  800420ed2f:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ed33:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed37:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ed3b:	48 8b 00             	mov    (%rax),%rax
  800420ed3e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ed42:	eb 4e                	jmp    800420ed92 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420ed44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed48:	8b 00                	mov    (%rax),%eax
  800420ed4a:	83 f8 30             	cmp    $0x30,%eax
  800420ed4d:	73 24                	jae    800420ed73 <getint+0xeb>
  800420ed4f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed53:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ed57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed5b:	8b 00                	mov    (%rax),%eax
  800420ed5d:	89 c0                	mov    %eax,%eax
  800420ed5f:	48 01 d0             	add    %rdx,%rax
  800420ed62:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed66:	8b 12                	mov    (%rdx),%edx
  800420ed68:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ed6b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed6f:	89 0a                	mov    %ecx,(%rdx)
  800420ed71:	eb 17                	jmp    800420ed8a <getint+0x102>
  800420ed73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed77:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ed7b:	48 89 d0             	mov    %rdx,%rax
  800420ed7e:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ed82:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed86:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ed8a:	8b 00                	mov    (%rax),%eax
  800420ed8c:	48 98                	cltq   
  800420ed8e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420ed92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ed96:	c9                   	leaveq 
  800420ed97:	c3                   	retq   

000000800420ed98 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420ed98:	55                   	push   %rbp
  800420ed99:	48 89 e5             	mov    %rsp,%rbp
  800420ed9c:	41 54                	push   %r12
  800420ed9e:	53                   	push   %rbx
  800420ed9f:	48 83 ec 60          	sub    $0x60,%rsp
  800420eda3:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420eda7:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420edab:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420edaf:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420edb3:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420edb7:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420edbb:	48 8b 0a             	mov    (%rdx),%rcx
  800420edbe:	48 89 08             	mov    %rcx,(%rax)
  800420edc1:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420edc5:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420edc9:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420edcd:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420edd1:	eb 17                	jmp    800420edea <vprintfmt+0x52>
			if (ch == '\0')
  800420edd3:	85 db                	test   %ebx,%ebx
  800420edd5:	0f 84 cc 04 00 00    	je     800420f2a7 <vprintfmt+0x50f>
				return;
			putch(ch, putdat);
  800420eddb:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420eddf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ede3:	48 89 d6             	mov    %rdx,%rsi
  800420ede6:	89 df                	mov    %ebx,%edi
  800420ede8:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420edea:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420edee:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420edf2:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420edf6:	0f b6 00             	movzbl (%rax),%eax
  800420edf9:	0f b6 d8             	movzbl %al,%ebx
  800420edfc:	83 fb 25             	cmp    $0x25,%ebx
  800420edff:	75 d2                	jne    800420edd3 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420ee01:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420ee05:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420ee0c:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420ee13:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420ee1a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420ee21:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ee25:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ee29:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420ee2d:	0f b6 00             	movzbl (%rax),%eax
  800420ee30:	0f b6 d8             	movzbl %al,%ebx
  800420ee33:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420ee36:	83 f8 55             	cmp    $0x55,%eax
  800420ee39:	0f 87 34 04 00 00    	ja     800420f273 <vprintfmt+0x4db>
  800420ee3f:	89 c0                	mov    %eax,%eax
  800420ee41:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ee48:	00 
  800420ee49:	48 b8 58 a0 21 04 80 	movabs $0x800421a058,%rax
  800420ee50:	00 00 00 
  800420ee53:	48 01 d0             	add    %rdx,%rax
  800420ee56:	48 8b 00             	mov    (%rax),%rax
  800420ee59:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800420ee5b:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420ee5f:	eb c0                	jmp    800420ee21 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420ee61:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420ee65:	eb ba                	jmp    800420ee21 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420ee67:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420ee6e:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420ee71:	89 d0                	mov    %edx,%eax
  800420ee73:	c1 e0 02             	shl    $0x2,%eax
  800420ee76:	01 d0                	add    %edx,%eax
  800420ee78:	01 c0                	add    %eax,%eax
  800420ee7a:	01 d8                	add    %ebx,%eax
  800420ee7c:	83 e8 30             	sub    $0x30,%eax
  800420ee7f:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420ee82:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ee86:	0f b6 00             	movzbl (%rax),%eax
  800420ee89:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420ee8c:	83 fb 2f             	cmp    $0x2f,%ebx
  800420ee8f:	7e 0c                	jle    800420ee9d <vprintfmt+0x105>
  800420ee91:	83 fb 39             	cmp    $0x39,%ebx
  800420ee94:	7f 07                	jg     800420ee9d <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420ee96:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420ee9b:	eb d1                	jmp    800420ee6e <vprintfmt+0xd6>
			goto process_precision;
  800420ee9d:	eb 58                	jmp    800420eef7 <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  800420ee9f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420eea2:	83 f8 30             	cmp    $0x30,%eax
  800420eea5:	73 17                	jae    800420eebe <vprintfmt+0x126>
  800420eea7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420eeab:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420eeae:	89 c0                	mov    %eax,%eax
  800420eeb0:	48 01 d0             	add    %rdx,%rax
  800420eeb3:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420eeb6:	83 c2 08             	add    $0x8,%edx
  800420eeb9:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420eebc:	eb 0f                	jmp    800420eecd <vprintfmt+0x135>
  800420eebe:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420eec2:	48 89 d0             	mov    %rdx,%rax
  800420eec5:	48 83 c2 08          	add    $0x8,%rdx
  800420eec9:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420eecd:	8b 00                	mov    (%rax),%eax
  800420eecf:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420eed2:	eb 23                	jmp    800420eef7 <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  800420eed4:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420eed8:	79 0c                	jns    800420eee6 <vprintfmt+0x14e>
				width = 0;
  800420eeda:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420eee1:	e9 3b ff ff ff       	jmpq   800420ee21 <vprintfmt+0x89>
  800420eee6:	e9 36 ff ff ff       	jmpq   800420ee21 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  800420eeeb:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420eef2:	e9 2a ff ff ff       	jmpq   800420ee21 <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  800420eef7:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420eefb:	79 12                	jns    800420ef0f <vprintfmt+0x177>
				width = precision, precision = -1;
  800420eefd:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420ef00:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420ef03:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420ef0a:	e9 12 ff ff ff       	jmpq   800420ee21 <vprintfmt+0x89>
  800420ef0f:	e9 0d ff ff ff       	jmpq   800420ee21 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420ef14:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420ef18:	e9 04 ff ff ff       	jmpq   800420ee21 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420ef1d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ef20:	83 f8 30             	cmp    $0x30,%eax
  800420ef23:	73 17                	jae    800420ef3c <vprintfmt+0x1a4>
  800420ef25:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ef29:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ef2c:	89 c0                	mov    %eax,%eax
  800420ef2e:	48 01 d0             	add    %rdx,%rax
  800420ef31:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420ef34:	83 c2 08             	add    $0x8,%edx
  800420ef37:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420ef3a:	eb 0f                	jmp    800420ef4b <vprintfmt+0x1b3>
  800420ef3c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420ef40:	48 89 d0             	mov    %rdx,%rax
  800420ef43:	48 83 c2 08          	add    $0x8,%rdx
  800420ef47:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420ef4b:	8b 10                	mov    (%rax),%edx
  800420ef4d:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420ef51:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ef55:	48 89 ce             	mov    %rcx,%rsi
  800420ef58:	89 d7                	mov    %edx,%edi
  800420ef5a:	ff d0                	callq  *%rax
			break;
  800420ef5c:	e9 40 03 00 00       	jmpq   800420f2a1 <vprintfmt+0x509>

			// error message
		case 'e':
			err = va_arg(aq, int);
  800420ef61:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ef64:	83 f8 30             	cmp    $0x30,%eax
  800420ef67:	73 17                	jae    800420ef80 <vprintfmt+0x1e8>
  800420ef69:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420ef6d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ef70:	89 c0                	mov    %eax,%eax
  800420ef72:	48 01 d0             	add    %rdx,%rax
  800420ef75:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420ef78:	83 c2 08             	add    $0x8,%edx
  800420ef7b:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420ef7e:	eb 0f                	jmp    800420ef8f <vprintfmt+0x1f7>
  800420ef80:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420ef84:	48 89 d0             	mov    %rdx,%rax
  800420ef87:	48 83 c2 08          	add    $0x8,%rdx
  800420ef8b:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420ef8f:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420ef91:	85 db                	test   %ebx,%ebx
  800420ef93:	79 02                	jns    800420ef97 <vprintfmt+0x1ff>
				err = -err;
  800420ef95:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420ef97:	83 fb 15             	cmp    $0x15,%ebx
  800420ef9a:	7f 16                	jg     800420efb2 <vprintfmt+0x21a>
  800420ef9c:	48 b8 80 9f 21 04 80 	movabs $0x8004219f80,%rax
  800420efa3:	00 00 00 
  800420efa6:	48 63 d3             	movslq %ebx,%rdx
  800420efa9:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420efad:	4d 85 e4             	test   %r12,%r12
  800420efb0:	75 2e                	jne    800420efe0 <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  800420efb2:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420efb6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420efba:	89 d9                	mov    %ebx,%ecx
  800420efbc:	48 ba 41 a0 21 04 80 	movabs $0x800421a041,%rdx
  800420efc3:	00 00 00 
  800420efc6:	48 89 c7             	mov    %rax,%rdi
  800420efc9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420efce:	49 b8 b0 f2 20 04 80 	movabs $0x800420f2b0,%r8
  800420efd5:	00 00 00 
  800420efd8:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420efdb:	e9 c1 02 00 00       	jmpq   800420f2a1 <vprintfmt+0x509>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420efe0:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420efe4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420efe8:	4c 89 e1             	mov    %r12,%rcx
  800420efeb:	48 ba 4a a0 21 04 80 	movabs $0x800421a04a,%rdx
  800420eff2:	00 00 00 
  800420eff5:	48 89 c7             	mov    %rax,%rdi
  800420eff8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420effd:	49 b8 b0 f2 20 04 80 	movabs $0x800420f2b0,%r8
  800420f004:	00 00 00 
  800420f007:	41 ff d0             	callq  *%r8
			break;
  800420f00a:	e9 92 02 00 00       	jmpq   800420f2a1 <vprintfmt+0x509>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420f00f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f012:	83 f8 30             	cmp    $0x30,%eax
  800420f015:	73 17                	jae    800420f02e <vprintfmt+0x296>
  800420f017:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f01b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f01e:	89 c0                	mov    %eax,%eax
  800420f020:	48 01 d0             	add    %rdx,%rax
  800420f023:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f026:	83 c2 08             	add    $0x8,%edx
  800420f029:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f02c:	eb 0f                	jmp    800420f03d <vprintfmt+0x2a5>
  800420f02e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f032:	48 89 d0             	mov    %rdx,%rax
  800420f035:	48 83 c2 08          	add    $0x8,%rdx
  800420f039:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f03d:	4c 8b 20             	mov    (%rax),%r12
  800420f040:	4d 85 e4             	test   %r12,%r12
  800420f043:	75 0a                	jne    800420f04f <vprintfmt+0x2b7>
				p = "(null)";
  800420f045:	49 bc 4d a0 21 04 80 	movabs $0x800421a04d,%r12
  800420f04c:	00 00 00 
			if (width > 0 && padc != '-')
  800420f04f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f053:	7e 3f                	jle    800420f094 <vprintfmt+0x2fc>
  800420f055:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420f059:	74 39                	je     800420f094 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420f05b:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420f05e:	48 98                	cltq   
  800420f060:	48 89 c6             	mov    %rax,%rsi
  800420f063:	4c 89 e7             	mov    %r12,%rdi
  800420f066:	48 b8 b1 f6 20 04 80 	movabs $0x800420f6b1,%rax
  800420f06d:	00 00 00 
  800420f070:	ff d0                	callq  *%rax
  800420f072:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420f075:	eb 17                	jmp    800420f08e <vprintfmt+0x2f6>
					putch(padc, putdat);
  800420f077:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420f07b:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420f07f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f083:	48 89 ce             	mov    %rcx,%rsi
  800420f086:	89 d7                	mov    %edx,%edi
  800420f088:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420f08a:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f08e:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f092:	7f e3                	jg     800420f077 <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420f094:	eb 37                	jmp    800420f0cd <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  800420f096:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420f09a:	74 1e                	je     800420f0ba <vprintfmt+0x322>
  800420f09c:	83 fb 1f             	cmp    $0x1f,%ebx
  800420f09f:	7e 05                	jle    800420f0a6 <vprintfmt+0x30e>
  800420f0a1:	83 fb 7e             	cmp    $0x7e,%ebx
  800420f0a4:	7e 14                	jle    800420f0ba <vprintfmt+0x322>
					putch('?', putdat);
  800420f0a6:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f0aa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f0ae:	48 89 d6             	mov    %rdx,%rsi
  800420f0b1:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420f0b6:	ff d0                	callq  *%rax
  800420f0b8:	eb 0f                	jmp    800420f0c9 <vprintfmt+0x331>
				else
					putch(ch, putdat);
  800420f0ba:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f0be:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f0c2:	48 89 d6             	mov    %rdx,%rsi
  800420f0c5:	89 df                	mov    %ebx,%edi
  800420f0c7:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420f0c9:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f0cd:	4c 89 e0             	mov    %r12,%rax
  800420f0d0:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420f0d4:	0f b6 00             	movzbl (%rax),%eax
  800420f0d7:	0f be d8             	movsbl %al,%ebx
  800420f0da:	85 db                	test   %ebx,%ebx
  800420f0dc:	74 10                	je     800420f0ee <vprintfmt+0x356>
  800420f0de:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420f0e2:	78 b2                	js     800420f096 <vprintfmt+0x2fe>
  800420f0e4:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420f0e8:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420f0ec:	79 a8                	jns    800420f096 <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420f0ee:	eb 16                	jmp    800420f106 <vprintfmt+0x36e>
				putch(' ', putdat);
  800420f0f0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f0f4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f0f8:	48 89 d6             	mov    %rdx,%rsi
  800420f0fb:	bf 20 00 00 00       	mov    $0x20,%edi
  800420f100:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420f102:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f106:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f10a:	7f e4                	jg     800420f0f0 <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  800420f10c:	e9 90 01 00 00       	jmpq   800420f2a1 <vprintfmt+0x509>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420f111:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f115:	be 03 00 00 00       	mov    $0x3,%esi
  800420f11a:	48 89 c7             	mov    %rax,%rdi
  800420f11d:	48 b8 88 ec 20 04 80 	movabs $0x800420ec88,%rax
  800420f124:	00 00 00 
  800420f127:	ff d0                	callq  *%rax
  800420f129:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420f12d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f131:	48 85 c0             	test   %rax,%rax
  800420f134:	79 1d                	jns    800420f153 <vprintfmt+0x3bb>
				putch('-', putdat);
  800420f136:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f13a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f13e:	48 89 d6             	mov    %rdx,%rsi
  800420f141:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420f146:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420f148:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f14c:	48 f7 d8             	neg    %rax
  800420f14f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420f153:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420f15a:	e9 d5 00 00 00       	jmpq   800420f234 <vprintfmt+0x49c>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420f15f:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f163:	be 03 00 00 00       	mov    $0x3,%esi
  800420f168:	48 89 c7             	mov    %rax,%rdi
  800420f16b:	48 b8 78 eb 20 04 80 	movabs $0x800420eb78,%rax
  800420f172:	00 00 00 
  800420f175:	ff d0                	callq  *%rax
  800420f177:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420f17b:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420f182:	e9 ad 00 00 00       	jmpq   800420f234 <vprintfmt+0x49c>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getint(&aq, lflag);
  800420f187:	8b 55 e0             	mov    -0x20(%rbp),%edx
  800420f18a:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f18e:	89 d6                	mov    %edx,%esi
  800420f190:	48 89 c7             	mov    %rax,%rdi
  800420f193:	48 b8 88 ec 20 04 80 	movabs $0x800420ec88,%rax
  800420f19a:	00 00 00 
  800420f19d:	ff d0                	callq  *%rax
  800420f19f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  800420f1a3:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  800420f1aa:	e9 85 00 00 00       	jmpq   800420f234 <vprintfmt+0x49c>


			// pointer
		case 'p':
			putch('0', putdat);
  800420f1af:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f1b3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f1b7:	48 89 d6             	mov    %rdx,%rsi
  800420f1ba:	bf 30 00 00 00       	mov    $0x30,%edi
  800420f1bf:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420f1c1:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f1c5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f1c9:	48 89 d6             	mov    %rdx,%rsi
  800420f1cc:	bf 78 00 00 00       	mov    $0x78,%edi
  800420f1d1:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420f1d3:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f1d6:	83 f8 30             	cmp    $0x30,%eax
  800420f1d9:	73 17                	jae    800420f1f2 <vprintfmt+0x45a>
  800420f1db:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f1df:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f1e2:	89 c0                	mov    %eax,%eax
  800420f1e4:	48 01 d0             	add    %rdx,%rax
  800420f1e7:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f1ea:	83 c2 08             	add    $0x8,%edx
  800420f1ed:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420f1f0:	eb 0f                	jmp    800420f201 <vprintfmt+0x469>
				(uintptr_t) va_arg(aq, void *);
  800420f1f2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f1f6:	48 89 d0             	mov    %rdx,%rax
  800420f1f9:	48 83 c2 08          	add    $0x8,%rdx
  800420f1fd:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f201:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420f204:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420f208:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420f20f:	eb 23                	jmp    800420f234 <vprintfmt+0x49c>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420f211:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f215:	be 03 00 00 00       	mov    $0x3,%esi
  800420f21a:	48 89 c7             	mov    %rax,%rdi
  800420f21d:	48 b8 78 eb 20 04 80 	movabs $0x800420eb78,%rax
  800420f224:	00 00 00 
  800420f227:	ff d0                	callq  *%rax
  800420f229:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420f22d:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420f234:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420f239:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420f23c:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420f23f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f243:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f247:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f24b:	45 89 c1             	mov    %r8d,%r9d
  800420f24e:	41 89 f8             	mov    %edi,%r8d
  800420f251:	48 89 c7             	mov    %rax,%rdi
  800420f254:	48 b8 bd ea 20 04 80 	movabs $0x800420eabd,%rax
  800420f25b:	00 00 00 
  800420f25e:	ff d0                	callq  *%rax
			break;
  800420f260:	eb 3f                	jmp    800420f2a1 <vprintfmt+0x509>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420f262:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f266:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f26a:	48 89 d6             	mov    %rdx,%rsi
  800420f26d:	89 df                	mov    %ebx,%edi
  800420f26f:	ff d0                	callq  *%rax
			break;
  800420f271:	eb 2e                	jmp    800420f2a1 <vprintfmt+0x509>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420f273:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f277:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f27b:	48 89 d6             	mov    %rdx,%rsi
  800420f27e:	bf 25 00 00 00       	mov    $0x25,%edi
  800420f283:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420f285:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420f28a:	eb 05                	jmp    800420f291 <vprintfmt+0x4f9>
  800420f28c:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420f291:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f295:	48 83 e8 01          	sub    $0x1,%rax
  800420f299:	0f b6 00             	movzbl (%rax),%eax
  800420f29c:	3c 25                	cmp    $0x25,%al
  800420f29e:	75 ec                	jne    800420f28c <vprintfmt+0x4f4>
				/* do nothing */;
			break;
  800420f2a0:	90                   	nop
		}
	}
  800420f2a1:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420f2a2:	e9 43 fb ff ff       	jmpq   800420edea <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  800420f2a7:	48 83 c4 60          	add    $0x60,%rsp
  800420f2ab:	5b                   	pop    %rbx
  800420f2ac:	41 5c                	pop    %r12
  800420f2ae:	5d                   	pop    %rbp
  800420f2af:	c3                   	retq   

000000800420f2b0 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420f2b0:	55                   	push   %rbp
  800420f2b1:	48 89 e5             	mov    %rsp,%rbp
  800420f2b4:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420f2bb:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420f2c2:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420f2c9:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420f2d0:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420f2d7:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420f2de:	84 c0                	test   %al,%al
  800420f2e0:	74 20                	je     800420f302 <printfmt+0x52>
  800420f2e2:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420f2e6:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420f2ea:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420f2ee:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420f2f2:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420f2f6:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420f2fa:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420f2fe:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420f302:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420f309:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420f310:	00 00 00 
  800420f313:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420f31a:	00 00 00 
  800420f31d:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420f321:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420f328:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f32f:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420f336:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420f33d:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420f344:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420f34b:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420f352:	48 89 c7             	mov    %rax,%rdi
  800420f355:	48 b8 98 ed 20 04 80 	movabs $0x800420ed98,%rax
  800420f35c:	00 00 00 
  800420f35f:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420f361:	c9                   	leaveq 
  800420f362:	c3                   	retq   

000000800420f363 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420f363:	55                   	push   %rbp
  800420f364:	48 89 e5             	mov    %rsp,%rbp
  800420f367:	48 83 ec 10          	sub    $0x10,%rsp
  800420f36b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420f36e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420f372:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f376:	8b 40 10             	mov    0x10(%rax),%eax
  800420f379:	8d 50 01             	lea    0x1(%rax),%edx
  800420f37c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f380:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420f383:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f387:	48 8b 10             	mov    (%rax),%rdx
  800420f38a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f38e:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f392:	48 39 c2             	cmp    %rax,%rdx
  800420f395:	73 17                	jae    800420f3ae <sprintputch+0x4b>
		*b->buf++ = ch;
  800420f397:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f39b:	48 8b 00             	mov    (%rax),%rax
  800420f39e:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420f3a2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f3a6:	48 89 0a             	mov    %rcx,(%rdx)
  800420f3a9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420f3ac:	88 10                	mov    %dl,(%rax)
}
  800420f3ae:	c9                   	leaveq 
  800420f3af:	c3                   	retq   

000000800420f3b0 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420f3b0:	55                   	push   %rbp
  800420f3b1:	48 89 e5             	mov    %rsp,%rbp
  800420f3b4:	48 83 ec 50          	sub    $0x50,%rsp
  800420f3b8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420f3bc:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420f3bf:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420f3c3:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420f3c7:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420f3cb:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420f3cf:	48 8b 0a             	mov    (%rdx),%rcx
  800420f3d2:	48 89 08             	mov    %rcx,(%rax)
  800420f3d5:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420f3d9:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420f3dd:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420f3e1:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420f3e5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f3e9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420f3ed:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420f3f0:	48 98                	cltq   
  800420f3f2:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420f3f6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f3fa:	48 01 d0             	add    %rdx,%rax
  800420f3fd:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420f401:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420f408:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420f40d:	74 06                	je     800420f415 <vsnprintf+0x65>
  800420f40f:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420f413:	7f 07                	jg     800420f41c <vsnprintf+0x6c>
		return -E_INVAL;
  800420f415:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420f41a:	eb 2f                	jmp    800420f44b <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420f41c:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420f420:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420f424:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420f428:	48 89 c6             	mov    %rax,%rsi
  800420f42b:	48 bf 63 f3 20 04 80 	movabs $0x800420f363,%rdi
  800420f432:	00 00 00 
  800420f435:	48 b8 98 ed 20 04 80 	movabs $0x800420ed98,%rax
  800420f43c:	00 00 00 
  800420f43f:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420f441:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f445:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420f448:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420f44b:	c9                   	leaveq 
  800420f44c:	c3                   	retq   

000000800420f44d <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420f44d:	55                   	push   %rbp
  800420f44e:	48 89 e5             	mov    %rsp,%rbp
  800420f451:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420f458:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420f45f:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420f465:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420f46c:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420f473:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420f47a:	84 c0                	test   %al,%al
  800420f47c:	74 20                	je     800420f49e <snprintf+0x51>
  800420f47e:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420f482:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420f486:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420f48a:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420f48e:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420f492:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420f496:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420f49a:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420f49e:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420f4a5:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420f4ac:	00 00 00 
  800420f4af:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420f4b6:	00 00 00 
  800420f4b9:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420f4bd:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420f4c4:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f4cb:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420f4d2:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420f4d9:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420f4e0:	48 8b 0a             	mov    (%rdx),%rcx
  800420f4e3:	48 89 08             	mov    %rcx,(%rax)
  800420f4e6:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420f4ea:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420f4ee:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420f4f2:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420f4f6:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420f4fd:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420f504:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420f50a:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420f511:	48 89 c7             	mov    %rax,%rdi
  800420f514:	48 b8 b0 f3 20 04 80 	movabs $0x800420f3b0,%rax
  800420f51b:	00 00 00 
  800420f51e:	ff d0                	callq  *%rax
  800420f520:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420f526:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420f52c:	c9                   	leaveq 
  800420f52d:	c3                   	retq   

000000800420f52e <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420f52e:	55                   	push   %rbp
  800420f52f:	48 89 e5             	mov    %rsp,%rbp
  800420f532:	48 83 ec 20          	sub    $0x20,%rsp
  800420f536:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

#if JOS_KERNEL
	if (prompt != NULL)
  800420f53a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f53f:	74 22                	je     800420f563 <readline+0x35>
		cprintf("%s", prompt);
  800420f541:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f545:	48 89 c6             	mov    %rax,%rsi
  800420f548:	48 bf 08 a3 21 04 80 	movabs $0x800421a308,%rdi
  800420f54f:	00 00 00 
  800420f552:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f557:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420f55e:	00 00 00 
  800420f561:	ff d2                	callq  *%rdx
#else
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif

	i = 0;
  800420f563:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420f56a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420f56f:	48 b8 8d 12 20 04 80 	movabs $0x800420128d,%rax
  800420f576:	00 00 00 
  800420f579:	ff d0                	callq  *%rax
  800420f57b:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420f57e:	48 b8 6b 12 20 04 80 	movabs $0x800420126b,%rax
  800420f585:	00 00 00 
  800420f588:	ff d0                	callq  *%rax
  800420f58a:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420f58d:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420f591:	79 30                	jns    800420f5c3 <readline+0x95>
			if (c != -E_EOF)
  800420f593:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800420f597:	74 20                	je     800420f5b9 <readline+0x8b>
				cprintf("read error: %e\n", c);
  800420f599:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f59c:	89 c6                	mov    %eax,%esi
  800420f59e:	48 bf 0b a3 21 04 80 	movabs $0x800421a30b,%rdi
  800420f5a5:	00 00 00 
  800420f5a8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f5ad:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800420f5b4:	00 00 00 
  800420f5b7:	ff d2                	callq  *%rdx
			return NULL;
  800420f5b9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f5be:	e9 be 00 00 00       	jmpq   800420f681 <readline+0x153>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420f5c3:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420f5c7:	74 06                	je     800420f5cf <readline+0xa1>
  800420f5c9:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420f5cd:	75 26                	jne    800420f5f5 <readline+0xc7>
  800420f5cf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f5d3:	7e 20                	jle    800420f5f5 <readline+0xc7>
			if (echoing)
  800420f5d5:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f5d9:	74 11                	je     800420f5ec <readline+0xbe>
				cputchar('\b');
  800420f5db:	bf 08 00 00 00       	mov    $0x8,%edi
  800420f5e0:	48 b8 4d 12 20 04 80 	movabs $0x800420124d,%rax
  800420f5e7:	00 00 00 
  800420f5ea:	ff d0                	callq  *%rax
			i--;
  800420f5ec:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420f5f0:	e9 87 00 00 00       	jmpq   800420f67c <readline+0x14e>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420f5f5:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f5f9:	7e 3f                	jle    800420f63a <readline+0x10c>
  800420f5fb:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420f602:	7f 36                	jg     800420f63a <readline+0x10c>
			if (echoing)
  800420f604:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f608:	74 11                	je     800420f61b <readline+0xed>
				cputchar(c);
  800420f60a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f60d:	89 c7                	mov    %eax,%edi
  800420f60f:	48 b8 4d 12 20 04 80 	movabs $0x800420124d,%rax
  800420f616:	00 00 00 
  800420f619:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420f61b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f61e:	8d 50 01             	lea    0x1(%rax),%edx
  800420f621:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420f624:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420f627:	89 d1                	mov    %edx,%ecx
  800420f629:	48 ba c0 82 60 04 80 	movabs $0x80046082c0,%rdx
  800420f630:	00 00 00 
  800420f633:	48 98                	cltq   
  800420f635:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420f638:	eb 42                	jmp    800420f67c <readline+0x14e>
		} else if (c == '\n' || c == '\r') {
  800420f63a:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420f63e:	74 06                	je     800420f646 <readline+0x118>
  800420f640:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420f644:	75 36                	jne    800420f67c <readline+0x14e>
			if (echoing)
  800420f646:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f64a:	74 11                	je     800420f65d <readline+0x12f>
				cputchar('\n');
  800420f64c:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420f651:	48 b8 4d 12 20 04 80 	movabs $0x800420124d,%rax
  800420f658:	00 00 00 
  800420f65b:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420f65d:	48 ba c0 82 60 04 80 	movabs $0x80046082c0,%rdx
  800420f664:	00 00 00 
  800420f667:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f66a:	48 98                	cltq   
  800420f66c:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420f670:	48 b8 c0 82 60 04 80 	movabs $0x80046082c0,%rax
  800420f677:	00 00 00 
  800420f67a:	eb 05                	jmp    800420f681 <readline+0x153>
		}
	}
  800420f67c:	e9 fd fe ff ff       	jmpq   800420f57e <readline+0x50>
}
  800420f681:	c9                   	leaveq 
  800420f682:	c3                   	retq   

000000800420f683 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420f683:	55                   	push   %rbp
  800420f684:	48 89 e5             	mov    %rsp,%rbp
  800420f687:	48 83 ec 18          	sub    $0x18,%rsp
  800420f68b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420f68f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f696:	eb 09                	jmp    800420f6a1 <strlen+0x1e>
		n++;
  800420f698:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420f69c:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420f6a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6a5:	0f b6 00             	movzbl (%rax),%eax
  800420f6a8:	84 c0                	test   %al,%al
  800420f6aa:	75 ec                	jne    800420f698 <strlen+0x15>
		n++;
	return n;
  800420f6ac:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420f6af:	c9                   	leaveq 
  800420f6b0:	c3                   	retq   

000000800420f6b1 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420f6b1:	55                   	push   %rbp
  800420f6b2:	48 89 e5             	mov    %rsp,%rbp
  800420f6b5:	48 83 ec 20          	sub    $0x20,%rsp
  800420f6b9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f6bd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420f6c1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f6c8:	eb 0e                	jmp    800420f6d8 <strnlen+0x27>
		n++;
  800420f6ca:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420f6ce:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420f6d3:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420f6d8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420f6dd:	74 0b                	je     800420f6ea <strnlen+0x39>
  800420f6df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6e3:	0f b6 00             	movzbl (%rax),%eax
  800420f6e6:	84 c0                	test   %al,%al
  800420f6e8:	75 e0                	jne    800420f6ca <strnlen+0x19>
		n++;
	return n;
  800420f6ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420f6ed:	c9                   	leaveq 
  800420f6ee:	c3                   	retq   

000000800420f6ef <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420f6ef:	55                   	push   %rbp
  800420f6f0:	48 89 e5             	mov    %rsp,%rbp
  800420f6f3:	48 83 ec 20          	sub    $0x20,%rsp
  800420f6f7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f6fb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420f6ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f703:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420f707:	90                   	nop
  800420f708:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f70c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f710:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f714:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f718:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420f71c:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420f720:	0f b6 12             	movzbl (%rdx),%edx
  800420f723:	88 10                	mov    %dl,(%rax)
  800420f725:	0f b6 00             	movzbl (%rax),%eax
  800420f728:	84 c0                	test   %al,%al
  800420f72a:	75 dc                	jne    800420f708 <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420f72c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f730:	c9                   	leaveq 
  800420f731:	c3                   	retq   

000000800420f732 <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420f732:	55                   	push   %rbp
  800420f733:	48 89 e5             	mov    %rsp,%rbp
  800420f736:	48 83 ec 20          	sub    $0x20,%rsp
  800420f73a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f73e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420f742:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f746:	48 89 c7             	mov    %rax,%rdi
  800420f749:	48 b8 83 f6 20 04 80 	movabs $0x800420f683,%rax
  800420f750:	00 00 00 
  800420f753:	ff d0                	callq  *%rax
  800420f755:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420f758:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f75b:	48 63 d0             	movslq %eax,%rdx
  800420f75e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f762:	48 01 c2             	add    %rax,%rdx
  800420f765:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f769:	48 89 c6             	mov    %rax,%rsi
  800420f76c:	48 89 d7             	mov    %rdx,%rdi
  800420f76f:	48 b8 ef f6 20 04 80 	movabs $0x800420f6ef,%rax
  800420f776:	00 00 00 
  800420f779:	ff d0                	callq  *%rax
	return dst;
  800420f77b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420f77f:	c9                   	leaveq 
  800420f780:	c3                   	retq   

000000800420f781 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420f781:	55                   	push   %rbp
  800420f782:	48 89 e5             	mov    %rsp,%rbp
  800420f785:	48 83 ec 28          	sub    $0x28,%rsp
  800420f789:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f78d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f791:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420f795:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f799:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420f79d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f7a4:	00 
  800420f7a5:	eb 2a                	jmp    800420f7d1 <strncpy+0x50>
		*dst++ = *src;
  800420f7a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7ab:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f7af:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f7b3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f7b7:	0f b6 12             	movzbl (%rdx),%edx
  800420f7ba:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420f7bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f7c0:	0f b6 00             	movzbl (%rax),%eax
  800420f7c3:	84 c0                	test   %al,%al
  800420f7c5:	74 05                	je     800420f7cc <strncpy+0x4b>
			src++;
  800420f7c7:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420f7cc:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f7d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f7d5:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420f7d9:	72 cc                	jb     800420f7a7 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420f7db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f7df:	c9                   	leaveq 
  800420f7e0:	c3                   	retq   

000000800420f7e1 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420f7e1:	55                   	push   %rbp
  800420f7e2:	48 89 e5             	mov    %rsp,%rbp
  800420f7e5:	48 83 ec 28          	sub    $0x28,%rsp
  800420f7e9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f7ed:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f7f1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420f7f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7f9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420f7fd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420f802:	74 3d                	je     800420f841 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420f804:	eb 1d                	jmp    800420f823 <strlcpy+0x42>
			*dst++ = *src++;
  800420f806:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f80a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f80e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f812:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f816:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420f81a:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420f81e:	0f b6 12             	movzbl (%rdx),%edx
  800420f821:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420f823:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420f828:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420f82d:	74 0b                	je     800420f83a <strlcpy+0x59>
  800420f82f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f833:	0f b6 00             	movzbl (%rax),%eax
  800420f836:	84 c0                	test   %al,%al
  800420f838:	75 cc                	jne    800420f806 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420f83a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f83e:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420f841:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f845:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f849:	48 29 c2             	sub    %rax,%rdx
  800420f84c:	48 89 d0             	mov    %rdx,%rax
}
  800420f84f:	c9                   	leaveq 
  800420f850:	c3                   	retq   

000000800420f851 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420f851:	55                   	push   %rbp
  800420f852:	48 89 e5             	mov    %rsp,%rbp
  800420f855:	48 83 ec 10          	sub    $0x10,%rsp
  800420f859:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f85d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420f861:	eb 0a                	jmp    800420f86d <strcmp+0x1c>
		p++, q++;
  800420f863:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f868:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420f86d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f871:	0f b6 00             	movzbl (%rax),%eax
  800420f874:	84 c0                	test   %al,%al
  800420f876:	74 12                	je     800420f88a <strcmp+0x39>
  800420f878:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f87c:	0f b6 10             	movzbl (%rax),%edx
  800420f87f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f883:	0f b6 00             	movzbl (%rax),%eax
  800420f886:	38 c2                	cmp    %al,%dl
  800420f888:	74 d9                	je     800420f863 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420f88a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f88e:	0f b6 00             	movzbl (%rax),%eax
  800420f891:	0f b6 d0             	movzbl %al,%edx
  800420f894:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f898:	0f b6 00             	movzbl (%rax),%eax
  800420f89b:	0f b6 c0             	movzbl %al,%eax
  800420f89e:	29 c2                	sub    %eax,%edx
  800420f8a0:	89 d0                	mov    %edx,%eax
}
  800420f8a2:	c9                   	leaveq 
  800420f8a3:	c3                   	retq   

000000800420f8a4 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420f8a4:	55                   	push   %rbp
  800420f8a5:	48 89 e5             	mov    %rsp,%rbp
  800420f8a8:	48 83 ec 18          	sub    $0x18,%rsp
  800420f8ac:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f8b0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420f8b4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420f8b8:	eb 0f                	jmp    800420f8c9 <strncmp+0x25>
		n--, p++, q++;
  800420f8ba:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420f8bf:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f8c4:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420f8c9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f8ce:	74 1d                	je     800420f8ed <strncmp+0x49>
  800420f8d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f8d4:	0f b6 00             	movzbl (%rax),%eax
  800420f8d7:	84 c0                	test   %al,%al
  800420f8d9:	74 12                	je     800420f8ed <strncmp+0x49>
  800420f8db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f8df:	0f b6 10             	movzbl (%rax),%edx
  800420f8e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f8e6:	0f b6 00             	movzbl (%rax),%eax
  800420f8e9:	38 c2                	cmp    %al,%dl
  800420f8eb:	74 cd                	je     800420f8ba <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420f8ed:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f8f2:	75 07                	jne    800420f8fb <strncmp+0x57>
		return 0;
  800420f8f4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f8f9:	eb 18                	jmp    800420f913 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420f8fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f8ff:	0f b6 00             	movzbl (%rax),%eax
  800420f902:	0f b6 d0             	movzbl %al,%edx
  800420f905:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f909:	0f b6 00             	movzbl (%rax),%eax
  800420f90c:	0f b6 c0             	movzbl %al,%eax
  800420f90f:	29 c2                	sub    %eax,%edx
  800420f911:	89 d0                	mov    %edx,%eax
}
  800420f913:	c9                   	leaveq 
  800420f914:	c3                   	retq   

000000800420f915 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420f915:	55                   	push   %rbp
  800420f916:	48 89 e5             	mov    %rsp,%rbp
  800420f919:	48 83 ec 0c          	sub    $0xc,%rsp
  800420f91d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f921:	89 f0                	mov    %esi,%eax
  800420f923:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420f926:	eb 17                	jmp    800420f93f <strchr+0x2a>
		if (*s == c)
  800420f928:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f92c:	0f b6 00             	movzbl (%rax),%eax
  800420f92f:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420f932:	75 06                	jne    800420f93a <strchr+0x25>
			return (char *) s;
  800420f934:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f938:	eb 15                	jmp    800420f94f <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420f93a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f93f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f943:	0f b6 00             	movzbl (%rax),%eax
  800420f946:	84 c0                	test   %al,%al
  800420f948:	75 de                	jne    800420f928 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420f94a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f94f:	c9                   	leaveq 
  800420f950:	c3                   	retq   

000000800420f951 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420f951:	55                   	push   %rbp
  800420f952:	48 89 e5             	mov    %rsp,%rbp
  800420f955:	48 83 ec 0c          	sub    $0xc,%rsp
  800420f959:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f95d:	89 f0                	mov    %esi,%eax
  800420f95f:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420f962:	eb 13                	jmp    800420f977 <strfind+0x26>
		if (*s == c)
  800420f964:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f968:	0f b6 00             	movzbl (%rax),%eax
  800420f96b:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420f96e:	75 02                	jne    800420f972 <strfind+0x21>
			break;
  800420f970:	eb 10                	jmp    800420f982 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420f972:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f977:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f97b:	0f b6 00             	movzbl (%rax),%eax
  800420f97e:	84 c0                	test   %al,%al
  800420f980:	75 e2                	jne    800420f964 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  800420f982:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f986:	c9                   	leaveq 
  800420f987:	c3                   	retq   

000000800420f988 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420f988:	55                   	push   %rbp
  800420f989:	48 89 e5             	mov    %rsp,%rbp
  800420f98c:	48 83 ec 18          	sub    $0x18,%rsp
  800420f990:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f994:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420f997:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420f99b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f9a0:	75 06                	jne    800420f9a8 <memset+0x20>
		return v;
  800420f9a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f9a6:	eb 69                	jmp    800420fa11 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420f9a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f9ac:	83 e0 03             	and    $0x3,%eax
  800420f9af:	48 85 c0             	test   %rax,%rax
  800420f9b2:	75 48                	jne    800420f9fc <memset+0x74>
  800420f9b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9b8:	83 e0 03             	and    $0x3,%eax
  800420f9bb:	48 85 c0             	test   %rax,%rax
  800420f9be:	75 3c                	jne    800420f9fc <memset+0x74>
		c &= 0xFF;
  800420f9c0:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420f9c7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f9ca:	c1 e0 18             	shl    $0x18,%eax
  800420f9cd:	89 c2                	mov    %eax,%edx
  800420f9cf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f9d2:	c1 e0 10             	shl    $0x10,%eax
  800420f9d5:	09 c2                	or     %eax,%edx
  800420f9d7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f9da:	c1 e0 08             	shl    $0x8,%eax
  800420f9dd:	09 d0                	or     %edx,%eax
  800420f9df:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  800420f9e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9e6:	48 c1 e8 02          	shr    $0x2,%rax
  800420f9ea:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420f9ed:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420f9f1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f9f4:	48 89 d7             	mov    %rdx,%rdi
  800420f9f7:	fc                   	cld    
  800420f9f8:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420f9fa:	eb 11                	jmp    800420fa0d <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420f9fc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fa00:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fa03:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420fa07:	48 89 d7             	mov    %rdx,%rdi
  800420fa0a:	fc                   	cld    
  800420fa0b:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  800420fa0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420fa11:	c9                   	leaveq 
  800420fa12:	c3                   	retq   

000000800420fa13 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420fa13:	55                   	push   %rbp
  800420fa14:	48 89 e5             	mov    %rsp,%rbp
  800420fa17:	48 83 ec 28          	sub    $0x28,%rsp
  800420fa1b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fa1f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fa23:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420fa27:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fa2b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420fa2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa33:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420fa37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa3b:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420fa3f:	0f 83 88 00 00 00    	jae    800420facd <memmove+0xba>
  800420fa45:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa49:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fa4d:	48 01 d0             	add    %rdx,%rax
  800420fa50:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420fa54:	76 77                	jbe    800420facd <memmove+0xba>
		s += n;
  800420fa56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa5a:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420fa5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa62:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420fa66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa6a:	83 e0 03             	and    $0x3,%eax
  800420fa6d:	48 85 c0             	test   %rax,%rax
  800420fa70:	75 3b                	jne    800420faad <memmove+0x9a>
  800420fa72:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fa76:	83 e0 03             	and    $0x3,%eax
  800420fa79:	48 85 c0             	test   %rax,%rax
  800420fa7c:	75 2f                	jne    800420faad <memmove+0x9a>
  800420fa7e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa82:	83 e0 03             	and    $0x3,%eax
  800420fa85:	48 85 c0             	test   %rax,%rax
  800420fa88:	75 23                	jne    800420faad <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420fa8a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fa8e:	48 83 e8 04          	sub    $0x4,%rax
  800420fa92:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fa96:	48 83 ea 04          	sub    $0x4,%rdx
  800420fa9a:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420fa9e:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420faa2:	48 89 c7             	mov    %rax,%rdi
  800420faa5:	48 89 d6             	mov    %rdx,%rsi
  800420faa8:	fd                   	std    
  800420faa9:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420faab:	eb 1d                	jmp    800420faca <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420faad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fab1:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420fab5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fab9:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420fabd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fac1:	48 89 d7             	mov    %rdx,%rdi
  800420fac4:	48 89 c1             	mov    %rax,%rcx
  800420fac7:	fd                   	std    
  800420fac8:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420faca:	fc                   	cld    
  800420facb:	eb 57                	jmp    800420fb24 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420facd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fad1:	83 e0 03             	and    $0x3,%eax
  800420fad4:	48 85 c0             	test   %rax,%rax
  800420fad7:	75 36                	jne    800420fb0f <memmove+0xfc>
  800420fad9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fadd:	83 e0 03             	and    $0x3,%eax
  800420fae0:	48 85 c0             	test   %rax,%rax
  800420fae3:	75 2a                	jne    800420fb0f <memmove+0xfc>
  800420fae5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fae9:	83 e0 03             	and    $0x3,%eax
  800420faec:	48 85 c0             	test   %rax,%rax
  800420faef:	75 1e                	jne    800420fb0f <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420faf1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420faf5:	48 c1 e8 02          	shr    $0x2,%rax
  800420faf9:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420fafc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb00:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fb04:	48 89 c7             	mov    %rax,%rdi
  800420fb07:	48 89 d6             	mov    %rdx,%rsi
  800420fb0a:	fc                   	cld    
  800420fb0b:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420fb0d:	eb 15                	jmp    800420fb24 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420fb0f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb13:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fb17:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420fb1b:	48 89 c7             	mov    %rax,%rdi
  800420fb1e:	48 89 d6             	mov    %rdx,%rsi
  800420fb21:	fc                   	cld    
  800420fb22:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420fb24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420fb28:	c9                   	leaveq 
  800420fb29:	c3                   	retq   

000000800420fb2a <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420fb2a:	55                   	push   %rbp
  800420fb2b:	48 89 e5             	mov    %rsp,%rbp
  800420fb2e:	48 83 ec 18          	sub    $0x18,%rsp
  800420fb32:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fb36:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420fb3a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420fb3e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fb42:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420fb46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb4a:	48 89 ce             	mov    %rcx,%rsi
  800420fb4d:	48 89 c7             	mov    %rax,%rdi
  800420fb50:	48 b8 13 fa 20 04 80 	movabs $0x800420fa13,%rax
  800420fb57:	00 00 00 
  800420fb5a:	ff d0                	callq  *%rax
}
  800420fb5c:	c9                   	leaveq 
  800420fb5d:	c3                   	retq   

000000800420fb5e <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420fb5e:	55                   	push   %rbp
  800420fb5f:	48 89 e5             	mov    %rsp,%rbp
  800420fb62:	48 83 ec 28          	sub    $0x28,%rsp
  800420fb66:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fb6a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fb6e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420fb72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb76:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420fb7a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fb7e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420fb82:	eb 36                	jmp    800420fbba <memcmp+0x5c>
		if (*s1 != *s2)
  800420fb84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb88:	0f b6 10             	movzbl (%rax),%edx
  800420fb8b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb8f:	0f b6 00             	movzbl (%rax),%eax
  800420fb92:	38 c2                	cmp    %al,%dl
  800420fb94:	74 1a                	je     800420fbb0 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420fb96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb9a:	0f b6 00             	movzbl (%rax),%eax
  800420fb9d:	0f b6 d0             	movzbl %al,%edx
  800420fba0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fba4:	0f b6 00             	movzbl (%rax),%eax
  800420fba7:	0f b6 c0             	movzbl %al,%eax
  800420fbaa:	29 c2                	sub    %eax,%edx
  800420fbac:	89 d0                	mov    %edx,%eax
  800420fbae:	eb 20                	jmp    800420fbd0 <memcmp+0x72>
		s1++, s2++;
  800420fbb0:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420fbb5:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420fbba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fbbe:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420fbc2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420fbc6:	48 85 c0             	test   %rax,%rax
  800420fbc9:	75 b9                	jne    800420fb84 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420fbcb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fbd0:	c9                   	leaveq 
  800420fbd1:	c3                   	retq   

000000800420fbd2 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420fbd2:	55                   	push   %rbp
  800420fbd3:	48 89 e5             	mov    %rsp,%rbp
  800420fbd6:	48 83 ec 28          	sub    $0x28,%rsp
  800420fbda:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fbde:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420fbe1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420fbe5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fbe9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fbed:	48 01 d0             	add    %rdx,%rax
  800420fbf0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420fbf4:	eb 15                	jmp    800420fc0b <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420fbf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fbfa:	0f b6 10             	movzbl (%rax),%edx
  800420fbfd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420fc00:	38 c2                	cmp    %al,%dl
  800420fc02:	75 02                	jne    800420fc06 <memfind+0x34>
			break;
  800420fc04:	eb 0f                	jmp    800420fc15 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420fc06:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420fc0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc0f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420fc13:	72 e1                	jb     800420fbf6 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  800420fc15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420fc19:	c9                   	leaveq 
  800420fc1a:	c3                   	retq   

000000800420fc1b <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420fc1b:	55                   	push   %rbp
  800420fc1c:	48 89 e5             	mov    %rsp,%rbp
  800420fc1f:	48 83 ec 34          	sub    $0x34,%rsp
  800420fc23:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420fc27:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420fc2b:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420fc2e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420fc35:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420fc3c:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420fc3d:	eb 05                	jmp    800420fc44 <strtol+0x29>
		s++;
  800420fc3f:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420fc44:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc48:	0f b6 00             	movzbl (%rax),%eax
  800420fc4b:	3c 20                	cmp    $0x20,%al
  800420fc4d:	74 f0                	je     800420fc3f <strtol+0x24>
  800420fc4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc53:	0f b6 00             	movzbl (%rax),%eax
  800420fc56:	3c 09                	cmp    $0x9,%al
  800420fc58:	74 e5                	je     800420fc3f <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420fc5a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc5e:	0f b6 00             	movzbl (%rax),%eax
  800420fc61:	3c 2b                	cmp    $0x2b,%al
  800420fc63:	75 07                	jne    800420fc6c <strtol+0x51>
		s++;
  800420fc65:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fc6a:	eb 17                	jmp    800420fc83 <strtol+0x68>
	else if (*s == '-')
  800420fc6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc70:	0f b6 00             	movzbl (%rax),%eax
  800420fc73:	3c 2d                	cmp    $0x2d,%al
  800420fc75:	75 0c                	jne    800420fc83 <strtol+0x68>
		s++, neg = 1;
  800420fc77:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fc7c:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420fc83:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fc87:	74 06                	je     800420fc8f <strtol+0x74>
  800420fc89:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420fc8d:	75 28                	jne    800420fcb7 <strtol+0x9c>
  800420fc8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc93:	0f b6 00             	movzbl (%rax),%eax
  800420fc96:	3c 30                	cmp    $0x30,%al
  800420fc98:	75 1d                	jne    800420fcb7 <strtol+0x9c>
  800420fc9a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fc9e:	48 83 c0 01          	add    $0x1,%rax
  800420fca2:	0f b6 00             	movzbl (%rax),%eax
  800420fca5:	3c 78                	cmp    $0x78,%al
  800420fca7:	75 0e                	jne    800420fcb7 <strtol+0x9c>
		s += 2, base = 16;
  800420fca9:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420fcae:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420fcb5:	eb 2c                	jmp    800420fce3 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420fcb7:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fcbb:	75 19                	jne    800420fcd6 <strtol+0xbb>
  800420fcbd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fcc1:	0f b6 00             	movzbl (%rax),%eax
  800420fcc4:	3c 30                	cmp    $0x30,%al
  800420fcc6:	75 0e                	jne    800420fcd6 <strtol+0xbb>
		s++, base = 8;
  800420fcc8:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fccd:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420fcd4:	eb 0d                	jmp    800420fce3 <strtol+0xc8>
	else if (base == 0)
  800420fcd6:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fcda:	75 07                	jne    800420fce3 <strtol+0xc8>
		base = 10;
  800420fcdc:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420fce3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fce7:	0f b6 00             	movzbl (%rax),%eax
  800420fcea:	3c 2f                	cmp    $0x2f,%al
  800420fcec:	7e 1d                	jle    800420fd0b <strtol+0xf0>
  800420fcee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fcf2:	0f b6 00             	movzbl (%rax),%eax
  800420fcf5:	3c 39                	cmp    $0x39,%al
  800420fcf7:	7f 12                	jg     800420fd0b <strtol+0xf0>
			dig = *s - '0';
  800420fcf9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fcfd:	0f b6 00             	movzbl (%rax),%eax
  800420fd00:	0f be c0             	movsbl %al,%eax
  800420fd03:	83 e8 30             	sub    $0x30,%eax
  800420fd06:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420fd09:	eb 4e                	jmp    800420fd59 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420fd0b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd0f:	0f b6 00             	movzbl (%rax),%eax
  800420fd12:	3c 60                	cmp    $0x60,%al
  800420fd14:	7e 1d                	jle    800420fd33 <strtol+0x118>
  800420fd16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd1a:	0f b6 00             	movzbl (%rax),%eax
  800420fd1d:	3c 7a                	cmp    $0x7a,%al
  800420fd1f:	7f 12                	jg     800420fd33 <strtol+0x118>
			dig = *s - 'a' + 10;
  800420fd21:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd25:	0f b6 00             	movzbl (%rax),%eax
  800420fd28:	0f be c0             	movsbl %al,%eax
  800420fd2b:	83 e8 57             	sub    $0x57,%eax
  800420fd2e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420fd31:	eb 26                	jmp    800420fd59 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420fd33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd37:	0f b6 00             	movzbl (%rax),%eax
  800420fd3a:	3c 40                	cmp    $0x40,%al
  800420fd3c:	7e 48                	jle    800420fd86 <strtol+0x16b>
  800420fd3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd42:	0f b6 00             	movzbl (%rax),%eax
  800420fd45:	3c 5a                	cmp    $0x5a,%al
  800420fd47:	7f 3d                	jg     800420fd86 <strtol+0x16b>
			dig = *s - 'A' + 10;
  800420fd49:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd4d:	0f b6 00             	movzbl (%rax),%eax
  800420fd50:	0f be c0             	movsbl %al,%eax
  800420fd53:	83 e8 37             	sub    $0x37,%eax
  800420fd56:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420fd59:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420fd5c:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420fd5f:	7c 02                	jl     800420fd63 <strtol+0x148>
			break;
  800420fd61:	eb 23                	jmp    800420fd86 <strtol+0x16b>
		s++, val = (val * base) + dig;
  800420fd63:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fd68:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420fd6b:	48 98                	cltq   
  800420fd6d:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420fd72:	48 89 c2             	mov    %rax,%rdx
  800420fd75:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420fd78:	48 98                	cltq   
  800420fd7a:	48 01 d0             	add    %rdx,%rax
  800420fd7d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420fd81:	e9 5d ff ff ff       	jmpq   800420fce3 <strtol+0xc8>

	if (endptr)
  800420fd86:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420fd8b:	74 0b                	je     800420fd98 <strtol+0x17d>
		*endptr = (char *) s;
  800420fd8d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fd91:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420fd95:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420fd98:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420fd9c:	74 09                	je     800420fda7 <strtol+0x18c>
  800420fd9e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fda2:	48 f7 d8             	neg    %rax
  800420fda5:	eb 04                	jmp    800420fdab <strtol+0x190>
  800420fda7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420fdab:	c9                   	leaveq 
  800420fdac:	c3                   	retq   

000000800420fdad <strstr>:

char * strstr(const char *in, const char *str)
{
  800420fdad:	55                   	push   %rbp
  800420fdae:	48 89 e5             	mov    %rsp,%rbp
  800420fdb1:	48 83 ec 30          	sub    $0x30,%rsp
  800420fdb5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420fdb9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  800420fdbd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fdc1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fdc5:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420fdc9:	0f b6 00             	movzbl (%rax),%eax
  800420fdcc:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  800420fdcf:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420fdd3:	75 06                	jne    800420fddb <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  800420fdd5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fdd9:	eb 6b                	jmp    800420fe46 <strstr+0x99>

	len = strlen(str);
  800420fddb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fddf:	48 89 c7             	mov    %rax,%rdi
  800420fde2:	48 b8 83 f6 20 04 80 	movabs $0x800420f683,%rax
  800420fde9:	00 00 00 
  800420fdec:	ff d0                	callq  *%rax
  800420fdee:	48 98                	cltq   
  800420fdf0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  800420fdf4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fdf8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fdfc:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420fe00:	0f b6 00             	movzbl (%rax),%eax
  800420fe03:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800420fe06:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420fe0a:	75 07                	jne    800420fe13 <strstr+0x66>
				return (char *) 0;
  800420fe0c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fe11:	eb 33                	jmp    800420fe46 <strstr+0x99>
		} while (sc != c);
  800420fe13:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420fe17:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420fe1a:	75 d8                	jne    800420fdf4 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  800420fe1c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fe20:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420fe24:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe28:	48 89 ce             	mov    %rcx,%rsi
  800420fe2b:	48 89 c7             	mov    %rax,%rdi
  800420fe2e:	48 b8 a4 f8 20 04 80 	movabs $0x800420f8a4,%rax
  800420fe35:	00 00 00 
  800420fe38:	ff d0                	callq  *%rax
  800420fe3a:	85 c0                	test   %eax,%eax
  800420fe3c:	75 b6                	jne    800420fdf4 <strstr+0x47>

	return (char *) (in - 1);
  800420fe3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe42:	48 83 e8 01          	sub    $0x1,%rax
}
  800420fe46:	c9                   	leaveq 
  800420fe47:	c3                   	retq   

000000800420fe48 <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420fe48:	55                   	push   %rbp
  800420fe49:	48 89 e5             	mov    %rsp,%rbp
  800420fe4c:	48 83 ec 24          	sub    $0x24,%rsp
  800420fe50:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fe54:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fe58:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420fe5b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe5f:	48 8b 10             	mov    (%rax),%rdx
  800420fe62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe66:	48 01 d0             	add    %rdx,%rax
  800420fe69:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420fe6d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420fe74:	00 
	switch (bytes_to_read) {
  800420fe75:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420fe78:	83 f8 02             	cmp    $0x2,%eax
  800420fe7b:	0f 84 ab 00 00 00    	je     800420ff2c <_dwarf_read_lsb+0xe4>
  800420fe81:	83 f8 02             	cmp    $0x2,%eax
  800420fe84:	7f 0e                	jg     800420fe94 <_dwarf_read_lsb+0x4c>
  800420fe86:	83 f8 01             	cmp    $0x1,%eax
  800420fe89:	0f 84 b3 00 00 00    	je     800420ff42 <_dwarf_read_lsb+0xfa>
  800420fe8f:	e9 d9 00 00 00       	jmpq   800420ff6d <_dwarf_read_lsb+0x125>
  800420fe94:	83 f8 04             	cmp    $0x4,%eax
  800420fe97:	74 65                	je     800420fefe <_dwarf_read_lsb+0xb6>
  800420fe99:	83 f8 08             	cmp    $0x8,%eax
  800420fe9c:	0f 85 cb 00 00 00    	jne    800420ff6d <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420fea2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fea6:	48 83 c0 04          	add    $0x4,%rax
  800420feaa:	0f b6 00             	movzbl (%rax),%eax
  800420fead:	0f b6 c0             	movzbl %al,%eax
  800420feb0:	48 c1 e0 20          	shl    $0x20,%rax
  800420feb4:	48 89 c2             	mov    %rax,%rdx
  800420feb7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420febb:	48 83 c0 05          	add    $0x5,%rax
  800420febf:	0f b6 00             	movzbl (%rax),%eax
  800420fec2:	0f b6 c0             	movzbl %al,%eax
  800420fec5:	48 c1 e0 28          	shl    $0x28,%rax
  800420fec9:	48 09 d0             	or     %rdx,%rax
  800420fecc:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420fed0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fed4:	48 83 c0 06          	add    $0x6,%rax
  800420fed8:	0f b6 00             	movzbl (%rax),%eax
  800420fedb:	0f b6 c0             	movzbl %al,%eax
  800420fede:	48 c1 e0 30          	shl    $0x30,%rax
  800420fee2:	48 89 c2             	mov    %rax,%rdx
  800420fee5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fee9:	48 83 c0 07          	add    $0x7,%rax
  800420feed:	0f b6 00             	movzbl (%rax),%eax
  800420fef0:	0f b6 c0             	movzbl %al,%eax
  800420fef3:	48 c1 e0 38          	shl    $0x38,%rax
  800420fef7:	48 09 d0             	or     %rdx,%rax
  800420fefa:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420fefe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff02:	48 83 c0 02          	add    $0x2,%rax
  800420ff06:	0f b6 00             	movzbl (%rax),%eax
  800420ff09:	0f b6 c0             	movzbl %al,%eax
  800420ff0c:	48 c1 e0 10          	shl    $0x10,%rax
  800420ff10:	48 89 c2             	mov    %rax,%rdx
  800420ff13:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff17:	48 83 c0 03          	add    $0x3,%rax
  800420ff1b:	0f b6 00             	movzbl (%rax),%eax
  800420ff1e:	0f b6 c0             	movzbl %al,%eax
  800420ff21:	48 c1 e0 18          	shl    $0x18,%rax
  800420ff25:	48 09 d0             	or     %rdx,%rax
  800420ff28:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420ff2c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff30:	48 83 c0 01          	add    $0x1,%rax
  800420ff34:	0f b6 00             	movzbl (%rax),%eax
  800420ff37:	0f b6 c0             	movzbl %al,%eax
  800420ff3a:	48 c1 e0 08          	shl    $0x8,%rax
  800420ff3e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420ff42:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff46:	0f b6 00             	movzbl (%rax),%eax
  800420ff49:	0f b6 c0             	movzbl %al,%eax
  800420ff4c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420ff50:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800420ff51:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ff55:	48 8b 10             	mov    (%rax),%rdx
  800420ff58:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420ff5b:	48 98                	cltq   
  800420ff5d:	48 01 c2             	add    %rax,%rdx
  800420ff60:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ff64:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420ff67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ff6b:	eb 05                	jmp    800420ff72 <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420ff6d:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800420ff72:	c9                   	leaveq 
  800420ff73:	c3                   	retq   

000000800420ff74 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800420ff74:	55                   	push   %rbp
  800420ff75:	48 89 e5             	mov    %rsp,%rbp
  800420ff78:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ff7c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ff80:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420ff83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff87:	48 8b 00             	mov    (%rax),%rax
  800420ff8a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420ff8e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ff95:	00 
	switch (bytes_to_read) {
  800420ff96:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420ff99:	83 f8 02             	cmp    $0x2,%eax
  800420ff9c:	0f 84 ab 00 00 00    	je     800421004d <_dwarf_decode_lsb+0xd9>
  800420ffa2:	83 f8 02             	cmp    $0x2,%eax
  800420ffa5:	7f 0e                	jg     800420ffb5 <_dwarf_decode_lsb+0x41>
  800420ffa7:	83 f8 01             	cmp    $0x1,%eax
  800420ffaa:	0f 84 b3 00 00 00    	je     8004210063 <_dwarf_decode_lsb+0xef>
  800420ffb0:	e9 d9 00 00 00       	jmpq   800421008e <_dwarf_decode_lsb+0x11a>
  800420ffb5:	83 f8 04             	cmp    $0x4,%eax
  800420ffb8:	74 65                	je     800421001f <_dwarf_decode_lsb+0xab>
  800420ffba:	83 f8 08             	cmp    $0x8,%eax
  800420ffbd:	0f 85 cb 00 00 00    	jne    800421008e <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420ffc3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ffc7:	48 83 c0 04          	add    $0x4,%rax
  800420ffcb:	0f b6 00             	movzbl (%rax),%eax
  800420ffce:	0f b6 c0             	movzbl %al,%eax
  800420ffd1:	48 c1 e0 20          	shl    $0x20,%rax
  800420ffd5:	48 89 c2             	mov    %rax,%rdx
  800420ffd8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ffdc:	48 83 c0 05          	add    $0x5,%rax
  800420ffe0:	0f b6 00             	movzbl (%rax),%eax
  800420ffe3:	0f b6 c0             	movzbl %al,%eax
  800420ffe6:	48 c1 e0 28          	shl    $0x28,%rax
  800420ffea:	48 09 d0             	or     %rdx,%rax
  800420ffed:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420fff1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fff5:	48 83 c0 06          	add    $0x6,%rax
  800420fff9:	0f b6 00             	movzbl (%rax),%eax
  800420fffc:	0f b6 c0             	movzbl %al,%eax
  800420ffff:	48 c1 e0 30          	shl    $0x30,%rax
  8004210003:	48 89 c2             	mov    %rax,%rdx
  8004210006:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421000a:	48 83 c0 07          	add    $0x7,%rax
  800421000e:	0f b6 00             	movzbl (%rax),%eax
  8004210011:	0f b6 c0             	movzbl %al,%eax
  8004210014:	48 c1 e0 38          	shl    $0x38,%rax
  8004210018:	48 09 d0             	or     %rdx,%rax
  800421001b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800421001f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210023:	48 83 c0 02          	add    $0x2,%rax
  8004210027:	0f b6 00             	movzbl (%rax),%eax
  800421002a:	0f b6 c0             	movzbl %al,%eax
  800421002d:	48 c1 e0 10          	shl    $0x10,%rax
  8004210031:	48 89 c2             	mov    %rax,%rdx
  8004210034:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210038:	48 83 c0 03          	add    $0x3,%rax
  800421003c:	0f b6 00             	movzbl (%rax),%eax
  800421003f:	0f b6 c0             	movzbl %al,%eax
  8004210042:	48 c1 e0 18          	shl    $0x18,%rax
  8004210046:	48 09 d0             	or     %rdx,%rax
  8004210049:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800421004d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210051:	48 83 c0 01          	add    $0x1,%rax
  8004210055:	0f b6 00             	movzbl (%rax),%eax
  8004210058:	0f b6 c0             	movzbl %al,%eax
  800421005b:	48 c1 e0 08          	shl    $0x8,%rax
  800421005f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  8004210063:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210067:	0f b6 00             	movzbl (%rax),%eax
  800421006a:	0f b6 c0             	movzbl %al,%eax
  800421006d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210071:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  8004210072:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210076:	48 8b 10             	mov    (%rax),%rdx
  8004210079:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421007c:	48 98                	cltq   
  800421007e:	48 01 c2             	add    %rax,%rdx
  8004210081:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210085:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210088:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421008c:	eb 05                	jmp    8004210093 <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800421008e:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  8004210093:	c9                   	leaveq 
  8004210094:	c3                   	retq   

0000008004210095 <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  8004210095:	55                   	push   %rbp
  8004210096:	48 89 e5             	mov    %rsp,%rbp
  8004210099:	48 83 ec 24          	sub    $0x24,%rsp
  800421009d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042100a1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042100a5:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  80042100a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042100ac:	48 8b 10             	mov    (%rax),%rdx
  80042100af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042100b3:	48 01 d0             	add    %rdx,%rax
  80042100b6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  80042100ba:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042100bd:	83 f8 02             	cmp    $0x2,%eax
  80042100c0:	74 35                	je     80042100f7 <_dwarf_read_msb+0x62>
  80042100c2:	83 f8 02             	cmp    $0x2,%eax
  80042100c5:	7f 0a                	jg     80042100d1 <_dwarf_read_msb+0x3c>
  80042100c7:	83 f8 01             	cmp    $0x1,%eax
  80042100ca:	74 18                	je     80042100e4 <_dwarf_read_msb+0x4f>
  80042100cc:	e9 53 01 00 00       	jmpq   8004210224 <_dwarf_read_msb+0x18f>
  80042100d1:	83 f8 04             	cmp    $0x4,%eax
  80042100d4:	74 49                	je     800421011f <_dwarf_read_msb+0x8a>
  80042100d6:	83 f8 08             	cmp    $0x8,%eax
  80042100d9:	0f 84 96 00 00 00    	je     8004210175 <_dwarf_read_msb+0xe0>
  80042100df:	e9 40 01 00 00       	jmpq   8004210224 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  80042100e4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100e8:	0f b6 00             	movzbl (%rax),%eax
  80042100eb:	0f b6 c0             	movzbl %al,%eax
  80042100ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042100f2:	e9 34 01 00 00       	jmpq   800421022b <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  80042100f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100fb:	48 83 c0 01          	add    $0x1,%rax
  80042100ff:	0f b6 00             	movzbl (%rax),%eax
  8004210102:	0f b6 d0             	movzbl %al,%edx
  8004210105:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210109:	0f b6 00             	movzbl (%rax),%eax
  800421010c:	0f b6 c0             	movzbl %al,%eax
  800421010f:	48 c1 e0 08          	shl    $0x8,%rax
  8004210113:	48 09 d0             	or     %rdx,%rax
  8004210116:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800421011a:	e9 0c 01 00 00       	jmpq   800421022b <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800421011f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210123:	48 83 c0 03          	add    $0x3,%rax
  8004210127:	0f b6 00             	movzbl (%rax),%eax
  800421012a:	0f b6 c0             	movzbl %al,%eax
  800421012d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210131:	48 83 c2 02          	add    $0x2,%rdx
  8004210135:	0f b6 12             	movzbl (%rdx),%edx
  8004210138:	0f b6 d2             	movzbl %dl,%edx
  800421013b:	48 c1 e2 08          	shl    $0x8,%rdx
  800421013f:	48 09 d0             	or     %rdx,%rax
  8004210142:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  8004210146:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421014a:	48 83 c0 01          	add    $0x1,%rax
  800421014e:	0f b6 00             	movzbl (%rax),%eax
  8004210151:	0f b6 c0             	movzbl %al,%eax
  8004210154:	48 c1 e0 10          	shl    $0x10,%rax
  8004210158:	48 89 c2             	mov    %rax,%rdx
  800421015b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421015f:	0f b6 00             	movzbl (%rax),%eax
  8004210162:	0f b6 c0             	movzbl %al,%eax
  8004210165:	48 c1 e0 18          	shl    $0x18,%rax
  8004210169:	48 09 d0             	or     %rdx,%rax
  800421016c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210170:	e9 b6 00 00 00       	jmpq   800421022b <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004210175:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210179:	48 83 c0 07          	add    $0x7,%rax
  800421017d:	0f b6 00             	movzbl (%rax),%eax
  8004210180:	0f b6 c0             	movzbl %al,%eax
  8004210183:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210187:	48 83 c2 06          	add    $0x6,%rdx
  800421018b:	0f b6 12             	movzbl (%rdx),%edx
  800421018e:	0f b6 d2             	movzbl %dl,%edx
  8004210191:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210195:	48 09 d0             	or     %rdx,%rax
  8004210198:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800421019c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101a0:	48 83 c0 05          	add    $0x5,%rax
  80042101a4:	0f b6 00             	movzbl (%rax),%eax
  80042101a7:	0f b6 c0             	movzbl %al,%eax
  80042101aa:	48 c1 e0 10          	shl    $0x10,%rax
  80042101ae:	48 89 c2             	mov    %rax,%rdx
  80042101b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101b5:	48 83 c0 04          	add    $0x4,%rax
  80042101b9:	0f b6 00             	movzbl (%rax),%eax
  80042101bc:	0f b6 c0             	movzbl %al,%eax
  80042101bf:	48 c1 e0 18          	shl    $0x18,%rax
  80042101c3:	48 09 d0             	or     %rdx,%rax
  80042101c6:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  80042101ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101ce:	48 83 c0 03          	add    $0x3,%rax
  80042101d2:	0f b6 00             	movzbl (%rax),%eax
  80042101d5:	0f b6 c0             	movzbl %al,%eax
  80042101d8:	48 c1 e0 20          	shl    $0x20,%rax
  80042101dc:	48 89 c2             	mov    %rax,%rdx
  80042101df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101e3:	48 83 c0 02          	add    $0x2,%rax
  80042101e7:	0f b6 00             	movzbl (%rax),%eax
  80042101ea:	0f b6 c0             	movzbl %al,%eax
  80042101ed:	48 c1 e0 28          	shl    $0x28,%rax
  80042101f1:	48 09 d0             	or     %rdx,%rax
  80042101f4:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  80042101f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101fc:	48 83 c0 01          	add    $0x1,%rax
  8004210200:	0f b6 00             	movzbl (%rax),%eax
  8004210203:	0f b6 c0             	movzbl %al,%eax
  8004210206:	48 c1 e0 30          	shl    $0x30,%rax
  800421020a:	48 89 c2             	mov    %rax,%rdx
  800421020d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210211:	0f b6 00             	movzbl (%rax),%eax
  8004210214:	0f b6 c0             	movzbl %al,%eax
  8004210217:	48 c1 e0 38          	shl    $0x38,%rax
  800421021b:	48 09 d0             	or     %rdx,%rax
  800421021e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210222:	eb 07                	jmp    800421022b <_dwarf_read_msb+0x196>
	default:
		return (0);
  8004210224:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210229:	eb 1a                	jmp    8004210245 <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  800421022b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421022f:	48 8b 10             	mov    (%rax),%rdx
  8004210232:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210235:	48 98                	cltq   
  8004210237:	48 01 c2             	add    %rax,%rdx
  800421023a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421023e:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210241:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210245:	c9                   	leaveq 
  8004210246:	c3                   	retq   

0000008004210247 <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  8004210247:	55                   	push   %rbp
  8004210248:	48 89 e5             	mov    %rsp,%rbp
  800421024b:	48 83 ec 1c          	sub    $0x1c,%rsp
  800421024f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210253:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  8004210256:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421025a:	48 8b 00             	mov    (%rax),%rax
  800421025d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004210261:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210268:	00 
	switch (bytes_to_read) {
  8004210269:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421026c:	83 f8 02             	cmp    $0x2,%eax
  800421026f:	74 35                	je     80042102a6 <_dwarf_decode_msb+0x5f>
  8004210271:	83 f8 02             	cmp    $0x2,%eax
  8004210274:	7f 0a                	jg     8004210280 <_dwarf_decode_msb+0x39>
  8004210276:	83 f8 01             	cmp    $0x1,%eax
  8004210279:	74 18                	je     8004210293 <_dwarf_decode_msb+0x4c>
  800421027b:	e9 53 01 00 00       	jmpq   80042103d3 <_dwarf_decode_msb+0x18c>
  8004210280:	83 f8 04             	cmp    $0x4,%eax
  8004210283:	74 49                	je     80042102ce <_dwarf_decode_msb+0x87>
  8004210285:	83 f8 08             	cmp    $0x8,%eax
  8004210288:	0f 84 96 00 00 00    	je     8004210324 <_dwarf_decode_msb+0xdd>
  800421028e:	e9 40 01 00 00       	jmpq   80042103d3 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  8004210293:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210297:	0f b6 00             	movzbl (%rax),%eax
  800421029a:	0f b6 c0             	movzbl %al,%eax
  800421029d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042102a1:	e9 34 01 00 00       	jmpq   80042103da <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  80042102a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102aa:	48 83 c0 01          	add    $0x1,%rax
  80042102ae:	0f b6 00             	movzbl (%rax),%eax
  80042102b1:	0f b6 d0             	movzbl %al,%edx
  80042102b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102b8:	0f b6 00             	movzbl (%rax),%eax
  80042102bb:	0f b6 c0             	movzbl %al,%eax
  80042102be:	48 c1 e0 08          	shl    $0x8,%rax
  80042102c2:	48 09 d0             	or     %rdx,%rax
  80042102c5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042102c9:	e9 0c 01 00 00       	jmpq   80042103da <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  80042102ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102d2:	48 83 c0 03          	add    $0x3,%rax
  80042102d6:	0f b6 00             	movzbl (%rax),%eax
  80042102d9:	0f b6 c0             	movzbl %al,%eax
  80042102dc:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042102e0:	48 83 c2 02          	add    $0x2,%rdx
  80042102e4:	0f b6 12             	movzbl (%rdx),%edx
  80042102e7:	0f b6 d2             	movzbl %dl,%edx
  80042102ea:	48 c1 e2 08          	shl    $0x8,%rdx
  80042102ee:	48 09 d0             	or     %rdx,%rax
  80042102f1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  80042102f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102f9:	48 83 c0 01          	add    $0x1,%rax
  80042102fd:	0f b6 00             	movzbl (%rax),%eax
  8004210300:	0f b6 c0             	movzbl %al,%eax
  8004210303:	48 c1 e0 10          	shl    $0x10,%rax
  8004210307:	48 89 c2             	mov    %rax,%rdx
  800421030a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421030e:	0f b6 00             	movzbl (%rax),%eax
  8004210311:	0f b6 c0             	movzbl %al,%eax
  8004210314:	48 c1 e0 18          	shl    $0x18,%rax
  8004210318:	48 09 d0             	or     %rdx,%rax
  800421031b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421031f:	e9 b6 00 00 00       	jmpq   80042103da <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004210324:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210328:	48 83 c0 07          	add    $0x7,%rax
  800421032c:	0f b6 00             	movzbl (%rax),%eax
  800421032f:	0f b6 c0             	movzbl %al,%eax
  8004210332:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210336:	48 83 c2 06          	add    $0x6,%rdx
  800421033a:	0f b6 12             	movzbl (%rdx),%edx
  800421033d:	0f b6 d2             	movzbl %dl,%edx
  8004210340:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210344:	48 09 d0             	or     %rdx,%rax
  8004210347:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800421034b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421034f:	48 83 c0 05          	add    $0x5,%rax
  8004210353:	0f b6 00             	movzbl (%rax),%eax
  8004210356:	0f b6 c0             	movzbl %al,%eax
  8004210359:	48 c1 e0 10          	shl    $0x10,%rax
  800421035d:	48 89 c2             	mov    %rax,%rdx
  8004210360:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210364:	48 83 c0 04          	add    $0x4,%rax
  8004210368:	0f b6 00             	movzbl (%rax),%eax
  800421036b:	0f b6 c0             	movzbl %al,%eax
  800421036e:	48 c1 e0 18          	shl    $0x18,%rax
  8004210372:	48 09 d0             	or     %rdx,%rax
  8004210375:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  8004210379:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421037d:	48 83 c0 03          	add    $0x3,%rax
  8004210381:	0f b6 00             	movzbl (%rax),%eax
  8004210384:	0f b6 c0             	movzbl %al,%eax
  8004210387:	48 c1 e0 20          	shl    $0x20,%rax
  800421038b:	48 89 c2             	mov    %rax,%rdx
  800421038e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210392:	48 83 c0 02          	add    $0x2,%rax
  8004210396:	0f b6 00             	movzbl (%rax),%eax
  8004210399:	0f b6 c0             	movzbl %al,%eax
  800421039c:	48 c1 e0 28          	shl    $0x28,%rax
  80042103a0:	48 09 d0             	or     %rdx,%rax
  80042103a3:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  80042103a7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042103ab:	48 83 c0 01          	add    $0x1,%rax
  80042103af:	0f b6 00             	movzbl (%rax),%eax
  80042103b2:	0f b6 c0             	movzbl %al,%eax
  80042103b5:	48 c1 e0 30          	shl    $0x30,%rax
  80042103b9:	48 89 c2             	mov    %rax,%rdx
  80042103bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042103c0:	0f b6 00             	movzbl (%rax),%eax
  80042103c3:	0f b6 c0             	movzbl %al,%eax
  80042103c6:	48 c1 e0 38          	shl    $0x38,%rax
  80042103ca:	48 09 d0             	or     %rdx,%rax
  80042103cd:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  80042103d1:	eb 07                	jmp    80042103da <_dwarf_decode_msb+0x193>
	default:
		return (0);
  80042103d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042103d8:	eb 1a                	jmp    80042103f4 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  80042103da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103de:	48 8b 10             	mov    (%rax),%rdx
  80042103e1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042103e4:	48 98                	cltq   
  80042103e6:	48 01 c2             	add    %rax,%rdx
  80042103e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103ed:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042103f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042103f4:	c9                   	leaveq 
  80042103f5:	c3                   	retq   

00000080042103f6 <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  80042103f6:	55                   	push   %rbp
  80042103f7:	48 89 e5             	mov    %rsp,%rbp
  80042103fa:	48 83 ec 30          	sub    $0x30,%rsp
  80042103fe:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210402:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  8004210406:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421040d:	00 
	uint8_t b;
	int shift = 0;
  800421040e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004210415:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210419:	48 8b 10             	mov    (%rax),%rdx
  800421041c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210420:	48 01 d0             	add    %rdx,%rax
  8004210423:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004210427:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421042b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421042f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210433:	0f b6 00             	movzbl (%rax),%eax
  8004210436:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210439:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421043d:	83 e0 7f             	and    $0x7f,%eax
  8004210440:	89 c2                	mov    %eax,%edx
  8004210442:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210445:	89 c1                	mov    %eax,%ecx
  8004210447:	d3 e2                	shl    %cl,%edx
  8004210449:	89 d0                	mov    %edx,%eax
  800421044b:	48 98                	cltq   
  800421044d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  8004210451:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210455:	48 8b 00             	mov    (%rax),%rax
  8004210458:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421045c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210460:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004210463:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004210467:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421046b:	84 c0                	test   %al,%al
  800421046d:	78 b8                	js     8004210427 <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  800421046f:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004210473:	7f 1f                	jg     8004210494 <_dwarf_read_sleb128+0x9e>
  8004210475:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210479:	83 e0 40             	and    $0x40,%eax
  800421047c:	85 c0                	test   %eax,%eax
  800421047e:	74 14                	je     8004210494 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  8004210480:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210483:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004210488:	89 c1                	mov    %eax,%ecx
  800421048a:	d3 e2                	shl    %cl,%edx
  800421048c:	89 d0                	mov    %edx,%eax
  800421048e:	48 98                	cltq   
  8004210490:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  8004210494:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210498:	c9                   	leaveq 
  8004210499:	c3                   	retq   

000000800421049a <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  800421049a:	55                   	push   %rbp
  800421049b:	48 89 e5             	mov    %rsp,%rbp
  800421049e:	48 83 ec 30          	sub    $0x30,%rsp
  80042104a2:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042104a6:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  80042104aa:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042104b1:	00 
	uint8_t b;
	int shift = 0;
  80042104b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  80042104b9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042104bd:	48 8b 10             	mov    (%rax),%rdx
  80042104c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042104c4:	48 01 d0             	add    %rdx,%rax
  80042104c7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  80042104cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104cf:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042104d3:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042104d7:	0f b6 00             	movzbl (%rax),%eax
  80042104da:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  80042104dd:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042104e1:	83 e0 7f             	and    $0x7f,%eax
  80042104e4:	89 c2                	mov    %eax,%edx
  80042104e6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042104e9:	89 c1                	mov    %eax,%ecx
  80042104eb:	d3 e2                	shl    %cl,%edx
  80042104ed:	89 d0                	mov    %edx,%eax
  80042104ef:	48 98                	cltq   
  80042104f1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  80042104f5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042104f9:	48 8b 00             	mov    (%rax),%rax
  80042104fc:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210500:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210504:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004210507:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800421050b:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421050f:	84 c0                	test   %al,%al
  8004210511:	78 b8                	js     80042104cb <_dwarf_read_uleb128+0x31>

	return (ret);
  8004210513:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210517:	c9                   	leaveq 
  8004210518:	c3                   	retq   

0000008004210519 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  8004210519:	55                   	push   %rbp
  800421051a:	48 89 e5             	mov    %rsp,%rbp
  800421051d:	48 83 ec 28          	sub    $0x28,%rsp
  8004210521:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  8004210525:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421052c:	00 
	uint8_t b;
	int shift = 0;
  800421052d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  8004210534:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210538:	48 8b 00             	mov    (%rax),%rax
  800421053b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800421053f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210543:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210547:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800421054b:	0f b6 00             	movzbl (%rax),%eax
  800421054e:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210551:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210555:	83 e0 7f             	and    $0x7f,%eax
  8004210558:	89 c2                	mov    %eax,%edx
  800421055a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421055d:	89 c1                	mov    %eax,%ecx
  800421055f:	d3 e2                	shl    %cl,%edx
  8004210561:	89 d0                	mov    %edx,%eax
  8004210563:	48 98                	cltq   
  8004210565:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  8004210569:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800421056d:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210571:	84 c0                	test   %al,%al
  8004210573:	78 ca                	js     800421053f <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  8004210575:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004210579:	7f 1f                	jg     800421059a <_dwarf_decode_sleb128+0x81>
  800421057b:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421057f:	83 e0 40             	and    $0x40,%eax
  8004210582:	85 c0                	test   %eax,%eax
  8004210584:	74 14                	je     800421059a <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  8004210586:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210589:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800421058e:	89 c1                	mov    %eax,%ecx
  8004210590:	d3 e2                	shl    %cl,%edx
  8004210592:	89 d0                	mov    %edx,%eax
  8004210594:	48 98                	cltq   
  8004210596:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  800421059a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421059e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042105a2:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042105a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042105a9:	c9                   	leaveq 
  80042105aa:	c3                   	retq   

00000080042105ab <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  80042105ab:	55                   	push   %rbp
  80042105ac:	48 89 e5             	mov    %rsp,%rbp
  80042105af:	48 83 ec 28          	sub    $0x28,%rsp
  80042105b3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  80042105b7:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042105be:	00 
	uint8_t b;
	int shift = 0;
  80042105bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  80042105c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042105ca:	48 8b 00             	mov    (%rax),%rax
  80042105cd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  80042105d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042105d5:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042105d9:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042105dd:	0f b6 00             	movzbl (%rax),%eax
  80042105e0:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  80042105e3:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042105e7:	83 e0 7f             	and    $0x7f,%eax
  80042105ea:	89 c2                	mov    %eax,%edx
  80042105ec:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042105ef:	89 c1                	mov    %eax,%ecx
  80042105f1:	d3 e2                	shl    %cl,%edx
  80042105f3:	89 d0                	mov    %edx,%eax
  80042105f5:	48 98                	cltq   
  80042105f7:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  80042105fb:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  80042105ff:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210603:	84 c0                	test   %al,%al
  8004210605:	78 ca                	js     80042105d1 <_dwarf_decode_uleb128+0x26>

	*dp = src;
  8004210607:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421060b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421060f:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210612:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210616:	c9                   	leaveq 
  8004210617:	c3                   	retq   

0000008004210618 <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  8004210618:	55                   	push   %rbp
  8004210619:	48 89 e5             	mov    %rsp,%rbp
  800421061c:	48 83 ec 28          	sub    $0x28,%rsp
  8004210620:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210624:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210628:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  800421062c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210630:	48 8b 10             	mov    (%rax),%rdx
  8004210633:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210637:	48 01 d0             	add    %rdx,%rax
  800421063a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421063e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210642:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  8004210646:	eb 17                	jmp    800421065f <_dwarf_read_string+0x47>
		src++;
  8004210648:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  800421064d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210651:	48 8b 00             	mov    (%rax),%rax
  8004210654:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210658:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421065c:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  800421065f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210663:	0f b6 00             	movzbl (%rax),%eax
  8004210666:	84 c0                	test   %al,%al
  8004210668:	74 0d                	je     8004210677 <_dwarf_read_string+0x5f>
  800421066a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421066e:	48 8b 00             	mov    (%rax),%rax
  8004210671:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004210675:	72 d1                	jb     8004210648 <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  8004210677:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421067b:	0f b6 00             	movzbl (%rax),%eax
  800421067e:	84 c0                	test   %al,%al
  8004210680:	75 1f                	jne    80042106a1 <_dwarf_read_string+0x89>
  8004210682:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210686:	48 8b 00             	mov    (%rax),%rax
  8004210689:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421068d:	73 12                	jae    80042106a1 <_dwarf_read_string+0x89>
		(*offsetp)++;
  800421068f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210693:	48 8b 00             	mov    (%rax),%rax
  8004210696:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421069a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421069e:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042106a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042106a5:	c9                   	leaveq 
  80042106a6:	c3                   	retq   

00000080042106a7 <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  80042106a7:	55                   	push   %rbp
  80042106a8:	48 89 e5             	mov    %rsp,%rbp
  80042106ab:	48 83 ec 28          	sub    $0x28,%rsp
  80042106af:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042106b3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042106b7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  80042106bb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042106bf:	48 8b 10             	mov    (%rax),%rdx
  80042106c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042106c6:	48 01 d0             	add    %rdx,%rax
  80042106c9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042106cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042106d1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  80042106d5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042106d9:	48 8b 10             	mov    (%rax),%rdx
  80042106dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106e0:	48 01 c2             	add    %rax,%rdx
  80042106e3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042106e7:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042106ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042106ee:	c9                   	leaveq 
  80042106ef:	c3                   	retq   

00000080042106f0 <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  80042106f0:	55                   	push   %rbp
  80042106f1:	48 89 e5             	mov    %rsp,%rbp
  80042106f4:	48 83 ec 20          	sub    $0x20,%rsp
  80042106f8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  80042106fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210700:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  8004210704:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210709:	75 35                	jne    8004210740 <_dwarf_elf_get_byte_order+0x50>
  800421070b:	48 b9 20 a3 21 04 80 	movabs $0x800421a320,%rcx
  8004210712:	00 00 00 
  8004210715:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  800421071c:	00 00 00 
  800421071f:	be 29 01 00 00       	mov    $0x129,%esi
  8004210724:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  800421072b:	00 00 00 
  800421072e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210733:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800421073a:	00 00 00 
  800421073d:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  8004210740:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210744:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  8004210748:	0f b6 c0             	movzbl %al,%eax
  800421074b:	83 f8 02             	cmp    $0x2,%eax
  800421074e:	75 07                	jne    8004210757 <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  8004210750:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210755:	eb 05                	jmp    800421075c <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  8004210757:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  800421075c:	c9                   	leaveq 
  800421075d:	c3                   	retq   

000000800421075e <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  800421075e:	55                   	push   %rbp
  800421075f:	48 89 e5             	mov    %rsp,%rbp
  8004210762:	48 83 ec 20          	sub    $0x20,%rsp
  8004210766:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  800421076a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421076e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  8004210772:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210777:	75 35                	jne    80042107ae <_dwarf_elf_get_pointer_size+0x50>
  8004210779:	48 b9 20 a3 21 04 80 	movabs $0x800421a320,%rcx
  8004210780:	00 00 00 
  8004210783:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  800421078a:	00 00 00 
  800421078d:	be 3f 01 00 00       	mov    $0x13f,%esi
  8004210792:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004210799:	00 00 00 
  800421079c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042107a1:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042107a8:	00 00 00 
  80042107ab:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  80042107ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042107b2:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  80042107b6:	3c 01                	cmp    $0x1,%al
  80042107b8:	75 07                	jne    80042107c1 <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  80042107ba:	b8 04 00 00 00       	mov    $0x4,%eax
  80042107bf:	eb 05                	jmp    80042107c6 <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  80042107c1:	b8 08 00 00 00       	mov    $0x8,%eax
}
  80042107c6:	c9                   	leaveq 
  80042107c7:	c3                   	retq   

00000080042107c8 <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  80042107c8:	55                   	push   %rbp
  80042107c9:	48 89 e5             	mov    %rsp,%rbp
  80042107cc:	53                   	push   %rbx
  80042107cd:	48 83 ec 18          	sub    $0x18,%rsp
  80042107d1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042107d5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  80042107d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107dd:	ba 60 00 00 00       	mov    $0x60,%edx
  80042107e2:	be 00 00 00 00       	mov    $0x0,%esi
  80042107e7:	48 89 c7             	mov    %rax,%rdi
  80042107ea:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  80042107f1:	00 00 00 
  80042107f4:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  80042107f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107fa:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  8004210801:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210805:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800421080c:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  800421080d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210811:	48 89 c7             	mov    %rax,%rdi
  8004210814:	48 b8 5e 07 21 04 80 	movabs $0x800421075e,%rax
  800421081b:	00 00 00 
  800421081e:	ff d0                	callq  *%rax
  8004210820:	0f b6 d0             	movzbl %al,%edx
  8004210823:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210827:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  800421082a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421082e:	48 89 c7             	mov    %rax,%rdi
  8004210831:	48 b8 f0 06 21 04 80 	movabs $0x80042106f0,%rax
  8004210838:	00 00 00 
  800421083b:	ff d0                	callq  *%rax
  800421083d:	85 c0                	test   %eax,%eax
  800421083f:	75 26                	jne    8004210867 <_dwarf_init+0x9f>
		dbg->read = _dwarf_read_msb;
  8004210841:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210845:	48 b9 95 00 21 04 80 	movabs $0x8004210095,%rcx
  800421084c:	00 00 00 
  800421084f:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  8004210853:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210857:	48 bb 47 02 21 04 80 	movabs $0x8004210247,%rbx
  800421085e:	00 00 00 
  8004210861:	48 89 58 20          	mov    %rbx,0x20(%rax)
  8004210865:	eb 24                	jmp    800421088b <_dwarf_init+0xc3>
	} else {
		dbg->read = _dwarf_read_lsb;
  8004210867:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421086b:	48 b9 48 fe 20 04 80 	movabs $0x800420fe48,%rcx
  8004210872:	00 00 00 
  8004210875:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  8004210879:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421087d:	48 be 74 ff 20 04 80 	movabs $0x800420ff74,%rsi
  8004210884:	00 00 00 
  8004210887:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  800421088b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421088f:	48 89 c7             	mov    %rax,%rdi
  8004210892:	48 b8 95 1d 21 04 80 	movabs $0x8004211d95,%rax
  8004210899:	00 00 00 
  800421089c:	ff d0                	callq  *%rax
	return 0;
  800421089e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042108a3:	48 83 c4 18          	add    $0x18,%rsp
  80042108a7:	5b                   	pop    %rbx
  80042108a8:	5d                   	pop    %rbp
  80042108a9:	c3                   	retq   

00000080042108aa <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  80042108aa:	55                   	push   %rbp
  80042108ab:	48 89 e5             	mov    %rsp,%rbp
  80042108ae:	48 83 ec 20          	sub    $0x20,%rsp
  80042108b2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042108b6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  80042108ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108be:	48 8b 10             	mov    (%rax),%rdx
  80042108c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108c5:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042108c9:	48 39 c2             	cmp    %rax,%rdx
  80042108cc:	76 0a                	jbe    80042108d8 <_get_next_cu+0x2e>
		return -1;
  80042108ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042108d3:	e9 6b 01 00 00       	jmpq   8004210a43 <_get_next_cu+0x199>

	offset = dbg->curr_off_dbginfo;
  80042108d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108dc:	48 8b 00             	mov    (%rax),%rax
  80042108df:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  80042108e3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042108e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042108eb:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  80042108ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108f3:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042108f7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042108fb:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80042108ff:	48 89 d1             	mov    %rdx,%rcx
  8004210902:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210906:	ba 04 00 00 00       	mov    $0x4,%edx
  800421090b:	48 89 cf             	mov    %rcx,%rdi
  800421090e:	ff d0                	callq  *%rax
  8004210910:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  8004210913:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004210917:	75 2a                	jne    8004210943 <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  8004210919:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421091d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210921:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210925:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210929:	48 89 d1             	mov    %rdx,%rcx
  800421092c:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210930:	ba 08 00 00 00       	mov    $0x8,%edx
  8004210935:	48 89 cf             	mov    %rcx,%rdi
  8004210938:	ff d0                	callq  *%rax
  800421093a:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  800421093d:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  8004210941:	eb 04                	jmp    8004210947 <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  8004210943:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  8004210947:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421094b:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800421094f:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  8004210952:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004210955:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210959:	48 01 c2             	add    %rax,%rdx
  800421095c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210960:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  8004210963:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210967:	48 8b 10             	mov    (%rax),%rdx
  800421096a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421096e:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  8004210972:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004210975:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210979:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  800421097c:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  8004210980:	75 07                	jne    8004210989 <_get_next_cu+0xdf>
  8004210982:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210987:	eb 05                	jmp    800421098e <_get_next_cu+0xe4>
  8004210989:	b8 0c 00 00 00       	mov    $0xc,%eax
  800421098e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210992:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  8004210995:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210999:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421099d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042109a1:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80042109a5:	48 89 d1             	mov    %rdx,%rcx
  80042109a8:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  80042109ac:	ba 02 00 00 00       	mov    $0x2,%edx
  80042109b1:	48 89 cf             	mov    %rcx,%rdi
  80042109b4:	ff d0                	callq  *%rax
  80042109b6:	89 c2                	mov    %eax,%edx
  80042109b8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042109bc:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  80042109c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109c4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042109c8:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  80042109cc:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042109d0:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  80042109d4:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  80042109d8:	48 89 cf             	mov    %rcx,%rdi
  80042109db:	ff d0                	callq  *%rax
  80042109dd:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042109e1:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  80042109e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109e9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042109ed:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042109f1:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80042109f5:	48 89 d1             	mov    %rdx,%rcx
  80042109f8:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  80042109fc:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210a01:	48 89 cf             	mov    %rcx,%rdi
  8004210a04:	ff d0                	callq  *%rax
  8004210a06:	89 c2                	mov    %eax,%edx
  8004210a08:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a0c:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  8004210a0f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a13:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210a17:	66 83 f8 01          	cmp    $0x1,%ax
  8004210a1b:	76 0e                	jbe    8004210a2b <_get_next_cu+0x181>
  8004210a1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a21:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210a25:	66 83 f8 04          	cmp    $0x4,%ax
  8004210a29:	76 07                	jbe    8004210a32 <_get_next_cu+0x188>
		return -1;
  8004210a2b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210a30:	eb 11                	jmp    8004210a43 <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  8004210a32:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210a36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a3a:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  8004210a3e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210a43:	c9                   	leaveq 
  8004210a44:	c3                   	retq   

0000008004210a45 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  8004210a45:	55                   	push   %rbp
  8004210a46:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  8004210a49:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  8004210a4d:	0f b6 c8             	movzbl %al,%ecx
  8004210a50:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  8004210a54:	0f b7 d0             	movzwl %ax,%edx
  8004210a57:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8004210a5b:	48 89 c6             	mov    %rax,%rsi
  8004210a5e:	48 bf 52 a3 21 04 80 	movabs $0x800421a352,%rdi
  8004210a65:	00 00 00 
  8004210a68:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210a6d:	49 b8 c3 8d 20 04 80 	movabs $0x8004208dc3,%r8
  8004210a74:	00 00 00 
  8004210a77:	41 ff d0             	callq  *%r8
}
  8004210a7a:	5d                   	pop    %rbp
  8004210a7b:	c3                   	retq   

0000008004210a7c <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  8004210a7c:	55                   	push   %rbp
  8004210a7d:	48 89 e5             	mov    %rsp,%rbp
  8004210a80:	48 83 ec 60          	sub    $0x60,%rsp
  8004210a84:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004210a88:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004210a8c:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004210a90:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  8004210a94:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004210a99:	75 35                	jne    8004210ad0 <_dwarf_abbrev_parse+0x54>
  8004210a9b:	48 b9 61 a3 21 04 80 	movabs $0x800421a361,%rcx
  8004210aa2:	00 00 00 
  8004210aa5:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  8004210aac:	00 00 00 
  8004210aaf:	be a4 01 00 00       	mov    $0x1a4,%esi
  8004210ab4:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004210abb:	00 00 00 
  8004210abe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210ac3:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004210aca:	00 00 00 
  8004210acd:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  8004210ad0:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8004210ad5:	75 35                	jne    8004210b0c <_dwarf_abbrev_parse+0x90>
  8004210ad7:	48 b9 6d a3 21 04 80 	movabs $0x800421a36d,%rcx
  8004210ade:	00 00 00 
  8004210ae1:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  8004210ae8:	00 00 00 
  8004210aeb:	be a5 01 00 00       	mov    $0x1a5,%esi
  8004210af0:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004210af7:	00 00 00 
  8004210afa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210aff:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004210b06:	00 00 00 
  8004210b09:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  8004210b0c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210b10:	48 8b 10             	mov    (%rax),%rdx
  8004210b13:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210b17:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210b1b:	48 39 c2             	cmp    %rax,%rdx
  8004210b1e:	72 0a                	jb     8004210b2a <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  8004210b20:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210b25:	e9 d3 01 00 00       	jmpq   8004210cfd <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  8004210b2a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210b2e:	48 8b 00             	mov    (%rax),%rax
  8004210b31:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  8004210b35:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210b39:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210b3d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210b41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b45:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210b49:	48 89 d6             	mov    %rdx,%rsi
  8004210b4c:	48 89 c7             	mov    %rax,%rdi
  8004210b4f:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  8004210b56:	00 00 00 
  8004210b59:	ff d0                	callq  *%rax
  8004210b5b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  8004210b5f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210b64:	75 15                	jne    8004210b7b <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  8004210b66:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210b6a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  8004210b71:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210b76:	e9 82 01 00 00       	jmpq   8004210cfd <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210b7b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b7f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210b83:	48 89 d6             	mov    %rdx,%rsi
  8004210b86:	48 89 c7             	mov    %rax,%rdi
  8004210b89:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  8004210b90:	00 00 00 
  8004210b93:	ff d0                	callq  *%rax
  8004210b95:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  8004210b99:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210b9d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210ba1:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004210ba5:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004210ba9:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210bae:	48 89 cf             	mov    %rcx,%rdi
  8004210bb1:	ff d0                	callq  *%rax
  8004210bb3:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  8004210bb6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210bba:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210bbe:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  8004210bc1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210bc5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210bc9:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  8004210bcd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210bd1:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  8004210bd5:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  8004210bd8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210bdc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210be0:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  8004210be4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210be8:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  8004210bef:	00 
	abp->ab_atnum    = 0;
  8004210bf0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210bf4:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  8004210bfb:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  8004210bfc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210c00:	48 8b 00             	mov    (%rax),%rax
  8004210c03:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210c07:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c0b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210c0f:	48 89 d6             	mov    %rdx,%rsi
  8004210c12:	48 89 c7             	mov    %rax,%rdi
  8004210c15:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  8004210c1c:	00 00 00 
  8004210c1f:	ff d0                	callq  *%rax
  8004210c21:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210c25:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c29:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210c2d:	48 89 d6             	mov    %rdx,%rsi
  8004210c30:	48 89 c7             	mov    %rax,%rdi
  8004210c33:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  8004210c3a:	00 00 00 
  8004210c3d:	ff d0                	callq  *%rax
  8004210c3f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  8004210c43:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210c48:	0f 84 89 00 00 00    	je     8004210cd7 <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  8004210c4e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210c52:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210c56:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210c5a:	48 89 d0             	mov    %rdx,%rax
  8004210c5d:	48 01 c0             	add    %rax,%rax
  8004210c60:	48 01 d0             	add    %rdx,%rax
  8004210c63:	48 c1 e0 03          	shl    $0x3,%rax
  8004210c67:	48 01 c8             	add    %rcx,%rax
  8004210c6a:	48 8d 50 30          	lea    0x30(%rax),%rdx
  8004210c6e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210c72:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  8004210c75:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210c79:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210c7d:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210c81:	48 89 d0             	mov    %rdx,%rax
  8004210c84:	48 01 c0             	add    %rax,%rax
  8004210c87:	48 01 d0             	add    %rdx,%rax
  8004210c8a:	48 c1 e0 03          	shl    $0x3,%rax
  8004210c8e:	48 01 c8             	add    %rcx,%rax
  8004210c91:	48 8d 50 38          	lea    0x38(%rax),%rdx
  8004210c95:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210c99:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  8004210c9c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210ca0:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210ca4:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210ca8:	48 89 d0             	mov    %rdx,%rax
  8004210cab:	48 01 c0             	add    %rax,%rax
  8004210cae:	48 01 d0             	add    %rdx,%rax
  8004210cb1:	48 c1 e0 03          	shl    $0x3,%rax
  8004210cb5:	48 01 c8             	add    %rcx,%rax
  8004210cb8:	48 8d 50 40          	lea    0x40(%rax),%rdx
  8004210cbc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210cc0:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  8004210cc3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210cc7:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210ccb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210ccf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210cd3:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  8004210cd7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210cdc:	0f 85 1a ff ff ff    	jne    8004210bfc <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  8004210ce2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210ce6:	48 8b 00             	mov    (%rax),%rax
  8004210ce9:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004210ced:	48 89 c2             	mov    %rax,%rdx
  8004210cf0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210cf4:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  8004210cf8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210cfd:	c9                   	leaveq 
  8004210cfe:	c3                   	retq   

0000008004210cff <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  8004210cff:	55                   	push   %rbp
  8004210d00:	48 89 e5             	mov    %rsp,%rbp
  8004210d03:	48 83 ec 70          	sub    $0x70,%rsp
  8004210d07:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210d0b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210d0f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  8004210d13:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210d18:	75 0a                	jne    8004210d24 <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  8004210d1a:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210d1f:	e9 0a 01 00 00       	jmpq   8004210e2e <_dwarf_abbrev_find+0x12f>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  8004210d24:	48 bf 78 a3 21 04 80 	movabs $0x800421a378,%rdi
  8004210d2b:	00 00 00 
  8004210d2e:	48 b8 5f 50 21 04 80 	movabs $0x800421505f,%rax
  8004210d35:	00 00 00 
  8004210d38:	ff d0                	callq  *%rax
  8004210d3a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  8004210d3e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210d43:	75 35                	jne    8004210d7a <_dwarf_abbrev_find+0x7b>
  8004210d45:	48 b9 6d a3 21 04 80 	movabs $0x800421a36d,%rcx
  8004210d4c:	00 00 00 
  8004210d4f:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  8004210d56:	00 00 00 
  8004210d59:	be e5 01 00 00       	mov    $0x1e5,%esi
  8004210d5e:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004210d65:	00 00 00 
  8004210d68:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210d6d:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004210d74:	00 00 00 
  8004210d77:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  8004210d7a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210d7e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  8004210d82:	e9 8d 00 00 00       	jmpq   8004210e14 <_dwarf_abbrev_find+0x115>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  8004210d87:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004210d8b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210d8f:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  8004210d93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210d97:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004210d9b:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210d9f:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  8004210da3:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004210da8:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  8004210dac:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004210db1:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  8004210db5:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004210dba:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  8004210dbe:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004210dc3:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  8004210dc7:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004210dcc:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  8004210dd0:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  8004210dd5:	48 89 c7             	mov    %rax,%rdi
  8004210dd8:	48 b8 7c 0a 21 04 80 	movabs $0x8004210a7c,%rax
  8004210ddf:	00 00 00 
  8004210de2:	ff d0                	callq  *%rax
  8004210de4:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  8004210de7:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004210deb:	74 05                	je     8004210df2 <_dwarf_abbrev_find+0xf3>
			return (ret);
  8004210ded:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210df0:	eb 3c                	jmp    8004210e2e <_dwarf_abbrev_find+0x12f>
		if (abp->ab_entry == entry) {
  8004210df2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210df6:	48 8b 00             	mov    (%rax),%rax
  8004210df9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004210dfd:	75 07                	jne    8004210e06 <_dwarf_abbrev_find+0x107>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  8004210dff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e04:	eb 28                	jmp    8004210e2e <_dwarf_abbrev_find+0x12f>
		}
		if (abp->ab_entry == 0) {
  8004210e06:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210e0a:	48 8b 00             	mov    (%rax),%rax
  8004210e0d:	48 85 c0             	test   %rax,%rax
  8004210e10:	75 02                	jne    8004210e14 <_dwarf_abbrev_find+0x115>
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  8004210e12:	eb 15                	jmp    8004210e29 <_dwarf_abbrev_find+0x12a>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  8004210e14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210e18:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210e1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210e20:	48 39 c2             	cmp    %rax,%rdx
  8004210e23:	0f 87 5e ff ff ff    	ja     8004210d87 <_dwarf_abbrev_find+0x88>
			//cu->cu_abbrev_loaded = 1;
			break;
		}
	}

	return DW_DLE_NO_ENTRY;
  8004210e29:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004210e2e:	c9                   	leaveq 
  8004210e2f:	c3                   	retq   

0000008004210e30 <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  8004210e30:	55                   	push   %rbp
  8004210e31:	48 89 e5             	mov    %rsp,%rbp
  8004210e34:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  8004210e3b:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004210e42:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004210e49:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004210e50:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  8004210e57:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  8004210e5e:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  8004210e65:	48 bf 86 a3 21 04 80 	movabs $0x800421a386,%rdi
  8004210e6c:	00 00 00 
  8004210e6f:	48 b8 5f 50 21 04 80 	movabs $0x800421505f,%rax
  8004210e76:	00 00 00 
  8004210e79:	ff d0                	callq  *%rax
  8004210e7b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  8004210e7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210e83:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210e87:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  8004210e8b:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004210e92:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004210e96:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  8004210e99:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  8004210ea0:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004210ea7:	ba 60 00 00 00       	mov    $0x60,%edx
  8004210eac:	be 00 00 00 00       	mov    $0x0,%esi
  8004210eb1:	48 89 c7             	mov    %rax,%rdi
  8004210eb4:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004210ebb:	00 00 00 
  8004210ebe:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  8004210ec0:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004210ec7:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  8004210ece:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004210ed5:	48 8b 00             	mov    (%rax),%rax
  8004210ed8:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  8004210edc:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004210ee3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210ee7:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  8004210eeb:	8b 45 10             	mov    0x10(%rbp),%eax
  8004210eee:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  8004210ef1:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004210ef8:	00 

	switch (form) {
  8004210ef9:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  8004210f00:	20 
  8004210f01:	0f 87 82 04 00 00    	ja     8004211389 <_dwarf_attr_init+0x559>
  8004210f07:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004210f0e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004210f15:	00 
  8004210f16:	48 b8 b0 a3 21 04 80 	movabs $0x800421a3b0,%rax
  8004210f1d:	00 00 00 
  8004210f20:	48 01 d0             	add    %rdx,%rax
  8004210f23:	48 8b 00             	mov    (%rax),%rax
  8004210f26:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004210f28:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210f2f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210f33:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004210f3a:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004210f3e:	0f b6 d2             	movzbl %dl,%edx
  8004210f41:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210f48:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210f4c:	48 89 cf             	mov    %rcx,%rdi
  8004210f4f:	ff d0                	callq  *%rax
  8004210f51:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210f55:	e9 37 04 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004210f5a:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004210f61:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f65:	48 89 d6             	mov    %rdx,%rsi
  8004210f68:	48 89 c7             	mov    %rax,%rdi
  8004210f6b:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  8004210f72:	00 00 00 
  8004210f75:	ff d0                	callq  *%rax
  8004210f77:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004210f7b:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210f7f:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210f86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f8a:	48 89 ce             	mov    %rcx,%rsi
  8004210f8d:	48 89 c7             	mov    %rax,%rdi
  8004210f90:	48 b8 a7 06 21 04 80 	movabs $0x80042106a7,%rax
  8004210f97:	00 00 00 
  8004210f9a:	ff d0                	callq  *%rax
  8004210f9c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210fa0:	e9 ec 03 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004210fa5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210fac:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210fb0:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210fb7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210fbb:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210fc0:	48 89 cf             	mov    %rcx,%rdi
  8004210fc3:	ff d0                	callq  *%rax
  8004210fc5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004210fc9:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210fcd:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210fd4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210fd8:	48 89 ce             	mov    %rcx,%rsi
  8004210fdb:	48 89 c7             	mov    %rax,%rdi
  8004210fde:	48 b8 a7 06 21 04 80 	movabs $0x80042106a7,%rax
  8004210fe5:	00 00 00 
  8004210fe8:	ff d0                	callq  *%rax
  8004210fea:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210fee:	e9 9e 03 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  8004210ff3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210ffa:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210ffe:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211005:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211009:	ba 02 00 00 00       	mov    $0x2,%edx
  800421100e:	48 89 cf             	mov    %rcx,%rdi
  8004211011:	ff d0                	callq  *%rax
  8004211013:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211017:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421101b:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211022:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211026:	48 89 ce             	mov    %rcx,%rsi
  8004211029:	48 89 c7             	mov    %rax,%rdi
  800421102c:	48 b8 a7 06 21 04 80 	movabs $0x80042106a7,%rax
  8004211033:	00 00 00 
  8004211036:	ff d0                	callq  *%rax
  8004211038:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421103c:	e9 50 03 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004211041:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211048:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421104c:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211053:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211057:	ba 04 00 00 00       	mov    $0x4,%edx
  800421105c:	48 89 cf             	mov    %rcx,%rdi
  800421105f:	ff d0                	callq  *%rax
  8004211061:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211065:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211069:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211070:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211074:	48 89 ce             	mov    %rcx,%rsi
  8004211077:	48 89 c7             	mov    %rax,%rdi
  800421107a:	48 b8 a7 06 21 04 80 	movabs $0x80042106a7,%rax
  8004211081:	00 00 00 
  8004211084:	ff d0                	callq  *%rax
  8004211086:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421108a:	e9 02 03 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800421108f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211096:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421109a:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042110a1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042110a5:	ba 01 00 00 00       	mov    $0x1,%edx
  80042110aa:	48 89 cf             	mov    %rcx,%rdi
  80042110ad:	ff d0                	callq  *%rax
  80042110af:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042110b3:	e9 d9 02 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042110b8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042110bf:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042110c3:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042110ca:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042110ce:	ba 02 00 00 00       	mov    $0x2,%edx
  80042110d3:	48 89 cf             	mov    %rcx,%rdi
  80042110d6:	ff d0                	callq  *%rax
  80042110d8:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042110dc:	e9 b0 02 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  80042110e1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042110e8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042110ec:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042110f3:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042110f7:	ba 04 00 00 00       	mov    $0x4,%edx
  80042110fc:	48 89 cf             	mov    %rcx,%rdi
  80042110ff:	ff d0                	callq  *%rax
  8004211101:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211105:	e9 87 02 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  800421110a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211111:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211115:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421111c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211120:	ba 08 00 00 00       	mov    $0x8,%edx
  8004211125:	48 89 cf             	mov    %rcx,%rdi
  8004211128:	ff d0                	callq  *%rax
  800421112a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421112e:	e9 5e 02 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  8004211133:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421113a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421113e:	48 89 d6             	mov    %rdx,%rsi
  8004211141:	48 89 c7             	mov    %rax,%rdi
  8004211144:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  800421114b:	00 00 00 
  800421114e:	ff d0                	callq  *%rax
  8004211150:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  8004211157:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  800421115e:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  8004211165:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800421116c:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004211173:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421117a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211181:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  8004211188:	4d 89 c1             	mov    %r8,%r9
  800421118b:	49 89 f8             	mov    %rdi,%r8
  800421118e:	48 89 c7             	mov    %rax,%rdi
  8004211191:	48 b8 30 0e 21 04 80 	movabs $0x8004210e30,%rax
  8004211198:	00 00 00 
  800421119b:	ff d0                	callq  *%rax
  800421119d:	e9 1d 03 00 00       	jmpq   80042114bf <_dwarf_attr_init+0x68f>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  80042111a2:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042111a9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042111ad:	66 83 f8 02          	cmp    $0x2,%ax
  80042111b1:	75 2f                	jne    80042111e2 <_dwarf_attr_init+0x3b2>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  80042111b3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042111ba:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042111be:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  80042111c5:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  80042111c9:	0f b6 d2             	movzbl %dl,%edx
  80042111cc:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042111d3:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042111d7:	48 89 cf             	mov    %rcx,%rdi
  80042111da:	ff d0                	callq  *%rax
  80042111dc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042111e0:	eb 39                	jmp    800421121b <_dwarf_attr_init+0x3eb>
		else if (cu->version == 3)
  80042111e2:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042111e9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042111ed:	66 83 f8 03          	cmp    $0x3,%ax
  80042111f1:	75 28                	jne    800421121b <_dwarf_attr_init+0x3eb>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042111f3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042111fa:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042111fe:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004211202:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211209:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421120d:	48 89 cf             	mov    %rcx,%rdi
  8004211210:	ff d0                	callq  *%rax
  8004211212:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211216:	e9 76 01 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
  800421121b:	e9 71 01 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004211220:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211227:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421122b:	48 89 d6             	mov    %rdx,%rsi
  800421122e:	48 89 c7             	mov    %rax,%rdi
  8004211231:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  8004211238:	00 00 00 
  800421123b:	ff d0                	callq  *%rax
  800421123d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211241:	e9 4b 01 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  8004211246:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421124d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211251:	48 89 d6             	mov    %rdx,%rsi
  8004211254:	48 89 c7             	mov    %rax,%rdi
  8004211257:	48 b8 f6 03 21 04 80 	movabs $0x80042103f6,%rax
  800421125e:	00 00 00 
  8004211261:	ff d0                	callq  *%rax
  8004211263:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211267:	e9 25 01 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800421126c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211273:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211277:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800421127b:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211282:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211286:	48 89 cf             	mov    %rcx,%rdi
  8004211289:	ff d0                	callq  *%rax
  800421128b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421128f:	e9 fd 00 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  8004211294:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211298:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800421129c:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042112a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112a7:	48 89 ce             	mov    %rcx,%rsi
  80042112aa:	48 89 c7             	mov    %rax,%rdi
  80042112ad:	48 b8 18 06 21 04 80 	movabs $0x8004210618,%rax
  80042112b4:	00 00 00 
  80042112b7:	ff d0                	callq  *%rax
  80042112b9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042112bd:	e9 cf 00 00 00       	jmpq   8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042112c2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042112c9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042112cd:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042112d1:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042112d8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042112dc:	48 89 cf             	mov    %rcx,%rdi
  80042112df:	ff d0                	callq  *%rax
  80042112e1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  80042112e5:	48 bf 92 a3 21 04 80 	movabs $0x800421a392,%rdi
  80042112ec:	00 00 00 
  80042112ef:	48 b8 5f 50 21 04 80 	movabs $0x800421505f,%rax
  80042112f6:	00 00 00 
  80042112f9:	ff d0                	callq  *%rax
  80042112fb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  80042112ff:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211304:	75 35                	jne    800421133b <_dwarf_attr_init+0x50b>
  8004211306:	48 b9 9d a3 21 04 80 	movabs $0x800421a39d,%rcx
  800421130d:	00 00 00 
  8004211310:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  8004211317:	00 00 00 
  800421131a:	be 51 02 00 00       	mov    $0x251,%esi
  800421131f:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004211326:	00 00 00 
  8004211329:	b8 00 00 00 00       	mov    $0x0,%eax
  800421132e:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004211335:	00 00 00 
  8004211338:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  800421133b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421133f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211343:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211347:	48 01 d0             	add    %rdx,%rax
  800421134a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421134e:	eb 41                	jmp    8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  8004211350:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  8004211357:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  8004211358:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421135c:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211363:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211367:	48 89 ce             	mov    %rcx,%rsi
  800421136a:	48 89 c7             	mov    %rax,%rdi
  800421136d:	48 b8 a7 06 21 04 80 	movabs $0x80042106a7,%rax
  8004211374:	00 00 00 
  8004211377:	ff d0                	callq  *%rax
  8004211379:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421137d:	eb 12                	jmp    8004211391 <_dwarf_attr_init+0x561>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  800421137f:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  8004211386:	00 
		break;
  8004211387:	eb 08                	jmp    8004211391 <_dwarf_attr_init+0x561>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  8004211389:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  8004211390:	90                   	nop
	}

	if (ret == DW_DLE_NONE) {
  8004211391:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211395:	0f 85 21 01 00 00    	jne    80042114bc <_dwarf_attr_init+0x68c>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  800421139b:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  80042113a2:	09 
  80042113a3:	74 1e                	je     80042113c3 <_dwarf_attr_init+0x593>
  80042113a5:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  80042113ac:	0a 
  80042113ad:	74 14                	je     80042113c3 <_dwarf_attr_init+0x593>
  80042113af:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  80042113b6:	03 
  80042113b7:	74 0a                	je     80042113c3 <_dwarf_attr_init+0x593>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  80042113b9:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  80042113c0:	04 
  80042113c1:	75 10                	jne    80042113d3 <_dwarf_attr_init+0x5a3>
			atref.at_block.bl_len = atref.u[0].u64;
  80042113c3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042113c7:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  80042113cb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042113cf:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  80042113d3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042113d7:	48 83 f8 03          	cmp    $0x3,%rax
  80042113db:	75 39                	jne    8004211416 <_dwarf_attr_init+0x5e6>
			switch (atref.at_form) {
  80042113dd:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042113e1:	48 83 f8 08          	cmp    $0x8,%rax
  80042113e5:	74 1c                	je     8004211403 <_dwarf_attr_init+0x5d3>
  80042113e7:	48 83 f8 0e          	cmp    $0xe,%rax
  80042113eb:	74 02                	je     80042113ef <_dwarf_attr_init+0x5bf>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  80042113ed:	eb 27                	jmp    8004211416 <_dwarf_attr_init+0x5e6>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  80042113ef:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042113f3:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042113fa:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  8004211401:	eb 13                	jmp    8004211416 <_dwarf_attr_init+0x5e6>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  8004211403:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211407:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800421140e:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  8004211415:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  8004211416:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800421141d:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004211424:	8d 48 01             	lea    0x1(%rax),%ecx
  8004211427:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  800421142e:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  8004211434:	0f b6 c0             	movzbl %al,%eax
  8004211437:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800421143e:	48 63 d0             	movslq %eax,%rdx
  8004211441:	48 89 d0             	mov    %rdx,%rax
  8004211444:	48 01 c0             	add    %rax,%rax
  8004211447:	48 01 d0             	add    %rdx,%rax
  800421144a:	48 c1 e0 05          	shl    $0x5,%rax
  800421144e:	48 01 c8             	add    %rcx,%rax
  8004211451:	48 05 70 03 00 00    	add    $0x370,%rax
  8004211457:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421145e:	48 89 10             	mov    %rdx,(%rax)
  8004211461:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004211468:	48 89 50 08          	mov    %rdx,0x8(%rax)
  800421146c:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004211470:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004211474:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004211478:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421147c:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004211480:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004211484:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211488:	48 89 50 28          	mov    %rdx,0x28(%rax)
  800421148c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211490:	48 89 50 30          	mov    %rdx,0x30(%rax)
  8004211494:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004211498:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800421149c:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042114a0:	48 89 50 40          	mov    %rdx,0x40(%rax)
  80042114a4:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042114a8:	48 89 50 48          	mov    %rdx,0x48(%rax)
  80042114ac:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042114b0:	48 89 50 50          	mov    %rdx,0x50(%rax)
  80042114b4:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042114b8:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  80042114bc:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042114bf:	c9                   	leaveq 
  80042114c0:	c3                   	retq   

00000080042114c1 <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  80042114c1:	55                   	push   %rbp
  80042114c2:	48 89 e5             	mov    %rsp,%rbp
  80042114c5:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  80042114cc:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  80042114d3:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  80042114da:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  80042114e1:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  80042114e7:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  80042114ee:	00 
  80042114ef:	75 35                	jne    8004211526 <dwarf_search_die_within_cu+0x65>
  80042114f1:	48 b9 b8 a4 21 04 80 	movabs $0x800421a4b8,%rcx
  80042114f8:	00 00 00 
  80042114fb:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  8004211502:	00 00 00 
  8004211505:	be 86 02 00 00       	mov    $0x286,%esi
  800421150a:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004211511:	00 00 00 
  8004211514:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211519:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004211520:	00 00 00 
  8004211523:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  8004211526:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  800421152d:	00 
  800421152e:	75 35                	jne    8004211565 <dwarf_search_die_within_cu+0xa4>
  8004211530:	48 b9 bc a4 21 04 80 	movabs $0x800421a4bc,%rcx
  8004211537:	00 00 00 
  800421153a:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  8004211541:	00 00 00 
  8004211544:	be 88 02 00 00       	mov    $0x288,%esi
  8004211549:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004211550:	00 00 00 
  8004211553:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211558:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800421155f:	00 00 00 
  8004211562:	41 ff d0             	callq  *%r8

	level = 1;
  8004211565:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  800421156c:	e9 17 02 00 00       	jmpq   8004211788 <dwarf_search_die_within_cu+0x2c7>

		die_offset = offset;
  8004211571:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004211578:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  800421157c:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004211583:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211587:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  800421158e:	48 89 d6             	mov    %rdx,%rsi
  8004211591:	48 89 c7             	mov    %rax,%rdi
  8004211594:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  800421159b:	00 00 00 
  800421159e:	ff d0                	callq  *%rax
  80042115a0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  80042115a4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042115a9:	75 22                	jne    80042115cd <dwarf_search_die_within_cu+0x10c>
			if (level == 0 || !search_sibling) {
  80042115ab:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042115af:	74 09                	je     80042115ba <dwarf_search_die_within_cu+0xf9>
  80042115b1:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  80042115b8:	75 0a                	jne    80042115c4 <dwarf_search_die_within_cu+0x103>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  80042115ba:	b8 04 00 00 00       	mov    $0x4,%eax
  80042115bf:	e9 f4 01 00 00       	jmpq   80042117b8 <dwarf_search_die_within_cu+0x2f7>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  80042115c4:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  80042115c8:	e9 bb 01 00 00       	jmpq   8004211788 <dwarf_search_die_within_cu+0x2c7>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  80042115cd:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  80042115d4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042115d8:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042115df:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  80042115e3:	48 89 34 24          	mov    %rsi,(%rsp)
  80042115e7:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  80042115eb:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  80042115f0:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  80042115f4:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  80042115f9:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  80042115fd:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  8004211602:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  8004211606:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  800421160b:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  800421160f:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  8004211614:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  8004211618:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  800421161d:	48 89 ce             	mov    %rcx,%rsi
  8004211620:	48 89 c7             	mov    %rax,%rdi
  8004211623:	48 b8 ff 0c 21 04 80 	movabs $0x8004210cff,%rax
  800421162a:	00 00 00 
  800421162d:	ff d0                	callq  *%rax
  800421162f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004211632:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211636:	74 08                	je     8004211640 <dwarf_search_die_within_cu+0x17f>
			return (ret);
  8004211638:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421163b:	e9 78 01 00 00       	jmpq   80042117b8 <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_offset = die_offset;
  8004211640:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211647:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421164b:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  800421164e:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211655:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211659:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  800421165d:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211664:	48 8d 78 20          	lea    0x20(%rax),%rdi
  8004211668:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  800421166f:	b8 66 00 00 00       	mov    $0x66,%eax
  8004211674:	48 89 d6             	mov    %rdx,%rsi
  8004211677:	48 89 c1             	mov    %rax,%rcx
  800421167a:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  800421167d:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211684:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  800421168b:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  8004211692:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211699:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  800421169d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042116a4:	e9 8e 00 00 00       	jmpq   8004211737 <dwarf_search_die_within_cu+0x276>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  80042116a9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042116ac:	48 63 d0             	movslq %eax,%rdx
  80042116af:	48 89 d0             	mov    %rdx,%rax
  80042116b2:	48 01 c0             	add    %rax,%rax
  80042116b5:	48 01 d0             	add    %rdx,%rax
  80042116b8:	48 c1 e0 03          	shl    $0x3,%rax
  80042116bc:	48 01 e8             	add    %rbp,%rax
  80042116bf:	48 2d 18 03 00 00    	sub    $0x318,%rax
  80042116c5:	48 8b 08             	mov    (%rax),%rcx
  80042116c8:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  80042116cf:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042116d2:	48 63 d0             	movslq %eax,%rdx
  80042116d5:	48 89 d0             	mov    %rdx,%rax
  80042116d8:	48 01 c0             	add    %rax,%rax
  80042116db:	48 01 d0             	add    %rdx,%rax
  80042116de:	48 c1 e0 03          	shl    $0x3,%rax
  80042116e2:	48 83 c0 30          	add    $0x30,%rax
  80042116e6:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  80042116ea:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  80042116f1:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  80042116f8:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042116ff:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  8004211706:	49 89 c9             	mov    %rcx,%r9
  8004211709:	49 89 f8             	mov    %rdi,%r8
  800421170c:	48 89 d1             	mov    %rdx,%rcx
  800421170f:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  8004211713:	48 89 c7             	mov    %rax,%rdi
  8004211716:	48 b8 30 0e 21 04 80 	movabs $0x8004210e30,%rax
  800421171d:	00 00 00 
  8004211720:	ff d0                	callq  *%rax
  8004211722:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004211725:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211729:	74 08                	je     8004211733 <dwarf_search_die_within_cu+0x272>
				return (ret);
  800421172b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421172e:	e9 85 00 00 00       	jmpq   80042117b8 <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004211733:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004211737:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421173a:	48 63 d0             	movslq %eax,%rdx
  800421173d:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004211744:	48 39 c2             	cmp    %rax,%rdx
  8004211747:	0f 82 5c ff ff ff    	jb     80042116a9 <dwarf_search_die_within_cu+0x1e8>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  800421174d:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  8004211754:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421175b:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  800421175f:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004211766:	74 19                	je     8004211781 <dwarf_search_die_within_cu+0x2c0>
  8004211768:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421176c:	7e 13                	jle    8004211781 <dwarf_search_die_within_cu+0x2c0>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  800421176e:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  8004211775:	3c 01                	cmp    $0x1,%al
  8004211777:	75 06                	jne    800421177f <dwarf_search_die_within_cu+0x2be>
				/* Advance to next DIE level. */
				level++;
  8004211779:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  800421177d:	eb 09                	jmp    8004211788 <dwarf_search_die_within_cu+0x2c7>
  800421177f:	eb 07                	jmp    8004211788 <dwarf_search_die_within_cu+0x2c7>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  8004211781:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211786:	eb 30                	jmp    80042117b8 <dwarf_search_die_within_cu+0x2f7>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004211788:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  800421178c:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004211793:	48 39 c2             	cmp    %rax,%rdx
  8004211796:	76 1b                	jbe    80042117b3 <dwarf_search_die_within_cu+0x2f2>
  8004211798:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800421179f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042117a3:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042117aa:	48 39 c2             	cmp    %rax,%rdx
  80042117ad:	0f 87 be fd ff ff    	ja     8004211571 <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  80042117b3:	b8 04 00 00 00       	mov    $0x4,%eax
}
  80042117b8:	c9                   	leaveq 
  80042117b9:	c3                   	retq   

00000080042117ba <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  80042117ba:	55                   	push   %rbp
  80042117bb:	48 89 e5             	mov    %rsp,%rbp
  80042117be:	48 83 ec 60          	sub    $0x60,%rsp
  80042117c2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042117c6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042117ca:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  80042117ce:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042117d3:	75 35                	jne    800421180a <dwarf_offdie+0x50>
  80042117d5:	48 b9 b8 a4 21 04 80 	movabs $0x800421a4b8,%rcx
  80042117dc:	00 00 00 
  80042117df:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  80042117e6:	00 00 00 
  80042117e9:	be c4 02 00 00       	mov    $0x2c4,%esi
  80042117ee:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  80042117f5:	00 00 00 
  80042117f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042117fd:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004211804:	00 00 00 
  8004211807:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800421180a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421180f:	75 35                	jne    8004211846 <dwarf_offdie+0x8c>
  8004211811:	48 b9 bc a4 21 04 80 	movabs $0x800421a4bc,%rcx
  8004211818:	00 00 00 
  800421181b:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  8004211822:	00 00 00 
  8004211825:	be c5 02 00 00       	mov    $0x2c5,%esi
  800421182a:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004211831:	00 00 00 
  8004211834:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211839:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004211840:	00 00 00 
  8004211843:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004211846:	48 8b 45 30          	mov    0x30(%rbp),%rax
  800421184a:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421184e:	76 66                	jbe    80042118b6 <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  8004211850:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211854:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004211858:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421185c:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  8004211860:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004211864:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  8004211868:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800421186d:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  8004211871:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004211876:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421187a:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  800421187f:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  8004211883:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004211888:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  800421188c:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004211891:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  8004211895:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  800421189a:	b9 00 00 00 00       	mov    $0x0,%ecx
  800421189f:	48 89 c7             	mov    %rax,%rdi
  80042118a2:	48 b8 c1 14 21 04 80 	movabs $0x80042114c1,%rax
  80042118a9:	00 00 00 
  80042118ac:	ff d0                	callq  *%rax
  80042118ae:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  80042118b1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042118b4:	eb 05                	jmp    80042118bb <dwarf_offdie+0x101>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  80042118b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042118bb:	c9                   	leaveq 
  80042118bc:	c3                   	retq   

00000080042118bd <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  80042118bd:	55                   	push   %rbp
  80042118be:	48 89 e5             	mov    %rsp,%rbp
  80042118c1:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042118c5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042118c9:	89 f0                	mov    %esi,%eax
  80042118cb:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  80042118cf:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042118d6:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  80042118d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042118de:	eb 57                	jmp    8004211937 <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  80042118e0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042118e4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042118e7:	48 63 d0             	movslq %eax,%rdx
  80042118ea:	48 89 d0             	mov    %rdx,%rax
  80042118ed:	48 01 c0             	add    %rax,%rax
  80042118f0:	48 01 d0             	add    %rdx,%rax
  80042118f3:	48 c1 e0 05          	shl    $0x5,%rax
  80042118f7:	48 01 c8             	add    %rcx,%rax
  80042118fa:	48 05 80 03 00 00    	add    $0x380,%rax
  8004211900:	48 8b 10             	mov    (%rax),%rdx
  8004211903:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  8004211907:	48 39 c2             	cmp    %rax,%rdx
  800421190a:	75 27                	jne    8004211933 <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  800421190c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421190f:	48 63 d0             	movslq %eax,%rdx
  8004211912:	48 89 d0             	mov    %rdx,%rax
  8004211915:	48 01 c0             	add    %rax,%rax
  8004211918:	48 01 d0             	add    %rdx,%rax
  800421191b:	48 c1 e0 05          	shl    $0x5,%rax
  800421191f:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004211926:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421192a:	48 01 d0             	add    %rdx,%rax
  800421192d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004211931:	eb 17                	jmp    800421194a <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004211933:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004211937:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421193b:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004211942:	0f b6 c0             	movzbl %al,%eax
  8004211945:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004211948:	7f 96                	jg     80042118e0 <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  800421194a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421194e:	c9                   	leaveq 
  800421194f:	c3                   	retq   

0000008004211950 <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  8004211950:	55                   	push   %rbp
  8004211951:	48 89 e5             	mov    %rsp,%rbp
  8004211954:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004211958:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421195c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211960:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211964:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  8004211968:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421196d:	75 35                	jne    80042119a4 <dwarf_siblingof+0x54>
  800421196f:	48 b9 b8 a4 21 04 80 	movabs $0x800421a4b8,%rcx
  8004211976:	00 00 00 
  8004211979:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  8004211980:	00 00 00 
  8004211983:	be ec 02 00 00       	mov    $0x2ec,%esi
  8004211988:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  800421198f:	00 00 00 
  8004211992:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211997:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800421199e:	00 00 00 
  80042119a1:	41 ff d0             	callq  *%r8
	assert(ret_die);
  80042119a4:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042119a9:	75 35                	jne    80042119e0 <dwarf_siblingof+0x90>
  80042119ab:	48 b9 bc a4 21 04 80 	movabs $0x800421a4bc,%rcx
  80042119b2:	00 00 00 
  80042119b5:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  80042119bc:	00 00 00 
  80042119bf:	be ed 02 00 00       	mov    $0x2ed,%esi
  80042119c4:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  80042119cb:	00 00 00 
  80042119ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042119d3:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042119da:	00 00 00 
  80042119dd:	41 ff d0             	callq  *%r8
	assert(cu);
  80042119e0:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042119e5:	75 35                	jne    8004211a1c <dwarf_siblingof+0xcc>
  80042119e7:	48 b9 c4 a4 21 04 80 	movabs $0x800421a4c4,%rcx
  80042119ee:	00 00 00 
  80042119f1:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  80042119f8:	00 00 00 
  80042119fb:	be ee 02 00 00       	mov    $0x2ee,%esi
  8004211a00:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004211a07:	00 00 00 
  8004211a0a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211a0f:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004211a16:	00 00 00 
  8004211a19:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  8004211a1c:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211a21:	75 65                	jne    8004211a88 <dwarf_siblingof+0x138>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  8004211a23:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211a27:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004211a2b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211a2f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004211a33:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211a37:	48 8b 38             	mov    (%rax),%rdi
  8004211a3a:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004211a3e:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004211a42:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004211a47:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8004211a4b:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004211a50:	48 8b 78 18          	mov    0x18(%rax),%rdi
  8004211a54:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004211a59:	48 8b 78 20          	mov    0x20(%rax),%rdi
  8004211a5d:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004211a62:	48 8b 78 28          	mov    0x28(%rax),%rdi
  8004211a66:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004211a6b:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211a6f:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211a74:	48 89 cf             	mov    %rcx,%rdi
  8004211a77:	48 b8 ba 17 21 04 80 	movabs $0x80042117ba,%rax
  8004211a7e:	00 00 00 
  8004211a81:	ff d0                	callq  *%rax
  8004211a83:	e9 0a 01 00 00       	jmpq   8004211b92 <dwarf_siblingof+0x242>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  8004211a88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004211a8f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211a93:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004211a97:	84 c0                	test   %al,%al
  8004211a99:	75 0e                	jne    8004211aa9 <dwarf_siblingof+0x159>
		offset = die->die_next_off;
  8004211a9b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211a9f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211aa3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211aa7:	eb 6b                	jmp    8004211b14 <dwarf_siblingof+0x1c4>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  8004211aa9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211aad:	be 01 00 00 00       	mov    $0x1,%esi
  8004211ab2:	48 89 c7             	mov    %rax,%rdi
  8004211ab5:	48 b8 bd 18 21 04 80 	movabs $0x80042118bd,%rax
  8004211abc:	00 00 00 
  8004211abf:	ff d0                	callq  *%rax
  8004211ac1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004211ac5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211aca:	74 35                	je     8004211b01 <dwarf_siblingof+0x1b1>
			if (at->at_form != DW_FORM_ref_addr)
  8004211acc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ad0:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211ad4:	48 83 f8 10          	cmp    $0x10,%rax
  8004211ad8:	74 19                	je     8004211af3 <dwarf_siblingof+0x1a3>
				offset = at->u[0].u64 + cu->cu_offset;
  8004211ada:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ade:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004211ae2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211ae6:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211aea:	48 01 d0             	add    %rdx,%rax
  8004211aed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211af1:	eb 21                	jmp    8004211b14 <dwarf_siblingof+0x1c4>
			else
				offset = at->u[0].u64;
  8004211af3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211af7:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211afb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211aff:	eb 13                	jmp    8004211b14 <dwarf_siblingof+0x1c4>
		} else {
			offset = die->die_next_off;
  8004211b01:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211b05:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211b09:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  8004211b0d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  8004211b14:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004211b17:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211b1b:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004211b1f:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8004211b23:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211b27:	4c 8b 00             	mov    (%rax),%r8
  8004211b2a:	4c 89 04 24          	mov    %r8,(%rsp)
  8004211b2e:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004211b32:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004211b37:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004211b3b:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004211b40:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211b44:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004211b49:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004211b4d:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  8004211b52:	4c 8b 40 28          	mov    0x28(%rax),%r8
  8004211b56:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  8004211b5b:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211b5f:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211b64:	48 b8 c1 14 21 04 80 	movabs $0x80042114c1,%rax
  8004211b6b:	00 00 00 
  8004211b6e:	ff d0                	callq  *%rax
  8004211b70:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  8004211b73:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  8004211b77:	75 07                	jne    8004211b80 <dwarf_siblingof+0x230>
		return (DW_DLV_NO_ENTRY);
  8004211b79:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211b7e:	eb 12                	jmp    8004211b92 <dwarf_siblingof+0x242>
	} else if (ret != DW_DLE_NONE)
  8004211b80:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211b84:	74 07                	je     8004211b8d <dwarf_siblingof+0x23d>
		return (DW_DLV_ERROR);
  8004211b86:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211b8b:	eb 05                	jmp    8004211b92 <dwarf_siblingof+0x242>


	return (DW_DLV_OK);
  8004211b8d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211b92:	c9                   	leaveq 
  8004211b93:	c3                   	retq   

0000008004211b94 <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  8004211b94:	55                   	push   %rbp
  8004211b95:	48 89 e5             	mov    %rsp,%rbp
  8004211b98:	48 83 ec 70          	sub    $0x70,%rsp
  8004211b9c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211ba0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211ba4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211ba8:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  8004211bac:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211bb1:	75 35                	jne    8004211be8 <dwarf_child+0x54>
  8004211bb3:	48 b9 c7 a4 21 04 80 	movabs $0x800421a4c7,%rcx
  8004211bba:	00 00 00 
  8004211bbd:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  8004211bc4:	00 00 00 
  8004211bc7:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004211bcc:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004211bd3:	00 00 00 
  8004211bd6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211bdb:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004211be2:	00 00 00 
  8004211be5:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004211be8:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211bed:	75 35                	jne    8004211c24 <dwarf_child+0x90>
  8004211bef:	48 b9 bc a4 21 04 80 	movabs $0x800421a4bc,%rcx
  8004211bf6:	00 00 00 
  8004211bf9:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  8004211c00:	00 00 00 
  8004211c03:	be 1d 03 00 00       	mov    $0x31d,%esi
  8004211c08:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004211c0f:	00 00 00 
  8004211c12:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211c17:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004211c1e:	00 00 00 
  8004211c21:	41 ff d0             	callq  *%r8
	assert(dbg);
  8004211c24:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211c29:	75 35                	jne    8004211c60 <dwarf_child+0xcc>
  8004211c2b:	48 b9 b8 a4 21 04 80 	movabs $0x800421a4b8,%rcx
  8004211c32:	00 00 00 
  8004211c35:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  8004211c3c:	00 00 00 
  8004211c3f:	be 1e 03 00 00       	mov    $0x31e,%esi
  8004211c44:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004211c4b:	00 00 00 
  8004211c4e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211c53:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004211c5a:	00 00 00 
  8004211c5d:	41 ff d0             	callq  *%r8
	assert(cu);
  8004211c60:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004211c65:	75 35                	jne    8004211c9c <dwarf_child+0x108>
  8004211c67:	48 b9 c4 a4 21 04 80 	movabs $0x800421a4c4,%rcx
  8004211c6e:	00 00 00 
  8004211c71:	48 ba 2a a3 21 04 80 	movabs $0x800421a32a,%rdx
  8004211c78:	00 00 00 
  8004211c7b:	be 1f 03 00 00       	mov    $0x31f,%esi
  8004211c80:	48 bf 3f a3 21 04 80 	movabs $0x800421a33f,%rdi
  8004211c87:	00 00 00 
  8004211c8a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211c8f:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004211c96:	00 00 00 
  8004211c99:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004211c9c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211ca0:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004211ca4:	84 c0                	test   %al,%al
  8004211ca6:	75 0a                	jne    8004211cb2 <dwarf_child+0x11e>
		return (DW_DLE_NO_ENTRY);
  8004211ca8:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211cad:	e9 84 00 00 00       	jmpq   8004211d36 <dwarf_child+0x1a2>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  8004211cb2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211cb6:	48 8b 70 08          	mov    0x8(%rax),%rsi
  8004211cba:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211cbe:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8004211cc2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211cc6:	48 8b 08             	mov    (%rax),%rcx
  8004211cc9:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004211ccd:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004211cd1:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004211cd6:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004211cda:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004211cdf:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004211ce3:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004211ce8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211cec:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004211cf1:	48 8b 48 28          	mov    0x28(%rax),%rcx
  8004211cf5:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004211cfa:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211cfe:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211d03:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004211d08:	48 b8 c1 14 21 04 80 	movabs $0x80042114c1,%rax
  8004211d0f:	00 00 00 
  8004211d12:	ff d0                	callq  *%rax
  8004211d14:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  8004211d17:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004211d1b:	75 07                	jne    8004211d24 <dwarf_child+0x190>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004211d1d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211d22:	eb 12                	jmp    8004211d36 <dwarf_child+0x1a2>
	} else if (ret != DW_DLE_NONE)
  8004211d24:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211d28:	74 07                	je     8004211d31 <dwarf_child+0x19d>
		return (DW_DLV_ERROR);
  8004211d2a:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211d2f:	eb 05                	jmp    8004211d36 <dwarf_child+0x1a2>

	return (DW_DLV_OK);
  8004211d31:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211d36:	c9                   	leaveq 
  8004211d37:	c3                   	retq   

0000008004211d38 <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004211d38:	55                   	push   %rbp
  8004211d39:	48 89 e5             	mov    %rsp,%rbp
  8004211d3c:	48 83 ec 20          	sub    $0x20,%rsp
  8004211d40:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  8004211d44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d48:	48 8b 00             	mov    (%rax),%rax
  8004211d4b:	48 89 c7             	mov    %rax,%rdi
  8004211d4e:	48 b8 5f 50 21 04 80 	movabs $0x800421505f,%rax
  8004211d55:	00 00 00 
  8004211d58:	ff d0                	callq  *%rax
  8004211d5a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  8004211d5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211d62:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211d66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d6a:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  8004211d6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211d72:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211d76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d7a:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  8004211d7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211d82:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211d86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d8a:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  8004211d8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211d93:	c9                   	leaveq 
  8004211d94:	c3                   	retq   

0000008004211d95 <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  8004211d95:	55                   	push   %rbp
  8004211d96:	48 89 e5             	mov    %rsp,%rbp
  8004211d99:	48 83 ec 08          	sub    $0x8,%rsp
  8004211d9d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	/* Initialise call frame related parameters. */
	dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  8004211da1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211da5:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
	dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  8004211dab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211daf:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
	dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  8004211db5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211db9:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
	dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004211dbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211dc3:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
	dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  8004211dc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211dcd:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  8004211dd3:	c9                   	leaveq 
  8004211dd4:	c3                   	retq   

0000008004211dd5 <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie,
		    Dwarf_Error *error)
{
  8004211dd5:	55                   	push   %rbp
  8004211dd6:	48 89 e5             	mov    %rsp,%rbp
  8004211dd9:	48 83 ec 40          	sub    $0x40,%rsp
  8004211ddd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211de1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211de5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211de9:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004211ded:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	Dwarf_Fde fde = ret_fde;
  8004211df1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211df5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  8004211df9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211dfd:	ba 80 00 00 00       	mov    $0x80,%edx
  8004211e02:	be 00 00 00 00       	mov    $0x0,%esi
  8004211e07:	48 89 c7             	mov    %rax,%rdi
  8004211e0a:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004211e11:	00 00 00 
  8004211e14:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  8004211e16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e1a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211e1e:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	if (ret_fde == NULL)
  8004211e22:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211e27:	75 07                	jne    8004211e30 <dwarf_get_fde_at_pc+0x5b>
		return (DW_DLV_ERROR);
  8004211e29:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211e2e:	eb 75                	jmp    8004211ea5 <dwarf_get_fde_at_pc+0xd0>

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  8004211e30:	eb 59                	jmp    8004211e8b <dwarf_get_fde_at_pc+0xb6>
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  8004211e32:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004211e36:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211e3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e3e:	be 01 00 00 00       	mov    $0x1,%esi
  8004211e43:	48 89 c7             	mov    %rax,%rdi
  8004211e46:	48 b8 ea 3f 21 04 80 	movabs $0x8004213fea,%rax
  8004211e4d:	00 00 00 
  8004211e50:	ff d0                	callq  *%rax
  8004211e52:	85 c0                	test   %eax,%eax
  8004211e54:	79 07                	jns    8004211e5d <dwarf_get_fde_at_pc+0x88>
		{
			return DW_DLV_NO_ENTRY;
  8004211e56:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211e5b:	eb 48                	jmp    8004211ea5 <dwarf_get_fde_at_pc+0xd0>
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004211e5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e61:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211e65:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211e69:	77 20                	ja     8004211e8b <dwarf_get_fde_at_pc+0xb6>
  8004211e6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e6f:	48 8b 50 30          	mov    0x30(%rax),%rdx
		    fde->fde_adrange)
  8004211e73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e77:	48 8b 40 38          	mov    0x38(%rax),%rax
	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004211e7b:	48 01 d0             	add    %rdx,%rax
  8004211e7e:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211e82:	76 07                	jbe    8004211e8b <dwarf_get_fde_at_pc+0xb6>
		    fde->fde_adrange)
			return (DW_DLV_OK);
  8004211e84:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211e89:	eb 1a                	jmp    8004211ea5 <dwarf_get_fde_at_pc+0xd0>
	fde->fde_cie = cie;
	
	if (ret_fde == NULL)
		return (DW_DLV_ERROR);

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  8004211e8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e8f:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004211e93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e97:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004211e9b:	48 39 c2             	cmp    %rax,%rdx
  8004211e9e:	72 92                	jb     8004211e32 <dwarf_get_fde_at_pc+0x5d>
		    fde->fde_adrange)
			return (DW_DLV_OK);
	}

	DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
	return (DW_DLV_NO_ENTRY);
  8004211ea0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8004211ea5:	c9                   	leaveq 
  8004211ea6:	c3                   	retq   

0000008004211ea7 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  8004211ea7:	55                   	push   %rbp
  8004211ea8:	48 89 e5             	mov    %rsp,%rbp
  8004211eab:	53                   	push   %rbx
  8004211eac:	48 83 ec 38          	sub    $0x38,%rsp
  8004211eb0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211eb4:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211eb8:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211ebc:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	int i;

	assert(dest != NULL);
  8004211ec0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211ec5:	75 35                	jne    8004211efc <_dwarf_frame_regtable_copy+0x55>
  8004211ec7:	48 b9 da a4 21 04 80 	movabs $0x800421a4da,%rcx
  8004211ece:	00 00 00 
  8004211ed1:	48 ba e7 a4 21 04 80 	movabs $0x800421a4e7,%rdx
  8004211ed8:	00 00 00 
  8004211edb:	be 57 00 00 00       	mov    $0x57,%esi
  8004211ee0:	48 bf fc a4 21 04 80 	movabs $0x800421a4fc,%rdi
  8004211ee7:	00 00 00 
  8004211eea:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211eef:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004211ef6:	00 00 00 
  8004211ef9:	41 ff d0             	callq  *%r8
	assert(src != NULL);
  8004211efc:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211f01:	75 35                	jne    8004211f38 <_dwarf_frame_regtable_copy+0x91>
  8004211f03:	48 b9 12 a5 21 04 80 	movabs $0x800421a512,%rcx
  8004211f0a:	00 00 00 
  8004211f0d:	48 ba e7 a4 21 04 80 	movabs $0x800421a4e7,%rdx
  8004211f14:	00 00 00 
  8004211f17:	be 58 00 00 00       	mov    $0x58,%esi
  8004211f1c:	48 bf fc a4 21 04 80 	movabs $0x800421a4fc,%rdi
  8004211f23:	00 00 00 
  8004211f26:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211f2b:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004211f32:	00 00 00 
  8004211f35:	41 ff d0             	callq  *%r8

	if (*dest == NULL) {
  8004211f38:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211f3c:	48 8b 00             	mov    (%rax),%rax
  8004211f3f:	48 85 c0             	test   %rax,%rax
  8004211f42:	75 39                	jne    8004211f7d <_dwarf_frame_regtable_copy+0xd6>
		*dest = &global_rt_table_shadow;
  8004211f44:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211f48:	48 bb 00 87 60 04 80 	movabs $0x8004608700,%rbx
  8004211f4f:	00 00 00 
  8004211f52:	48 89 18             	mov    %rbx,(%rax)
		(*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  8004211f55:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211f59:	48 8b 00             	mov    (%rax),%rax
  8004211f5c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211f60:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  8004211f64:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  8004211f68:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211f6c:	48 8b 00             	mov    (%rax),%rax
  8004211f6f:	48 bb 80 89 60 04 80 	movabs $0x8004608980,%rbx
  8004211f76:	00 00 00 
  8004211f79:	48 89 58 20          	mov    %rbx,0x20(%rax)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  8004211f7d:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004211f81:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211f85:	48 8b 00             	mov    (%rax),%rax
  8004211f88:	ba 18 00 00 00       	mov    $0x18,%edx
  8004211f8d:	48 89 ce             	mov    %rcx,%rsi
  8004211f90:	48 89 c7             	mov    %rax,%rdi
  8004211f93:	48 b8 2a fb 20 04 80 	movabs $0x800420fb2a,%rax
  8004211f9a:	00 00 00 
  8004211f9d:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004211f9f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004211fa6:	eb 5a                	jmp    8004212002 <_dwarf_frame_regtable_copy+0x15b>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  8004211fa8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211fac:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211fb0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211fb3:	48 63 d0             	movslq %eax,%rdx
  8004211fb6:	48 89 d0             	mov    %rdx,%rax
  8004211fb9:	48 01 c0             	add    %rax,%rax
  8004211fbc:	48 01 d0             	add    %rdx,%rax
  8004211fbf:	48 c1 e0 03          	shl    $0x3,%rax
  8004211fc3:	48 01 c1             	add    %rax,%rcx
  8004211fc6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211fca:	48 8b 00             	mov    (%rax),%rax
  8004211fcd:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211fd1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211fd4:	48 63 d0             	movslq %eax,%rdx
  8004211fd7:	48 89 d0             	mov    %rdx,%rax
  8004211fda:	48 01 c0             	add    %rax,%rax
  8004211fdd:	48 01 d0             	add    %rdx,%rax
  8004211fe0:	48 c1 e0 03          	shl    $0x3,%rax
  8004211fe4:	48 01 f0             	add    %rsi,%rax
  8004211fe7:	ba 18 00 00 00       	mov    $0x18,%edx
  8004211fec:	48 89 ce             	mov    %rcx,%rsi
  8004211fef:	48 89 c7             	mov    %rax,%rdi
  8004211ff2:	48 b8 2a fb 20 04 80 	movabs $0x800420fb2a,%rax
  8004211ff9:	00 00 00 
  8004211ffc:	ff d0                	callq  *%rax

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  8004211ffe:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004212002:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212006:	48 8b 00             	mov    (%rax),%rax
  8004212009:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421200d:	0f b7 c0             	movzwl %ax,%eax
  8004212010:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004212013:	7e 10                	jle    8004212025 <_dwarf_frame_regtable_copy+0x17e>
		     i < src->rt3_reg_table_size; i++)
  8004212015:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212019:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421201d:	0f b7 c0             	movzwl %ax,%eax
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004212020:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004212023:	7f 83                	jg     8004211fa8 <_dwarf_frame_regtable_copy+0x101>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  8004212025:	eb 32                	jmp    8004212059 <_dwarf_frame_regtable_copy+0x1b2>
		(*dest)->rt3_rules[i].dw_regnum =
  8004212027:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421202b:	48 8b 00             	mov    (%rax),%rax
  800421202e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212032:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004212035:	48 63 d0             	movslq %eax,%rdx
  8004212038:	48 89 d0             	mov    %rdx,%rax
  800421203b:	48 01 c0             	add    %rax,%rax
  800421203e:	48 01 d0             	add    %rdx,%rax
  8004212041:	48 c1 e0 03          	shl    $0x3,%rax
  8004212045:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  8004212049:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421204d:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
		(*dest)->rt3_rules[i].dw_regnum =
  8004212051:	66 89 42 02          	mov    %ax,0x2(%rdx)
	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  8004212055:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004212059:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421205d:	48 8b 00             	mov    (%rax),%rax
  8004212060:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212064:	0f b7 c0             	movzwl %ax,%eax
  8004212067:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421206a:	7f bb                	jg     8004212027 <_dwarf_frame_regtable_copy+0x180>
		(*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

	return (DW_DLE_NONE);
  800421206c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212071:	48 83 c4 38          	add    $0x38,%rsp
  8004212075:	5b                   	pop    %rbx
  8004212076:	5d                   	pop    %rbp
  8004212077:	c3                   	retq   

0000008004212078 <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004212078:	55                   	push   %rbp
  8004212079:	48 89 e5             	mov    %rsp,%rbp
  800421207c:	53                   	push   %rbx
  800421207d:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  8004212084:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004212088:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  800421208c:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004212090:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004212094:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  800421209b:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
			ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
			goto program_done;                              \
		}                                                       \
	} while(0)

	ret = DW_DLE_NONE;
  80042120a2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	init_rt = saved_rt = NULL;
  80042120a9:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80042120b0:	00 
  80042120b1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042120b5:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	*row_pc = pc;
  80042120b9:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042120bd:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042120c1:	48 89 10             	mov    %rdx,(%rax)

	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  80042120c4:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042120c8:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042120cc:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  80042120d0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042120d4:	48 89 c7             	mov    %rax,%rdi
  80042120d7:	48 b8 a7 1e 21 04 80 	movabs $0x8004211ea7,%rax
  80042120de:	00 00 00 
  80042120e1:	ff d0                	callq  *%rax
	p = insts;
  80042120e3:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042120e7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	pe = p + len;
  80042120eb:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042120ef:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042120f3:	48 01 d0             	add    %rdx,%rax
  80042120f6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	while (p < pe) {
  80042120fa:	e9 3a 0d 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		if (*p == DW_CFA_nop) {
  80042120ff:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212103:	0f b6 00             	movzbl (%rax),%eax
  8004212106:	84 c0                	test   %al,%al
  8004212108:	75 11                	jne    800421211b <_dwarf_frame_run_inst+0xa3>
			p++;
  800421210a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421210e:	48 83 c0 01          	add    $0x1,%rax
  8004212112:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			continue;
  8004212116:	e9 1e 0d 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		}

		high2 = *p & 0xc0;
  800421211b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421211f:	0f b6 00             	movzbl (%rax),%eax
  8004212122:	83 e0 c0             	and    $0xffffffc0,%eax
  8004212125:	88 45 df             	mov    %al,-0x21(%rbp)
		low6 = *p & 0x3f;
  8004212128:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421212c:	0f b6 00             	movzbl (%rax),%eax
  800421212f:	83 e0 3f             	and    $0x3f,%eax
  8004212132:	88 45 de             	mov    %al,-0x22(%rbp)
		p++;
  8004212135:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212139:	48 83 c0 01          	add    $0x1,%rax
  800421213d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

		if (high2 > 0) {
  8004212141:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  8004212145:	0f 84 a1 01 00 00    	je     80042122ec <_dwarf_frame_run_inst+0x274>
			switch (high2) {
  800421214b:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800421214f:	3d 80 00 00 00       	cmp    $0x80,%eax
  8004212154:	74 38                	je     800421218e <_dwarf_frame_run_inst+0x116>
  8004212156:	3d c0 00 00 00       	cmp    $0xc0,%eax
  800421215b:	0f 84 01 01 00 00    	je     8004212262 <_dwarf_frame_run_inst+0x1ea>
  8004212161:	83 f8 40             	cmp    $0x40,%eax
  8004212164:	0f 85 71 01 00 00    	jne    80042122db <_dwarf_frame_run_inst+0x263>
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
  800421216a:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  800421216e:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212175:	ff 
  8004212176:	48 01 45 10          	add    %rax,0x10(%rbp)
			        if (pc_req < pc)
  800421217a:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421217e:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212182:	73 05                	jae    8004212189 <_dwarf_frame_run_inst+0x111>
			                goto program_done;
  8004212184:	e9 be 0c 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			        break;
  8004212189:	e9 59 01 00 00       	jmpq   80042122e7 <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_offset:
			        *row_pc = pc;
  800421218e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212192:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212196:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  8004212199:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421219d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042121a1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042121a5:	66 39 c2             	cmp    %ax,%dx
  80042121a8:	72 0c                	jb     80042121b6 <_dwarf_frame_run_inst+0x13e>
  80042121aa:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042121b1:	e9 91 0c 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			        RL[low6].dw_offset_relevant = 1;
  80042121b6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042121ba:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042121be:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042121c2:	48 89 d0             	mov    %rdx,%rax
  80042121c5:	48 01 c0             	add    %rax,%rax
  80042121c8:	48 01 d0             	add    %rdx,%rax
  80042121cb:	48 c1 e0 03          	shl    $0x3,%rax
  80042121cf:	48 01 c8             	add    %rcx,%rax
  80042121d2:	c6 00 01             	movb   $0x1,(%rax)
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
  80042121d5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042121d9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042121dd:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042121e1:	48 89 d0             	mov    %rdx,%rax
  80042121e4:	48 01 c0             	add    %rax,%rax
  80042121e7:	48 01 d0             	add    %rdx,%rax
  80042121ea:	48 c1 e0 03          	shl    $0x3,%rax
  80042121ee:	48 01 c8             	add    %rcx,%rax
  80042121f1:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  80042121f5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042121f9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042121fd:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212201:	48 89 d0             	mov    %rdx,%rax
  8004212204:	48 01 c0             	add    %rax,%rax
  8004212207:	48 01 d0             	add    %rdx,%rax
  800421220a:	48 c1 e0 03          	shl    $0x3,%rax
  800421220e:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212212:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212216:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800421221a:	66 89 42 02          	mov    %ax,0x2(%rdx)
			        RL[low6].dw_offset_or_block_len =
  800421221e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212222:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212226:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421222a:	48 89 d0             	mov    %rdx,%rax
  800421222d:	48 01 c0             	add    %rax,%rax
  8004212230:	48 01 d0             	add    %rdx,%rax
  8004212233:	48 c1 e0 03          	shl    $0x3,%rax
  8004212237:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  800421223b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421223f:	48 89 c7             	mov    %rax,%rdi
  8004212242:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212249:	00 00 00 
  800421224c:	ff d0                	callq  *%rax
  800421224e:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212255:	48 0f af c2          	imul   %rdx,%rax
			        *row_pc = pc;
			        CHECK_TABLE_SIZE(low6);
			        RL[low6].dw_offset_relevant = 1;
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
			        RL[low6].dw_offset_or_block_len =
  8004212259:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
			        break;
  800421225d:	e9 85 00 00 00       	jmpq   80042122e7 <_dwarf_frame_run_inst+0x26f>
			case DW_CFA_restore:
			        *row_pc = pc;
  8004212262:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212266:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421226a:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  800421226d:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212271:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212275:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212279:	66 39 c2             	cmp    %ax,%dx
  800421227c:	72 0c                	jb     800421228a <_dwarf_frame_run_inst+0x212>
  800421227e:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212285:	e9 bd 0b 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			        memcpy(&RL[low6], &INITRL[low6],
  800421228a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421228e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212292:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212296:	48 89 d0             	mov    %rdx,%rax
  8004212299:	48 01 c0             	add    %rax,%rax
  800421229c:	48 01 d0             	add    %rdx,%rax
  800421229f:	48 c1 e0 03          	shl    $0x3,%rax
  80042122a3:	48 01 c1             	add    %rax,%rcx
  80042122a6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042122aa:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042122ae:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042122b2:	48 89 d0             	mov    %rdx,%rax
  80042122b5:	48 01 c0             	add    %rax,%rax
  80042122b8:	48 01 d0             	add    %rdx,%rax
  80042122bb:	48 c1 e0 03          	shl    $0x3,%rax
  80042122bf:	48 01 f0             	add    %rsi,%rax
  80042122c2:	ba 18 00 00 00       	mov    $0x18,%edx
  80042122c7:	48 89 ce             	mov    %rcx,%rsi
  80042122ca:	48 89 c7             	mov    %rax,%rdi
  80042122cd:	48 b8 2a fb 20 04 80 	movabs $0x800420fb2a,%rax
  80042122d4:	00 00 00 
  80042122d7:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
			        break;
  80042122d9:	eb 0c                	jmp    80042122e7 <_dwarf_frame_run_inst+0x26f>
			default:
			        DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  80042122db:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			        goto program_done;
  80042122e2:	e9 60 0b 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			}

			continue;
  80042122e7:	e9 4d 0b 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		}

		switch (low6) {
  80042122ec:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  80042122f0:	83 f8 16             	cmp    $0x16,%eax
  80042122f3:	0f 87 37 0b 00 00    	ja     8004212e30 <_dwarf_frame_run_inst+0xdb8>
  80042122f9:	89 c0                	mov    %eax,%eax
  80042122fb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004212302:	00 
  8004212303:	48 b8 20 a5 21 04 80 	movabs $0x800421a520,%rax
  800421230a:	00 00 00 
  800421230d:	48 01 d0             	add    %rdx,%rax
  8004212310:	48 8b 00             	mov    (%rax),%rax
  8004212313:	ff e0                	jmpq   *%rax
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
  8004212315:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212319:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421231d:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004212321:	8b 4a 28             	mov    0x28(%rdx),%ecx
  8004212324:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212328:	89 ce                	mov    %ecx,%esi
  800421232a:	48 89 d7             	mov    %rdx,%rdi
  800421232d:	ff d0                	callq  *%rax
  800421232f:	48 89 45 10          	mov    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004212333:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212337:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421233b:	73 05                	jae    8004212342 <_dwarf_frame_run_inst+0x2ca>
			        goto program_done;
  800421233d:	e9 05 0b 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			break;
  8004212342:	e9 f2 0a 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
  8004212347:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421234b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421234f:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212353:	be 01 00 00 00       	mov    $0x1,%esi
  8004212358:	48 89 d7             	mov    %rdx,%rdi
  800421235b:	ff d0                	callq  *%rax
  800421235d:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212364:	ff 
  8004212365:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004212369:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421236d:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212371:	73 05                	jae    8004212378 <_dwarf_frame_run_inst+0x300>
			        goto program_done;
  8004212373:	e9 cf 0a 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			break;
  8004212378:	e9 bc 0a 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
  800421237d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212381:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212385:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212389:	be 02 00 00 00       	mov    $0x2,%esi
  800421238e:	48 89 d7             	mov    %rdx,%rdi
  8004212391:	ff d0                	callq  *%rax
  8004212393:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800421239a:	ff 
  800421239b:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  800421239f:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042123a3:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042123a7:	73 05                	jae    80042123ae <_dwarf_frame_run_inst+0x336>
			        goto program_done;
  80042123a9:	e9 99 0a 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			break;
  80042123ae:	e9 86 0a 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
  80042123b3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042123b7:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042123bb:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042123bf:	be 04 00 00 00       	mov    $0x4,%esi
  80042123c4:	48 89 d7             	mov    %rdx,%rdi
  80042123c7:	ff d0                	callq  *%rax
  80042123c9:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042123d0:	ff 
  80042123d1:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  80042123d5:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042123d9:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042123dd:	73 05                	jae    80042123e4 <_dwarf_frame_run_inst+0x36c>
			        goto program_done;
  80042123df:	e9 63 0a 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			break;
  80042123e4:	e9 50 0a 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended:
			*row_pc = pc;
  80042123e9:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042123ed:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042123f1:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042123f4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042123f8:	48 89 c7             	mov    %rax,%rdi
  80042123fb:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212402:	00 00 00 
  8004212405:	ff d0                	callq  *%rax
  8004212407:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  800421240b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421240f:	48 89 c7             	mov    %rax,%rdi
  8004212412:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212419:	00 00 00 
  800421241c:	ff d0                	callq  *%rax
  800421241e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004212422:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212426:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421242a:	0f b7 c0             	movzwl %ax,%eax
  800421242d:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212431:	77 0c                	ja     800421243f <_dwarf_frame_run_inst+0x3c7>
  8004212433:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421243a:	e9 08 0a 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  800421243f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212443:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212447:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421244b:	48 89 d0             	mov    %rdx,%rax
  800421244e:	48 01 c0             	add    %rax,%rax
  8004212451:	48 01 d0             	add    %rdx,%rax
  8004212454:	48 c1 e0 03          	shl    $0x3,%rax
  8004212458:	48 01 c8             	add    %rcx,%rax
  800421245b:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  800421245e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212462:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212466:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421246a:	48 89 d0             	mov    %rdx,%rax
  800421246d:	48 01 c0             	add    %rax,%rax
  8004212470:	48 01 d0             	add    %rdx,%rax
  8004212473:	48 c1 e0 03          	shl    $0x3,%rax
  8004212477:	48 01 c8             	add    %rcx,%rax
  800421247a:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800421247e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212482:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212486:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421248a:	48 89 d0             	mov    %rdx,%rax
  800421248d:	48 01 c0             	add    %rax,%rax
  8004212490:	48 01 d0             	add    %rdx,%rax
  8004212493:	48 c1 e0 03          	shl    $0x3,%rax
  8004212497:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421249b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421249f:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042124a3:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  80042124a7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042124ab:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042124af:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042124b3:	48 89 d0             	mov    %rdx,%rax
  80042124b6:	48 01 c0             	add    %rax,%rax
  80042124b9:	48 01 d0             	add    %rdx,%rax
  80042124bc:	48 c1 e0 03          	shl    $0x3,%rax
  80042124c0:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042124c4:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042124cb:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  80042124d0:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  80042124d4:	e9 60 09 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_extended:
			*row_pc = pc;
  80042124d9:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042124dd:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042124e1:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042124e4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042124e8:	48 89 c7             	mov    %rax,%rdi
  80042124eb:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  80042124f2:	00 00 00 
  80042124f5:	ff d0                	callq  *%rax
  80042124f7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042124fb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042124ff:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212503:	0f b7 c0             	movzwl %ax,%eax
  8004212506:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421250a:	77 0c                	ja     8004212518 <_dwarf_frame_run_inst+0x4a0>
  800421250c:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212513:	e9 2f 09 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			memcpy(&RL[reg], &INITRL[reg],
  8004212518:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421251c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212520:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212524:	48 89 d0             	mov    %rdx,%rax
  8004212527:	48 01 c0             	add    %rax,%rax
  800421252a:	48 01 d0             	add    %rdx,%rax
  800421252d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212531:	48 01 c1             	add    %rax,%rcx
  8004212534:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212538:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421253c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212540:	48 89 d0             	mov    %rdx,%rax
  8004212543:	48 01 c0             	add    %rax,%rax
  8004212546:	48 01 d0             	add    %rdx,%rax
  8004212549:	48 c1 e0 03          	shl    $0x3,%rax
  800421254d:	48 01 f0             	add    %rsi,%rax
  8004212550:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212555:	48 89 ce             	mov    %rcx,%rsi
  8004212558:	48 89 c7             	mov    %rax,%rdi
  800421255b:	48 b8 2a fb 20 04 80 	movabs $0x800420fb2a,%rax
  8004212562:	00 00 00 
  8004212565:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
			break;
  8004212567:	e9 cd 08 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_undefined:
			*row_pc = pc;
  800421256c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212570:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212574:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212577:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421257b:	48 89 c7             	mov    %rax,%rdi
  800421257e:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212585:	00 00 00 
  8004212588:	ff d0                	callq  *%rax
  800421258a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421258e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212592:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212596:	0f b7 c0             	movzwl %ax,%eax
  8004212599:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421259d:	77 0c                	ja     80042125ab <_dwarf_frame_run_inst+0x533>
  800421259f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042125a6:	e9 9c 08 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  80042125ab:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042125af:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042125b3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042125b7:	48 89 d0             	mov    %rdx,%rax
  80042125ba:	48 01 c0             	add    %rax,%rax
  80042125bd:	48 01 d0             	add    %rdx,%rax
  80042125c0:	48 c1 e0 03          	shl    $0x3,%rax
  80042125c4:	48 01 c8             	add    %rcx,%rax
  80042125c7:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  80042125ca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042125ce:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042125d2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042125d6:	48 89 d0             	mov    %rdx,%rax
  80042125d9:	48 01 c0             	add    %rax,%rax
  80042125dc:	48 01 d0             	add    %rdx,%rax
  80042125df:	48 c1 e0 03          	shl    $0x3,%rax
  80042125e3:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042125e7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042125eb:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80042125ef:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  80042125f3:	e9 41 08 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_same_value:
			reg = _dwarf_decode_uleb128(&p);
  80042125f8:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042125fc:	48 89 c7             	mov    %rax,%rdi
  80042125ff:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212606:	00 00 00 
  8004212609:	ff d0                	callq  *%rax
  800421260b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421260f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212613:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212617:	0f b7 c0             	movzwl %ax,%eax
  800421261a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421261e:	77 0c                	ja     800421262c <_dwarf_frame_run_inst+0x5b4>
  8004212620:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212627:	e9 1b 08 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  800421262c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212630:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212634:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212638:	48 89 d0             	mov    %rdx,%rax
  800421263b:	48 01 c0             	add    %rax,%rax
  800421263e:	48 01 d0             	add    %rdx,%rax
  8004212641:	48 c1 e0 03          	shl    $0x3,%rax
  8004212645:	48 01 c8             	add    %rcx,%rax
  8004212648:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  800421264b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421264f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212653:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212657:	48 89 d0             	mov    %rdx,%rax
  800421265a:	48 01 c0             	add    %rax,%rax
  800421265d:	48 01 d0             	add    %rdx,%rax
  8004212660:	48 c1 e0 03          	shl    $0x3,%rax
  8004212664:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212668:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421266c:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  8004212670:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004212674:	e9 c0 07 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_register:
			*row_pc = pc;
  8004212679:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421267d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212681:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212684:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212688:	48 89 c7             	mov    %rax,%rdi
  800421268b:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212692:	00 00 00 
  8004212695:	ff d0                	callq  *%rax
  8004212697:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			reg2 = _dwarf_decode_uleb128(&p);
  800421269b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421269f:	48 89 c7             	mov    %rax,%rdi
  80042126a2:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  80042126a9:	00 00 00 
  80042126ac:	ff d0                	callq  *%rax
  80042126ae:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042126b2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042126b6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042126ba:	0f b7 c0             	movzwl %ax,%eax
  80042126bd:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042126c1:	77 0c                	ja     80042126cf <_dwarf_frame_run_inst+0x657>
  80042126c3:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042126ca:	e9 78 07 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  80042126cf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042126d3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042126d7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042126db:	48 89 d0             	mov    %rdx,%rax
  80042126de:	48 01 c0             	add    %rax,%rax
  80042126e1:	48 01 d0             	add    %rdx,%rax
  80042126e4:	48 c1 e0 03          	shl    $0x3,%rax
  80042126e8:	48 01 c8             	add    %rcx,%rax
  80042126eb:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = reg2;
  80042126ee:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042126f2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042126f6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042126fa:	48 89 d0             	mov    %rdx,%rax
  80042126fd:	48 01 c0             	add    %rax,%rax
  8004212700:	48 01 d0             	add    %rdx,%rax
  8004212703:	48 c1 e0 03          	shl    $0x3,%rax
  8004212707:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421270b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421270f:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004212713:	e9 21 07 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_remember_state:
			_dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  8004212718:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800421271c:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004212720:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  8004212724:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212728:	48 89 c7             	mov    %rax,%rdi
  800421272b:	48 b8 a7 1e 21 04 80 	movabs $0x8004211ea7,%rax
  8004212732:	00 00 00 
  8004212735:	ff d0                	callq  *%rax
			break;
  8004212737:	e9 fd 06 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_restore_state:
			*row_pc = pc;
  800421273c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212740:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212744:	48 89 10             	mov    %rdx,(%rax)
			_dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004212747:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800421274b:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421274f:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  8004212753:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212757:	48 89 c7             	mov    %rax,%rdi
  800421275a:	48 b8 a7 1e 21 04 80 	movabs $0x8004211ea7,%rax
  8004212761:	00 00 00 
  8004212764:	ff d0                	callq  *%rax
			break;
  8004212766:	e9 ce 06 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa:
			*row_pc = pc;
  800421276b:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421276f:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212773:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212776:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421277a:	48 89 c7             	mov    %rax,%rdi
  800421277d:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212784:	00 00 00 
  8004212787:	ff d0                	callq  *%rax
  8004212789:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  800421278d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212791:	48 89 c7             	mov    %rax,%rdi
  8004212794:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  800421279b:	00 00 00 
  800421279e:	ff d0                	callq  *%rax
  80042127a0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  80042127a4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127a8:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  80042127ab:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127af:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  80042127b3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127b7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042127bb:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = uoff;
  80042127bf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127c3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042127c7:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  80042127cb:	e9 69 06 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_register:
			*row_pc = pc;
  80042127d0:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042127d4:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042127d8:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042127db:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042127df:	48 89 c7             	mov    %rax,%rdi
  80042127e2:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  80042127e9:	00 00 00 
  80042127ec:	ff d0                	callq  *%rax
  80042127ee:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CFA.dw_regnum = reg;
  80042127f2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127f6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042127fa:	66 89 50 02          	mov    %dx,0x2(%rax)
			 * Note that DW_CFA_def_cfa_register change the CFA
			 * rule register while keep the old offset. So we
			 * should not touch the CFA.dw_offset_relevant flag
			 * here.
			 */
			break;
  80042127fe:	e9 36 06 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset:
			*row_pc = pc;
  8004212803:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212807:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421280b:	48 89 10             	mov    %rdx,(%rax)
			uoff = _dwarf_decode_uleb128(&p);
  800421280e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212812:	48 89 c7             	mov    %rax,%rdi
  8004212815:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  800421281c:	00 00 00 
  800421281f:	ff d0                	callq  *%rax
  8004212821:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004212825:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212829:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  800421282c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212830:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = uoff;
  8004212834:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212838:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421283c:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004212840:	e9 f4 05 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_expression:
			*row_pc = pc;
  8004212845:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212849:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421284d:	48 89 10             	mov    %rdx,(%rax)
			CFA.dw_offset_relevant = 0;
  8004212850:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212854:	c6 00 00             	movb   $0x0,(%rax)
			CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004212857:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421285b:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  800421285f:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8004212863:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212867:	48 89 c7             	mov    %rax,%rdi
  800421286a:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212871:	00 00 00 
  8004212874:	ff d0                	callq  *%rax
  8004212876:	48 89 43 08          	mov    %rax,0x8(%rbx)
			CFA.dw_block_ptr = p;
  800421287a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421287e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004212882:	48 89 50 10          	mov    %rdx,0x10(%rax)
			p += CFA.dw_offset_or_block_len;
  8004212886:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421288a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421288e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212892:	48 01 d0             	add    %rdx,%rax
  8004212895:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004212899:	e9 9b 05 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_expression:
			*row_pc = pc;
  800421289e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042128a2:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042128a6:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042128a9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042128ad:	48 89 c7             	mov    %rax,%rdi
  80042128b0:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  80042128b7:	00 00 00 
  80042128ba:	ff d0                	callq  *%rax
  80042128bc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042128c0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042128c4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042128c8:	0f b7 c0             	movzwl %ax,%eax
  80042128cb:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042128cf:	77 0c                	ja     80042128dd <_dwarf_frame_run_inst+0x865>
  80042128d1:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042128d8:	e9 6a 05 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  80042128dd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042128e1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042128e5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042128e9:	48 89 d0             	mov    %rdx,%rax
  80042128ec:	48 01 c0             	add    %rax,%rax
  80042128ef:	48 01 d0             	add    %rdx,%rax
  80042128f2:	48 c1 e0 03          	shl    $0x3,%rax
  80042128f6:	48 01 c8             	add    %rcx,%rax
  80042128f9:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  80042128fc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212900:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212904:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212908:	48 89 d0             	mov    %rdx,%rax
  800421290b:	48 01 c0             	add    %rax,%rax
  800421290e:	48 01 d0             	add    %rdx,%rax
  8004212911:	48 c1 e0 03          	shl    $0x3,%rax
  8004212915:	48 01 c8             	add    %rcx,%rax
  8004212918:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  800421291c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212920:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212924:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212928:	48 89 d0             	mov    %rdx,%rax
  800421292b:	48 01 c0             	add    %rax,%rax
  800421292e:	48 01 d0             	add    %rdx,%rax
  8004212931:	48 c1 e0 03          	shl    $0x3,%rax
  8004212935:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004212939:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421293d:	48 89 c7             	mov    %rax,%rdi
  8004212940:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212947:	00 00 00 
  800421294a:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  800421294c:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  8004212950:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212954:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212958:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421295c:	48 89 d0             	mov    %rdx,%rax
  800421295f:	48 01 c0             	add    %rax,%rax
  8004212962:	48 01 d0             	add    %rdx,%rax
  8004212965:	48 c1 e0 03          	shl    $0x3,%rax
  8004212969:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421296d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212971:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004212975:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004212979:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421297d:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212981:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212985:	48 89 d0             	mov    %rdx,%rax
  8004212988:	48 01 c0             	add    %rax,%rax
  800421298b:	48 01 d0             	add    %rdx,%rax
  800421298e:	48 c1 e0 03          	shl    $0x3,%rax
  8004212992:	48 01 f0             	add    %rsi,%rax
  8004212995:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212999:	48 01 c8             	add    %rcx,%rax
  800421299c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  80042129a0:	e9 94 04 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_offset_extended_sf:
			*row_pc = pc;
  80042129a5:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042129a9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042129ad:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042129b0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042129b4:	48 89 c7             	mov    %rax,%rdi
  80042129b7:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  80042129be:	00 00 00 
  80042129c1:	ff d0                	callq  *%rax
  80042129c3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  80042129c7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042129cb:	48 89 c7             	mov    %rax,%rdi
  80042129ce:	48 b8 19 05 21 04 80 	movabs $0x8004210519,%rax
  80042129d5:	00 00 00 
  80042129d8:	ff d0                	callq  *%rax
  80042129da:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042129de:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042129e2:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042129e6:	0f b7 c0             	movzwl %ax,%eax
  80042129e9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042129ed:	77 0c                	ja     80042129fb <_dwarf_frame_run_inst+0x983>
  80042129ef:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042129f6:	e9 4c 04 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  80042129fb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042129ff:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212a03:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a07:	48 89 d0             	mov    %rdx,%rax
  8004212a0a:	48 01 c0             	add    %rax,%rax
  8004212a0d:	48 01 d0             	add    %rdx,%rax
  8004212a10:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a14:	48 01 c8             	add    %rcx,%rax
  8004212a17:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004212a1a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a1e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212a22:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a26:	48 89 d0             	mov    %rdx,%rax
  8004212a29:	48 01 c0             	add    %rax,%rax
  8004212a2c:	48 01 d0             	add    %rdx,%rax
  8004212a2f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a33:	48 01 c8             	add    %rcx,%rax
  8004212a36:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212a3a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a3e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212a42:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a46:	48 89 d0             	mov    %rdx,%rax
  8004212a49:	48 01 c0             	add    %rax,%rax
  8004212a4c:	48 01 d0             	add    %rdx,%rax
  8004212a4f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a53:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212a57:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212a5b:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212a5f:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004212a63:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a67:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212a6b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a6f:	48 89 d0             	mov    %rdx,%rax
  8004212a72:	48 01 c0             	add    %rax,%rax
  8004212a75:	48 01 d0             	add    %rdx,%rax
  8004212a78:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a7c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212a80:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212a87:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004212a8c:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004212a90:	e9 a4 03 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_sf:
			*row_pc = pc;
  8004212a95:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212a99:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212a9d:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212aa0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212aa4:	48 89 c7             	mov    %rax,%rdi
  8004212aa7:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212aae:	00 00 00 
  8004212ab1:	ff d0                	callq  *%rax
  8004212ab3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004212ab7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212abb:	48 89 c7             	mov    %rax,%rdi
  8004212abe:	48 b8 19 05 21 04 80 	movabs $0x8004210519,%rax
  8004212ac5:	00 00 00 
  8004212ac8:	ff d0                	callq  *%rax
  8004212aca:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004212ace:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ad2:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212ad5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ad9:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004212add:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ae1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ae5:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004212ae9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212aed:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212af4:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004212af9:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004212afd:	e9 37 03 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_def_cfa_offset_sf:
			*row_pc = pc;
  8004212b02:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212b06:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212b0a:	48 89 10             	mov    %rdx,(%rax)
			soff = _dwarf_decode_sleb128(&p);
  8004212b0d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212b11:	48 89 c7             	mov    %rax,%rdi
  8004212b14:	48 b8 19 05 21 04 80 	movabs $0x8004210519,%rax
  8004212b1b:	00 00 00 
  8004212b1e:	ff d0                	callq  *%rax
  8004212b20:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004212b24:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b28:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212b2b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b2f:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004212b33:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b37:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212b3e:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004212b43:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004212b47:	e9 ed 02 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset:
			*row_pc = pc;
  8004212b4c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212b50:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212b54:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212b57:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212b5b:	48 89 c7             	mov    %rax,%rdi
  8004212b5e:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212b65:	00 00 00 
  8004212b68:	ff d0                	callq  *%rax
  8004212b6a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004212b6e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212b72:	48 89 c7             	mov    %rax,%rdi
  8004212b75:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212b7c:	00 00 00 
  8004212b7f:	ff d0                	callq  *%rax
  8004212b81:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004212b85:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b89:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212b8d:	0f b7 c0             	movzwl %ax,%eax
  8004212b90:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212b94:	77 0c                	ja     8004212ba2 <_dwarf_frame_run_inst+0xb2a>
  8004212b96:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212b9d:	e9 a5 02 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004212ba2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ba6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212baa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212bae:	48 89 d0             	mov    %rdx,%rax
  8004212bb1:	48 01 c0             	add    %rax,%rax
  8004212bb4:	48 01 d0             	add    %rdx,%rax
  8004212bb7:	48 c1 e0 03          	shl    $0x3,%rax
  8004212bbb:	48 01 c8             	add    %rcx,%rax
  8004212bbe:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004212bc1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bc5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212bc9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212bcd:	48 89 d0             	mov    %rdx,%rax
  8004212bd0:	48 01 c0             	add    %rax,%rax
  8004212bd3:	48 01 d0             	add    %rdx,%rax
  8004212bd6:	48 c1 e0 03          	shl    $0x3,%rax
  8004212bda:	48 01 c8             	add    %rcx,%rax
  8004212bdd:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212be1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212be5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212be9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212bed:	48 89 d0             	mov    %rdx,%rax
  8004212bf0:	48 01 c0             	add    %rax,%rax
  8004212bf3:	48 01 d0             	add    %rdx,%rax
  8004212bf6:	48 c1 e0 03          	shl    $0x3,%rax
  8004212bfa:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212bfe:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212c02:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212c06:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  8004212c0a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c0e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c12:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212c16:	48 89 d0             	mov    %rdx,%rax
  8004212c19:	48 01 c0             	add    %rax,%rax
  8004212c1c:	48 01 d0             	add    %rdx,%rax
  8004212c1f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c23:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212c27:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212c2e:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004212c33:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004212c37:	e9 fd 01 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_offset_sf:
			*row_pc = pc;
  8004212c3c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212c40:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212c44:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212c47:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212c4b:	48 89 c7             	mov    %rax,%rdi
  8004212c4e:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212c55:	00 00 00 
  8004212c58:	ff d0                	callq  *%rax
  8004212c5a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004212c5e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212c62:	48 89 c7             	mov    %rax,%rdi
  8004212c65:	48 b8 19 05 21 04 80 	movabs $0x8004210519,%rax
  8004212c6c:	00 00 00 
  8004212c6f:	ff d0                	callq  *%rax
  8004212c71:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004212c75:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c79:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212c7d:	0f b7 c0             	movzwl %ax,%eax
  8004212c80:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212c84:	77 0c                	ja     8004212c92 <_dwarf_frame_run_inst+0xc1a>
  8004212c86:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212c8d:	e9 b5 01 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 1;
  8004212c92:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c96:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c9a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212c9e:	48 89 d0             	mov    %rdx,%rax
  8004212ca1:	48 01 c0             	add    %rax,%rax
  8004212ca4:	48 01 d0             	add    %rdx,%rax
  8004212ca7:	48 c1 e0 03          	shl    $0x3,%rax
  8004212cab:	48 01 c8             	add    %rcx,%rax
  8004212cae:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004212cb1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cb5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cb9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212cbd:	48 89 d0             	mov    %rdx,%rax
  8004212cc0:	48 01 c0             	add    %rax,%rax
  8004212cc3:	48 01 d0             	add    %rdx,%rax
  8004212cc6:	48 c1 e0 03          	shl    $0x3,%rax
  8004212cca:	48 01 c8             	add    %rcx,%rax
  8004212ccd:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212cd1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cd5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cd9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212cdd:	48 89 d0             	mov    %rdx,%rax
  8004212ce0:	48 01 c0             	add    %rax,%rax
  8004212ce3:	48 01 d0             	add    %rdx,%rax
  8004212ce6:	48 c1 e0 03          	shl    $0x3,%rax
  8004212cea:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212cee:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212cf2:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212cf6:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004212cfa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cfe:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212d02:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d06:	48 89 d0             	mov    %rdx,%rax
  8004212d09:	48 01 c0             	add    %rax,%rax
  8004212d0c:	48 01 d0             	add    %rdx,%rax
  8004212d0f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d13:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212d17:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212d1e:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004212d23:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004212d27:	e9 0d 01 00 00       	jmpq   8004212e39 <_dwarf_frame_run_inst+0xdc1>
		case DW_CFA_val_expression:
			*row_pc = pc;
  8004212d2c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212d30:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212d34:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004212d37:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212d3b:	48 89 c7             	mov    %rax,%rdi
  8004212d3e:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212d45:	00 00 00 
  8004212d48:	ff d0                	callq  *%rax
  8004212d4a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004212d4e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d52:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212d56:	0f b7 c0             	movzwl %ax,%eax
  8004212d59:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212d5d:	77 0c                	ja     8004212d6b <_dwarf_frame_run_inst+0xcf3>
  8004212d5f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212d66:	e9 dc 00 00 00       	jmpq   8004212e47 <_dwarf_frame_run_inst+0xdcf>
			RL[reg].dw_offset_relevant = 0;
  8004212d6b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d6f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212d73:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d77:	48 89 d0             	mov    %rdx,%rax
  8004212d7a:	48 01 c0             	add    %rax,%rax
  8004212d7d:	48 01 d0             	add    %rdx,%rax
  8004212d80:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d84:	48 01 c8             	add    %rcx,%rax
  8004212d87:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  8004212d8a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d8e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212d92:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d96:	48 89 d0             	mov    %rdx,%rax
  8004212d99:	48 01 c0             	add    %rax,%rax
  8004212d9c:	48 01 d0             	add    %rdx,%rax
  8004212d9f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212da3:	48 01 c8             	add    %rcx,%rax
  8004212da6:	c6 40 01 03          	movb   $0x3,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  8004212daa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212dae:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212db2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212db6:	48 89 d0             	mov    %rdx,%rax
  8004212db9:	48 01 c0             	add    %rax,%rax
  8004212dbc:	48 01 d0             	add    %rdx,%rax
  8004212dbf:	48 c1 e0 03          	shl    $0x3,%rax
  8004212dc3:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004212dc7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212dcb:	48 89 c7             	mov    %rax,%rdi
  8004212dce:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004212dd5:	00 00 00 
  8004212dd8:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004212dda:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  8004212dde:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212de2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212de6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212dea:	48 89 d0             	mov    %rdx,%rax
  8004212ded:	48 01 c0             	add    %rax,%rax
  8004212df0:	48 01 d0             	add    %rdx,%rax
  8004212df3:	48 c1 e0 03          	shl    $0x3,%rax
  8004212df7:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212dfb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212dff:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004212e03:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004212e07:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e0b:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212e0f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212e13:	48 89 d0             	mov    %rdx,%rax
  8004212e16:	48 01 c0             	add    %rax,%rax
  8004212e19:	48 01 d0             	add    %rdx,%rax
  8004212e1c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212e20:	48 01 f0             	add    %rsi,%rax
  8004212e23:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212e27:	48 01 c8             	add    %rcx,%rax
  8004212e2a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004212e2e:	eb 09                	jmp    8004212e39 <_dwarf_frame_run_inst+0xdc1>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
			ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004212e30:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			goto program_done;
  8004212e37:	eb 0e                	jmp    8004212e47 <_dwarf_frame_run_inst+0xdcf>
	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
	p = insts;
	pe = p + len;

	while (p < pe) {
  8004212e39:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212e3d:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212e41:	0f 82 b8 f2 ff ff    	jb     80042120ff <_dwarf_frame_run_inst+0x87>
			goto program_done;
		}
	}

program_done:
	return (ret);
  8004212e47:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004212e4a:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  8004212e51:	5b                   	pop    %rbx
  8004212e52:	5d                   	pop    %rbp
  8004212e53:	c3                   	retq   

0000008004212e54 <_dwarf_frame_get_internal_table>:
int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt,
				Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  8004212e54:	55                   	push   %rbp
  8004212e55:	48 89 e5             	mov    %rsp,%rbp
  8004212e58:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004212e5c:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212e60:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212e64:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212e68:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004212e6c:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  8004212e70:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Cie cie;
	Dwarf_Regtable3 *rt;
	Dwarf_Addr row_pc;
	int i, ret;

	assert(ret_rt != NULL);
  8004212e74:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004212e79:	75 35                	jne    8004212eb0 <_dwarf_frame_get_internal_table+0x5c>
  8004212e7b:	48 b9 d8 a5 21 04 80 	movabs $0x800421a5d8,%rcx
  8004212e82:	00 00 00 
  8004212e85:	48 ba e7 a4 21 04 80 	movabs $0x800421a4e7,%rdx
  8004212e8c:	00 00 00 
  8004212e8f:	be 83 01 00 00       	mov    $0x183,%esi
  8004212e94:	48 bf fc a4 21 04 80 	movabs $0x800421a4fc,%rdi
  8004212e9b:	00 00 00 
  8004212e9e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212ea3:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004212eaa:	00 00 00 
  8004212ead:	41 ff d0             	callq  *%r8

	//dbg = fde->fde_dbg;
	assert(dbg != NULL);
  8004212eb0:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004212eb5:	75 35                	jne    8004212eec <_dwarf_frame_get_internal_table+0x98>
  8004212eb7:	48 b9 e7 a5 21 04 80 	movabs $0x800421a5e7,%rcx
  8004212ebe:	00 00 00 
  8004212ec1:	48 ba e7 a4 21 04 80 	movabs $0x800421a4e7,%rdx
  8004212ec8:	00 00 00 
  8004212ecb:	be 86 01 00 00       	mov    $0x186,%esi
  8004212ed0:	48 bf fc a4 21 04 80 	movabs $0x800421a4fc,%rdi
  8004212ed7:	00 00 00 
  8004212eda:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212edf:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004212ee6:	00 00 00 
  8004212ee9:	41 ff d0             	callq  *%r8

	rt = dbg->dbg_internal_reg_table;
  8004212eec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ef0:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212ef4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	/* Clear the content of regtable from previous run. */
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  8004212ef8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212efc:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212f01:	be 00 00 00 00       	mov    $0x0,%esi
  8004212f06:	48 89 c7             	mov    %rax,%rdi
  8004212f09:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004212f10:	00 00 00 
  8004212f13:	ff d0                	callq  *%rax
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  8004212f15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212f19:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212f1d:	0f b7 d0             	movzwl %ax,%edx
  8004212f20:	48 89 d0             	mov    %rdx,%rax
  8004212f23:	48 01 c0             	add    %rax,%rax
  8004212f26:	48 01 d0             	add    %rdx,%rax
  8004212f29:	48 c1 e0 03          	shl    $0x3,%rax
  8004212f2d:	48 89 c2             	mov    %rax,%rdx
  8004212f30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212f34:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212f38:	be 00 00 00 00       	mov    $0x0,%esi
  8004212f3d:	48 89 c7             	mov    %rax,%rdi
  8004212f40:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004212f47:	00 00 00 
  8004212f4a:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004212f4c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004212f53:	eb 2f                	jmp    8004212f84 <_dwarf_frame_get_internal_table+0x130>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  8004212f55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212f59:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212f5d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212f60:	48 63 d0             	movslq %eax,%rdx
  8004212f63:	48 89 d0             	mov    %rdx,%rax
  8004212f66:	48 01 c0             	add    %rax,%rax
  8004212f69:	48 01 d0             	add    %rdx,%rax
  8004212f6c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212f70:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212f74:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f78:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  8004212f7c:	66 89 42 02          	mov    %ax,0x2(%rdx)
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004212f80:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004212f84:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212f88:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212f8c:	0f b7 c0             	movzwl %ax,%eax
  8004212f8f:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004212f92:	7f c1                	jg     8004212f55 <_dwarf_frame_get_internal_table+0x101>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

	/* Run initial instructions in CIE. */
	cie = fde->fde_cie;
  8004212f94:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212f98:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212f9c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	assert(cie != NULL);
  8004212fa0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212fa5:	75 35                	jne    8004212fdc <_dwarf_frame_get_internal_table+0x188>
  8004212fa7:	48 b9 f3 a5 21 04 80 	movabs $0x800421a5f3,%rcx
  8004212fae:	00 00 00 
  8004212fb1:	48 ba e7 a4 21 04 80 	movabs $0x800421a4e7,%rdx
  8004212fb8:	00 00 00 
  8004212fbb:	be 95 01 00 00       	mov    $0x195,%esi
  8004212fc0:	48 bf fc a4 21 04 80 	movabs $0x800421a4fc,%rdi
  8004212fc7:	00 00 00 
  8004212fca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212fcf:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004212fd6:	00 00 00 
  8004212fd9:	41 ff d0             	callq  *%r8
	ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004212fdc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fe0:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004212fe4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fe8:	4c 8b 40 38          	mov    0x38(%rax),%r8
  8004212fec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ff0:	48 8b 48 70          	mov    0x70(%rax),%rcx
  8004212ff4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ff8:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004212ffc:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004213000:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213004:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8004213008:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800421300d:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  8004213011:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004213016:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  800421301d:	ff ff 
  800421301f:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8004213026:	00 
  8004213027:	48 89 c7             	mov    %rax,%rdi
  800421302a:	48 b8 78 20 21 04 80 	movabs $0x8004212078,%rax
  8004213031:	00 00 00 
  8004213034:	ff d0                	callq  *%rax
  8004213036:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf,
				    cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
	if (ret != DW_DLE_NONE)
  8004213039:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421303d:	74 08                	je     8004213047 <_dwarf_frame_get_internal_table+0x1f3>
		return (ret);
  800421303f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004213042:	e9 98 00 00 00       	jmpq   80042130df <_dwarf_frame_get_internal_table+0x28b>
	/* Run instructions in FDE. */
	if (pc_req >= fde->fde_initloc) {
  8004213047:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421304b:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421304f:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004213053:	77 6f                	ja     80042130c4 <_dwarf_frame_get_internal_table+0x270>
		ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004213055:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213059:	48 8b 78 30          	mov    0x30(%rax),%rdi
  800421305d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213061:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004213065:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213069:	4c 8b 50 38          	mov    0x38(%rax),%r10
  800421306d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213071:	48 8b 48 58          	mov    0x58(%rax),%rcx
  8004213075:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213079:	48 8b 50 50          	mov    0x50(%rax),%rdx
  800421307d:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004213081:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213085:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  8004213089:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  800421308e:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  8004213092:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004213097:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  800421309b:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  80042130a0:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042130a4:	4d 89 d0             	mov    %r10,%r8
  80042130a7:	48 89 c7             	mov    %rax,%rdi
  80042130aa:	48 b8 78 20 21 04 80 	movabs $0x8004212078,%rax
  80042130b1:	00 00 00 
  80042130b4:	ff d0                	callq  *%rax
  80042130b6:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf,
					    cie->cie_daf,
					    fde->fde_initloc, pc_req,
					    &row_pc, error);
		if (ret != DW_DLE_NONE)
  80042130b9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042130bd:	74 05                	je     80042130c4 <_dwarf_frame_get_internal_table+0x270>
			return (ret);
  80042130bf:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042130c2:	eb 1b                	jmp    80042130df <_dwarf_frame_get_internal_table+0x28b>
	}

	*ret_rt = rt;
  80042130c4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042130c8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042130cc:	48 89 10             	mov    %rdx,(%rax)
	*ret_row_pc = row_pc;
  80042130cf:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042130d3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042130d7:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  80042130da:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042130df:	c9                   	leaveq 
  80042130e0:	c3                   	retq   

00000080042130e1 <dwarf_get_fde_info_for_all_regs>:
int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested,
				Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  80042130e1:	55                   	push   %rbp
  80042130e2:	48 89 e5             	mov    %rsp,%rbp
  80042130e5:	48 83 ec 50          	sub    $0x50,%rsp
  80042130e9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042130ed:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042130f1:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042130f5:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  80042130f9:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  80042130fd:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
	Dwarf_Regtable3 *rt;
	Dwarf_Addr pc;
	Dwarf_Half cfa;
	int i, ret;

	if (fde == NULL || reg_table == NULL) {
  8004213101:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004213106:	74 07                	je     800421310f <dwarf_get_fde_info_for_all_regs+0x2e>
  8004213108:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800421310d:	75 0a                	jne    8004213119 <dwarf_get_fde_info_for_all_regs+0x38>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  800421310f:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213114:	e9 eb 02 00 00       	jmpq   8004213404 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	assert(dbg != NULL);
  8004213119:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421311e:	75 35                	jne    8004213155 <dwarf_get_fde_info_for_all_regs+0x74>
  8004213120:	48 b9 e7 a5 21 04 80 	movabs $0x800421a5e7,%rcx
  8004213127:	00 00 00 
  800421312a:	48 ba e7 a4 21 04 80 	movabs $0x800421a4e7,%rdx
  8004213131:	00 00 00 
  8004213134:	be bf 01 00 00       	mov    $0x1bf,%esi
  8004213139:	48 bf fc a4 21 04 80 	movabs $0x800421a4fc,%rdi
  8004213140:	00 00 00 
  8004213143:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213148:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800421314f:	00 00 00 
  8004213152:	41 ff d0             	callq  *%r8

	if (pc_requested < fde->fde_initloc ||
  8004213155:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213159:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421315d:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004213161:	77 19                	ja     800421317c <dwarf_get_fde_info_for_all_regs+0x9b>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  8004213163:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213167:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800421316b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421316f:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213173:	48 01 d0             	add    %rdx,%rax
		return (DW_DLV_ERROR);
	}

	assert(dbg != NULL);

	if (pc_requested < fde->fde_initloc ||
  8004213176:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800421317a:	77 0a                	ja     8004213186 <dwarf_get_fde_info_for_all_regs+0xa5>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
		return (DW_DLV_ERROR);
  800421317c:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213181:	e9 7e 02 00 00       	jmpq   8004213404 <dwarf_get_fde_info_for_all_regs+0x323>
	}

	ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  8004213186:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  800421318a:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  800421318e:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  8004213192:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213196:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421319a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421319e:	4d 89 c1             	mov    %r8,%r9
  80042131a1:	49 89 f8             	mov    %rdi,%r8
  80042131a4:	48 89 c7             	mov    %rax,%rdi
  80042131a7:	48 b8 54 2e 21 04 80 	movabs $0x8004212e54,%rax
  80042131ae:	00 00 00 
  80042131b1:	ff d0                	callq  *%rax
  80042131b3:	89 45 f8             	mov    %eax,-0x8(%rbp)
					      error);
	if (ret != DW_DLE_NONE)
  80042131b6:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042131ba:	74 0a                	je     80042131c6 <dwarf_get_fde_info_for_all_regs+0xe5>
		return (DW_DLV_ERROR);
  80042131bc:	b8 01 00 00 00       	mov    $0x1,%eax
  80042131c1:	e9 3e 02 00 00       	jmpq   8004213404 <dwarf_get_fde_info_for_all_regs+0x323>
	/*
	 * Copy the CFA rule to the column intended for holding the CFA,
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
  80042131c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042131ca:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042131ce:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	if (cfa < DW_REG_TABLE_SIZE) {
  80042131d2:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  80042131d7:	0f 87 b1 00 00 00    	ja     800421328e <dwarf_get_fde_info_for_all_regs+0x1ad>
		reg_table->rules[cfa].dw_offset_relevant =
  80042131dd:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  80042131e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131e5:	0f b6 00             	movzbl (%rax),%eax
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
	if (cfa < DW_REG_TABLE_SIZE) {
		reg_table->rules[cfa].dw_offset_relevant =
  80042131e8:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042131ec:	48 63 c9             	movslq %ecx,%rcx
  80042131ef:	48 83 c1 01          	add    $0x1,%rcx
  80042131f3:	48 c1 e1 04          	shl    $0x4,%rcx
  80042131f7:	48 01 ca             	add    %rcx,%rdx
  80042131fa:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  80042131fc:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004213200:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213204:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8004213208:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421320c:	48 63 c9             	movslq %ecx,%rcx
  800421320f:	48 83 c1 01          	add    $0x1,%rcx
  8004213213:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213217:	48 01 ca             	add    %rcx,%rdx
  800421321a:	88 42 01             	mov    %al,0x1(%rdx)
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  800421321d:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004213221:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213225:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004213229:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421322d:	48 63 c9             	movslq %ecx,%rcx
  8004213230:	48 83 c1 01          	add    $0x1,%rcx
  8004213234:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213238:	48 01 ca             	add    %rcx,%rdx
  800421323b:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  800421323f:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004213243:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213247:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421324b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421324f:	48 63 c9             	movslq %ecx,%rcx
  8004213252:	48 83 c1 01          	add    $0x1,%rcx
  8004213256:	48 c1 e1 04          	shl    $0x4,%rcx
  800421325a:	48 01 ca             	add    %rcx,%rdx
  800421325d:	48 83 c2 08          	add    $0x8,%rdx
  8004213261:	48 89 02             	mov    %rax,(%rdx)
		reg_table->cfa_rule = reg_table->rules[cfa];
  8004213264:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004213268:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800421326c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213270:	48 63 d2             	movslq %edx,%rdx
  8004213273:	48 83 c2 01          	add    $0x1,%rdx
  8004213277:	48 c1 e2 04          	shl    $0x4,%rdx
  800421327b:	48 01 d0             	add    %rdx,%rax
  800421327e:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213282:	48 8b 00             	mov    (%rax),%rax
  8004213285:	48 89 01             	mov    %rax,(%rcx)
  8004213288:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  800421328c:	eb 3c                	jmp    80042132ca <dwarf_get_fde_info_for_all_regs+0x1e9>
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
		    CFA.dw_offset_relevant;
  800421328e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213292:	0f b6 10             	movzbl (%rax),%edx
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
		reg_table->cfa_rule = reg_table->rules[cfa];
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
  8004213295:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213299:	88 10                	mov    %dl,(%rax)
		    CFA.dw_offset_relevant;
		reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  800421329b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421329f:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  80042132a3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042132a7:	88 50 01             	mov    %dl,0x1(%rax)
		reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  80042132aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132ae:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  80042132b2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042132b6:	66 89 50 02          	mov    %dx,0x2(%rax)
		reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  80042132ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132be:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042132c2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042132c6:	48 89 50 08          	mov    %rdx,0x8(%rax)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042132ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042132d1:	e9 fd 00 00 00       	jmpq   80042133d3 <dwarf_get_fde_info_for_all_regs+0x2f2>
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
  80042132d6:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80042132da:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042132dd:	75 05                	jne    80042132e4 <dwarf_get_fde_info_for_all_regs+0x203>
			continue;
  80042132df:	e9 eb 00 00 00       	jmpq   80042133cf <dwarf_get_fde_info_for_all_regs+0x2ee>

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  80042132e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132e8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042132ec:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042132ef:	48 63 d0             	movslq %eax,%rdx
  80042132f2:	48 89 d0             	mov    %rdx,%rax
  80042132f5:	48 01 c0             	add    %rax,%rax
  80042132f8:	48 01 d0             	add    %rdx,%rax
  80042132fb:	48 c1 e0 03          	shl    $0x3,%rax
  80042132ff:	48 01 c8             	add    %rcx,%rax
  8004213302:	0f b6 00             	movzbl (%rax),%eax

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
  8004213305:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213309:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421330c:	48 63 c9             	movslq %ecx,%rcx
  800421330f:	48 83 c1 01          	add    $0x1,%rcx
  8004213313:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213317:	48 01 ca             	add    %rcx,%rdx
  800421331a:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  800421331c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213320:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213324:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213327:	48 63 d0             	movslq %eax,%rdx
  800421332a:	48 89 d0             	mov    %rdx,%rax
  800421332d:	48 01 c0             	add    %rax,%rax
  8004213330:	48 01 d0             	add    %rdx,%rax
  8004213333:	48 c1 e0 03          	shl    $0x3,%rax
  8004213337:	48 01 c8             	add    %rcx,%rax
  800421333a:	0f b6 40 01          	movzbl 0x1(%rax),%eax
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
  800421333e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213342:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213345:	48 63 c9             	movslq %ecx,%rcx
  8004213348:	48 83 c1 01          	add    $0x1,%rcx
  800421334c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213350:	48 01 ca             	add    %rcx,%rdx
  8004213353:	88 42 01             	mov    %al,0x1(%rdx)
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  8004213356:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421335a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421335e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213361:	48 63 d0             	movslq %eax,%rdx
  8004213364:	48 89 d0             	mov    %rdx,%rax
  8004213367:	48 01 c0             	add    %rax,%rax
  800421336a:	48 01 d0             	add    %rdx,%rax
  800421336d:	48 c1 e0 03          	shl    $0x3,%rax
  8004213371:	48 01 c8             	add    %rcx,%rax
  8004213374:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004213378:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421337c:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421337f:	48 63 c9             	movslq %ecx,%rcx
  8004213382:	48 83 c1 01          	add    $0x1,%rcx
  8004213386:	48 c1 e1 04          	shl    $0x4,%rcx
  800421338a:	48 01 ca             	add    %rcx,%rdx
  800421338d:	66 89 42 02          	mov    %ax,0x2(%rdx)
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  8004213391:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213395:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213399:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421339c:	48 63 d0             	movslq %eax,%rdx
  800421339f:	48 89 d0             	mov    %rdx,%rax
  80042133a2:	48 01 c0             	add    %rax,%rax
  80042133a5:	48 01 d0             	add    %rdx,%rax
  80042133a8:	48 c1 e0 03          	shl    $0x3,%rax
  80042133ac:	48 01 c8             	add    %rcx,%rax
  80042133af:	48 8b 40 08          	mov    0x8(%rax),%rax
		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
  80042133b3:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042133b7:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042133ba:	48 63 c9             	movslq %ecx,%rcx
  80042133bd:	48 83 c1 01          	add    $0x1,%rcx
  80042133c1:	48 c1 e1 04          	shl    $0x4,%rcx
  80042133c5:	48 01 ca             	add    %rcx,%rdx
  80042133c8:	48 83 c2 08          	add    $0x8,%rdx
  80042133cc:	48 89 02             	mov    %rax,(%rdx)

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {
  80042133cf:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042133d3:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  80042133d7:	7f 14                	jg     80042133ed <dwarf_get_fde_info_for_all_regs+0x30c>
  80042133d9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042133dd:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  80042133e1:	0f b7 c0             	movzwl %ax,%eax
  80042133e4:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042133e7:	0f 8f e9 fe ff ff    	jg     80042132d6 <dwarf_get_fde_info_for_all_regs+0x1f5>
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
	}

	if (row_pc) *row_pc = pc;
  80042133ed:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042133f2:	74 0b                	je     80042133ff <dwarf_get_fde_info_for_all_regs+0x31e>
  80042133f4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042133f8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042133fc:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLV_OK);
  80042133ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213404:	c9                   	leaveq 
  8004213405:	c3                   	retq   

0000008004213406 <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004213406:	55                   	push   %rbp
  8004213407:	48 89 e5             	mov    %rsp,%rbp
  800421340a:	48 83 ec 40          	sub    $0x40,%rsp
  800421340e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213412:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004213416:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421341a:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800421341e:	44 89 c0             	mov    %r8d,%eax
  8004213421:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  8004213425:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  8004213428:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  800421342c:	75 0a                	jne    8004213438 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  800421342e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213433:	e9 e6 01 00 00       	jmpq   800421361e <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  8004213438:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421343c:	83 e0 f0             	and    $0xfffffff0,%eax
  800421343f:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  8004213442:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  8004213446:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421344a:	83 f8 0c             	cmp    $0xc,%eax
  800421344d:	0f 87 72 01 00 00    	ja     80042135c5 <_dwarf_frame_read_lsb_encoded+0x1bf>
  8004213453:	89 c0                	mov    %eax,%eax
  8004213455:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421345c:	00 
  800421345d:	48 b8 00 a6 21 04 80 	movabs $0x800421a600,%rax
  8004213464:	00 00 00 
  8004213467:	48 01 d0             	add    %rdx,%rax
  800421346a:	48 8b 00             	mov    (%rax),%rax
  800421346d:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  800421346f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213473:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213477:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421347b:	8b 52 28             	mov    0x28(%rdx),%edx
  800421347e:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213482:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213486:	48 89 cf             	mov    %rcx,%rdi
  8004213489:	ff d0                	callq  *%rax
  800421348b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421348f:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213492:	e9 35 01 00 00       	jmpq   80042135cc <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  8004213497:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421349b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421349f:	48 89 d6             	mov    %rdx,%rsi
  80042134a2:	48 89 c7             	mov    %rax,%rdi
  80042134a5:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  80042134ac:	00 00 00 
  80042134af:	ff d0                	callq  *%rax
  80042134b1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042134b5:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042134b8:	e9 0f 01 00 00       	jmpq   80042135cc <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  80042134bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042134c1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042134c5:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042134c9:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042134cd:	ba 02 00 00 00       	mov    $0x2,%edx
  80042134d2:	48 89 cf             	mov    %rcx,%rdi
  80042134d5:	ff d0                	callq  *%rax
  80042134d7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042134db:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042134de:	e9 e9 00 00 00       	jmpq   80042135cc <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  80042134e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042134e7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042134eb:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042134ef:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042134f3:	ba 04 00 00 00       	mov    $0x4,%edx
  80042134f8:	48 89 cf             	mov    %rcx,%rdi
  80042134fb:	ff d0                	callq  *%rax
  80042134fd:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213501:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213504:	e9 c3 00 00 00       	jmpq   80042135cc <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  8004213509:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421350d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213511:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213515:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213519:	ba 08 00 00 00       	mov    $0x8,%edx
  800421351e:	48 89 cf             	mov    %rcx,%rdi
  8004213521:	ff d0                	callq  *%rax
  8004213523:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213527:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421352a:	e9 9d 00 00 00       	jmpq   80042135cc <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  800421352f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213533:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213537:	48 89 d6             	mov    %rdx,%rsi
  800421353a:	48 89 c7             	mov    %rax,%rdi
  800421353d:	48 b8 f6 03 21 04 80 	movabs $0x80042103f6,%rax
  8004213544:	00 00 00 
  8004213547:	ff d0                	callq  *%rax
  8004213549:	48 89 c2             	mov    %rax,%rdx
  800421354c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213550:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004213553:	eb 77                	jmp    80042135cc <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  8004213555:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213559:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421355d:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213561:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213565:	ba 02 00 00 00       	mov    $0x2,%edx
  800421356a:	48 89 cf             	mov    %rcx,%rdi
  800421356d:	ff d0                	callq  *%rax
  800421356f:	48 0f bf d0          	movswq %ax,%rdx
  8004213573:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213577:	48 89 10             	mov    %rdx,(%rax)
		break;
  800421357a:	eb 50                	jmp    80042135cc <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  800421357c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213580:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213584:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213588:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421358c:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213591:	48 89 cf             	mov    %rcx,%rdi
  8004213594:	ff d0                	callq  *%rax
  8004213596:	48 63 d0             	movslq %eax,%rdx
  8004213599:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421359d:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042135a0:	eb 2a                	jmp    80042135cc <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  80042135a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042135a6:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042135aa:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042135ae:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042135b2:	ba 08 00 00 00       	mov    $0x8,%edx
  80042135b7:	48 89 cf             	mov    %rcx,%rdi
  80042135ba:	ff d0                	callq  *%rax
  80042135bc:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042135c0:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042135c3:	eb 07                	jmp    80042135cc <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  80042135c5:	b8 14 00 00 00       	mov    $0x14,%eax
  80042135ca:	eb 52                	jmp    800421361e <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  80042135cc:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  80042135d0:	75 47                	jne    8004213619 <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  80042135d2:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042135d6:	83 f8 01             	cmp    $0x1,%eax
  80042135d9:	7c 3d                	jl     8004213618 <_dwarf_frame_read_lsb_encoded+0x212>
  80042135db:	83 f8 04             	cmp    $0x4,%eax
  80042135de:	7e 0a                	jle    80042135ea <_dwarf_frame_read_lsb_encoded+0x1e4>
  80042135e0:	83 e8 09             	sub    $0x9,%eax
  80042135e3:	83 f8 03             	cmp    $0x3,%eax
  80042135e6:	77 30                	ja     8004213618 <_dwarf_frame_read_lsb_encoded+0x212>
  80042135e8:	eb 17                	jmp    8004213601 <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  80042135ea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042135ee:	48 8b 10             	mov    (%rax),%rdx
  80042135f1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042135f5:	48 01 c2             	add    %rax,%rdx
  80042135f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042135fc:	48 89 10             	mov    %rdx,(%rax)
			break;
  80042135ff:	eb 18                	jmp    8004213619 <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  8004213601:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213605:	48 8b 10             	mov    (%rax),%rdx
  8004213608:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421360c:	48 01 c2             	add    %rax,%rdx
  800421360f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213613:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004213616:	eb 01                	jmp    8004213619 <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  8004213618:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004213619:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421361e:	c9                   	leaveq 
  800421361f:	c3                   	retq   

0000008004213620 <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  8004213620:	55                   	push   %rbp
  8004213621:	48 89 e5             	mov    %rsp,%rbp
  8004213624:	48 83 ec 50          	sub    $0x50,%rsp
  8004213628:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421362c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004213630:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  8004213634:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213638:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421363c:	48 85 c0             	test   %rax,%rax
  800421363f:	74 0f                	je     8004213650 <_dwarf_frame_parse_lsb_cie_augment+0x30>
  8004213641:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213645:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213649:	0f b6 00             	movzbl (%rax),%eax
  800421364c:	3c 7a                	cmp    $0x7a,%al
  800421364e:	74 35                	je     8004213685 <_dwarf_frame_parse_lsb_cie_augment+0x65>
  8004213650:	48 b9 68 a6 21 04 80 	movabs $0x800421a668,%rcx
  8004213657:	00 00 00 
  800421365a:	48 ba e7 a4 21 04 80 	movabs $0x800421a4e7,%rdx
  8004213661:	00 00 00 
  8004213664:	be 4a 02 00 00       	mov    $0x24a,%esi
  8004213669:	48 bf fc a4 21 04 80 	movabs $0x800421a4fc,%rdi
  8004213670:	00 00 00 
  8004213673:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213678:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800421367f:	00 00 00 
  8004213682:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  8004213685:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213689:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421368d:	48 83 c0 01          	add    $0x1,%rax
  8004213691:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  8004213695:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213699:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421369d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  80042136a1:	e9 af 00 00 00       	jmpq   8004213755 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  80042136a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042136aa:	0f b6 00             	movzbl (%rax),%eax
  80042136ad:	0f b6 c0             	movzbl %al,%eax
  80042136b0:	83 f8 50             	cmp    $0x50,%eax
  80042136b3:	74 18                	je     80042136cd <_dwarf_frame_parse_lsb_cie_augment+0xad>
  80042136b5:	83 f8 52             	cmp    $0x52,%eax
  80042136b8:	74 77                	je     8004213731 <_dwarf_frame_parse_lsb_cie_augment+0x111>
  80042136ba:	83 f8 4c             	cmp    $0x4c,%eax
  80042136bd:	0f 85 86 00 00 00    	jne    8004213749 <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  80042136c3:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  80042136c8:	e9 83 00 00 00       	jmpq   8004213750 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  80042136cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042136d1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042136d5:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  80042136d9:	0f b6 00             	movzbl (%rax),%eax
  80042136dc:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  80042136df:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80042136e6:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042136e7:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  80042136ec:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  80042136f0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042136f4:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  80042136f8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042136fc:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004213700:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213704:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421370a:	48 89 c7             	mov    %rax,%rdi
  800421370d:	48 b8 06 34 21 04 80 	movabs $0x8004213406,%rax
  8004213714:	00 00 00 
  8004213717:	ff d0                	callq  *%rax
  8004213719:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  800421371c:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004213720:	74 05                	je     8004213727 <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  8004213722:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004213725:	eb 42                	jmp    8004213769 <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  8004213727:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421372b:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  800421372f:	eb 1f                	jmp    8004213750 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  8004213731:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213735:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213739:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  800421373d:	0f b6 10             	movzbl (%rax),%edx
  8004213740:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213744:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  8004213747:	eb 07                	jmp    8004213750 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004213749:	b8 14 00 00 00       	mov    $0x14,%eax
  800421374e:	eb 19                	jmp    8004213769 <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  8004213750:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  8004213755:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213759:	0f b6 00             	movzbl (%rax),%eax
  800421375c:	84 c0                	test   %al,%al
  800421375e:	0f 85 42 ff ff ff    	jne    80042136a6 <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  8004213764:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213769:	c9                   	leaveq 
  800421376a:	c3                   	retq   

000000800421376b <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  800421376b:	55                   	push   %rbp
  800421376c:	48 89 e5             	mov    %rsp,%rbp
  800421376f:	48 83 ec 60          	sub    $0x60,%rsp
  8004213773:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213777:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421377b:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421377f:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004213783:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  8004213787:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  800421378c:	75 35                	jne    80042137c3 <_dwarf_frame_set_cie+0x58>
  800421378e:	48 b9 9d a6 21 04 80 	movabs $0x800421a69d,%rcx
  8004213795:	00 00 00 
  8004213798:	48 ba e7 a4 21 04 80 	movabs $0x800421a4e7,%rdx
  800421379f:	00 00 00 
  80042137a2:	be 7b 02 00 00       	mov    $0x27b,%esi
  80042137a7:	48 bf fc a4 21 04 80 	movabs $0x800421a4fc,%rdi
  80042137ae:	00 00 00 
  80042137b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042137b6:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042137bd:	00 00 00 
  80042137c0:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  80042137c3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042137c7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  80042137cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137cf:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042137d3:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  80042137d6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042137da:	48 8b 10             	mov    (%rax),%rdx
  80042137dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137e1:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  80042137e5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042137e9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042137ed:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042137f1:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042137f5:	48 89 d1             	mov    %rdx,%rcx
  80042137f8:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042137fc:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213801:	48 89 cf             	mov    %rcx,%rdi
  8004213804:	ff d0                	callq  *%rax
  8004213806:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  800421380a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421380f:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004213813:	75 2e                	jne    8004213843 <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  8004213815:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  800421381c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213820:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213824:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213828:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421382c:	48 89 d1             	mov    %rdx,%rcx
  800421382f:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213833:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213838:	48 89 cf             	mov    %rcx,%rdi
  800421383b:	ff d0                	callq  *%rax
  800421383d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213841:	eb 07                	jmp    800421384a <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  8004213843:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  800421384a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421384e:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004213852:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213856:	48 8b 00             	mov    (%rax),%rax
  8004213859:	48 29 c2             	sub    %rax,%rdx
  800421385c:	48 89 d0             	mov    %rdx,%rax
  800421385f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213863:	73 0a                	jae    800421386f <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004213865:	b8 12 00 00 00       	mov    $0x12,%eax
  800421386a:	e9 5d 03 00 00       	jmpq   8004213bcc <_dwarf_frame_set_cie+0x461>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  800421386f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213873:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213877:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421387b:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421387f:	48 89 d1             	mov    %rdx,%rcx
  8004213882:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213885:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213889:	48 89 cf             	mov    %rcx,%rdi
  800421388c:	ff d0                	callq  *%rax
	cie->cie_length = length;
  800421388e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213892:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213896:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  800421389a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421389e:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042138a2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042138a6:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042138aa:	48 89 d1             	mov    %rdx,%rcx
  80042138ad:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042138b1:	ba 01 00 00 00       	mov    $0x1,%edx
  80042138b6:	48 89 cf             	mov    %rcx,%rdi
  80042138b9:	ff d0                	callq  *%rax
  80042138bb:	89 c2                	mov    %eax,%edx
  80042138bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042138c1:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  80042138c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042138c9:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  80042138cd:	66 83 f8 01          	cmp    $0x1,%ax
  80042138d1:	74 26                	je     80042138f9 <_dwarf_frame_set_cie+0x18e>
  80042138d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042138d7:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  80042138db:	66 83 f8 03          	cmp    $0x3,%ax
  80042138df:	74 18                	je     80042138f9 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  80042138e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042138e5:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  80042138e9:	66 83 f8 04          	cmp    $0x4,%ax
  80042138ed:	74 0a                	je     80042138f9 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  80042138ef:	b8 16 00 00 00       	mov    $0x16,%eax
  80042138f4:	e9 d3 02 00 00       	jmpq   8004213bcc <_dwarf_frame_set_cie+0x461>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042138f9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042138fd:	48 8b 10             	mov    (%rax),%rdx
  8004213900:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213904:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213908:	48 01 d0             	add    %rdx,%rax
  800421390b:	48 89 c2             	mov    %rax,%rdx
  800421390e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213912:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004213916:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421391a:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421391e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  8004213922:	90                   	nop
  8004213923:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213927:	48 8b 00             	mov    (%rax),%rax
  800421392a:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800421392e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213932:	48 89 0a             	mov    %rcx,(%rdx)
  8004213935:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213939:	48 01 d0             	add    %rdx,%rax
  800421393c:	0f b6 00             	movzbl (%rax),%eax
  800421393f:	84 c0                	test   %al,%al
  8004213941:	75 e0                	jne    8004213923 <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004213943:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213947:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421394b:	0f b6 00             	movzbl (%rax),%eax
  800421394e:	84 c0                	test   %al,%al
  8004213950:	74 48                	je     800421399a <_dwarf_frame_set_cie+0x22f>
  8004213952:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213956:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421395a:	0f b6 00             	movzbl (%rax),%eax
  800421395d:	3c 7a                	cmp    $0x7a,%al
  800421395f:	74 39                	je     800421399a <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004213961:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213965:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213969:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800421396d:	75 07                	jne    8004213976 <_dwarf_frame_set_cie+0x20b>
  800421396f:	b8 04 00 00 00       	mov    $0x4,%eax
  8004213974:	eb 05                	jmp    800421397b <_dwarf_frame_set_cie+0x210>
  8004213976:	b8 0c 00 00 00       	mov    $0xc,%eax
  800421397b:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  800421397e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213982:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004213986:	48 01 c2             	add    %rax,%rdx
  8004213989:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421398d:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  8004213990:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213995:	e9 32 02 00 00       	jmpq   8004213bcc <_dwarf_frame_set_cie+0x461>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  800421399a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421399e:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042139a2:	48 be a5 a6 21 04 80 	movabs $0x800421a6a5,%rsi
  80042139a9:	00 00 00 
  80042139ac:	48 89 c7             	mov    %rax,%rdi
  80042139af:	48 b8 ad fd 20 04 80 	movabs $0x800420fdad,%rax
  80042139b6:	00 00 00 
  80042139b9:	ff d0                	callq  *%rax
  80042139bb:	48 85 c0             	test   %rax,%rax
  80042139be:	74 28                	je     80042139e8 <_dwarf_frame_set_cie+0x27d>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  80042139c0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042139c4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042139c8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042139cc:	8b 52 28             	mov    0x28(%rdx),%edx
  80042139cf:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042139d3:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  80042139d7:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042139db:	48 89 cf             	mov    %rcx,%rdi
  80042139de:	ff d0                	callq  *%rax
  80042139e0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042139e4:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  80042139e8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042139ec:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042139f0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042139f4:	48 89 d6             	mov    %rdx,%rsi
  80042139f7:	48 89 c7             	mov    %rax,%rdi
  80042139fa:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  8004213a01:	00 00 00 
  8004213a04:	ff d0                	callq  *%rax
  8004213a06:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213a0a:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213a0e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a12:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213a16:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213a1a:	48 89 d6             	mov    %rdx,%rsi
  8004213a1d:	48 89 c7             	mov    %rax,%rdi
  8004213a20:	48 b8 f6 03 21 04 80 	movabs $0x80042103f6,%rax
  8004213a27:	00 00 00 
  8004213a2a:	ff d0                	callq  *%rax
  8004213a2c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213a30:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004213a34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a38:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004213a3c:	66 83 f8 01          	cmp    $0x1,%ax
  8004213a40:	75 2b                	jne    8004213a6d <_dwarf_frame_set_cie+0x302>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004213a42:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a46:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213a4a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213a4e:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213a52:	48 89 d1             	mov    %rdx,%rcx
  8004213a55:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213a59:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213a5e:	48 89 cf             	mov    %rcx,%rdi
  8004213a61:	ff d0                	callq  *%rax
  8004213a63:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213a67:	48 89 42 48          	mov    %rax,0x48(%rdx)
  8004213a6b:	eb 26                	jmp    8004213a93 <_dwarf_frame_set_cie+0x328>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213a6d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a71:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213a75:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213a79:	48 89 d6             	mov    %rdx,%rsi
  8004213a7c:	48 89 c7             	mov    %rax,%rdi
  8004213a7f:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  8004213a86:	00 00 00 
  8004213a89:	ff d0                	callq  *%rax
  8004213a8b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213a8f:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  8004213a93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a97:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213a9b:	0f b6 00             	movzbl (%rax),%eax
  8004213a9e:	3c 7a                	cmp    $0x7a,%al
  8004213aa0:	0f 85 93 00 00 00    	jne    8004213b39 <_dwarf_frame_set_cie+0x3ce>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213aa6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213aaa:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213aae:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213ab2:	48 89 d6             	mov    %rdx,%rsi
  8004213ab5:	48 89 c7             	mov    %rax,%rdi
  8004213ab8:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  8004213abf:	00 00 00 
  8004213ac2:	ff d0                	callq  *%rax
  8004213ac4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213ac8:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213acc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213ad0:	48 8b 10             	mov    (%rax),%rdx
  8004213ad3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ad7:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213adb:	48 01 d0             	add    %rdx,%rax
  8004213ade:	48 89 c2             	mov    %rax,%rdx
  8004213ae1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ae5:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004213ae9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213aed:	48 8b 10             	mov    (%rax),%rdx
  8004213af0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213af4:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004213af8:	48 01 c2             	add    %rax,%rdx
  8004213afb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213aff:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004213b02:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b06:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004213b0a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004213b0e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004213b12:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b16:	48 89 ce             	mov    %rcx,%rsi
  8004213b19:	48 89 c7             	mov    %rax,%rdi
  8004213b1c:	48 b8 20 36 21 04 80 	movabs $0x8004213620,%rax
  8004213b23:	00 00 00 
  8004213b26:	ff d0                	callq  *%rax
  8004213b28:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004213b2b:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213b2f:	74 08                	je     8004213b39 <_dwarf_frame_set_cie+0x3ce>
			return (ret);
  8004213b31:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213b34:	e9 93 00 00 00       	jmpq   8004213bcc <_dwarf_frame_set_cie+0x461>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213b39:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b3d:	48 8b 10             	mov    (%rax),%rdx
  8004213b40:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b44:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213b48:	48 01 d0             	add    %rdx,%rax
  8004213b4b:	48 89 c2             	mov    %rax,%rdx
  8004213b4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b52:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  8004213b56:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213b5a:	75 2a                	jne    8004213b86 <_dwarf_frame_set_cie+0x41b>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004213b5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b60:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213b64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213b68:	48 01 c2             	add    %rax,%rdx
  8004213b6b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b6f:	48 8b 00             	mov    (%rax),%rax
  8004213b72:	48 29 c2             	sub    %rax,%rdx
  8004213b75:	48 89 d0             	mov    %rdx,%rax
  8004213b78:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004213b7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b80:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004213b84:	eb 28                	jmp    8004213bae <_dwarf_frame_set_cie+0x443>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004213b86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b8a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213b8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213b92:	48 01 c2             	add    %rax,%rdx
  8004213b95:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b99:	48 8b 00             	mov    (%rax),%rax
  8004213b9c:	48 29 c2             	sub    %rax,%rdx
  8004213b9f:	48 89 d0             	mov    %rdx,%rax
  8004213ba2:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004213ba6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213baa:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004213bae:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213bb2:	48 8b 10             	mov    (%rax),%rdx
  8004213bb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213bb9:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004213bbd:	48 01 c2             	add    %rax,%rdx
  8004213bc0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213bc4:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004213bc7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213bcc:	c9                   	leaveq 
  8004213bcd:	c3                   	retq   

0000008004213bce <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004213bce:	55                   	push   %rbp
  8004213bcf:	48 89 e5             	mov    %rsp,%rbp
  8004213bd2:	48 83 ec 70          	sub    $0x70,%rsp
  8004213bd6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213bda:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004213bde:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004213be2:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004213be6:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004213bea:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  8004213bee:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213bf2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  8004213bf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213bfa:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213bfe:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213c01:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213c05:	48 8b 10             	mov    (%rax),%rdx
  8004213c08:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213c0c:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213c10:	48 01 d0             	add    %rdx,%rax
  8004213c13:	48 89 c2             	mov    %rax,%rdx
  8004213c16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c1a:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004213c1e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213c22:	48 8b 10             	mov    (%rax),%rdx
  8004213c25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c29:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004213c2d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213c31:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213c35:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213c39:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213c3d:	48 89 d1             	mov    %rdx,%rcx
  8004213c40:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213c44:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213c49:	48 89 cf             	mov    %rcx,%rdi
  8004213c4c:	ff d0                	callq  *%rax
  8004213c4e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004213c52:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213c57:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004213c5b:	75 2e                	jne    8004213c8b <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  8004213c5d:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004213c64:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213c68:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213c6c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213c70:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213c74:	48 89 d1             	mov    %rdx,%rcx
  8004213c77:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213c7b:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213c80:	48 89 cf             	mov    %rcx,%rdi
  8004213c83:	ff d0                	callq  *%rax
  8004213c85:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213c89:	eb 07                	jmp    8004213c92 <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  8004213c8b:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004213c92:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213c96:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004213c9a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213c9e:	48 8b 00             	mov    (%rax),%rax
  8004213ca1:	48 29 c2             	sub    %rax,%rdx
  8004213ca4:	48 89 d0             	mov    %rdx,%rax
  8004213ca7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213cab:	73 0a                	jae    8004213cb7 <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004213cad:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213cb2:	e9 ca 02 00 00       	jmpq   8004213f81 <_dwarf_frame_set_fde+0x3b3>
	}

	fde->fde_length = length;
  8004213cb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213cbb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213cbf:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004213cc3:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213cc7:	74 5e                	je     8004213d27 <_dwarf_frame_set_fde+0x159>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004213cc9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ccd:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213cd1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213cd5:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213cd9:	48 89 d1             	mov    %rdx,%rcx
  8004213cdc:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213ce0:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213ce5:	48 89 cf             	mov    %rcx,%rdi
  8004213ce8:	ff d0                	callq  *%rax
  8004213cea:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213cee:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004213cf2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213cf6:	48 8b 10             	mov    (%rax),%rdx
  8004213cf9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213cfd:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213d01:	48 29 c2             	sub    %rax,%rdx
  8004213d04:	48 89 d0             	mov    %rdx,%rax
  8004213d07:	48 83 e8 04          	sub    $0x4,%rax
  8004213d0b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004213d0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d13:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213d17:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004213d1b:	75 3d                	jne    8004213d5a <_dwarf_frame_set_fde+0x18c>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004213d1d:	b8 13 00 00 00       	mov    $0x13,%eax
  8004213d22:	e9 5a 02 00 00       	jmpq   8004213f81 <_dwarf_frame_set_fde+0x3b3>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  8004213d27:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d2b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213d2f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d33:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213d37:	48 89 d1             	mov    %rdx,%rcx
  8004213d3a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213d3d:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213d41:	48 89 cf             	mov    %rcx,%rdi
  8004213d44:	ff d0                	callq  *%rax
  8004213d46:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213d4a:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  8004213d4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d52:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213d56:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  8004213d5a:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213d5e:	0f 84 c9 00 00 00    	je     8004213e2d <_dwarf_frame_set_fde+0x25f>
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004213d64:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213d68:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213d6c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213d70:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213d73:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004213d77:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213d7b:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213d7f:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  8004213d83:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d87:	48 8b 40 38          	mov    0x38(%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213d8b:	48 89 c2             	mov    %rax,%rdx
  8004213d8e:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004213d92:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004213d96:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d9a:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004213d9e:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213da2:	48 89 c7             	mov    %rax,%rdi
  8004213da5:	48 b8 06 34 21 04 80 	movabs $0x8004213406,%rax
  8004213dac:	00 00 00 
  8004213daf:	ff d0                	callq  *%rax
  8004213db1:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004213db4:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213db8:	74 08                	je     8004213dc2 <_dwarf_frame_set_fde+0x1f4>
			return (ret);
  8004213dba:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213dbd:	e9 bf 01 00 00       	jmpq   8004213f81 <_dwarf_frame_set_fde+0x3b3>
		fde->fde_initloc = val;
  8004213dc2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213dc6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213dca:	48 89 50 30          	mov    %rdx,0x30(%rax)
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
  8004213dce:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213dd2:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213dd6:	44 0f b6 c0          	movzbl %al,%r8d
						    (uint8_t *)dbg->dbg_eh_offset,
  8004213dda:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213dde:	48 8b 40 38          	mov    0x38(%rax),%rax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213de2:	48 89 c2             	mov    %rax,%rdx
  8004213de5:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004213de9:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004213ded:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213df1:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004213df5:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213df9:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004213dff:	48 89 c7             	mov    %rax,%rdi
  8004213e02:	48 b8 06 34 21 04 80 	movabs $0x8004213406,%rax
  8004213e09:	00 00 00 
  8004213e0c:	ff d0                	callq  *%rax
  8004213e0e:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  8004213e11:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213e15:	74 08                	je     8004213e1f <_dwarf_frame_set_fde+0x251>
			return (ret);
  8004213e17:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213e1a:	e9 62 01 00 00       	jmpq   8004213f81 <_dwarf_frame_set_fde+0x3b3>
		fde->fde_adrange = val;
  8004213e1f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e27:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004213e2b:	eb 50                	jmp    8004213e7d <_dwarf_frame_set_fde+0x2af>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004213e2d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213e31:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213e35:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213e39:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213e3c:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004213e40:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004213e44:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213e48:	48 89 cf             	mov    %rcx,%rdi
  8004213e4b:	ff d0                	callq  *%rax
  8004213e4d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213e51:	48 89 42 30          	mov    %rax,0x30(%rdx)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004213e55:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213e59:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213e5d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213e61:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213e64:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004213e68:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004213e6c:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213e70:	48 89 cf             	mov    %rcx,%rdi
  8004213e73:	ff d0                	callq  *%rax
  8004213e75:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213e79:	48 89 42 38          	mov    %rax,0x38(%rdx)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004213e7d:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213e81:	74 6b                	je     8004213eee <_dwarf_frame_set_fde+0x320>
  8004213e83:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213e87:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213e8b:	0f b6 00             	movzbl (%rax),%eax
  8004213e8e:	3c 7a                	cmp    $0x7a,%al
  8004213e90:	75 5c                	jne    8004213eee <_dwarf_frame_set_fde+0x320>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213e92:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213e96:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213e9a:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004213e9e:	48 89 d6             	mov    %rdx,%rsi
  8004213ea1:	48 89 c7             	mov    %rax,%rdi
  8004213ea4:	48 b8 9a 04 21 04 80 	movabs $0x800421049a,%rax
  8004213eab:	00 00 00 
  8004213eae:	ff d0                	callq  *%rax
  8004213eb0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213eb4:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213eb8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213ebc:	48 8b 10             	mov    (%rax),%rdx
  8004213ebf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ec3:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213ec7:	48 01 d0             	add    %rdx,%rax
  8004213eca:	48 89 c2             	mov    %rax,%rdx
  8004213ecd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ed1:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  8004213ed5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213ed9:	48 8b 10             	mov    (%rax),%rdx
  8004213edc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ee0:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004213ee4:	48 01 c2             	add    %rax,%rdx
  8004213ee7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213eeb:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213eee:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213ef2:	48 8b 10             	mov    (%rax),%rdx
  8004213ef5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ef9:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213efd:	48 01 d0             	add    %rdx,%rax
  8004213f00:	48 89 c2             	mov    %rax,%rdx
  8004213f03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f07:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  8004213f0b:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213f0f:	75 2a                	jne    8004213f3b <_dwarf_frame_set_fde+0x36d>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  8004213f11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f15:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213f19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213f1d:	48 01 c2             	add    %rax,%rdx
  8004213f20:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213f24:	48 8b 00             	mov    (%rax),%rax
  8004213f27:	48 29 c2             	sub    %rax,%rdx
  8004213f2a:	48 89 d0             	mov    %rdx,%rax
  8004213f2d:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004213f31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f35:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004213f39:	eb 28                	jmp    8004213f63 <_dwarf_frame_set_fde+0x395>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  8004213f3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f3f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213f43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213f47:	48 01 c2             	add    %rax,%rdx
  8004213f4a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213f4e:	48 8b 00             	mov    (%rax),%rax
  8004213f51:	48 29 c2             	sub    %rax,%rdx
  8004213f54:	48 89 d0             	mov    %rdx,%rax
  8004213f57:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004213f5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f5f:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004213f63:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213f67:	48 8b 10             	mov    (%rax),%rdx
  8004213f6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f6e:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004213f72:	48 01 c2             	add    %rax,%rdx
  8004213f75:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213f79:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004213f7c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213f81:	c9                   	leaveq 
  8004213f82:	c3                   	retq   

0000008004213f83 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004213f83:	55                   	push   %rbp
  8004213f84:	48 89 e5             	mov    %rsp,%rbp
  8004213f87:	48 83 ec 20          	sub    $0x20,%rsp
  8004213f8b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213f8f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	Dwarf_Regtable3 *rt = &global_rt_table;
  8004213f93:	48 b8 c0 86 60 04 80 	movabs $0x80046086c0,%rax
  8004213f9a:	00 00 00 
  8004213f9d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (dbg->dbg_internal_reg_table != NULL)
  8004213fa1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213fa5:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004213fa9:	48 85 c0             	test   %rax,%rax
  8004213fac:	74 07                	je     8004213fb5 <_dwarf_frame_interal_table_init+0x32>
		return (DW_DLE_NONE);
  8004213fae:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213fb3:	eb 33                	jmp    8004213fe8 <_dwarf_frame_interal_table_init+0x65>

	rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004213fb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213fb9:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  8004213fbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213fc1:	66 89 50 18          	mov    %dx,0x18(%rax)
	rt->rt3_rules = global_rules;
  8004213fc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213fc9:	48 b9 c0 8f 60 04 80 	movabs $0x8004608fc0,%rcx
  8004213fd0:	00 00 00 
  8004213fd3:	48 89 48 20          	mov    %rcx,0x20(%rax)

	dbg->dbg_internal_reg_table = rt;
  8004213fd7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213fdb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213fdf:	48 89 50 58          	mov    %rdx,0x58(%rax)

	return (DW_DLE_NONE);
  8004213fe3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213fe8:	c9                   	leaveq 
  8004213fe9:	c3                   	retq   

0000008004213fea <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
		    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  8004213fea:	55                   	push   %rbp
  8004213feb:	48 89 e5             	mov    %rsp,%rbp
  8004213fee:	48 83 ec 60          	sub    $0x60,%rsp
  8004213ff2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213ff6:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  8004213ff9:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004213ffd:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  8004214001:	48 b8 c0 d6 22 04 80 	movabs $0x800422d6c0,%rax
  8004214008:	00 00 00 
  800421400b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  800421400f:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  8004214016:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421401a:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421401e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  8004214022:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214026:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421402a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421402e:	48 39 c2             	cmp    %rax,%rdx
  8004214031:	0f 86 fe 01 00 00    	jbe    8004214235 <_dwarf_get_next_fde+0x24b>
		entry_off = offset;
  8004214037:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421403b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  800421403f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214043:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214047:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421404b:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421404f:	48 89 d1             	mov    %rdx,%rcx
  8004214052:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004214056:	ba 04 00 00 00       	mov    $0x4,%edx
  800421405b:	48 89 cf             	mov    %rcx,%rdi
  800421405e:	ff d0                	callq  *%rax
  8004214060:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004214064:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214069:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421406d:	75 2e                	jne    800421409d <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  800421406f:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  8004214076:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421407a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421407e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214082:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214086:	48 89 d1             	mov    %rdx,%rcx
  8004214089:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  800421408d:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214092:	48 89 cf             	mov    %rcx,%rdi
  8004214095:	ff d0                	callq  *%rax
  8004214097:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421409b:	eb 07                	jmp    80042140a4 <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  800421409d:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  80042140a4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042140a8:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042140ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042140b0:	48 29 c2             	sub    %rax,%rdx
  80042140b3:	48 89 d0             	mov    %rdx,%rax
  80042140b6:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042140ba:	72 0d                	jb     80042140c9 <_dwarf_get_next_fde+0xdf>
  80042140bc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042140c1:	75 10                	jne    80042140d3 <_dwarf_get_next_fde+0xe9>
  80042140c3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042140c7:	75 0a                	jne    80042140d3 <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042140c9:	b8 12 00 00 00       	mov    $0x12,%eax
  80042140ce:	e9 67 01 00 00       	jmpq   800421423a <_dwarf_get_next_fde+0x250>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  80042140d3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042140d7:	74 11                	je     80042140ea <_dwarf_get_next_fde+0x100>
  80042140d9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042140de:	75 0a                	jne    80042140ea <_dwarf_get_next_fde+0x100>
			return(-1);
  80042140e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042140e5:	e9 50 01 00 00       	jmpq   800421423a <_dwarf_get_next_fde+0x250>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  80042140ea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042140ee:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042140f2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042140f6:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042140fa:	48 89 d1             	mov    %rdx,%rcx
  80042140fd:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214100:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004214104:	48 89 cf             	mov    %rcx,%rdi
  8004214107:	ff d0                	callq  *%rax
  8004214109:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  800421410d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004214111:	74 79                	je     800421418c <_dwarf_get_next_fde+0x1a2>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  8004214113:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004214118:	75 32                	jne    800421414c <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  800421411a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421411e:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004214122:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214126:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800421412a:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800421412e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214132:	49 89 f8             	mov    %rdi,%r8
  8004214135:	48 89 c7             	mov    %rax,%rdi
  8004214138:	48 b8 6b 37 21 04 80 	movabs $0x800421376b,%rax
  800421413f:	00 00 00 
  8004214142:	ff d0                	callq  *%rax
  8004214144:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004214147:	e9 c8 00 00 00       	jmpq   8004214214 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  800421414c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214150:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004214154:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004214158:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421415c:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214160:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214164:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214168:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421416c:	4d 89 c1             	mov    %r8,%r9
  800421416f:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004214175:	48 89 c7             	mov    %rax,%rdi
  8004214178:	48 b8 ce 3b 21 04 80 	movabs $0x8004213bce,%rax
  800421417f:	00 00 00 
  8004214182:	ff d0                	callq  *%rax
  8004214184:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004214187:	e9 88 00 00 00       	jmpq   8004214214 <_dwarf_get_next_fde+0x22a>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  800421418c:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004214190:	75 0b                	jne    800421419d <_dwarf_get_next_fde+0x1b3>
  8004214192:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214197:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800421419b:	74 0d                	je     80042141aa <_dwarf_get_next_fde+0x1c0>
  800421419d:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  80042141a1:	75 36                	jne    80042141d9 <_dwarf_get_next_fde+0x1ef>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  80042141a3:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  80042141a8:	75 2f                	jne    80042141d9 <_dwarf_get_next_fde+0x1ef>
				ret = _dwarf_frame_set_cie(dbg, ds,
  80042141aa:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042141ae:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042141b2:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042141b6:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80042141ba:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80042141be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042141c2:	49 89 f8             	mov    %rdi,%r8
  80042141c5:	48 89 c7             	mov    %rax,%rdi
  80042141c8:	48 b8 6b 37 21 04 80 	movabs $0x800421376b,%rax
  80042141cf:	00 00 00 
  80042141d2:	ff d0                	callq  *%rax
  80042141d4:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042141d7:	eb 3b                	jmp    8004214214 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  80042141d9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042141dd:	4c 8b 40 08          	mov    0x8(%rax),%r8
  80042141e1:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80042141e5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042141e9:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042141ed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042141f1:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042141f5:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042141f9:	4d 89 c1             	mov    %r8,%r9
  80042141fc:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004214202:	48 89 c7             	mov    %rax,%rdi
  8004214205:	48 b8 ce 3b 21 04 80 	movabs $0x8004213bce,%rax
  800421420c:	00 00 00 
  800421420f:	ff d0                	callq  *%rax
  8004214211:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004214214:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004214218:	74 07                	je     8004214221 <_dwarf_get_next_fde+0x237>
			return(-1);
  800421421a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421421f:	eb 19                	jmp    800421423a <_dwarf_get_next_fde+0x250>

		offset = entry_off;
  8004214221:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214225:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  8004214229:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421422d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214231:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004214235:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421423a:	c9                   	leaveq 
  800421423b:	c3                   	retq   

000000800421423c <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  800421423c:	55                   	push   %rbp
  800421423d:	48 89 e5             	mov    %rsp,%rbp
  8004214240:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004214244:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214248:	89 f0                	mov    %esi,%eax
  800421424a:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Half old_value;

	old_value = dbg->dbg_frame_cfa_value;
  800421424e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214252:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004214256:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
	dbg->dbg_frame_cfa_value = value;
  800421425a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421425e:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004214262:	66 89 50 4c          	mov    %dx,0x4c(%rax)

	return (old_value);
  8004214266:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  800421426a:	c9                   	leaveq 
  800421426b:	c3                   	retq   

000000800421426c <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  800421426c:	55                   	push   %rbp
  800421426d:	48 89 e5             	mov    %rsp,%rbp
  8004214270:	48 83 ec 10          	sub    $0x10,%rsp
  8004214274:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004214278:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  800421427c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214281:	75 0a                	jne    800421428d <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004214283:	b8 01 00 00 00       	mov    $0x1,%eax
  8004214288:	e9 85 00 00 00       	jmpq   8004214312 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  800421428d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214291:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004214295:	48 85 c0             	test   %rax,%rax
  8004214298:	75 25                	jne    80042142bf <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  800421429a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421429e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042142a2:	48 89 d6             	mov    %rdx,%rsi
  80042142a5:	48 89 c7             	mov    %rax,%rdi
  80042142a8:	48 b8 83 3f 21 04 80 	movabs $0x8004213f83,%rax
  80042142af:	00 00 00 
  80042142b2:	ff d0                	callq  *%rax
  80042142b4:	85 c0                	test   %eax,%eax
  80042142b6:	74 07                	je     80042142bf <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  80042142b8:	b8 01 00 00 00       	mov    $0x1,%eax
  80042142bd:	eb 53                	jmp    8004214312 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  80042142bf:	48 bf c0 d6 22 04 80 	movabs $0x800422d6c0,%rdi
  80042142c6:	00 00 00 
  80042142c9:	48 b8 38 1d 21 04 80 	movabs $0x8004211d38,%rax
  80042142d0:	00 00 00 
  80042142d3:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  80042142d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042142d9:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80042142e0:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  80042142e1:	48 b8 c0 d6 22 04 80 	movabs $0x800422d6c0,%rax
  80042142e8:	00 00 00 
  80042142eb:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042142ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042142f3:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  80042142f7:	48 b8 c0 d6 22 04 80 	movabs $0x800422d6c0,%rax
  80042142fe:	00 00 00 
  8004214301:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214305:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214309:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  800421430d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214312:	c9                   	leaveq 
  8004214313:	c3                   	retq   

0000008004214314 <_dwarf_lineno_run_program>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004214314:	55                   	push   %rbp
  8004214315:	48 89 e5             	mov    %rsp,%rbp
  8004214318:	53                   	push   %rbx
  8004214319:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  8004214320:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  8004214324:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  8004214328:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  800421432f:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  8004214336:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  800421433d:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  8004214344:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214348:	48 83 c0 48          	add    $0x48,%rax
  800421434c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  8004214350:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214357:	00 
  8004214358:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  800421435f:	00 
  8004214360:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004214367:	00 
  8004214368:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800421436f:	00 
  8004214370:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214374:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004214378:	0f b6 c0             	movzbl %al,%eax
  800421437b:	89 45 cc             	mov    %eax,-0x34(%rbp)
  800421437e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004214385:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  800421438c:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004214393:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  800421439a:	e9 0a 05 00 00       	jmpq   80042148a9 <_dwarf_lineno_run_program+0x595>
		if (*p == 0) {
  800421439f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042143a6:	0f b6 00             	movzbl (%rax),%eax
  80042143a9:	84 c0                	test   %al,%al
  80042143ab:	0f 85 78 01 00 00    	jne    8004214529 <_dwarf_lineno_run_program+0x215>

			/*
			 * Extended Opcodes.
			 */

			p++;
  80042143b1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042143b8:	48 83 c0 01          	add    $0x1,%rax
  80042143bc:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  80042143c3:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042143ca:	48 89 c7             	mov    %rax,%rdi
  80042143cd:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  80042143d4:	00 00 00 
  80042143d7:	ff d0                	callq  *%rax
  80042143d9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			switch (*p) {
  80042143dd:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042143e4:	0f b6 00             	movzbl (%rax),%eax
  80042143e7:	0f b6 c0             	movzbl %al,%eax
  80042143ea:	83 f8 02             	cmp    $0x2,%eax
  80042143ed:	74 7a                	je     8004214469 <_dwarf_lineno_run_program+0x155>
  80042143ef:	83 f8 03             	cmp    $0x3,%eax
  80042143f2:	0f 84 b3 00 00 00    	je     80042144ab <_dwarf_lineno_run_program+0x197>
  80042143f8:	83 f8 01             	cmp    $0x1,%eax
  80042143fb:	0f 85 09 01 00 00    	jne    800421450a <_dwarf_lineno_run_program+0x1f6>
			case DW_LNE_end_sequence:
				p++;
  8004214401:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214408:	48 83 c0 01          	add    $0x1,%rax
  800421440c:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				end_sequence = 1;
  8004214413:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				RESET_REGISTERS;
  800421441a:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214421:	00 
  8004214422:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  8004214429:	00 
  800421442a:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004214431:	00 
  8004214432:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004214439:	00 
  800421443a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421443e:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004214442:	0f b6 c0             	movzbl %al,%eax
  8004214445:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004214448:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  800421444f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004214456:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  800421445d:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  8004214464:	e9 bb 00 00 00       	jmpq   8004214524 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_set_address:
				p++;
  8004214469:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214470:	48 83 c0 01          	add    $0x1,%rax
  8004214474:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  800421447b:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214482:	00 00 00 
  8004214485:	48 8b 00             	mov    (%rax),%rax
  8004214488:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421448c:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004214490:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004214494:	0f b6 ca             	movzbl %dl,%ecx
  8004214497:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  800421449e:	89 ce                	mov    %ecx,%esi
  80042144a0:	48 89 d7             	mov    %rdx,%rdi
  80042144a3:	ff d0                	callq  *%rax
  80042144a5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				break;
  80042144a9:	eb 79                	jmp    8004214524 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_define_file:
				p++;
  80042144ab:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042144b2:	48 83 c0 01          	add    $0x1,%rax
  80042144b6:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  80042144bd:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  80042144c4:	00 00 00 
  80042144c7:	48 8b 08             	mov    (%rax),%rcx
  80042144ca:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042144d1:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  80042144d8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042144dc:	49 89 c8             	mov    %rcx,%r8
  80042144df:	48 89 d1             	mov    %rdx,%rcx
  80042144e2:	ba 00 00 00 00       	mov    $0x0,%edx
  80042144e7:	48 89 c7             	mov    %rax,%rdi
  80042144ea:	48 b8 cc 48 21 04 80 	movabs $0x80042148cc,%rax
  80042144f1:	00 00 00 
  80042144f4:	ff d0                	callq  *%rax
  80042144f6:	89 45 a4             	mov    %eax,-0x5c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  80042144f9:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  80042144fd:	74 09                	je     8004214508 <_dwarf_lineno_run_program+0x1f4>
					goto prog_fail;
  80042144ff:	90                   	nop

	return (DW_DLE_NONE);

prog_fail:

	return (ret);
  8004214500:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004214503:	e9 ba 03 00 00       	jmpq   80042148c2 <_dwarf_lineno_run_program+0x5ae>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  8004214508:	eb 1a                	jmp    8004214524 <_dwarf_lineno_run_program+0x210>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  800421450a:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004214511:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214515:	48 01 d0             	add    %rdx,%rax
  8004214518:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  800421451f:	e9 85 03 00 00       	jmpq   80042148a9 <_dwarf_lineno_run_program+0x595>
  8004214524:	e9 80 03 00 00       	jmpq   80042148a9 <_dwarf_lineno_run_program+0x595>
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  8004214529:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214530:	0f b6 00             	movzbl (%rax),%eax
  8004214533:	84 c0                	test   %al,%al
  8004214535:	0f 84 3c 02 00 00    	je     8004214777 <_dwarf_lineno_run_program+0x463>
  800421453b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214542:	0f b6 10             	movzbl (%rax),%edx
  8004214545:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214549:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421454d:	38 c2                	cmp    %al,%dl
  800421454f:	0f 83 22 02 00 00    	jae    8004214777 <_dwarf_lineno_run_program+0x463>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  8004214555:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421455c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214560:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004214567:	0f b6 00             	movzbl (%rax),%eax
  800421456a:	0f b6 c0             	movzbl %al,%eax
  800421456d:	83 f8 0c             	cmp    $0xc,%eax
  8004214570:	0f 87 fb 01 00 00    	ja     8004214771 <_dwarf_lineno_run_program+0x45d>
  8004214576:	89 c0                	mov    %eax,%eax
  8004214578:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421457f:	00 
  8004214580:	48 b8 a8 a6 21 04 80 	movabs $0x800421a6a8,%rax
  8004214587:	00 00 00 
  800421458a:	48 01 d0             	add    %rdx,%rax
  800421458d:	48 8b 00             	mov    (%rax),%rax
  8004214590:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  8004214592:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214599:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421459d:	73 0a                	jae    80042145a9 <_dwarf_lineno_run_program+0x295>
  800421459f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042145a4:	e9 19 03 00 00       	jmpq   80042148c2 <_dwarf_lineno_run_program+0x5ae>
  80042145a9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145ad:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042145b1:	48 89 10             	mov    %rdx,(%rax)
  80042145b4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145b8:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80042145bf:	00 
  80042145c0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145c4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042145c8:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042145cc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145d0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042145d4:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042145d8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042145dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145e0:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042145e4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145e8:	8b 55 c8             	mov    -0x38(%rbp),%edx
  80042145eb:	89 50 28             	mov    %edx,0x28(%rax)
  80042145ee:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145f2:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042145f5:	89 50 2c             	mov    %edx,0x2c(%rax)
  80042145f8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145fc:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042145ff:	89 50 30             	mov    %edx,0x30(%rax)
  8004214602:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214606:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  800421460d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214611:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214615:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  800421461c:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
				prologue_end = 0;
  8004214623:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
				epilogue_begin = 0;
  800421462a:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  8004214631:	e9 3c 01 00 00       	jmpq   8004214772 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004214636:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421463d:	48 89 c7             	mov    %rax,%rdi
  8004214640:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004214647:	00 00 00 
  800421464a:	ff d0                	callq  *%rax
					li->li_minlen;
  800421464c:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004214650:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004214654:	0f b6 d2             	movzbl %dl,%edx
  8004214657:	48 0f af c2          	imul   %rdx,%rax
  800421465b:	48 01 45 e8          	add    %rax,-0x18(%rbp)
					li->li_minlen;
				break;
  800421465f:	e9 0e 01 00 00       	jmpq   8004214772 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  8004214664:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421466b:	48 89 c7             	mov    %rax,%rdi
  800421466e:	48 b8 19 05 21 04 80 	movabs $0x8004210519,%rax
  8004214675:	00 00 00 
  8004214678:	ff d0                	callq  *%rax
  800421467a:	48 01 45 d8          	add    %rax,-0x28(%rbp)
				break;
  800421467e:	e9 ef 00 00 00       	jmpq   8004214772 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  8004214683:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421468a:	48 89 c7             	mov    %rax,%rdi
  800421468d:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004214694:	00 00 00 
  8004214697:	ff d0                	callq  *%rax
  8004214699:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  800421469d:	e9 d0 00 00 00       	jmpq   8004214772 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  80042146a2:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042146a9:	48 89 c7             	mov    %rax,%rdi
  80042146ac:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  80042146b3:	00 00 00 
  80042146b6:	ff d0                	callq  *%rax
  80042146b8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
				break;
  80042146bc:	e9 b1 00 00 00       	jmpq   8004214772 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  80042146c1:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042146c5:	0f 94 c0             	sete   %al
  80042146c8:	0f b6 c0             	movzbl %al,%eax
  80042146cb:	89 45 cc             	mov    %eax,-0x34(%rbp)
				break;
  80042146ce:	e9 9f 00 00 00       	jmpq   8004214772 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  80042146d3:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
				break;
  80042146da:	e9 93 00 00 00       	jmpq   8004214772 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  80042146df:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042146e3:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042146e7:	0f b6 c0             	movzbl %al,%eax
  80042146ea:	ba ff 00 00 00       	mov    $0xff,%edx
  80042146ef:	89 d1                	mov    %edx,%ecx
  80042146f1:	29 c1                	sub    %eax,%ecx
  80042146f3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042146f7:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042146fb:	0f b6 d8             	movzbl %al,%ebx
  80042146fe:	89 c8                	mov    %ecx,%eax
  8004214700:	99                   	cltd   
  8004214701:	f7 fb                	idiv   %ebx
  8004214703:	89 c2                	mov    %eax,%edx
  8004214705:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214709:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  800421470d:	0f b6 c0             	movzbl %al,%eax
  8004214710:	0f af c2             	imul   %edx,%eax
  8004214713:	48 98                	cltq   
  8004214715:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004214719:	eb 57                	jmp    8004214772 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  800421471b:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214722:	00 00 00 
  8004214725:	48 8b 00             	mov    (%rax),%rax
  8004214728:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421472c:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004214733:	be 02 00 00 00       	mov    $0x2,%esi
  8004214738:	48 89 d7             	mov    %rdx,%rdi
  800421473b:	ff d0                	callq  *%rax
  800421473d:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004214741:	eb 2f                	jmp    8004214772 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  8004214743:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
				break;
  800421474a:	eb 26                	jmp    8004214772 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  800421474c:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
				break;
  8004214753:	eb 1d                	jmp    8004214772 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  8004214755:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421475c:	48 89 c7             	mov    %rax,%rdi
  800421475f:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004214766:	00 00 00 
  8004214769:	ff d0                	callq  *%rax
  800421476b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
				break;
  800421476f:	eb 01                	jmp    8004214772 <_dwarf_lineno_run_program+0x45e>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  8004214771:	90                   	nop
			}

		} else {
  8004214772:	e9 32 01 00 00       	jmpq   80042148a9 <_dwarf_lineno_run_program+0x595>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  8004214777:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421477b:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  800421477f:	0f be c8             	movsbl %al,%ecx
  8004214782:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214789:	0f b6 00             	movzbl (%rax),%eax
  800421478c:	0f b6 d0             	movzbl %al,%edx
  800421478f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214793:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214797:	0f b6 c0             	movzbl %al,%eax
  800421479a:	29 c2                	sub    %eax,%edx
  800421479c:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042147a0:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042147a4:	0f b6 f0             	movzbl %al,%esi
  80042147a7:	89 d0                	mov    %edx,%eax
  80042147a9:	99                   	cltd   
  80042147aa:	f7 fe                	idiv   %esi
  80042147ac:	89 d0                	mov    %edx,%eax
  80042147ae:	01 c8                	add    %ecx,%eax
  80042147b0:	48 98                	cltq   
  80042147b2:	48 01 45 d8          	add    %rax,-0x28(%rbp)
			address += ADDRESS(*p);
  80042147b6:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042147bd:	0f b6 00             	movzbl (%rax),%eax
  80042147c0:	0f b6 d0             	movzbl %al,%edx
  80042147c3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042147c7:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042147cb:	0f b6 c0             	movzbl %al,%eax
  80042147ce:	89 d1                	mov    %edx,%ecx
  80042147d0:	29 c1                	sub    %eax,%ecx
  80042147d2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042147d6:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042147da:	0f b6 d8             	movzbl %al,%ebx
  80042147dd:	89 c8                	mov    %ecx,%eax
  80042147df:	99                   	cltd   
  80042147e0:	f7 fb                	idiv   %ebx
  80042147e2:	89 c2                	mov    %eax,%edx
  80042147e4:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042147e8:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80042147ec:	0f b6 c0             	movzbl %al,%eax
  80042147ef:	0f af c2             	imul   %edx,%eax
  80042147f2:	48 98                	cltq   
  80042147f4:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			APPEND_ROW;
  80042147f8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042147ff:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004214803:	73 0a                	jae    800421480f <_dwarf_lineno_run_program+0x4fb>
  8004214805:	b8 00 00 00 00       	mov    $0x0,%eax
  800421480a:	e9 b3 00 00 00       	jmpq   80042148c2 <_dwarf_lineno_run_program+0x5ae>
  800421480f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214813:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214817:	48 89 10             	mov    %rdx,(%rax)
  800421481a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421481e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004214825:	00 
  8004214826:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421482a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421482e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004214832:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214836:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421483a:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421483e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214842:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214846:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421484a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421484e:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004214851:	89 50 28             	mov    %edx,0x28(%rax)
  8004214854:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214858:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800421485b:	89 50 2c             	mov    %edx,0x2c(%rax)
  800421485e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214862:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004214865:	89 50 30             	mov    %edx,0x30(%rax)
  8004214868:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421486c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004214873:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214877:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421487b:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  8004214882:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
			prologue_end = 0;
  8004214889:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
			epilogue_begin = 0;
  8004214890:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
			p++;
  8004214897:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421489e:	48 83 c0 01          	add    $0x1,%rax
  80042148a2:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  80042148a9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042148b0:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  80042148b7:	0f 82 e2 fa ff ff    	jb     800421439f <_dwarf_lineno_run_program+0x8b>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  80042148bd:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  80042148c2:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  80042148c9:	5b                   	pop    %rbx
  80042148ca:	5d                   	pop    %rbp
  80042148cb:	c3                   	retq   

00000080042148cc <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  80042148cc:	55                   	push   %rbp
  80042148cd:	48 89 e5             	mov    %rsp,%rbp
  80042148d0:	53                   	push   %rbx
  80042148d1:	48 83 ec 48          	sub    $0x48,%rsp
  80042148d5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042148d9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042148dd:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042148e1:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  80042148e5:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  80042148e9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042148ed:	48 8b 00             	mov    (%rax),%rax
  80042148f0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  80042148f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042148f8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	src += strlen(fname) + 1;
  80042148fc:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004214900:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214904:	48 89 c7             	mov    %rax,%rdi
  8004214907:	48 b8 83 f6 20 04 80 	movabs $0x800420f683,%rax
  800421490e:	00 00 00 
  8004214911:	ff d0                	callq  *%rax
  8004214913:	48 98                	cltq   
  8004214915:	48 83 c0 01          	add    $0x1,%rax
  8004214919:	48 01 d8             	add    %rbx,%rax
  800421491c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	_dwarf_decode_uleb128(&src);
  8004214920:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214924:	48 89 c7             	mov    %rax,%rdi
  8004214927:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  800421492e:	00 00 00 
  8004214931:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  8004214933:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214937:	48 89 c7             	mov    %rax,%rdi
  800421493a:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004214941:	00 00 00 
  8004214944:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  8004214946:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800421494a:	48 89 c7             	mov    %rax,%rdi
  800421494d:	48 b8 ab 05 21 04 80 	movabs $0x80042105ab,%rax
  8004214954:	00 00 00 
  8004214957:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  8004214959:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421495d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214961:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004214964:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214969:	48 83 c4 48          	add    $0x48,%rsp
  800421496d:	5b                   	pop    %rbx
  800421496e:	5d                   	pop    %rbp
  800421496f:	c3                   	retq   

0000008004214970 <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004214970:	55                   	push   %rbp
  8004214971:	48 89 e5             	mov    %rsp,%rbp
  8004214974:	53                   	push   %rbx
  8004214975:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  800421497c:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004214983:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  800421498a:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  8004214991:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004214998:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  800421499f:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  80042149a6:	00 
  80042149a7:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  80042149ae:	00 
  80042149af:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  80042149b6:	00 
  80042149b7:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80042149be:	00 
  80042149bf:	48 b8 10 a7 21 04 80 	movabs $0x800421a710,%rax
  80042149c6:	00 00 00 
  80042149c9:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  80042149cd:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  80042149d1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  80042149d5:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042149dc:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  80042149e3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  80042149e7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042149ec:	75 35                	jne    8004214a23 <_dwarf_lineno_init+0xb3>
  80042149ee:	48 b9 1c a7 21 04 80 	movabs $0x800421a71c,%rcx
  80042149f5:	00 00 00 
  80042149f8:	48 ba 27 a7 21 04 80 	movabs $0x800421a727,%rdx
  80042149ff:	00 00 00 
  8004214a02:	be 13 01 00 00       	mov    $0x113,%esi
  8004214a07:	48 bf 3c a7 21 04 80 	movabs $0x800421a73c,%rdi
  8004214a0e:	00 00 00 
  8004214a11:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214a16:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004214a1d:	00 00 00 
  8004214a20:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  8004214a23:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214a2a:	00 00 00 
  8004214a2d:	48 8b 00             	mov    (%rax),%rax
  8004214a30:	48 85 c0             	test   %rax,%rax
  8004214a33:	75 35                	jne    8004214a6a <_dwarf_lineno_init+0xfa>
  8004214a35:	48 b9 53 a7 21 04 80 	movabs $0x800421a753,%rcx
  8004214a3c:	00 00 00 
  8004214a3f:	48 ba 27 a7 21 04 80 	movabs $0x800421a727,%rdx
  8004214a46:	00 00 00 
  8004214a49:	be 14 01 00 00       	mov    $0x114,%esi
  8004214a4e:	48 bf 3c a7 21 04 80 	movabs $0x800421a73c,%rdi
  8004214a55:	00 00 00 
  8004214a58:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214a5d:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004214a64:	00 00 00 
  8004214a67:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004214a6a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214a6e:	48 89 c7             	mov    %rax,%rdi
  8004214a71:	48 b8 38 1d 21 04 80 	movabs $0x8004211d38,%rax
  8004214a78:	00 00 00 
  8004214a7b:	ff d0                	callq  *%rax
  8004214a7d:	85 c0                	test   %eax,%eax
  8004214a7f:	74 0a                	je     8004214a8b <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  8004214a81:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214a86:	e9 4f 04 00 00       	jmpq   8004214eda <_dwarf_lineno_init+0x56a>

	li = linfo;
  8004214a8b:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004214a92:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  8004214a96:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214a9d:	00 00 00 
  8004214aa0:	48 8b 00             	mov    (%rax),%rax
  8004214aa3:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214aa7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214aab:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214aaf:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214ab6:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214abb:	48 89 cf             	mov    %rcx,%rdi
  8004214abe:	ff d0                	callq  *%rax
  8004214ac0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  8004214ac4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214ac9:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004214acd:	75 37                	jne    8004214b06 <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  8004214acf:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004214ad6:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214add:	00 00 00 
  8004214ae0:	48 8b 00             	mov    (%rax),%rax
  8004214ae3:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214ae7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214aeb:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214aef:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214af6:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214afb:	48 89 cf             	mov    %rcx,%rdi
  8004214afe:	ff d0                	callq  *%rax
  8004214b00:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004214b04:	eb 07                	jmp    8004214b0d <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004214b06:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004214b0d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214b11:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214b15:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214b1c:	48 29 c2             	sub    %rax,%rdx
  8004214b1f:	48 89 d0             	mov    %rdx,%rax
  8004214b22:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004214b26:	73 0a                	jae    8004214b32 <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004214b28:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004214b2d:	e9 a8 03 00 00       	jmpq   8004214eda <_dwarf_lineno_init+0x56a>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  8004214b32:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214b36:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214b3a:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  8004214b3d:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004214b44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214b48:	48 01 d0             	add    %rdx,%rax
  8004214b4b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004214b4f:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214b56:	00 00 00 
  8004214b59:	48 8b 00             	mov    (%rax),%rax
  8004214b5c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214b60:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214b64:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214b68:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214b6f:	ba 02 00 00 00       	mov    $0x2,%edx
  8004214b74:	48 89 cf             	mov    %rcx,%rdi
  8004214b77:	ff d0                	callq  *%rax
  8004214b79:	89 c2                	mov    %eax,%edx
  8004214b7b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214b7f:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004214b83:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214b8a:	00 00 00 
  8004214b8d:	48 8b 00             	mov    (%rax),%rax
  8004214b90:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214b94:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214b98:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214b9c:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004214b9f:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214ba6:	48 89 cf             	mov    %rcx,%rdi
  8004214ba9:	ff d0                	callq  *%rax
  8004214bab:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214baf:	48 89 42 10          	mov    %rax,0x10(%rdx)
	hdroff = offset;
  8004214bb3:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214bba:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004214bbe:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214bc5:	00 00 00 
  8004214bc8:	48 8b 00             	mov    (%rax),%rax
  8004214bcb:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214bcf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214bd3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214bd7:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214bde:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214be3:	48 89 cf             	mov    %rcx,%rdi
  8004214be6:	ff d0                	callq  *%rax
  8004214be8:	89 c2                	mov    %eax,%edx
  8004214bea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214bee:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004214bf1:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214bf8:	00 00 00 
  8004214bfb:	48 8b 00             	mov    (%rax),%rax
  8004214bfe:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c02:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214c06:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214c0a:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214c11:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214c16:	48 89 cf             	mov    %rcx,%rdi
  8004214c19:	ff d0                	callq  *%rax
  8004214c1b:	89 c2                	mov    %eax,%edx
  8004214c1d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214c21:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004214c24:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214c2b:	00 00 00 
  8004214c2e:	48 8b 00             	mov    (%rax),%rax
  8004214c31:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c35:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214c39:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214c3d:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214c44:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214c49:	48 89 cf             	mov    %rcx,%rdi
  8004214c4c:	ff d0                	callq  *%rax
  8004214c4e:	89 c2                	mov    %eax,%edx
  8004214c50:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214c54:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  8004214c57:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214c5e:	00 00 00 
  8004214c61:	48 8b 00             	mov    (%rax),%rax
  8004214c64:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c68:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214c6c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214c70:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214c77:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214c7c:	48 89 cf             	mov    %rcx,%rdi
  8004214c7f:	ff d0                	callq  *%rax
  8004214c81:	89 c2                	mov    %eax,%edx
  8004214c83:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214c87:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  8004214c8a:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214c91:	00 00 00 
  8004214c94:	48 8b 00             	mov    (%rax),%rax
  8004214c97:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c9b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214c9f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214ca3:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214caa:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214caf:	48 89 cf             	mov    %rcx,%rdi
  8004214cb2:	ff d0                	callq  *%rax
  8004214cb4:	89 c2                	mov    %eax,%edx
  8004214cb6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214cba:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004214cbd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214cc1:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214cc5:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004214cc8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214ccc:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214cd0:	0f b6 c0             	movzbl %al,%eax
  8004214cd3:	83 e8 01             	sub    $0x1,%eax
  8004214cd6:	39 c2                	cmp    %eax,%edx
  8004214cd8:	7d 0c                	jge    8004214ce6 <_dwarf_lineno_init+0x376>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214cda:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214ce1:	e9 f1 01 00 00       	jmpq   8004214ed7 <_dwarf_lineno_init+0x567>
	}

	li->li_oplen = global_std_op;
  8004214ce6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214cea:	48 bb 00 96 60 04 80 	movabs $0x8004609600,%rbx
  8004214cf1:	00 00 00 
  8004214cf4:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004214cf8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004214cff:	eb 41                	jmp    8004214d42 <_dwarf_lineno_init+0x3d2>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004214d01:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d05:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214d09:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004214d0c:	48 98                	cltq   
  8004214d0e:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004214d12:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214d19:	00 00 00 
  8004214d1c:	48 8b 00             	mov    (%rax),%rax
  8004214d1f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d23:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214d27:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214d2b:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214d32:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214d37:	48 89 cf             	mov    %rcx,%rdi
  8004214d3a:	ff d0                	callq  *%rax
  8004214d3c:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004214d3e:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004214d42:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d46:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214d4a:	0f b6 c0             	movzbl %al,%eax
  8004214d4d:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004214d50:	7f af                	jg     8004214d01 <_dwarf_lineno_init+0x391>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  8004214d52:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214d59:	00 
	p = ds->ds_data + offset;
  8004214d5a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214d5e:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214d62:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214d69:	48 01 d0             	add    %rdx,%rax
  8004214d6c:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  8004214d73:	eb 1f                	jmp    8004214d94 <_dwarf_lineno_init+0x424>
		while (*p++ != '\0')
  8004214d75:	90                   	nop
  8004214d76:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214d7d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214d81:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  8004214d88:	0f b6 00             	movzbl (%rax),%eax
  8004214d8b:	84 c0                	test   %al,%al
  8004214d8d:	75 e7                	jne    8004214d76 <_dwarf_lineno_init+0x406>
			;
		length++;
  8004214d8f:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  8004214d94:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214d9b:	0f b6 00             	movzbl (%rax),%eax
  8004214d9e:	84 c0                	test   %al,%al
  8004214da0:	75 d3                	jne    8004214d75 <_dwarf_lineno_init+0x405>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  8004214da2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214da6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214daa:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  8004214dae:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214db5:	48 89 c2             	mov    %rax,%rdx
  8004214db8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214dbc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214dc0:	48 29 c2             	sub    %rax,%rdx
  8004214dc3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214dc7:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214dcb:	48 98                	cltq   
  8004214dcd:	48 39 c2             	cmp    %rax,%rdx
  8004214dd0:	7e 0c                	jle    8004214dde <_dwarf_lineno_init+0x46e>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214dd2:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214dd9:	e9 f9 00 00 00       	jmpq   8004214ed7 <_dwarf_lineno_init+0x567>
	}
	p++;
  8004214dde:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214de5:	48 83 c0 01          	add    $0x1,%rax
  8004214de9:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004214df0:	eb 3c                	jmp    8004214e2e <_dwarf_lineno_init+0x4be>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004214df2:	48 b8 a8 d6 22 04 80 	movabs $0x800422d6a8,%rax
  8004214df9:	00 00 00 
  8004214dfc:	48 8b 08             	mov    (%rax),%rcx
  8004214dff:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004214e06:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004214e0d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214e11:	49 89 c8             	mov    %rcx,%r8
  8004214e14:	48 89 d1             	mov    %rdx,%rcx
  8004214e17:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214e1c:	48 89 c7             	mov    %rax,%rdi
  8004214e1f:	48 b8 cc 48 21 04 80 	movabs $0x80042148cc,%rax
  8004214e26:	00 00 00 
  8004214e29:	ff d0                	callq  *%rax
  8004214e2b:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004214e2e:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214e35:	0f b6 00             	movzbl (%rax),%eax
  8004214e38:	84 c0                	test   %al,%al
  8004214e3a:	75 b6                	jne    8004214df2 <_dwarf_lineno_init+0x482>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  8004214e3c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214e43:	48 83 c0 01          	add    $0x1,%rax
  8004214e47:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  8004214e4e:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214e55:	48 89 c2             	mov    %rax,%rdx
  8004214e58:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214e5c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214e60:	48 29 c2             	sub    %rax,%rdx
  8004214e63:	48 89 d0             	mov    %rdx,%rax
  8004214e66:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  8004214e6a:	48 89 c2             	mov    %rax,%rdx
  8004214e6d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214e71:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214e75:	48 39 c2             	cmp    %rax,%rdx
  8004214e78:	74 09                	je     8004214e83 <_dwarf_lineno_init+0x513>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214e7a:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214e81:	eb 54                	jmp    8004214ed7 <_dwarf_lineno_init+0x567>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  8004214e83:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214e87:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214e8b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214e8f:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004214e93:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004214e9a:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  8004214ea1:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  8004214ea8:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004214eac:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214eb0:	4d 89 c1             	mov    %r8,%r9
  8004214eb3:	49 89 f8             	mov    %rdi,%r8
  8004214eb6:	48 89 c7             	mov    %rax,%rdi
  8004214eb9:	48 b8 14 43 21 04 80 	movabs $0x8004214314,%rax
  8004214ec0:	00 00 00 
  8004214ec3:	ff d0                	callq  *%rax
  8004214ec5:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  8004214ec8:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214ecc:	74 02                	je     8004214ed0 <_dwarf_lineno_init+0x560>
		goto fail_cleanup;
  8004214ece:	eb 07                	jmp    8004214ed7 <_dwarf_lineno_init+0x567>

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  8004214ed0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214ed5:	eb 03                	jmp    8004214eda <_dwarf_lineno_init+0x56a>
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  8004214ed7:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004214eda:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  8004214ee1:	5b                   	pop    %rbx
  8004214ee2:	5d                   	pop    %rbp
  8004214ee3:	c3                   	retq   

0000008004214ee4 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004214ee4:	55                   	push   %rbp
  8004214ee5:	48 89 e5             	mov    %rsp,%rbp
  8004214ee8:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004214eef:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004214ef6:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004214efd:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004214f04:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  8004214f0b:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004214f12:	00 
  8004214f13:	75 35                	jne    8004214f4a <dwarf_srclines+0x66>
  8004214f15:	48 b9 5f a7 21 04 80 	movabs $0x800421a75f,%rcx
  8004214f1c:	00 00 00 
  8004214f1f:	48 ba 27 a7 21 04 80 	movabs $0x800421a727,%rdx
  8004214f26:	00 00 00 
  8004214f29:	be 9a 01 00 00       	mov    $0x19a,%esi
  8004214f2e:	48 bf 3c a7 21 04 80 	movabs $0x800421a73c,%rdi
  8004214f35:	00 00 00 
  8004214f38:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214f3d:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004214f44:	00 00 00 
  8004214f47:	41 ff d0             	callq  *%r8
	assert(linebuf);
  8004214f4a:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004214f51:	00 
  8004214f52:	75 35                	jne    8004214f89 <dwarf_srclines+0xa5>
  8004214f54:	48 b9 63 a7 21 04 80 	movabs $0x800421a763,%rcx
  8004214f5b:	00 00 00 
  8004214f5e:	48 ba 27 a7 21 04 80 	movabs $0x800421a727,%rdx
  8004214f65:	00 00 00 
  8004214f68:	be 9b 01 00 00       	mov    $0x19b,%esi
  8004214f6d:	48 bf 3c a7 21 04 80 	movabs $0x800421a73c,%rdi
  8004214f74:	00 00 00 
  8004214f77:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214f7c:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004214f83:	00 00 00 
  8004214f86:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  8004214f89:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004214f90:	ba 88 00 00 00       	mov    $0x88,%edx
  8004214f95:	be 00 00 00 00       	mov    $0x0,%esi
  8004214f9a:	48 89 c7             	mov    %rax,%rdi
  8004214f9d:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004214fa4:	00 00 00 
  8004214fa7:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  8004214fa9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214fb0:	be 10 00 00 00       	mov    $0x10,%esi
  8004214fb5:	48 89 c7             	mov    %rax,%rdi
  8004214fb8:	48 b8 bd 18 21 04 80 	movabs $0x80042118bd,%rax
  8004214fbf:	00 00 00 
  8004214fc2:	ff d0                	callq  *%rax
  8004214fc4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214fc8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214fcd:	75 0a                	jne    8004214fd9 <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004214fcf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214fd4:	e9 84 00 00 00       	jmpq   800421505d <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  8004214fd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214fdd:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004214fe1:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8004214fe8:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  8004214fef:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004214ff6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214ffd:	49 89 f8             	mov    %rdi,%r8
  8004215000:	48 89 c7             	mov    %rax,%rdi
  8004215003:	48 b8 70 49 21 04 80 	movabs $0x8004214970,%rax
  800421500a:	00 00 00 
  800421500d:	ff d0                	callq  *%rax
  800421500f:	85 c0                	test   %eax,%eax
  8004215011:	74 07                	je     800421501a <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  8004215013:	b8 01 00 00 00       	mov    $0x1,%eax
  8004215018:	eb 43                	jmp    800421505d <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  800421501a:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004215021:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004215025:	48 89 10             	mov    %rdx,(%rax)
  8004215028:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421502c:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004215030:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215034:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215038:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421503c:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215040:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215044:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004215048:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421504c:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004215050:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215054:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  8004215058:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421505d:	c9                   	leaveq 
  800421505e:	c3                   	retq   

000000800421505f <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  800421505f:	55                   	push   %rbp
  8004215060:	48 89 e5             	mov    %rsp,%rbp
  8004215063:	48 83 ec 20          	sub    $0x20,%rsp
  8004215067:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  800421506b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004215072:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004215073:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800421507a:	eb 57                	jmp    80042150d3 <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  800421507c:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215083:	00 00 00 
  8004215086:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215089:	48 63 d2             	movslq %edx,%rdx
  800421508c:	48 c1 e2 05          	shl    $0x5,%rdx
  8004215090:	48 01 d0             	add    %rdx,%rax
  8004215093:	48 8b 00             	mov    (%rax),%rax
  8004215096:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421509a:	48 89 d6             	mov    %rdx,%rsi
  800421509d:	48 89 c7             	mov    %rax,%rdi
  80042150a0:	48 b8 51 f8 20 04 80 	movabs $0x800420f851,%rax
  80042150a7:	00 00 00 
  80042150aa:	ff d0                	callq  *%rax
  80042150ac:	85 c0                	test   %eax,%eax
  80042150ae:	75 1f                	jne    80042150cf <_dwarf_find_section+0x70>
			ret = (section_info + i);
  80042150b0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042150b3:	48 98                	cltq   
  80042150b5:	48 c1 e0 05          	shl    $0x5,%rax
  80042150b9:	48 89 c2             	mov    %rax,%rdx
  80042150bc:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  80042150c3:	00 00 00 
  80042150c6:	48 01 d0             	add    %rdx,%rax
  80042150c9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  80042150cd:	eb 0a                	jmp    80042150d9 <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  80042150cf:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042150d3:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042150d7:	7e a3                	jle    800421507c <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  80042150d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042150dd:	c9                   	leaveq 
  80042150de:	c3                   	retq   

00000080042150df <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  80042150df:	55                   	push   %rbp
  80042150e0:	48 89 e5             	mov    %rsp,%rbp
  80042150e3:	48 83 ec 40          	sub    $0x40,%rsp
  80042150e7:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  80042150eb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042150ef:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  80042150f3:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  80042150fa:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  80042150fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042150ff:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004215103:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215107:	48 01 d0             	add    %rdx,%rax
  800421510a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  800421510e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215112:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004215116:	0f b7 c0             	movzwl %ax,%eax
  8004215119:	48 c1 e0 06          	shl    $0x6,%rax
  800421511d:	48 89 c2             	mov    %rax,%rdx
  8004215120:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215124:	48 01 d0             	add    %rdx,%rax
  8004215127:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  800421512b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421512f:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004215133:	0f b7 c0             	movzwl %ax,%eax
  8004215136:	48 c1 e0 06          	shl    $0x6,%rax
  800421513a:	48 89 c2             	mov    %rax,%rdx
  800421513d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215141:	48 01 d0             	add    %rdx,%rax
  8004215144:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  8004215148:	e9 4b 02 00 00       	jmpq   8004215398 <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  800421514d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215151:	8b 00                	mov    (%rax),%eax
  8004215153:	89 c2                	mov    %eax,%edx
  8004215155:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215159:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800421515d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215161:	48 01 c8             	add    %rcx,%rax
  8004215164:	48 01 d0             	add    %rdx,%rax
  8004215167:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  800421516b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421516f:	48 be 6b a7 21 04 80 	movabs $0x800421a76b,%rsi
  8004215176:	00 00 00 
  8004215179:	48 89 c7             	mov    %rax,%rdi
  800421517c:	48 b8 51 f8 20 04 80 	movabs $0x800420f851,%rax
  8004215183:	00 00 00 
  8004215186:	ff d0                	callq  *%rax
  8004215188:	85 c0                	test   %eax,%eax
  800421518a:	75 4b                	jne    80042151d7 <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  800421518c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215190:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215197:	00 00 00 
  800421519a:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  800421519e:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  80042151a5:	00 00 00 
  80042151a8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042151ac:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  80042151b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042151b4:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042151b8:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  80042151bf:	00 00 00 
  80042151c2:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  80042151c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042151ca:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042151ce:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042151d2:	e9 bc 01 00 00       	jmpq   8004215393 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  80042151d7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042151db:	48 be 77 a7 21 04 80 	movabs $0x800421a777,%rsi
  80042151e2:	00 00 00 
  80042151e5:	48 89 c7             	mov    %rax,%rdi
  80042151e8:	48 b8 51 f8 20 04 80 	movabs $0x800420f851,%rax
  80042151ef:	00 00 00 
  80042151f2:	ff d0                	callq  *%rax
  80042151f4:	85 c0                	test   %eax,%eax
  80042151f6:	75 4b                	jne    8004215243 <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  80042151f8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042151fc:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215203:	00 00 00 
  8004215206:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  800421520a:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215211:	00 00 00 
  8004215214:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215218:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  800421521c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215220:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215224:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  800421522b:	00 00 00 
  800421522e:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  8004215232:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215236:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421523a:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421523e:	e9 50 01 00 00       	jmpq   8004215393 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  8004215243:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215247:	48 be 8f a7 21 04 80 	movabs $0x800421a78f,%rsi
  800421524e:	00 00 00 
  8004215251:	48 89 c7             	mov    %rax,%rdi
  8004215254:	48 b8 51 f8 20 04 80 	movabs $0x800420f851,%rax
  800421525b:	00 00 00 
  800421525e:	ff d0                	callq  *%rax
  8004215260:	85 c0                	test   %eax,%eax
  8004215262:	75 4b                	jne    80042152af <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  8004215264:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215268:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  800421526f:	00 00 00 
  8004215272:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  8004215276:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  800421527d:	00 00 00 
  8004215280:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215284:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  8004215288:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421528c:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215290:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215297:	00 00 00 
  800421529a:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  800421529e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042152a2:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042152a6:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042152aa:	e9 e4 00 00 00       	jmpq   8004215393 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  80042152af:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042152b3:	48 be 85 a7 21 04 80 	movabs $0x800421a785,%rsi
  80042152ba:	00 00 00 
  80042152bd:	48 89 c7             	mov    %rax,%rdi
  80042152c0:	48 b8 51 f8 20 04 80 	movabs $0x800420f851,%rax
  80042152c7:	00 00 00 
  80042152ca:	ff d0                	callq  *%rax
  80042152cc:	85 c0                	test   %eax,%eax
  80042152ce:	75 53                	jne    8004215323 <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  80042152d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042152d4:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042152d8:	48 89 c2             	mov    %rax,%rdx
  80042152db:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  80042152e2:	00 00 00 
  80042152e5:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  80042152e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042152ed:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042152f1:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  80042152f8:	00 00 00 
  80042152fb:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  80042152ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215303:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215307:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  800421530e:	00 00 00 
  8004215311:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  8004215315:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215319:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421531d:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215321:	eb 70                	jmp    8004215393 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  8004215323:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215327:	48 be 9b a7 21 04 80 	movabs $0x800421a79b,%rsi
  800421532e:	00 00 00 
  8004215331:	48 89 c7             	mov    %rax,%rdi
  8004215334:	48 b8 51 f8 20 04 80 	movabs $0x800420f851,%rax
  800421533b:	00 00 00 
  800421533e:	ff d0                	callq  *%rax
  8004215340:	85 c0                	test   %eax,%eax
  8004215342:	75 4f                	jne    8004215393 <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004215344:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215348:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  800421534f:	00 00 00 
  8004215352:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  8004215359:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215360:	00 00 00 
  8004215363:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215367:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  800421536e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215372:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215376:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  800421537d:	00 00 00 
  8004215380:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  8004215387:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421538b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421538f:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  8004215393:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  8004215398:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421539c:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042153a0:	0f 82 a7 fd ff ff    	jb     800421514d <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  80042153a6:	c9                   	leaveq 
  80042153a7:	c3                   	retq   

00000080042153a8 <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  80042153a8:	55                   	push   %rbp
  80042153a9:	48 89 e5             	mov    %rsp,%rbp
  80042153ac:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  80042153b3:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  80042153ba:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  80042153c1:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  80042153c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042153cd:	ba 14 00 00 00       	mov    $0x14,%edx
  80042153d2:	48 89 f7             	mov    %rsi,%rdi
  80042153d5:	48 89 d1             	mov    %rdx,%rcx
  80042153d8:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  80042153db:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  80042153e2:	00 
  80042153e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042153e7:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  80042153ee:	48 01 d0             	add    %rdx,%rax
  80042153f1:	48 83 e8 01          	sub    $0x1,%rax
  80042153f5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042153f9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042153fd:	ba 00 00 00 00       	mov    $0x0,%edx
  8004215402:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004215406:	48 89 d0             	mov    %rdx,%rax
  8004215409:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421540d:	48 29 c2             	sub    %rax,%rdx
  8004215410:	48 89 d0             	mov    %rdx,%rax
  8004215413:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  8004215417:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  800421541e:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004215422:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215426:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  800421542a:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004215431:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  8004215432:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  8004215439:	00 00 00 
  800421543c:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004215443:	75 11                	jne    8004215456 <read_section_headers+0xae>
		offset = ((Elf*)elfhdr)->e_shoff;
  8004215445:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421544c:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215450:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215454:	eb 26                	jmp    800421547c <read_section_headers+0xd4>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  8004215456:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421545d:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004215461:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215468:	48 01 c2             	add    %rax,%rdx
  800421546b:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004215472:	ff ff ff 
  8004215475:	48 01 d0             	add    %rdx,%rax
  8004215478:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  800421547c:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215483:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004215487:	0f b7 c0             	movzwl %ax,%eax
  800421548a:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  800421548d:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215494:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  8004215498:	0f b7 c0             	movzwl %ax,%eax
  800421549b:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  800421549e:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042154a5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  80042154a9:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042154ac:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  80042154b0:	48 63 f0             	movslq %eax,%rsi
  80042154b3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042154b7:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042154be:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042154c2:	48 89 c7             	mov    %rax,%rdi
  80042154c5:	48 b8 e7 5a 21 04 80 	movabs $0x8004215ae7,%rax
  80042154cc:	00 00 00 
  80042154cf:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  80042154d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042154d5:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042154d9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042154dd:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042154e3:	48 89 c2             	mov    %rax,%rdx
  80042154e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042154ea:	48 29 d0             	sub    %rdx,%rax
  80042154ed:	48 89 c2             	mov    %rax,%rdx
  80042154f0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042154f4:	48 01 d0             	add    %rdx,%rax
  80042154f7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  80042154fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215502:	eb 24                	jmp    8004215528 <read_section_headers+0x180>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004215504:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215507:	48 98                	cltq   
  8004215509:	48 c1 e0 06          	shl    $0x6,%rax
  800421550d:	48 89 c2             	mov    %rax,%rdx
  8004215510:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215514:	48 01 c2             	add    %rax,%rdx
  8004215517:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421551a:	48 98                	cltq   
  800421551c:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004215523:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004215524:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215528:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421552b:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  800421552e:	7c d4                	jl     8004215504 <read_section_headers+0x15c>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004215530:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215534:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004215538:	0f b7 c0             	movzwl %ax,%eax
  800421553b:	48 98                	cltq   
  800421553d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215544:	ff 
  8004215545:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  8004215549:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004215550:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004215554:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215558:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421555c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215560:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215564:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  800421556b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421556f:	48 01 c8             	add    %rcx,%rax
  8004215572:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215579:	48 89 c7             	mov    %rax,%rdi
  800421557c:	48 b8 e7 5a 21 04 80 	movabs $0x8004215ae7,%rax
  8004215583:	00 00 00 
  8004215586:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  8004215588:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421558c:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215590:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215594:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215598:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  800421559c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042155a0:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042155a6:	48 29 c2             	sub    %rax,%rdx
  80042155a9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042155ad:	48 01 c2             	add    %rax,%rdx
  80042155b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042155b4:	48 01 d0             	add    %rdx,%rax
  80042155b7:	48 89 45 90          	mov    %rax,-0x70(%rbp)

	for (i = 0; i < numSectionHeaders; i++)
  80042155bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042155c2:	e9 04 05 00 00       	jmpq   8004215acb <read_section_headers+0x723>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  80042155c7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042155ca:	48 98                	cltq   
  80042155cc:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042155d3:	ff 
  80042155d4:	8b 00                	mov    (%rax),%eax
  80042155d6:	89 c2                	mov    %eax,%edx
  80042155d8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042155dc:	48 01 d0             	add    %rdx,%rax
  80042155df:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  80042155e3:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042155ea:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042155ef:	48 85 c0             	test   %rax,%rax
  80042155f2:	74 35                	je     8004215629 <read_section_headers+0x281>
  80042155f4:	48 b9 a6 a7 21 04 80 	movabs $0x800421a7a6,%rcx
  80042155fb:	00 00 00 
  80042155fe:	48 ba bf a7 21 04 80 	movabs $0x800421a7bf,%rdx
  8004215605:	00 00 00 
  8004215608:	be 86 00 00 00       	mov    $0x86,%esi
  800421560d:	48 bf d4 a7 21 04 80 	movabs $0x800421a7d4,%rdi
  8004215614:	00 00 00 
  8004215617:	b8 00 00 00 00       	mov    $0x0,%eax
  800421561c:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004215623:	00 00 00 
  8004215626:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  8004215629:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004215630:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004215634:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215638:	48 be 6b a7 21 04 80 	movabs $0x800421a76b,%rsi
  800421563f:	00 00 00 
  8004215642:	48 89 c7             	mov    %rax,%rdi
  8004215645:	48 b8 51 f8 20 04 80 	movabs $0x800420f851,%rax
  800421564c:	00 00 00 
  800421564f:	ff d0                	callq  *%rax
  8004215651:	85 c0                	test   %eax,%eax
  8004215653:	0f 85 d8 00 00 00    	jne    8004215731 <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215659:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421565c:	48 98                	cltq   
  800421565e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215665:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215666:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421566a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421566d:	48 98                	cltq   
  800421566f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215676:	ff 
  8004215677:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421567b:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215682:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215686:	48 01 c8             	add    %rcx,%rax
  8004215689:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215690:	48 89 c7             	mov    %rax,%rdi
  8004215693:	48 b8 e7 5a 21 04 80 	movabs $0x8004215ae7,%rax
  800421569a:	00 00 00 
  800421569d:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421569f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042156a2:	48 98                	cltq   
  80042156a4:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042156ab:	ff 
  80042156ac:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042156b0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042156b3:	48 98                	cltq   
  80042156b5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042156bc:	ff 
  80042156bd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042156c1:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  80042156c5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042156c9:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042156cf:	48 29 c2             	sub    %rax,%rdx
  80042156d2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042156d6:	48 01 c2             	add    %rax,%rdx
  80042156d9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042156dd:	48 01 c2             	add    %rax,%rdx
  80042156e0:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  80042156e7:	00 00 00 
  80042156ea:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  80042156ee:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  80042156f5:	00 00 00 
  80042156f8:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042156fc:	48 89 c2             	mov    %rax,%rdx
  80042156ff:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215706:	00 00 00 
  8004215709:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  800421570d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215710:	48 98                	cltq   
  8004215712:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215719:	ff 
  800421571a:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421571e:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215725:	00 00 00 
  8004215728:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421572c:	e9 96 03 00 00       	jmpq   8004215ac7 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  8004215731:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215735:	48 be 77 a7 21 04 80 	movabs $0x800421a777,%rsi
  800421573c:	00 00 00 
  800421573f:	48 89 c7             	mov    %rax,%rdi
  8004215742:	48 b8 51 f8 20 04 80 	movabs $0x800420f851,%rax
  8004215749:	00 00 00 
  800421574c:	ff d0                	callq  *%rax
  800421574e:	85 c0                	test   %eax,%eax
  8004215750:	0f 85 de 00 00 00    	jne    8004215834 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215756:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215759:	48 98                	cltq   
  800421575b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215762:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215763:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215767:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421576a:	48 98                	cltq   
  800421576c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215773:	ff 
  8004215774:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215778:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  800421577f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215783:	48 01 c8             	add    %rcx,%rax
  8004215786:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421578d:	48 89 c7             	mov    %rax,%rdi
  8004215790:	48 b8 e7 5a 21 04 80 	movabs $0x8004215ae7,%rax
  8004215797:	00 00 00 
  800421579a:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421579c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421579f:	48 98                	cltq   
  80042157a1:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042157a8:	ff 
  80042157a9:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042157ad:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042157b0:	48 98                	cltq   
  80042157b2:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042157b9:	ff 
  80042157ba:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042157be:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042157c5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042157cc:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042157d2:	48 29 c2             	sub    %rax,%rdx
  80042157d5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042157d9:	48 01 c2             	add    %rax,%rdx
  80042157dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042157e0:	48 01 c2             	add    %rax,%rdx
  80042157e3:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  80042157ea:	00 00 00 
  80042157ed:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  80042157f1:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  80042157f8:	00 00 00 
  80042157fb:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042157ff:	48 89 c2             	mov    %rax,%rdx
  8004215802:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215809:	00 00 00 
  800421580c:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004215810:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215813:	48 98                	cltq   
  8004215815:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421581c:	ff 
  800421581d:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215821:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215828:	00 00 00 
  800421582b:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800421582f:	e9 93 02 00 00       	jmpq   8004215ac7 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_line"))
  8004215834:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215838:	48 be 8f a7 21 04 80 	movabs $0x800421a78f,%rsi
  800421583f:	00 00 00 
  8004215842:	48 89 c7             	mov    %rax,%rdi
  8004215845:	48 b8 51 f8 20 04 80 	movabs $0x800420f851,%rax
  800421584c:	00 00 00 
  800421584f:	ff d0                	callq  *%rax
  8004215851:	85 c0                	test   %eax,%eax
  8004215853:	0f 85 de 00 00 00    	jne    8004215937 <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215859:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421585c:	48 98                	cltq   
  800421585e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215865:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215866:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421586a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421586d:	48 98                	cltq   
  800421586f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215876:	ff 
  8004215877:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421587b:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215882:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215886:	48 01 c8             	add    %rcx,%rax
  8004215889:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215890:	48 89 c7             	mov    %rax,%rdi
  8004215893:	48 b8 e7 5a 21 04 80 	movabs $0x8004215ae7,%rax
  800421589a:	00 00 00 
  800421589d:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421589f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042158a2:	48 98                	cltq   
  80042158a4:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042158ab:	ff 
  80042158ac:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042158b0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042158b3:	48 98                	cltq   
  80042158b5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042158bc:	ff 
  80042158bd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042158c1:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  80042158c8:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042158cf:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042158d5:	48 29 c2             	sub    %rax,%rdx
  80042158d8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042158dc:	48 01 c2             	add    %rax,%rdx
  80042158df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042158e3:	48 01 c2             	add    %rax,%rdx
  80042158e6:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  80042158ed:	00 00 00 
  80042158f0:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  80042158f4:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  80042158fb:	00 00 00 
  80042158fe:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004215902:	48 89 c2             	mov    %rax,%rdx
  8004215905:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  800421590c:	00 00 00 
  800421590f:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004215913:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215916:	48 98                	cltq   
  8004215918:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421591f:	ff 
  8004215920:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215924:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  800421592b:	00 00 00 
  800421592e:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004215932:	e9 90 01 00 00       	jmpq   8004215ac7 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004215937:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421593b:	48 be 85 a7 21 04 80 	movabs $0x800421a785,%rsi
  8004215942:	00 00 00 
  8004215945:	48 89 c7             	mov    %rax,%rdi
  8004215948:	48 b8 51 f8 20 04 80 	movabs $0x800420f851,%rax
  800421594f:	00 00 00 
  8004215952:	ff d0                	callq  *%rax
  8004215954:	85 c0                	test   %eax,%eax
  8004215956:	75 65                	jne    80042159bd <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004215958:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421595b:	48 98                	cltq   
  800421595d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215964:	ff 
  8004215965:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215969:	48 89 c2             	mov    %rax,%rdx
  800421596c:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215973:	00 00 00 
  8004215976:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  800421597a:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215981:	00 00 00 
  8004215984:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004215988:	48 89 c2             	mov    %rax,%rdx
  800421598b:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215992:	00 00 00 
  8004215995:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004215999:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421599c:	48 98                	cltq   
  800421599e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042159a5:	ff 
  80042159a6:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042159aa:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  80042159b1:	00 00 00 
  80042159b4:	48 89 50 58          	mov    %rdx,0x58(%rax)
  80042159b8:	e9 0a 01 00 00       	jmpq   8004215ac7 <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_str"))
  80042159bd:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042159c1:	48 be 9b a7 21 04 80 	movabs $0x800421a79b,%rsi
  80042159c8:	00 00 00 
  80042159cb:	48 89 c7             	mov    %rax,%rdi
  80042159ce:	48 b8 51 f8 20 04 80 	movabs $0x800420f851,%rax
  80042159d5:	00 00 00 
  80042159d8:	ff d0                	callq  *%rax
  80042159da:	85 c0                	test   %eax,%eax
  80042159dc:	0f 85 e5 00 00 00    	jne    8004215ac7 <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042159e2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042159e5:	48 98                	cltq   
  80042159e7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042159ee:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042159ef:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042159f3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042159f6:	48 98                	cltq   
  80042159f8:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042159ff:	ff 
  8004215a00:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215a04:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215a0b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215a0f:	48 01 c8             	add    %rcx,%rax
  8004215a12:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215a19:	48 89 c7             	mov    %rax,%rdi
  8004215a1c:	48 b8 e7 5a 21 04 80 	movabs $0x8004215ae7,%rax
  8004215a23:	00 00 00 
  8004215a26:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004215a28:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215a2b:	48 98                	cltq   
  8004215a2d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215a34:	ff 
  8004215a35:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215a39:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215a3c:	48 98                	cltq   
  8004215a3e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215a45:	ff 
  8004215a46:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215a4a:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004215a51:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004215a58:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004215a5e:	48 29 c2             	sub    %rax,%rdx
  8004215a61:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215a65:	48 01 c2             	add    %rax,%rdx
  8004215a68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215a6c:	48 01 c2             	add    %rax,%rdx
  8004215a6f:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215a76:	00 00 00 
  8004215a79:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  8004215a80:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215a87:	00 00 00 
  8004215a8a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004215a91:	48 89 c2             	mov    %rax,%rdx
  8004215a94:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215a9b:	00 00 00 
  8004215a9e:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004215aa5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215aa8:	48 98                	cltq   
  8004215aaa:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215ab1:	ff 
  8004215ab2:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215ab6:	48 b8 e0 d6 22 04 80 	movabs $0x800422d6e0,%rax
  8004215abd:	00 00 00 
  8004215ac0:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	temp = kvoffset;
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

	for (i = 0; i < numSectionHeaders; i++)
  8004215ac7:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215acb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215ace:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004215ad1:	0f 8c f0 fa ff ff    	jl     80042155c7 <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  8004215ad7:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215adb:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004215ae2:	48 01 d0             	add    %rdx,%rax
}
  8004215ae5:	c9                   	leaveq 
  8004215ae6:	c3                   	retq   

0000008004215ae7 <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004215ae7:	55                   	push   %rbp
  8004215ae8:	48 89 e5             	mov    %rsp,%rbp
  8004215aeb:	48 83 ec 30          	sub    $0x30,%rsp
  8004215aef:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215af3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004215af7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004215afb:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004215aff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215b03:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004215b07:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215b0b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215b0f:	48 01 d0             	add    %rdx,%rax
  8004215b12:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004215b16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b1a:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215b1f:	48 85 c0             	test   %rax,%rax
  8004215b22:	74 35                	je     8004215b59 <readseg+0x72>
  8004215b24:	48 b9 e2 a7 21 04 80 	movabs $0x800421a7e2,%rcx
  8004215b2b:	00 00 00 
  8004215b2e:	48 ba bf a7 21 04 80 	movabs $0x800421a7bf,%rdx
  8004215b35:	00 00 00 
  8004215b38:	be c0 00 00 00       	mov    $0xc0,%esi
  8004215b3d:	48 bf d4 a7 21 04 80 	movabs $0x800421a7d4,%rdi
  8004215b44:	00 00 00 
  8004215b47:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215b4c:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004215b53:	00 00 00 
  8004215b56:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004215b59:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004215b60:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004215b61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215b65:	48 c1 e8 09          	shr    $0x9,%rax
  8004215b69:	48 83 c0 01          	add    $0x1,%rax
  8004215b6d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215b71:	eb 3c                	jmp    8004215baf <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  8004215b73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b77:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215b7b:	48 89 d6             	mov    %rdx,%rsi
  8004215b7e:	48 89 c7             	mov    %rax,%rdi
  8004215b81:	48 b8 77 5c 21 04 80 	movabs $0x8004215c77,%rax
  8004215b88:	00 00 00 
  8004215b8b:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004215b8d:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004215b94:	00 
		*kvoffset += SECTSIZE;
  8004215b95:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215b99:	48 8b 00             	mov    (%rax),%rax
  8004215b9c:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004215ba3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215ba7:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004215baa:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215baf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215bb3:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004215bb7:	72 ba                	jb     8004215b73 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004215bb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215bbd:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215bc2:	48 89 c2             	mov    %rax,%rdx
  8004215bc5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215bc9:	48 01 d0             	add    %rdx,%rax
  8004215bcc:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004215bd2:	76 2f                	jbe    8004215c03 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004215bd4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215bd8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215bdc:	48 89 d6             	mov    %rdx,%rsi
  8004215bdf:	48 89 c7             	mov    %rax,%rdi
  8004215be2:	48 b8 77 5c 21 04 80 	movabs $0x8004215c77,%rax
  8004215be9:	00 00 00 
  8004215bec:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004215bee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215bf2:	48 8b 00             	mov    (%rax),%rax
  8004215bf5:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004215bfc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215c00:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004215c03:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215c07:	48 8b 00             	mov    (%rax),%rax
  8004215c0a:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215c0f:	48 85 c0             	test   %rax,%rax
  8004215c12:	74 35                	je     8004215c49 <readseg+0x162>
  8004215c14:	48 b9 f5 a7 21 04 80 	movabs $0x800421a7f5,%rcx
  8004215c1b:	00 00 00 
  8004215c1e:	48 ba bf a7 21 04 80 	movabs $0x800421a7bf,%rdx
  8004215c25:	00 00 00 
  8004215c28:	be d6 00 00 00       	mov    $0xd6,%esi
  8004215c2d:	48 bf d4 a7 21 04 80 	movabs $0x800421a7d4,%rdi
  8004215c34:	00 00 00 
  8004215c37:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215c3c:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004215c43:	00 00 00 
  8004215c46:	41 ff d0             	callq  *%r8
}
  8004215c49:	c9                   	leaveq 
  8004215c4a:	c3                   	retq   

0000008004215c4b <waitdisk>:

void
waitdisk(void)
{
  8004215c4b:	55                   	push   %rbp
  8004215c4c:	48 89 e5             	mov    %rsp,%rbp
  8004215c4f:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  8004215c53:	90                   	nop
  8004215c54:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004215c5b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215c5e:	89 c2                	mov    %eax,%edx
  8004215c60:	ec                   	in     (%dx),%al
  8004215c61:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004215c64:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004215c68:	0f b6 c0             	movzbl %al,%eax
  8004215c6b:	25 c0 00 00 00       	and    $0xc0,%eax
  8004215c70:	83 f8 40             	cmp    $0x40,%eax
  8004215c73:	75 df                	jne    8004215c54 <waitdisk+0x9>
		/* do nothing */;
}
  8004215c75:	c9                   	leaveq 
  8004215c76:	c3                   	retq   

0000008004215c77 <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  8004215c77:	55                   	push   %rbp
  8004215c78:	48 89 e5             	mov    %rsp,%rbp
  8004215c7b:	48 83 ec 60          	sub    $0x60,%rsp
  8004215c7f:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004215c83:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  8004215c87:	48 b8 4b 5c 21 04 80 	movabs $0x8004215c4b,%rax
  8004215c8e:	00 00 00 
  8004215c91:	ff d0                	callq  *%rax
  8004215c93:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  8004215c9a:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215c9e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004215ca2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215ca5:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004215ca6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215caa:	0f b6 c0             	movzbl %al,%eax
  8004215cad:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004215cb4:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004215cb7:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004215cbb:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215cbe:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004215cbf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215cc3:	48 c1 e8 08          	shr    $0x8,%rax
  8004215cc7:	0f b6 c0             	movzbl %al,%eax
  8004215cca:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  8004215cd1:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004215cd4:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004215cd8:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215cdb:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004215cdc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215ce0:	48 c1 e8 10          	shr    $0x10,%rax
  8004215ce4:	0f b6 c0             	movzbl %al,%eax
  8004215ce7:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  8004215cee:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004215cf1:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004215cf5:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004215cf8:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004215cf9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215cfd:	48 c1 e8 18          	shr    $0x18,%rax
  8004215d01:	83 c8 e0             	or     $0xffffffe0,%eax
  8004215d04:	0f b6 c0             	movzbl %al,%eax
  8004215d07:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  8004215d0e:	88 45 db             	mov    %al,-0x25(%rbp)
  8004215d11:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004215d15:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215d18:	ee                   	out    %al,(%dx)
  8004215d19:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  8004215d20:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004215d24:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004215d28:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215d2b:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004215d2c:	48 b8 4b 5c 21 04 80 	movabs $0x8004215c4b,%rax
  8004215d33:	00 00 00 
  8004215d36:	ff d0                	callq  *%rax
  8004215d38:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  8004215d3f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215d43:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004215d47:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  8004215d4e:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215d51:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004215d55:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004215d58:	48 89 ce             	mov    %rcx,%rsi
  8004215d5b:	48 89 f7             	mov    %rsi,%rdi
  8004215d5e:	89 c1                	mov    %eax,%ecx
  8004215d60:	fc                   	cld    
  8004215d61:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  8004215d63:	89 c8                	mov    %ecx,%eax
  8004215d65:	48 89 fe             	mov    %rdi,%rsi
  8004215d68:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004215d6c:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004215d6f:	c9                   	leaveq 
  8004215d70:	c3                   	retq   
  8004215d71:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000008004215d78 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  8004215d78:	fa                   	cli    
	xorw    %ax, %ax
  8004215d79:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  8004215d7b:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215d7d:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215d7f:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  8004215d81:	0f 01 16             	lgdt   (%rsi)
  8004215d84:	e0 70                	loopne 8004215df6 <start64+0x10>
	movl    %cr0, %eax
  8004215d86:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215d89:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  8004215d8d:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004215d90:	ea                   	(bad)  
  8004215d91:	1d 70 08 00 66       	sbb    $0x66000870,%eax

0000008004215d95 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004215d95:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004215d99:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215d9b:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215d9d:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004215d9f:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215da3:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215da5:	8e e8                	mov    %eax,%gs

	movl $CR4_PAE,%eax
  8004215da7:	b8 20 00 00 00       	mov    $0x20,%eax

	movl %eax,%cr4
  8004215dac:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  8004215daf:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421ce76 <error_string+0x2ef6>
	movl    %cr0, %eax
  8004215db6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215db9:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  8004215dbc:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  8004215dbf:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004215dc4:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004215dc7:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  8004215dcc:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  8004215dce:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004215dd2:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004215dd4:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004215dd7:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  8004215ddc:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  8004215ddf:	ea                   	(bad)  
  8004215de0:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004215de1:	70 00                	jo     8004215de3 <start32+0x4e>
  8004215de3:	00 08                	add    %cl,(%rax)
	...

0000008004215de6 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004215de6:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004215dea:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215dec:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215dee:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004215df0:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215df4:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215df6:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004215df8:	48 a1 68 87 60 04 80 	movabs 0x8004608768,%rax
  8004215dff:	00 00 00 
	movq    %rax,%rsp
  8004215e02:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004215e05:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  8004215e0c:	48 b8 5d 04 20 04 80 	movabs $0x800420045d,%rax
  8004215e13:	00 00 00 
	call    *%rax
  8004215e16:	ff d0                	callq  *%rax

0000008004215e18 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004215e18:	eb fe                	jmp    8004215e18 <spin>
  8004215e1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004215e20 <gdt>:
	...
  8004215e28:	ff                   	(bad)  
  8004215e29:	ff 00                	incl   (%rax)
  8004215e2b:	00 00                	add    %al,(%rax)
  8004215e2d:	9a                   	(bad)  
  8004215e2e:	af                   	scas   %es:(%rdi),%eax
  8004215e2f:	00 ff                	add    %bh,%bh
  8004215e31:	ff 00                	incl   (%rax)
  8004215e33:	00 00                	add    %al,(%rax)
  8004215e35:	92                   	xchg   %eax,%edx
  8004215e36:	af                   	scas   %es:(%rdi),%eax
	...

0000008004215e38 <gdtdesc>:
  8004215e38:	17                   	(bad)  
  8004215e39:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  8004215e3f:	90                   	nop

0000008004215e40 <gdt32>:
	...
  8004215e48:	ff                   	(bad)  
  8004215e49:	ff 00                	incl   (%rax)
  8004215e4b:	00 00                	add    %al,(%rax)
  8004215e4d:	9a                   	(bad)  
  8004215e4e:	cf                   	iret   
  8004215e4f:	00 ff                	add    %bh,%bh
  8004215e51:	ff 00                	incl   (%rax)
  8004215e53:	00 00                	add    %al,(%rax)
  8004215e55:	92                   	xchg   %eax,%edx
  8004215e56:	cf                   	iret   
	...

0000008004215e58 <gdt32desc>:
  8004215e58:	17                   	(bad)  
  8004215e59:	00 c8                	add    %cl,%al
  8004215e5b:	70 00                	jo     8004215e5d <gdt32desc+0x5>
	...

0000008004215e5e <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  8004215e5e:	90                   	nop

0000008004215e5f <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  8004215e5f:	55                   	push   %rbp
  8004215e60:	48 89 e5             	mov    %rsp,%rbp
  8004215e63:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004215e67:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215e6b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  8004215e6e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  8004215e75:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004215e7c:	eb 1a                	jmp    8004215e98 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  8004215e7e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215e81:	48 63 d0             	movslq %eax,%rdx
  8004215e84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215e88:	48 01 d0             	add    %rdx,%rax
  8004215e8b:	0f b6 00             	movzbl (%rax),%eax
  8004215e8e:	0f b6 c0             	movzbl %al,%eax
  8004215e91:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  8004215e94:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004215e98:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215e9b:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004215e9e:	7c de                	jl     8004215e7e <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  8004215ea0:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8004215ea3:	c9                   	leaveq 
  8004215ea4:	c3                   	retq   

0000008004215ea5 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  8004215ea5:	55                   	push   %rbp
  8004215ea6:	48 89 e5             	mov    %rsp,%rbp
  8004215ea9:	48 83 ec 40          	sub    $0x40,%rsp
  8004215ead:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004215eb1:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004215eb4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215eb8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004215ebc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215ec0:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215ec4:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215ec7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215eca:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004215ed1:	00 00 00 
  8004215ed4:	48 8b 00             	mov    (%rax),%rax
  8004215ed7:	48 39 c2             	cmp    %rax,%rdx
  8004215eda:	72 32                	jb     8004215f0e <mpsearch1+0x69>
  8004215edc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215ee0:	48 89 c1             	mov    %rax,%rcx
  8004215ee3:	48 ba 10 a8 21 04 80 	movabs $0x800421a810,%rdx
  8004215eea:	00 00 00 
  8004215eed:	be 58 00 00 00       	mov    $0x58,%esi
  8004215ef2:	48 bf 33 a8 21 04 80 	movabs $0x800421a833,%rdi
  8004215ef9:	00 00 00 
  8004215efc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215f01:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004215f08:	00 00 00 
  8004215f0b:	41 ff d0             	callq  *%r8
  8004215f0e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215f15:	00 00 00 
  8004215f18:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215f1c:	48 01 d0             	add    %rdx,%rax
  8004215f1f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215f23:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004215f26:	48 63 d0             	movslq %eax,%rdx
  8004215f29:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215f2d:	48 01 d0             	add    %rdx,%rax
  8004215f30:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004215f34:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215f38:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215f3c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004215f3f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215f42:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004215f49:	00 00 00 
  8004215f4c:	48 8b 00             	mov    (%rax),%rax
  8004215f4f:	48 39 c2             	cmp    %rax,%rdx
  8004215f52:	72 32                	jb     8004215f86 <mpsearch1+0xe1>
  8004215f54:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215f58:	48 89 c1             	mov    %rax,%rcx
  8004215f5b:	48 ba 10 a8 21 04 80 	movabs $0x800421a810,%rdx
  8004215f62:	00 00 00 
  8004215f65:	be 58 00 00 00       	mov    $0x58,%esi
  8004215f6a:	48 bf 33 a8 21 04 80 	movabs $0x800421a833,%rdi
  8004215f71:	00 00 00 
  8004215f74:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215f79:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004215f80:	00 00 00 
  8004215f83:	41 ff d0             	callq  *%r8
  8004215f86:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215f8d:	00 00 00 
  8004215f90:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215f94:	48 01 d0             	add    %rdx,%rax
  8004215f97:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  8004215f9b:	eb 4d                	jmp    8004215fea <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004215f9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215fa1:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215fa6:	48 be 43 a8 21 04 80 	movabs $0x800421a843,%rsi
  8004215fad:	00 00 00 
  8004215fb0:	48 89 c7             	mov    %rax,%rdi
  8004215fb3:	48 b8 5e fb 20 04 80 	movabs $0x800420fb5e,%rax
  8004215fba:	00 00 00 
  8004215fbd:	ff d0                	callq  *%rax
  8004215fbf:	85 c0                	test   %eax,%eax
  8004215fc1:	75 22                	jne    8004215fe5 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  8004215fc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215fc7:	be 10 00 00 00       	mov    $0x10,%esi
  8004215fcc:	48 89 c7             	mov    %rax,%rdi
  8004215fcf:	48 b8 5f 5e 21 04 80 	movabs $0x8004215e5f,%rax
  8004215fd6:	00 00 00 
  8004215fd9:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004215fdb:	84 c0                	test   %al,%al
  8004215fdd:	75 06                	jne    8004215fe5 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  8004215fdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215fe3:	eb 14                	jmp    8004215ff9 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  8004215fe5:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  8004215fea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215fee:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004215ff2:	72 a9                	jb     8004215f9d <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  8004215ff4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215ff9:	c9                   	leaveq 
  8004215ffa:	c3                   	retq   

0000008004215ffb <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  8004215ffb:	55                   	push   %rbp
  8004215ffc:	48 89 e5             	mov    %rsp,%rbp
  8004215fff:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004216003:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800421600a:	00 
  800421600b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421600f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216013:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004216016:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004216019:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004216020:	00 00 00 
  8004216023:	48 8b 00             	mov    (%rax),%rax
  8004216026:	48 39 c2             	cmp    %rax,%rdx
  8004216029:	72 32                	jb     800421605d <mpsearch+0x62>
  800421602b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421602f:	48 89 c1             	mov    %rax,%rcx
  8004216032:	48 ba 10 a8 21 04 80 	movabs $0x800421a810,%rdx
  8004216039:	00 00 00 
  800421603c:	be 70 00 00 00       	mov    $0x70,%esi
  8004216041:	48 bf 33 a8 21 04 80 	movabs $0x800421a833,%rdi
  8004216048:	00 00 00 
  800421604b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216050:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004216057:	00 00 00 
  800421605a:	41 ff d0             	callq  *%r8
  800421605d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004216064:	00 00 00 
  8004216067:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421606b:	48 01 d0             	add    %rdx,%rax
  800421606e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  8004216072:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216076:	48 83 c0 0e          	add    $0xe,%rax
  800421607a:	0f b7 00             	movzwl (%rax),%eax
  800421607d:	0f b7 c0             	movzwl %ax,%eax
  8004216080:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004216083:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004216087:	74 2c                	je     80042160b5 <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  8004216089:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  800421608d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216090:	be 00 04 00 00       	mov    $0x400,%esi
  8004216095:	48 89 c7             	mov    %rax,%rdi
  8004216098:	48 b8 a5 5e 21 04 80 	movabs $0x8004215ea5,%rax
  800421609f:	00 00 00 
  80042160a2:	ff d0                	callq  *%rax
  80042160a4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042160a8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042160ad:	74 49                	je     80042160f8 <mpsearch+0xfd>
			return mp;
  80042160af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042160b3:	eb 59                	jmp    800421610e <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  80042160b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042160b9:	48 83 c0 13          	add    $0x13,%rax
  80042160bd:	0f b7 00             	movzwl (%rax),%eax
  80042160c0:	0f b7 c0             	movzwl %ax,%eax
  80042160c3:	c1 e0 0a             	shl    $0xa,%eax
  80042160c6:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  80042160c9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042160cc:	2d 00 04 00 00       	sub    $0x400,%eax
  80042160d1:	89 c0                	mov    %eax,%eax
  80042160d3:	be 00 04 00 00       	mov    $0x400,%esi
  80042160d8:	48 89 c7             	mov    %rax,%rdi
  80042160db:	48 b8 a5 5e 21 04 80 	movabs $0x8004215ea5,%rax
  80042160e2:	00 00 00 
  80042160e5:	ff d0                	callq  *%rax
  80042160e7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042160eb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042160f0:	74 06                	je     80042160f8 <mpsearch+0xfd>
			return mp;
  80042160f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042160f6:	eb 16                	jmp    800421610e <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  80042160f8:	be 00 00 01 00       	mov    $0x10000,%esi
  80042160fd:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004216102:	48 b8 a5 5e 21 04 80 	movabs $0x8004215ea5,%rax
  8004216109:	00 00 00 
  800421610c:	ff d0                	callq  *%rax
}
  800421610e:	c9                   	leaveq 
  800421610f:	c3                   	retq   

0000008004216110 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004216110:	55                   	push   %rbp
  8004216111:	48 89 e5             	mov    %rsp,%rbp
  8004216114:	48 83 ec 30          	sub    $0x30,%rsp
  8004216118:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  800421611c:	48 b8 fb 5f 21 04 80 	movabs $0x8004215ffb,%rax
  8004216123:	00 00 00 
  8004216126:	ff d0                	callq  *%rax
  8004216128:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421612c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004216131:	75 0a                	jne    800421613d <mpconfig+0x2d>
		return NULL;
  8004216133:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216138:	e9 f6 01 00 00       	jmpq   8004216333 <mpconfig+0x223>
	if (mp->physaddr == 0 || mp->type != 0) {
  800421613d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216141:	8b 40 04             	mov    0x4(%rax),%eax
  8004216144:	85 c0                	test   %eax,%eax
  8004216146:	74 0c                	je     8004216154 <mpconfig+0x44>
  8004216148:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421614c:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004216150:	84 c0                	test   %al,%al
  8004216152:	74 25                	je     8004216179 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  8004216154:	48 bf 48 a8 21 04 80 	movabs $0x800421a848,%rdi
  800421615b:	00 00 00 
  800421615e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216163:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800421616a:	00 00 00 
  800421616d:	ff d2                	callq  *%rdx
		return NULL;
  800421616f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216174:	e9 ba 01 00 00       	jmpq   8004216333 <mpconfig+0x223>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  8004216179:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421617d:	8b 40 04             	mov    0x4(%rax),%eax
  8004216180:	89 c0                	mov    %eax,%eax
  8004216182:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004216186:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421618a:	48 c1 e8 0c          	shr    $0xc,%rax
  800421618e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004216191:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216194:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  800421619b:	00 00 00 
  800421619e:	48 8b 00             	mov    (%rax),%rax
  80042161a1:	48 39 c2             	cmp    %rax,%rdx
  80042161a4:	72 32                	jb     80042161d8 <mpconfig+0xc8>
  80042161a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042161aa:	48 89 c1             	mov    %rax,%rcx
  80042161ad:	48 ba 10 a8 21 04 80 	movabs $0x800421a810,%rdx
  80042161b4:	00 00 00 
  80042161b7:	be 91 00 00 00       	mov    $0x91,%esi
  80042161bc:	48 bf 33 a8 21 04 80 	movabs $0x800421a833,%rdi
  80042161c3:	00 00 00 
  80042161c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042161cb:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042161d2:	00 00 00 
  80042161d5:	41 ff d0             	callq  *%r8
  80042161d8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042161df:	00 00 00 
  80042161e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042161e6:	48 01 d0             	add    %rdx,%rax
  80042161e9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  80042161ed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042161f1:	ba 04 00 00 00       	mov    $0x4,%edx
  80042161f6:	48 be 75 a8 21 04 80 	movabs $0x800421a875,%rsi
  80042161fd:	00 00 00 
  8004216200:	48 89 c7             	mov    %rax,%rdi
  8004216203:	48 b8 5e fb 20 04 80 	movabs $0x800420fb5e,%rax
  800421620a:	00 00 00 
  800421620d:	ff d0                	callq  *%rax
  800421620f:	85 c0                	test   %eax,%eax
  8004216211:	74 25                	je     8004216238 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004216213:	48 bf 80 a8 21 04 80 	movabs $0x800421a880,%rdi
  800421621a:	00 00 00 
  800421621d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216222:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004216229:	00 00 00 
  800421622c:	ff d2                	callq  *%rdx
		return NULL;
  800421622e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216233:	e9 fb 00 00 00       	jmpq   8004216333 <mpconfig+0x223>
	}
	if (sum(conf, conf->length) != 0) {
  8004216238:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421623c:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004216240:	0f b7 d0             	movzwl %ax,%edx
  8004216243:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216247:	89 d6                	mov    %edx,%esi
  8004216249:	48 89 c7             	mov    %rax,%rdi
  800421624c:	48 b8 5f 5e 21 04 80 	movabs $0x8004215e5f,%rax
  8004216253:	00 00 00 
  8004216256:	ff d0                	callq  *%rax
  8004216258:	84 c0                	test   %al,%al
  800421625a:	74 25                	je     8004216281 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  800421625c:	48 bf b8 a8 21 04 80 	movabs $0x800421a8b8,%rdi
  8004216263:	00 00 00 
  8004216266:	b8 00 00 00 00       	mov    $0x0,%eax
  800421626b:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004216272:	00 00 00 
  8004216275:	ff d2                	callq  *%rdx
		return NULL;
  8004216277:	b8 00 00 00 00       	mov    $0x0,%eax
  800421627c:	e9 b2 00 00 00       	jmpq   8004216333 <mpconfig+0x223>
	}
	if (conf->version != 1 && conf->version != 4) {
  8004216281:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216285:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216289:	3c 01                	cmp    $0x1,%al
  800421628b:	74 3b                	je     80042162c8 <mpconfig+0x1b8>
  800421628d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216291:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216295:	3c 04                	cmp    $0x4,%al
  8004216297:	74 2f                	je     80042162c8 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  8004216299:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421629d:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042162a1:	0f b6 c0             	movzbl %al,%eax
  80042162a4:	89 c6                	mov    %eax,%esi
  80042162a6:	48 bf e0 a8 21 04 80 	movabs $0x800421a8e0,%rdi
  80042162ad:	00 00 00 
  80042162b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042162b5:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042162bc:	00 00 00 
  80042162bf:	ff d2                	callq  *%rdx
		return NULL;
  80042162c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042162c6:	eb 6b                	jmp    8004216333 <mpconfig+0x223>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  80042162c8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042162cc:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80042162d0:	0f b7 c0             	movzwl %ax,%eax
  80042162d3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042162d7:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  80042162db:	0f b7 ca             	movzwl %dx,%ecx
  80042162de:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042162e2:	48 01 ca             	add    %rcx,%rdx
  80042162e5:	89 c6                	mov    %eax,%esi
  80042162e7:	48 89 d7             	mov    %rdx,%rdi
  80042162ea:	48 b8 5f 5e 21 04 80 	movabs $0x8004215e5f,%rax
  80042162f1:	00 00 00 
  80042162f4:	ff d0                	callq  *%rax
  80042162f6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042162fa:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  80042162fe:	38 d0                	cmp    %dl,%al
  8004216300:	74 22                	je     8004216324 <mpconfig+0x214>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  8004216302:	48 bf 00 a9 21 04 80 	movabs $0x800421a900,%rdi
  8004216309:	00 00 00 
  800421630c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216311:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004216318:	00 00 00 
  800421631b:	ff d2                	callq  *%rdx
		return NULL;
  800421631d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216322:	eb 0f                	jmp    8004216333 <mpconfig+0x223>
	}
	*pmp = mp;
  8004216324:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216328:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421632c:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  800421632f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004216333:	c9                   	leaveq 
  8004216334:	c3                   	retq   

0000008004216335 <mp_init>:

void
mp_init(void)
{
  8004216335:	55                   	push   %rbp
  8004216336:	48 89 e5             	mov    %rsp,%rbp
  8004216339:	53                   	push   %rbx
  800421633a:	48 83 ec 58          	sub    $0x58,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  800421633e:	48 b8 e0 a3 60 04 80 	movabs $0x800460a3e0,%rax
  8004216345:	00 00 00 
  8004216348:	48 bb 20 a0 60 04 80 	movabs $0x800460a020,%rbx
  800421634f:	00 00 00 
  8004216352:	48 89 18             	mov    %rbx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  8004216355:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8004216359:	48 89 c7             	mov    %rax,%rdi
  800421635c:	48 b8 10 61 21 04 80 	movabs $0x8004216110,%rax
  8004216363:	00 00 00 
  8004216366:	ff d0                	callq  *%rax
  8004216368:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421636c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004216371:	75 05                	jne    8004216378 <mp_init+0x43>
		return;
  8004216373:	e9 71 03 00 00       	jmpq   80042166e9 <mp_init+0x3b4>
	ismp = 1;
  8004216378:	48 b8 00 a0 60 04 80 	movabs $0x800460a000,%rax
  800421637f:	00 00 00 
  8004216382:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  8004216388:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421638c:	8b 40 24             	mov    0x24(%rax),%eax
  800421638f:	89 c2                	mov    %eax,%edx
  8004216391:	48 b8 00 b0 68 04 80 	movabs $0x800468b000,%rax
  8004216398:	00 00 00 
  800421639b:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  800421639e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042163a2:	48 83 c0 2c          	add    $0x2c,%rax
  80042163a6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042163aa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  80042163b1:	e9 18 02 00 00       	jmpq   80042165ce <mp_init+0x299>
		switch (*p) {
  80042163b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042163ba:	0f b6 00             	movzbl (%rax),%eax
  80042163bd:	0f b6 c0             	movzbl %al,%eax
  80042163c0:	85 c0                	test   %eax,%eax
  80042163c2:	74 16                	je     80042163da <mp_init+0xa5>
  80042163c4:	85 c0                	test   %eax,%eax
  80042163c6:	0f 88 b9 01 00 00    	js     8004216585 <mp_init+0x250>
  80042163cc:	83 f8 04             	cmp    $0x4,%eax
  80042163cf:	0f 8f b0 01 00 00    	jg     8004216585 <mp_init+0x250>
  80042163d5:	e9 a4 01 00 00       	jmpq   800421657e <mp_init+0x249>
		case MPPROC:
			proc = (struct mpproc *)p;
  80042163da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042163de:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  80042163e2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042163e6:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042163ea:	0f b6 c0             	movzbl %al,%eax
  80042163ed:	83 e0 02             	and    $0x2,%eax
  80042163f0:	85 c0                	test   %eax,%eax
  80042163f2:	74 51                	je     8004216445 <mp_init+0x110>
				bootcpu = &cpus[ncpu];
  80042163f4:	48 b8 e8 a3 60 04 80 	movabs $0x800460a3e8,%rax
  80042163fb:	00 00 00 
  80042163fe:	8b 00                	mov    (%rax),%eax
  8004216400:	48 98                	cltq   
  8004216402:	48 c1 e0 03          	shl    $0x3,%rax
  8004216406:	48 89 c2             	mov    %rax,%rdx
  8004216409:	48 c1 e2 04          	shl    $0x4,%rdx
  800421640d:	48 29 c2             	sub    %rax,%rdx
  8004216410:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  8004216417:	00 00 00 
  800421641a:	48 01 c2             	add    %rax,%rdx
  800421641d:	48 b8 e0 a3 60 04 80 	movabs $0x800460a3e0,%rax
  8004216424:	00 00 00 
  8004216427:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  800421642a:	48 bf 2d a9 21 04 80 	movabs $0x800421a92d,%rdi
  8004216431:	00 00 00 
  8004216434:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216439:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004216440:	00 00 00 
  8004216443:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  8004216445:	48 b8 e8 a3 60 04 80 	movabs $0x800460a3e8,%rax
  800421644c:	00 00 00 
  800421644f:	8b 00                	mov    (%rax),%eax
  8004216451:	83 f8 07             	cmp    $0x7,%eax
  8004216454:	0f 8f f5 00 00 00    	jg     800421654f <mp_init+0x21a>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  800421645a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421645e:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  8004216462:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216466:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  800421646a:	0f b6 f0             	movzbl %al,%esi
  800421646d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216471:	8b 78 08             	mov    0x8(%rax),%edi
  8004216474:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216478:	4c 8d 50 04          	lea    0x4(%rax),%r10
  800421647c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216480:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  8004216484:	0f b6 c8             	movzbl %al,%ecx
  8004216487:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421648b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  800421648f:	0f b6 d0             	movzbl %al,%edx
  8004216492:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216496:	0f b6 00             	movzbl (%rax),%eax
  8004216499:	0f b6 c0             	movzbl %al,%eax
  800421649c:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  80042164a1:	89 34 24             	mov    %esi,(%rsp)
  80042164a4:	41 89 f9             	mov    %edi,%r9d
  80042164a7:	4d 89 d0             	mov    %r10,%r8
  80042164aa:	89 c6                	mov    %eax,%esi
  80042164ac:	48 bf 40 a9 21 04 80 	movabs $0x800421a940,%rdi
  80042164b3:	00 00 00 
  80042164b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042164bb:	49 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%r10
  80042164c2:	00 00 00 
  80042164c5:	41 ff d2             	callq  *%r10
				if (proc->flags & MPROC_EN) {
  80042164c8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042164cc:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042164d0:	0f b6 c0             	movzbl %al,%eax
  80042164d3:	83 e0 01             	and    $0x1,%eax
  80042164d6:	85 c0                	test   %eax,%eax
  80042164d8:	74 58                	je     8004216532 <mp_init+0x1fd>
					cpus[ncpu].cpu_id = ncpu;
  80042164da:	48 b8 e8 a3 60 04 80 	movabs $0x800460a3e8,%rax
  80042164e1:	00 00 00 
  80042164e4:	8b 10                	mov    (%rax),%edx
  80042164e6:	48 b8 e8 a3 60 04 80 	movabs $0x800460a3e8,%rax
  80042164ed:	00 00 00 
  80042164f0:	8b 00                	mov    (%rax),%eax
  80042164f2:	89 c1                	mov    %eax,%ecx
  80042164f4:	48 be 20 a0 60 04 80 	movabs $0x800460a020,%rsi
  80042164fb:	00 00 00 
  80042164fe:	48 63 c2             	movslq %edx,%rax
  8004216501:	48 c1 e0 03          	shl    $0x3,%rax
  8004216505:	48 89 c2             	mov    %rax,%rdx
  8004216508:	48 c1 e2 04          	shl    $0x4,%rdx
  800421650c:	48 29 c2             	sub    %rax,%rdx
  800421650f:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  8004216513:	88 08                	mov    %cl,(%rax)
					ncpu++;
  8004216515:	48 b8 e8 a3 60 04 80 	movabs $0x800460a3e8,%rax
  800421651c:	00 00 00 
  800421651f:	8b 00                	mov    (%rax),%eax
  8004216521:	8d 50 01             	lea    0x1(%rax),%edx
  8004216524:	48 b8 e8 a3 60 04 80 	movabs $0x800460a3e8,%rax
  800421652b:	00 00 00 
  800421652e:	89 10                	mov    %edx,(%rax)
  8004216530:	eb 45                	jmp    8004216577 <mp_init+0x242>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  8004216532:	48 bf 90 a9 21 04 80 	movabs $0x800421a990,%rdi
  8004216539:	00 00 00 
  800421653c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216541:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004216548:	00 00 00 
  800421654b:	ff d2                	callq  *%rdx
  800421654d:	eb 28                	jmp    8004216577 <mp_init+0x242>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  800421654f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216553:	0f b6 40 01          	movzbl 0x1(%rax),%eax
					ncpu++;
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  8004216557:	0f b6 c0             	movzbl %al,%eax
  800421655a:	89 c6                	mov    %eax,%esi
  800421655c:	48 bf c0 a9 21 04 80 	movabs $0x800421a9c0,%rdi
  8004216563:	00 00 00 
  8004216566:	b8 00 00 00 00       	mov    $0x0,%eax
  800421656b:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004216572:	00 00 00 
  8004216575:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  8004216577:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  800421657c:	eb 4c                	jmp    80042165ca <mp_init+0x295>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
		p += 8;
  800421657e:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
		continue;
  8004216583:	eb 45                	jmp    80042165ca <mp_init+0x295>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  8004216585:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216589:	0f b6 00             	movzbl (%rax),%eax
  800421658c:	0f b6 c0             	movzbl %al,%eax
  800421658f:	89 c6                	mov    %eax,%esi
  8004216591:	48 bf e8 a9 21 04 80 	movabs $0x800421a9e8,%rdi
  8004216598:	00 00 00 
  800421659b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042165a0:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042165a7:	00 00 00 
  80042165aa:	ff d2                	callq  *%rdx
			ismp = 0;
  80042165ac:	48 b8 00 a0 60 04 80 	movabs $0x800460a000,%rax
  80042165b3:	00 00 00 
  80042165b6:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  80042165bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042165c0:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  80042165c4:	0f b7 c0             	movzwl %ax,%eax
  80042165c7:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  80042165ca:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  80042165ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042165d2:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  80042165d6:	0f b7 c0             	movzwl %ax,%eax
  80042165d9:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80042165dc:	0f 87 d4 fd ff ff    	ja     80042163b6 <mp_init+0x81>
			i = conf->entry;
		}
	}


	bootcpu->cpu_status = CPU_STARTED;
  80042165e2:	48 b8 e0 a3 60 04 80 	movabs $0x800460a3e0,%rax
  80042165e9:	00 00 00 
  80042165ec:	48 8b 00             	mov    (%rax),%rax
  80042165ef:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  80042165f6:	48 b8 00 a0 60 04 80 	movabs $0x800460a000,%rax
  80042165fd:	00 00 00 
  8004216600:	8b 00                	mov    (%rax),%eax
  8004216602:	85 c0                	test   %eax,%eax
  8004216604:	75 41                	jne    8004216647 <mp_init+0x312>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  8004216606:	48 b8 e8 a3 60 04 80 	movabs $0x800460a3e8,%rax
  800421660d:	00 00 00 
  8004216610:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  8004216616:	48 b8 00 b0 68 04 80 	movabs $0x800468b000,%rax
  800421661d:	00 00 00 
  8004216620:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  8004216627:	48 bf 08 aa 21 04 80 	movabs $0x800421aa08,%rdi
  800421662e:	00 00 00 
  8004216631:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216636:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800421663d:	00 00 00 
  8004216640:	ff d2                	callq  *%rdx
		return;
  8004216642:	e9 a2 00 00 00       	jmpq   80042166e9 <mp_init+0x3b4>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  8004216647:	48 b8 e8 a3 60 04 80 	movabs $0x800460a3e8,%rax
  800421664e:	00 00 00 
  8004216651:	8b 10                	mov    (%rax),%edx
  8004216653:	48 b8 e0 a3 60 04 80 	movabs $0x800460a3e0,%rax
  800421665a:	00 00 00 
  800421665d:	48 8b 00             	mov    (%rax),%rax
  8004216660:	0f b6 00             	movzbl (%rax),%eax
  8004216663:	0f b6 c0             	movzbl %al,%eax
  8004216666:	89 c6                	mov    %eax,%esi
  8004216668:	48 bf 34 aa 21 04 80 	movabs $0x800421aa34,%rdi
  800421666f:	00 00 00 
  8004216672:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216677:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  800421667e:	00 00 00 
  8004216681:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  8004216683:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004216687:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  800421668b:	84 c0                	test   %al,%al
  800421668d:	74 5a                	je     80042166e9 <mp_init+0x3b4>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  800421668f:	48 bf 58 aa 21 04 80 	movabs $0x800421aa58,%rdi
  8004216696:	00 00 00 
  8004216699:	b8 00 00 00 00       	mov    $0x0,%eax
  800421669e:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  80042166a5:	00 00 00 
  80042166a8:	ff d2                	callq  *%rdx
  80042166aa:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  80042166b1:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042166b5:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042166b9:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042166bc:	ee                   	out    %al,(%dx)
  80042166bd:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042166c4:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042166c7:	89 c2                	mov    %eax,%edx
  80042166c9:	ec                   	in     (%dx),%al
  80042166ca:	88 45 c3             	mov    %al,-0x3d(%rbp)
	return data;
  80042166cd:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  80042166d1:	83 c8 01             	or     $0x1,%eax
  80042166d4:	0f b6 c0             	movzbl %al,%eax
  80042166d7:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  80042166de:	88 45 bb             	mov    %al,-0x45(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042166e1:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  80042166e5:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042166e8:	ee                   	out    %al,(%dx)
	}
}
  80042166e9:	48 83 c4 58          	add    $0x58,%rsp
  80042166ed:	5b                   	pop    %rbx
  80042166ee:	5d                   	pop    %rbp
  80042166ef:	c3                   	retq   

00000080042166f0 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  80042166f0:	55                   	push   %rbp
  80042166f1:	48 89 e5             	mov    %rsp,%rbp
  80042166f4:	48 83 ec 08          	sub    $0x8,%rsp
  80042166f8:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042166fb:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  80042166fe:	48 b8 08 b0 68 04 80 	movabs $0x800468b008,%rax
  8004216705:	00 00 00 
  8004216708:	48 8b 00             	mov    (%rax),%rax
  800421670b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421670e:	48 63 d2             	movslq %edx,%rdx
  8004216711:	48 c1 e2 02          	shl    $0x2,%rdx
  8004216715:	48 01 c2             	add    %rax,%rdx
  8004216718:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421671b:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  800421671d:	48 b8 08 b0 68 04 80 	movabs $0x800468b008,%rax
  8004216724:	00 00 00 
  8004216727:	48 8b 00             	mov    (%rax),%rax
  800421672a:	48 83 c0 20          	add    $0x20,%rax
  800421672e:	8b 00                	mov    (%rax),%eax
}
  8004216730:	c9                   	leaveq 
  8004216731:	c3                   	retq   

0000008004216732 <lapic_init>:

void
lapic_init(void)
{
  8004216732:	55                   	push   %rbp
  8004216733:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  8004216736:	48 b8 00 b0 68 04 80 	movabs $0x800468b000,%rax
  800421673d:	00 00 00 
  8004216740:	48 8b 00             	mov    (%rax),%rax
  8004216743:	48 85 c0             	test   %rax,%rax
  8004216746:	75 05                	jne    800421674d <lapic_init+0x1b>
		return;
  8004216748:	e9 da 01 00 00       	jmpq   8004216927 <lapic_init+0x1f5>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  800421674d:	48 b8 00 b0 68 04 80 	movabs $0x800468b000,%rax
  8004216754:	00 00 00 
  8004216757:	48 8b 00             	mov    (%rax),%rax
  800421675a:	be 00 10 00 00       	mov    $0x1000,%esi
  800421675f:	48 89 c7             	mov    %rax,%rdi
  8004216762:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  8004216769:	00 00 00 
  800421676c:	ff d0                	callq  *%rax
  800421676e:	48 ba 08 b0 68 04 80 	movabs $0x800468b008,%rdx
  8004216775:	00 00 00 
  8004216778:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  800421677b:	be 27 01 00 00       	mov    $0x127,%esi
  8004216780:	bf 3c 00 00 00       	mov    $0x3c,%edi
  8004216785:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  800421678c:	00 00 00 
  800421678f:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  8004216791:	be 0b 00 00 00       	mov    $0xb,%esi
  8004216796:	bf f8 00 00 00       	mov    $0xf8,%edi
  800421679b:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  80042167a2:	00 00 00 
  80042167a5:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  80042167a7:	be 20 00 02 00       	mov    $0x20020,%esi
  80042167ac:	bf c8 00 00 00       	mov    $0xc8,%edi
  80042167b1:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  80042167b8:	00 00 00 
  80042167bb:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  80042167bd:	be 80 96 98 00       	mov    $0x989680,%esi
  80042167c2:	bf e0 00 00 00       	mov    $0xe0,%edi
  80042167c7:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  80042167ce:	00 00 00 
  80042167d1:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  80042167d3:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  80042167da:	00 00 00 
  80042167dd:	ff d0                	callq  *%rax
  80042167df:	48 98                	cltq   
  80042167e1:	48 c1 e0 03          	shl    $0x3,%rax
  80042167e5:	48 89 c2             	mov    %rax,%rdx
  80042167e8:	48 c1 e2 04          	shl    $0x4,%rdx
  80042167ec:	48 29 c2             	sub    %rax,%rdx
  80042167ef:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  80042167f6:	00 00 00 
  80042167f9:	48 01 c2             	add    %rax,%rdx
  80042167fc:	48 b8 e0 a3 60 04 80 	movabs $0x800460a3e0,%rax
  8004216803:	00 00 00 
  8004216806:	48 8b 00             	mov    (%rax),%rax
  8004216809:	48 39 c2             	cmp    %rax,%rdx
  800421680c:	74 16                	je     8004216824 <lapic_init+0xf2>
		lapicw(LINT0, MASKED);
  800421680e:	be 00 00 01 00       	mov    $0x10000,%esi
  8004216813:	bf d4 00 00 00       	mov    $0xd4,%edi
  8004216818:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  800421681f:	00 00 00 
  8004216822:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  8004216824:	be 00 00 01 00       	mov    $0x10000,%esi
  8004216829:	bf d8 00 00 00       	mov    $0xd8,%edi
  800421682e:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  8004216835:	00 00 00 
  8004216838:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  800421683a:	48 b8 08 b0 68 04 80 	movabs $0x800468b008,%rax
  8004216841:	00 00 00 
  8004216844:	48 8b 00             	mov    (%rax),%rax
  8004216847:	48 83 c0 30          	add    $0x30,%rax
  800421684b:	8b 00                	mov    (%rax),%eax
  800421684d:	c1 e8 10             	shr    $0x10,%eax
  8004216850:	0f b6 c0             	movzbl %al,%eax
  8004216853:	83 f8 03             	cmp    $0x3,%eax
  8004216856:	76 16                	jbe    800421686e <lapic_init+0x13c>
		lapicw(PCINT, MASKED);
  8004216858:	be 00 00 01 00       	mov    $0x10000,%esi
  800421685d:	bf d0 00 00 00       	mov    $0xd0,%edi
  8004216862:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  8004216869:	00 00 00 
  800421686c:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  800421686e:	be 33 00 00 00       	mov    $0x33,%esi
  8004216873:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004216878:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  800421687f:	00 00 00 
  8004216882:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  8004216884:	be 00 00 00 00       	mov    $0x0,%esi
  8004216889:	bf a0 00 00 00       	mov    $0xa0,%edi
  800421688e:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  8004216895:	00 00 00 
  8004216898:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  800421689a:	be 00 00 00 00       	mov    $0x0,%esi
  800421689f:	bf a0 00 00 00       	mov    $0xa0,%edi
  80042168a4:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  80042168ab:	00 00 00 
  80042168ae:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  80042168b0:	be 00 00 00 00       	mov    $0x0,%esi
  80042168b5:	bf 2c 00 00 00       	mov    $0x2c,%edi
  80042168ba:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  80042168c1:	00 00 00 
  80042168c4:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  80042168c6:	be 00 00 00 00       	mov    $0x0,%esi
  80042168cb:	bf c4 00 00 00       	mov    $0xc4,%edi
  80042168d0:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  80042168d7:	00 00 00 
  80042168da:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  80042168dc:	be 00 85 08 00       	mov    $0x88500,%esi
  80042168e1:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042168e6:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  80042168ed:	00 00 00 
  80042168f0:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  80042168f2:	90                   	nop
  80042168f3:	48 b8 08 b0 68 04 80 	movabs $0x800468b008,%rax
  80042168fa:	00 00 00 
  80042168fd:	48 8b 00             	mov    (%rax),%rax
  8004216900:	48 05 00 03 00 00    	add    $0x300,%rax
  8004216906:	8b 00                	mov    (%rax),%eax
  8004216908:	25 00 10 00 00       	and    $0x1000,%eax
  800421690d:	85 c0                	test   %eax,%eax
  800421690f:	75 e2                	jne    80042168f3 <lapic_init+0x1c1>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  8004216911:	be 00 00 00 00       	mov    $0x0,%esi
  8004216916:	bf 20 00 00 00       	mov    $0x20,%edi
  800421691b:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  8004216922:	00 00 00 
  8004216925:	ff d0                	callq  *%rax
}
  8004216927:	5d                   	pop    %rbp
  8004216928:	c3                   	retq   

0000008004216929 <cpunum>:

int
cpunum(void)
{
  8004216929:	55                   	push   %rbp
  800421692a:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  800421692d:	48 b8 08 b0 68 04 80 	movabs $0x800468b008,%rax
  8004216934:	00 00 00 
  8004216937:	48 8b 00             	mov    (%rax),%rax
  800421693a:	48 85 c0             	test   %rax,%rax
  800421693d:	74 18                	je     8004216957 <cpunum+0x2e>
		return lapic[ID] >> 24;
  800421693f:	48 b8 08 b0 68 04 80 	movabs $0x800468b008,%rax
  8004216946:	00 00 00 
  8004216949:	48 8b 00             	mov    (%rax),%rax
  800421694c:	48 83 c0 20          	add    $0x20,%rax
  8004216950:	8b 00                	mov    (%rax),%eax
  8004216952:	c1 e8 18             	shr    $0x18,%eax
  8004216955:	eb 05                	jmp    800421695c <cpunum+0x33>
	return 0;
  8004216957:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421695c:	5d                   	pop    %rbp
  800421695d:	c3                   	retq   

000000800421695e <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  800421695e:	55                   	push   %rbp
  800421695f:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004216962:	48 b8 08 b0 68 04 80 	movabs $0x800468b008,%rax
  8004216969:	00 00 00 
  800421696c:	48 8b 00             	mov    (%rax),%rax
  800421696f:	48 85 c0             	test   %rax,%rax
  8004216972:	74 16                	je     800421698a <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004216974:	be 00 00 00 00       	mov    $0x0,%esi
  8004216979:	bf 2c 00 00 00       	mov    $0x2c,%edi
  800421697e:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  8004216985:	00 00 00 
  8004216988:	ff d0                	callq  *%rax
}
  800421698a:	5d                   	pop    %rbp
  800421698b:	c3                   	retq   

000000800421698c <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  800421698c:	55                   	push   %rbp
  800421698d:	48 89 e5             	mov    %rsp,%rbp
  8004216990:	48 83 ec 04          	sub    $0x4,%rsp
  8004216994:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004216997:	c9                   	leaveq 
  8004216998:	c3                   	retq   

0000008004216999 <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004216999:	55                   	push   %rbp
  800421699a:	48 89 e5             	mov    %rsp,%rbp
  800421699d:	48 83 ec 40          	sub    $0x40,%rsp
  80042169a1:	89 f8                	mov    %edi,%eax
  80042169a3:	89 75 c8             	mov    %esi,-0x38(%rbp)
  80042169a6:	88 45 cc             	mov    %al,-0x34(%rbp)
  80042169a9:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  80042169b0:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  80042169b4:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042169b8:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042169bb:	ee                   	out    %al,(%dx)
  80042169bc:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  80042169c3:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  80042169c7:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042169cb:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042169ce:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  80042169cf:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  80042169d6:	00 
  80042169d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042169db:	48 c1 e8 0c          	shr    $0xc,%rax
  80042169df:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042169e2:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042169e5:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  80042169ec:	00 00 00 
  80042169ef:	48 8b 00             	mov    (%rax),%rax
  80042169f2:	48 39 c2             	cmp    %rax,%rdx
  80042169f5:	72 32                	jb     8004216a29 <lapic_startap+0x90>
  80042169f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042169fb:	48 89 c1             	mov    %rax,%rcx
  80042169fe:	48 ba a0 aa 21 04 80 	movabs $0x800421aaa0,%rdx
  8004216a05:	00 00 00 
  8004216a08:	be 98 00 00 00       	mov    $0x98,%esi
  8004216a0d:	48 bf c3 aa 21 04 80 	movabs $0x800421aac3,%rdi
  8004216a14:	00 00 00 
  8004216a17:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216a1c:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004216a23:	00 00 00 
  8004216a26:	41 ff d0             	callq  *%r8
  8004216a29:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004216a30:	00 00 00 
  8004216a33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216a37:	48 01 d0             	add    %rdx,%rax
  8004216a3a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  8004216a3e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216a42:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004216a47:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216a4b:	48 8d 50 02          	lea    0x2(%rax),%rdx
  8004216a4f:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004216a52:	c1 e8 04             	shr    $0x4,%eax
  8004216a55:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004216a58:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004216a5c:	c1 e0 18             	shl    $0x18,%eax
  8004216a5f:	89 c6                	mov    %eax,%esi
  8004216a61:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216a66:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  8004216a6d:	00 00 00 
  8004216a70:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004216a72:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004216a77:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216a7c:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  8004216a83:	00 00 00 
  8004216a86:	ff d0                	callq  *%rax
	microdelay(200);
  8004216a88:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216a8d:	48 b8 8c 69 21 04 80 	movabs $0x800421698c,%rax
  8004216a94:	00 00 00 
  8004216a97:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004216a99:	be 00 85 00 00       	mov    $0x8500,%esi
  8004216a9e:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216aa3:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  8004216aaa:	00 00 00 
  8004216aad:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004216aaf:	bf 64 00 00 00       	mov    $0x64,%edi
  8004216ab4:	48 b8 8c 69 21 04 80 	movabs $0x800421698c,%rax
  8004216abb:	00 00 00 
  8004216abe:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004216ac0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004216ac7:	eb 4b                	jmp    8004216b14 <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  8004216ac9:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004216acd:	c1 e0 18             	shl    $0x18,%eax
  8004216ad0:	89 c6                	mov    %eax,%esi
  8004216ad2:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216ad7:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  8004216ade:	00 00 00 
  8004216ae1:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  8004216ae3:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004216ae6:	c1 e8 0c             	shr    $0xc,%eax
  8004216ae9:	80 cc 06             	or     $0x6,%ah
  8004216aec:	89 c6                	mov    %eax,%esi
  8004216aee:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216af3:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  8004216afa:	00 00 00 
  8004216afd:	ff d0                	callq  *%rax
		microdelay(200);
  8004216aff:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216b04:	48 b8 8c 69 21 04 80 	movabs $0x800421698c,%rax
  8004216b0b:	00 00 00 
  8004216b0e:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004216b10:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004216b14:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004216b18:	7e af                	jle    8004216ac9 <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  8004216b1a:	c9                   	leaveq 
  8004216b1b:	c3                   	retq   

0000008004216b1c <lapic_ipi>:

void
lapic_ipi(int vector)
{
  8004216b1c:	55                   	push   %rbp
  8004216b1d:	48 89 e5             	mov    %rsp,%rbp
  8004216b20:	48 83 ec 08          	sub    $0x8,%rsp
  8004216b24:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  8004216b27:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216b2a:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004216b2f:	89 c6                	mov    %eax,%esi
  8004216b31:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216b36:	48 b8 f0 66 21 04 80 	movabs $0x80042166f0,%rax
  8004216b3d:	00 00 00 
  8004216b40:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004216b42:	90                   	nop
  8004216b43:	48 b8 08 b0 68 04 80 	movabs $0x800468b008,%rax
  8004216b4a:	00 00 00 
  8004216b4d:	48 8b 00             	mov    (%rax),%rax
  8004216b50:	48 05 00 03 00 00    	add    $0x300,%rax
  8004216b56:	8b 00                	mov    (%rax),%eax
  8004216b58:	25 00 10 00 00       	and    $0x1000,%eax
  8004216b5d:	85 c0                	test   %eax,%eax
  8004216b5f:	75 e2                	jne    8004216b43 <lapic_ipi+0x27>
		;
}
  8004216b61:	c9                   	leaveq 
  8004216b62:	c3                   	retq   

0000008004216b63 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004216b63:	55                   	push   %rbp
  8004216b64:	48 89 e5             	mov    %rsp,%rbp
  8004216b67:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004216b6b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004216b6f:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004216b72:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004216b76:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216b79:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004216b7d:	f0 87 02             	lock xchg %eax,(%rdx)
  8004216b80:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004216b83:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004216b86:	c9                   	leaveq 
  8004216b87:	c3                   	retq   

0000008004216b88 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004216b88:	55                   	push   %rbp
  8004216b89:	48 89 e5             	mov    %rsp,%rbp
  8004216b8c:	48 83 ec 28          	sub    $0x28,%rsp
  8004216b90:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004216b94:	48 89 e8             	mov    %rbp,%rax
  8004216b97:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return rbp;
  8004216b9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004216b9f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  8004216ba3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004216baa:	eb 45                	jmp    8004216bf1 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004216bac:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004216bb1:	74 44                	je     8004216bf7 <get_caller_pcs+0x6f>
  8004216bb3:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004216bba:	00 00 00 
  8004216bbd:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004216bc1:	76 34                	jbe    8004216bf7 <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  8004216bc3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216bc6:	48 98                	cltq   
  8004216bc8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004216bcf:	00 
  8004216bd0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216bd4:	48 01 c2             	add    %rax,%rdx
  8004216bd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216bdb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004216bdf:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004216be2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216be6:	48 8b 00             	mov    (%rax),%rax
  8004216be9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  8004216bed:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216bf1:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004216bf5:	7e b5                	jle    8004216bac <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216bf7:	eb 1f                	jmp    8004216c18 <get_caller_pcs+0x90>
		pcs[i] = 0;
  8004216bf9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216bfc:	48 98                	cltq   
  8004216bfe:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004216c05:	00 
  8004216c06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c0a:	48 01 d0             	add    %rdx,%rax
  8004216c0d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216c14:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216c18:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004216c1c:	7e db                	jle    8004216bf9 <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  8004216c1e:	c9                   	leaveq 
  8004216c1f:	c3                   	retq   

0000008004216c20 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004216c20:	55                   	push   %rbp
  8004216c21:	48 89 e5             	mov    %rsp,%rbp
  8004216c24:	53                   	push   %rbx
  8004216c25:	48 83 ec 18          	sub    $0x18,%rsp
  8004216c29:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  8004216c2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216c31:	8b 00                	mov    (%rax),%eax
  8004216c33:	85 c0                	test   %eax,%eax
  8004216c35:	74 3d                	je     8004216c74 <holding+0x54>
  8004216c37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216c3b:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004216c3f:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004216c46:	00 00 00 
  8004216c49:	ff d0                	callq  *%rax
  8004216c4b:	48 98                	cltq   
  8004216c4d:	48 c1 e0 03          	shl    $0x3,%rax
  8004216c51:	48 89 c2             	mov    %rax,%rdx
  8004216c54:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216c58:	48 29 c2             	sub    %rax,%rdx
  8004216c5b:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  8004216c62:	00 00 00 
  8004216c65:	48 01 d0             	add    %rdx,%rax
  8004216c68:	48 39 c3             	cmp    %rax,%rbx
  8004216c6b:	75 07                	jne    8004216c74 <holding+0x54>
  8004216c6d:	b8 01 00 00 00       	mov    $0x1,%eax
  8004216c72:	eb 05                	jmp    8004216c79 <holding+0x59>
  8004216c74:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216c79:	48 83 c4 18          	add    $0x18,%rsp
  8004216c7d:	5b                   	pop    %rbx
  8004216c7e:	5d                   	pop    %rbp
  8004216c7f:	c3                   	retq   

0000008004216c80 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004216c80:	55                   	push   %rbp
  8004216c81:	48 89 e5             	mov    %rsp,%rbp
  8004216c84:	48 83 ec 10          	sub    $0x10,%rsp
  8004216c88:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004216c8c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004216c90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216c94:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004216c9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216c9e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004216ca2:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  8004216ca6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216caa:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004216cb1:	00 
#endif
}
  8004216cb2:	c9                   	leaveq 
  8004216cb3:	c3                   	retq   

0000008004216cb4 <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004216cb4:	55                   	push   %rbp
  8004216cb5:	48 89 e5             	mov    %rsp,%rbp
  8004216cb8:	53                   	push   %rbx
  8004216cb9:	48 83 ec 18          	sub    $0x18,%rsp
  8004216cbd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  8004216cc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216cc5:	48 89 c7             	mov    %rax,%rdi
  8004216cc8:	48 b8 20 6c 21 04 80 	movabs $0x8004216c20,%rax
  8004216ccf:	00 00 00 
  8004216cd2:	ff d0                	callq  *%rax
  8004216cd4:	85 c0                	test   %eax,%eax
  8004216cd6:	74 44                	je     8004216d1c <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004216cd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216cdc:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216ce0:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004216ce7:	00 00 00 
  8004216cea:	ff d0                	callq  *%rax
  8004216cec:	49 89 d8             	mov    %rbx,%r8
  8004216cef:	89 c1                	mov    %eax,%ecx
  8004216cf1:	48 ba e0 aa 21 04 80 	movabs $0x800421aae0,%rdx
  8004216cf8:	00 00 00 
  8004216cfb:	be 41 00 00 00       	mov    $0x41,%esi
  8004216d00:	48 bf 0a ab 21 04 80 	movabs $0x800421ab0a,%rdi
  8004216d07:	00 00 00 
  8004216d0a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d0f:	49 b9 23 05 20 04 80 	movabs $0x8004200523,%r9
  8004216d16:	00 00 00 
  8004216d19:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004216d1c:	eb 02                	jmp    8004216d20 <spin_lock+0x6c>
		asm volatile ("pause");
  8004216d1e:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004216d20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216d24:	be 01 00 00 00       	mov    $0x1,%esi
  8004216d29:	48 89 c7             	mov    %rax,%rdi
  8004216d2c:	48 b8 63 6b 21 04 80 	movabs $0x8004216b63,%rax
  8004216d33:	00 00 00 
  8004216d36:	ff d0                	callq  *%rax
  8004216d38:	85 c0                	test   %eax,%eax
  8004216d3a:	75 e2                	jne    8004216d1e <spin_lock+0x6a>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  8004216d3c:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004216d43:	00 00 00 
  8004216d46:	ff d0                	callq  *%rax
  8004216d48:	48 98                	cltq   
  8004216d4a:	48 c1 e0 03          	shl    $0x3,%rax
  8004216d4e:	48 89 c2             	mov    %rax,%rdx
  8004216d51:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216d55:	48 29 c2             	sub    %rax,%rdx
  8004216d58:	48 b8 20 a0 60 04 80 	movabs $0x800460a020,%rax
  8004216d5f:	00 00 00 
  8004216d62:	48 01 c2             	add    %rax,%rdx
  8004216d65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216d69:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004216d6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216d71:	48 83 c0 18          	add    $0x18,%rax
  8004216d75:	48 89 c7             	mov    %rax,%rdi
  8004216d78:	48 b8 88 6b 21 04 80 	movabs $0x8004216b88,%rax
  8004216d7f:	00 00 00 
  8004216d82:	ff d0                	callq  *%rax
#endif
}
  8004216d84:	48 83 c4 18          	add    $0x18,%rsp
  8004216d88:	5b                   	pop    %rbx
  8004216d89:	5d                   	pop    %rbp
  8004216d8a:	c3                   	retq   

0000008004216d8b <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004216d8b:	55                   	push   %rbp
  8004216d8c:	48 89 e5             	mov    %rsp,%rbp
  8004216d8f:	41 54                	push   %r12
  8004216d91:	53                   	push   %rbx
  8004216d92:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004216d99:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004216da0:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216da7:	48 89 c7             	mov    %rax,%rdi
  8004216daa:	48 b8 20 6c 21 04 80 	movabs $0x8004216c20,%rax
  8004216db1:	00 00 00 
  8004216db4:	ff d0                	callq  *%rax
  8004216db6:	85 c0                	test   %eax,%eax
  8004216db8:	0f 85 d2 01 00 00    	jne    8004216f90 <spin_unlock+0x205>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  8004216dbe:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216dc5:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004216dc9:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004216dd0:	ba 28 00 00 00       	mov    $0x28,%edx
  8004216dd5:	48 89 ce             	mov    %rcx,%rsi
  8004216dd8:	48 89 c7             	mov    %rax,%rdi
  8004216ddb:	48 b8 13 fa 20 04 80 	movabs $0x800420fa13,%rax
  8004216de2:	00 00 00 
  8004216de5:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004216de7:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216dee:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216df2:	48 85 c0             	test   %rax,%rax
  8004216df5:	75 39                	jne    8004216e30 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  8004216df7:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216dfe:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216e02:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004216e09:	00 00 00 
  8004216e0c:	ff d0                	callq  *%rax
  8004216e0e:	48 89 da             	mov    %rbx,%rdx
  8004216e11:	89 c6                	mov    %eax,%esi
  8004216e13:	48 bf 20 ab 21 04 80 	movabs $0x800421ab20,%rdi
  8004216e1a:	00 00 00 
  8004216e1d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216e22:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  8004216e29:	00 00 00 
  8004216e2c:	ff d1                	callq  *%rcx
  8004216e2e:	eb 4d                	jmp    8004216e7d <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004216e30:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216e37:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216e3b:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  8004216e3e:	44 0f b6 e0          	movzbl %al,%r12d
  8004216e42:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216e49:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216e4d:	48 b8 29 69 21 04 80 	movabs $0x8004216929,%rax
  8004216e54:	00 00 00 
  8004216e57:	ff d0                	callq  *%rax
  8004216e59:	44 89 e1             	mov    %r12d,%ecx
  8004216e5c:	48 89 da             	mov    %rbx,%rdx
  8004216e5f:	89 c6                	mov    %eax,%esi
  8004216e61:	48 bf 60 ab 21 04 80 	movabs $0x800421ab60,%rdi
  8004216e68:	00 00 00 
  8004216e6b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216e70:	49 b8 c3 8d 20 04 80 	movabs $0x8004208dc3,%r8
  8004216e77:	00 00 00 
  8004216e7a:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004216e7d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004216e84:	e9 c3 00 00 00       	jmpq   8004216f4c <spin_unlock+0x1c1>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  8004216e89:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216e8c:	48 98                	cltq   
  8004216e8e:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216e95:	89 c0                	mov    %eax,%eax
  8004216e97:	48 8d 95 10 fb ff ff 	lea    -0x4f0(%rbp),%rdx
  8004216e9e:	48 89 d6             	mov    %rdx,%rsi
  8004216ea1:	48 89 c7             	mov    %rax,%rdi
  8004216ea4:	48 b8 f0 e5 20 04 80 	movabs $0x800420e5f0,%rax
  8004216eab:	00 00 00 
  8004216eae:	ff d0                	callq  *%rax
  8004216eb0:	85 c0                	test   %eax,%eax
  8004216eb2:	78 6b                	js     8004216f1f <spin_unlock+0x194>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004216eb4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216eb7:	48 98                	cltq   
  8004216eb9:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004216ec0:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004216ec2:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004216ec9:	48 29 c2             	sub    %rax,%rdx
  8004216ecc:	49 89 d0             	mov    %rdx,%r8
  8004216ecf:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  8004216ed6:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  8004216edc:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  8004216ee2:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8004216ee9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216eec:	48 98                	cltq   
  8004216eee:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216ef5:	4c 89 04 24          	mov    %r8,(%rsp)
  8004216ef9:	49 89 f9             	mov    %rdi,%r9
  8004216efc:	41 89 f0             	mov    %esi,%r8d
  8004216eff:	89 c6                	mov    %eax,%esi
  8004216f01:	48 bf 96 ab 21 04 80 	movabs $0x800421ab96,%rdi
  8004216f08:	00 00 00 
  8004216f0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216f10:	49 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%r10
  8004216f17:	00 00 00 
  8004216f1a:	41 ff d2             	callq  *%r10
  8004216f1d:	eb 29                	jmp    8004216f48 <spin_unlock+0x1bd>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  8004216f1f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216f22:	48 98                	cltq   
  8004216f24:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216f2b:	89 c6                	mov    %eax,%esi
  8004216f2d:	48 bf ad ab 21 04 80 	movabs $0x800421abad,%rdi
  8004216f34:	00 00 00 
  8004216f37:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216f3c:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004216f43:	00 00 00 
  8004216f46:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004216f48:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004216f4c:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  8004216f50:	7f 14                	jg     8004216f66 <spin_unlock+0x1db>
  8004216f52:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216f55:	48 98                	cltq   
  8004216f57:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216f5e:	85 c0                	test   %eax,%eax
  8004216f60:	0f 85 23 ff ff ff    	jne    8004216e89 <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  8004216f66:	48 ba b5 ab 21 04 80 	movabs $0x800421abb5,%rdx
  8004216f6d:	00 00 00 
  8004216f70:	be 6b 00 00 00       	mov    $0x6b,%esi
  8004216f75:	48 bf 0a ab 21 04 80 	movabs $0x800421ab0a,%rdi
  8004216f7c:	00 00 00 
  8004216f7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216f84:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  8004216f8b:	00 00 00 
  8004216f8e:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  8004216f90:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216f97:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  8004216f9e:	00 
	lk->cpu = 0;
  8004216f9f:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216fa6:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004216fad:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  8004216fae:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216fb5:	be 00 00 00 00       	mov    $0x0,%esi
  8004216fba:	48 89 c7             	mov    %rax,%rdi
  8004216fbd:	48 b8 63 6b 21 04 80 	movabs $0x8004216b63,%rax
  8004216fc4:	00 00 00 
  8004216fc7:	ff d0                	callq  *%rax
}
  8004216fc9:	48 81 c4 20 05 00 00 	add    $0x520,%rsp
  8004216fd0:	5b                   	pop    %rbx
  8004216fd1:	41 5c                	pop    %r12
  8004216fd3:	5d                   	pop    %rbp
  8004216fd4:	c3                   	retq   

0000008004216fd5 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004216fd5:	55                   	push   %rbp
  8004216fd6:	48 89 e5             	mov    %rsp,%rbp
  8004216fd9:	48 83 ec 08          	sub    $0x8,%rsp
  8004216fdd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004216fe1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216fe5:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  8004216fec:	00 00 00 
  8004216fef:	48 8b 00             	mov    (%rax),%rax
  8004216ff2:	48 29 c2             	sub    %rax,%rdx
  8004216ff5:	48 89 d0             	mov    %rdx,%rax
  8004216ff8:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004216ffc:	c9                   	leaveq 
  8004216ffd:	c3                   	retq   

0000008004216ffe <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004216ffe:	55                   	push   %rbp
  8004216fff:	48 89 e5             	mov    %rsp,%rbp
  8004217002:	48 83 ec 08          	sub    $0x8,%rsp
  8004217006:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800421700a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421700e:	48 89 c7             	mov    %rax,%rdi
  8004217011:	48 b8 d5 6f 21 04 80 	movabs $0x8004216fd5,%rax
  8004217018:	00 00 00 
  800421701b:	ff d0                	callq  *%rax
  800421701d:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004217021:	c9                   	leaveq 
  8004217022:	c3                   	retq   

0000008004217023 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004217023:	55                   	push   %rbp
  8004217024:	48 89 e5             	mov    %rsp,%rbp
  8004217027:	48 83 ec 10          	sub    $0x10,%rsp
  800421702b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  800421702f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217033:	48 c1 e8 0c          	shr    $0xc,%rax
  8004217037:	48 89 c2             	mov    %rax,%rdx
  800421703a:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  8004217041:	00 00 00 
  8004217044:	48 8b 00             	mov    (%rax),%rax
  8004217047:	48 39 c2             	cmp    %rax,%rdx
  800421704a:	72 2a                	jb     8004217076 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  800421704c:	48 ba c8 ab 21 04 80 	movabs $0x800421abc8,%rdx
  8004217053:	00 00 00 
  8004217056:	be 54 00 00 00       	mov    $0x54,%esi
  800421705b:	48 bf e7 ab 21 04 80 	movabs $0x800421abe7,%rdi
  8004217062:	00 00 00 
  8004217065:	b8 00 00 00 00       	mov    $0x0,%eax
  800421706a:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  8004217071:	00 00 00 
  8004217074:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004217076:	48 b8 88 87 60 04 80 	movabs $0x8004608788,%rax
  800421707d:	00 00 00 
  8004217080:	48 8b 00             	mov    (%rax),%rax
  8004217083:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004217087:	48 c1 ea 0c          	shr    $0xc,%rdx
  800421708b:	48 c1 e2 04          	shl    $0x4,%rdx
  800421708f:	48 01 d0             	add    %rdx,%rax
}
  8004217092:	c9                   	leaveq 
  8004217093:	c3                   	retq   

0000008004217094 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004217094:	55                   	push   %rbp
  8004217095:	48 89 e5             	mov    %rsp,%rbp
  8004217098:	48 83 ec 20          	sub    $0x20,%rsp
  800421709c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  80042170a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042170a4:	48 89 c7             	mov    %rax,%rdi
  80042170a7:	48 b8 fe 6f 21 04 80 	movabs $0x8004216ffe,%rax
  80042170ae:	00 00 00 
  80042170b1:	ff d0                	callq  *%rax
  80042170b3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042170b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042170bb:	48 c1 e8 0c          	shr    $0xc,%rax
  80042170bf:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042170c2:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042170c5:	48 b8 80 87 60 04 80 	movabs $0x8004608780,%rax
  80042170cc:	00 00 00 
  80042170cf:	48 8b 00             	mov    (%rax),%rax
  80042170d2:	48 39 c2             	cmp    %rax,%rdx
  80042170d5:	72 32                	jb     8004217109 <page2kva+0x75>
  80042170d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042170db:	48 89 c1             	mov    %rax,%rcx
  80042170de:	48 ba f8 ab 21 04 80 	movabs $0x800421abf8,%rdx
  80042170e5:	00 00 00 
  80042170e8:	be 5b 00 00 00       	mov    $0x5b,%esi
  80042170ed:	48 bf e7 ab 21 04 80 	movabs $0x800421abe7,%rdi
  80042170f4:	00 00 00 
  80042170f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042170fc:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004217103:	00 00 00 
  8004217106:	41 ff d0             	callq  *%r8
  8004217109:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004217110:	00 00 00 
  8004217113:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217117:	48 01 d0             	add    %rdx,%rax
}
  800421711a:	c9                   	leaveq 
  800421711b:	c3                   	retq   

000000800421711c <initializeDescriptors>:
int tx_desc_head = 0;
int tx_desc_tail = 0;
volatile uint32_t *map_region;


void initializeDescriptors(){
  800421711c:	55                   	push   %rbp
  800421711d:	48 89 e5             	mov    %rsp,%rbp
  8004217120:	48 83 ec 10          	sub    $0x10,%rsp
    int i;
    struct PageInfo* page;
    for (i = 0;i<64;i++){
  8004217124:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421712b:	e9 99 00 00 00       	jmpq   80042171c9 <initializeDescriptors+0xad>
        page = page_alloc(1);
  8004217130:	bf 01 00 00 00       	mov    $0x1,%edi
  8004217135:	48 b8 33 2f 20 04 80 	movabs $0x8004202f33,%rax
  800421713c:	00 00 00 
  800421713f:	ff d0                	callq  *%rax
  8004217141:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        txDescArr[i].addr = page2pa(page);
  8004217145:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217149:	48 89 c7             	mov    %rax,%rdi
  800421714c:	48 b8 fe 6f 21 04 80 	movabs $0x8004216ffe,%rax
  8004217153:	00 00 00 
  8004217156:	ff d0                	callq  *%rax
  8004217158:	48 ba 20 b0 68 04 80 	movabs $0x800468b020,%rdx
  800421715f:	00 00 00 
  8004217162:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004217165:	48 63 c9             	movslq %ecx,%rcx
  8004217168:	48 c1 e1 04          	shl    $0x4,%rcx
  800421716c:	48 01 ca             	add    %rcx,%rdx
  800421716f:	48 89 02             	mov    %rax,(%rdx)
        txDescArr[i].cmd = 0x08;
  8004217172:	48 b8 20 b0 68 04 80 	movabs $0x800468b020,%rax
  8004217179:	00 00 00 
  800421717c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421717f:	48 63 d2             	movslq %edx,%rdx
  8004217182:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217186:	48 01 d0             	add    %rdx,%rax
  8004217189:	c6 40 0b 08          	movb   $0x8,0xb(%rax)
        txDescArr[i].length = E1000_TXD_BUFFER_LENGTH;
  800421718d:	48 b8 20 b0 68 04 80 	movabs $0x800468b020,%rax
  8004217194:	00 00 00 
  8004217197:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421719a:	48 63 d2             	movslq %edx,%rdx
  800421719d:	48 c1 e2 04          	shl    $0x4,%rdx
  80042171a1:	48 01 d0             	add    %rdx,%rax
  80042171a4:	66 c7 40 08 ee 05    	movw   $0x5ee,0x8(%rax)
        txDescArr[i].status = 0x1;
  80042171aa:	48 b8 20 b0 68 04 80 	movabs $0x800468b020,%rax
  80042171b1:	00 00 00 
  80042171b4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042171b7:	48 63 d2             	movslq %edx,%rdx
  80042171ba:	48 c1 e2 04          	shl    $0x4,%rdx
  80042171be:	48 01 d0             	add    %rdx,%rax
  80042171c1:	c6 40 0c 01          	movb   $0x1,0xc(%rax)


void initializeDescriptors(){
    int i;
    struct PageInfo* page;
    for (i = 0;i<64;i++){
  80042171c5:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042171c9:	83 7d fc 3f          	cmpl   $0x3f,-0x4(%rbp)
  80042171cd:	0f 8e 5d ff ff ff    	jle    8004217130 <initializeDescriptors+0x14>
        txDescArr[i].addr = page2pa(page);
        txDescArr[i].cmd = 0x08;
        txDescArr[i].length = E1000_TXD_BUFFER_LENGTH;
        txDescArr[i].status = 0x1;
    }
}
  80042171d3:	c9                   	leaveq 
  80042171d4:	c3                   	retq   

00000080042171d5 <pci_transmit_packet>:

int pci_transmit_packet(const void * src,size_t n){ //Need to check for more parameters
  80042171d5:	55                   	push   %rbp
  80042171d6:	48 89 e5             	mov    %rsp,%rbp
  80042171d9:	48 83 ec 20          	sub    $0x20,%rsp
  80042171dd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042171e1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    void * va;
	cprintf("%d\n", n);
  80042171e5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042171e9:	48 89 c6             	mov    %rax,%rsi
  80042171ec:	48 bf 1b ac 21 04 80 	movabs $0x800421ac1b,%rdi
  80042171f3:	00 00 00 
  80042171f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042171fb:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004217202:	00 00 00 
  8004217205:	ff d2                	callq  *%rdx
    if(n > E1000_TXD_BUFFER_LENGTH || n < 1){
  8004217207:	48 81 7d e0 ee 05 00 	cmpq   $0x5ee,-0x20(%rbp)
  800421720e:	00 
  800421720f:	77 07                	ja     8004217218 <pci_transmit_packet+0x43>
  8004217211:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004217216:	75 25                	jne    800421723d <pci_transmit_packet+0x68>
        cprintf("This should not fail\n");
  8004217218:	48 bf 1f ac 21 04 80 	movabs $0x800421ac1f,%rdi
  800421721f:	00 00 00 
  8004217222:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217227:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800421722e:	00 00 00 
  8004217231:	ff d2                	callq  *%rdx
        return -1;
  8004217233:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004217238:	e9 4b 01 00 00       	jmpq   8004217388 <pci_transmit_packet+0x1b3>
    }
    /*check if free descriptors are available*/
    if(!(txDescArr[tx_desc_tail].status & 0x1)){
  800421723d:	48 b8 2c 87 60 04 80 	movabs $0x800460872c,%rax
  8004217244:	00 00 00 
  8004217247:	8b 10                	mov    (%rax),%edx
  8004217249:	48 b8 20 b0 68 04 80 	movabs $0x800468b020,%rax
  8004217250:	00 00 00 
  8004217253:	48 63 d2             	movslq %edx,%rdx
  8004217256:	48 c1 e2 04          	shl    $0x4,%rdx
  800421725a:	48 01 d0             	add    %rdx,%rax
  800421725d:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004217261:	0f b6 c0             	movzbl %al,%eax
  8004217264:	83 e0 01             	and    $0x1,%eax
  8004217267:	85 c0                	test   %eax,%eax
  8004217269:	75 5a                	jne    80042172c5 <pci_transmit_packet+0xf0>
        cprintf("Tx Desc is not found [%d] and [%d]\n",txDescArr[tx_desc_tail].status, tx_desc_tail);
  800421726b:	48 b8 2c 87 60 04 80 	movabs $0x800460872c,%rax
  8004217272:	00 00 00 
  8004217275:	8b 10                	mov    (%rax),%edx
  8004217277:	48 b8 2c 87 60 04 80 	movabs $0x800460872c,%rax
  800421727e:	00 00 00 
  8004217281:	8b 08                	mov    (%rax),%ecx
  8004217283:	48 b8 20 b0 68 04 80 	movabs $0x800468b020,%rax
  800421728a:	00 00 00 
  800421728d:	48 63 c9             	movslq %ecx,%rcx
  8004217290:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217294:	48 01 c8             	add    %rcx,%rax
  8004217297:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  800421729b:	0f b6 c0             	movzbl %al,%eax
  800421729e:	89 c6                	mov    %eax,%esi
  80042172a0:	48 bf 38 ac 21 04 80 	movabs $0x800421ac38,%rdi
  80042172a7:	00 00 00 
  80042172aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042172af:	48 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%rcx
  80042172b6:	00 00 00 
  80042172b9:	ff d1                	callq  *%rcx
        return -1;
  80042172bb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042172c0:	e9 c3 00 00 00       	jmpq   8004217388 <pci_transmit_packet+0x1b3>
    }

    va = page2kva(pa2page(txDescArr[tx_desc_tail].addr));
  80042172c5:	48 b8 2c 87 60 04 80 	movabs $0x800460872c,%rax
  80042172cc:	00 00 00 
  80042172cf:	8b 10                	mov    (%rax),%edx
  80042172d1:	48 b8 20 b0 68 04 80 	movabs $0x800468b020,%rax
  80042172d8:	00 00 00 
  80042172db:	48 63 d2             	movslq %edx,%rdx
  80042172de:	48 c1 e2 04          	shl    $0x4,%rdx
  80042172e2:	48 01 d0             	add    %rdx,%rax
  80042172e5:	48 8b 00             	mov    (%rax),%rax
  80042172e8:	48 89 c7             	mov    %rax,%rdi
  80042172eb:	48 b8 23 70 21 04 80 	movabs $0x8004217023,%rax
  80042172f2:	00 00 00 
  80042172f5:	ff d0                	callq  *%rax
  80042172f7:	48 89 c7             	mov    %rax,%rdi
  80042172fa:	48 b8 94 70 21 04 80 	movabs $0x8004217094,%rax
  8004217301:	00 00 00 
  8004217304:	ff d0                	callq  *%rax
  8004217306:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    //memmove(va, src, n);
    tx_desc_tail++;
  800421730a:	48 b8 2c 87 60 04 80 	movabs $0x800460872c,%rax
  8004217311:	00 00 00 
  8004217314:	8b 00                	mov    (%rax),%eax
  8004217316:	8d 50 01             	lea    0x1(%rax),%edx
  8004217319:	48 b8 2c 87 60 04 80 	movabs $0x800460872c,%rax
  8004217320:	00 00 00 
  8004217323:	89 10                	mov    %edx,(%rax)
    map_region[0x3818 >> 2] = tx_desc_tail;
  8004217325:	48 b8 20 b4 68 04 80 	movabs $0x800468b420,%rax
  800421732c:	00 00 00 
  800421732f:	48 8b 00             	mov    (%rax),%rax
  8004217332:	48 8d 90 18 38 00 00 	lea    0x3818(%rax),%rdx
  8004217339:	48 b8 2c 87 60 04 80 	movabs $0x800460872c,%rax
  8004217340:	00 00 00 
  8004217343:	8b 00                	mov    (%rax),%eax
  8004217345:	89 02                	mov    %eax,(%rdx)
    if(tx_desc_tail == 64){
  8004217347:	48 b8 2c 87 60 04 80 	movabs $0x800460872c,%rax
  800421734e:	00 00 00 
  8004217351:	8b 00                	mov    (%rax),%eax
  8004217353:	83 f8 40             	cmp    $0x40,%eax
  8004217356:	75 10                	jne    8004217368 <pci_transmit_packet+0x193>
    	tx_desc_tail = 0;
  8004217358:	48 b8 2c 87 60 04 80 	movabs $0x800460872c,%rax
  800421735f:	00 00 00 
  8004217362:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    }
    cprintf("We did all we can \n");
  8004217368:	48 bf 5c ac 21 04 80 	movabs $0x800421ac5c,%rdi
  800421736f:	00 00 00 
  8004217372:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217377:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  800421737e:	00 00 00 
  8004217381:	ff d2                	callq  *%rdx
    return 0;
  8004217383:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217388:	c9                   	leaveq 
  8004217389:	c3                   	retq   

000000800421738a <pci_func_attach_E1000>:

int
pci_func_attach_E1000(struct pci_func *f)
{
  800421738a:	55                   	push   %rbp
  800421738b:	48 89 e5             	mov    %rsp,%rbp
  800421738e:	48 83 ec 20          	sub    $0x20,%rsp
  8004217392:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    pci_func_enable(f);
  8004217396:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421739a:	48 89 c7             	mov    %rax,%rdi
  800421739d:	48 b8 6e 7d 21 04 80 	movabs $0x8004217d6e,%rax
  80042173a4:	00 00 00 
  80042173a7:	ff d0                	callq  *%rax
    map_region = (uint32_t *)mmio_map_region(f->reg_base[0] ,(size_t)f->reg_size[0]);
  80042173a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042173ad:	8b 40 30             	mov    0x30(%rax),%eax
  80042173b0:	89 c2                	mov    %eax,%edx
  80042173b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042173b6:	8b 40 18             	mov    0x18(%rax),%eax
  80042173b9:	89 c0                	mov    %eax,%eax
  80042173bb:	48 89 d6             	mov    %rdx,%rsi
  80042173be:	48 89 c7             	mov    %rax,%rdi
  80042173c1:	48 b8 15 3b 20 04 80 	movabs $0x8004203b15,%rax
  80042173c8:	00 00 00 
  80042173cb:	ff d0                	callq  *%rax
  80042173cd:	48 ba 20 b4 68 04 80 	movabs $0x800468b420,%rdx
  80042173d4:	00 00 00 
  80042173d7:	48 89 02             	mov    %rax,(%rdx)
    cprintf("Device status reg is %x\n",map_region[2]);
  80042173da:	48 b8 20 b4 68 04 80 	movabs $0x800468b420,%rax
  80042173e1:	00 00 00 
  80042173e4:	48 8b 00             	mov    (%rax),%rax
  80042173e7:	48 83 c0 08          	add    $0x8,%rax
  80042173eb:	8b 00                	mov    (%rax),%eax
  80042173ed:	89 c6                	mov    %eax,%esi
  80042173ef:	48 bf 70 ac 21 04 80 	movabs $0x800421ac70,%rdi
  80042173f6:	00 00 00 
  80042173f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042173fe:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004217405:	00 00 00 
  8004217408:	ff d2                	callq  *%rdx
	map_region[0x3810 >> 2] = 0x0; //TDH set to 0b
  800421740a:	48 b8 20 b4 68 04 80 	movabs $0x800468b420,%rax
  8004217411:	00 00 00 
  8004217414:	48 8b 00             	mov    (%rax),%rax
  8004217417:	48 05 10 38 00 00    	add    $0x3810,%rax
  800421741d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	map_region[0x3818 >> 2] = 0x0; //TDT set to 0b
  8004217423:	48 b8 20 b4 68 04 80 	movabs $0x800468b420,%rax
  800421742a:	00 00 00 
  800421742d:	48 8b 00             	mov    (%rax),%rax
  8004217430:	48 05 18 38 00 00    	add    $0x3818,%rax
  8004217436:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    map_region[0x400 >> 2] = 0x4008A; //TCTL
  800421743c:	48 b8 20 b4 68 04 80 	movabs $0x800468b420,%rax
  8004217443:	00 00 00 
  8004217446:	48 8b 00             	mov    (%rax),%rax
  8004217449:	48 05 00 04 00 00    	add    $0x400,%rax
  800421744f:	c7 00 8a 00 04 00    	movl   $0x4008a,(%rax)
    map_region[0x410 >> 2] = 0x60200A; //TIPG  /*binary: 00000000011000000010000000001010*/
  8004217455:	48 b8 20 b4 68 04 80 	movabs $0x800468b420,%rax
  800421745c:	00 00 00 
  800421745f:	48 8b 00             	mov    (%rax),%rax
  8004217462:	48 05 10 04 00 00    	add    $0x410,%rax
  8004217468:	c7 00 0a 20 60 00    	movl   $0x60200a,(%rax)
    map_region[0x3800 >> 2] = PADDR(txDescArr); //TDBAL & TDBAH
  800421746e:	48 b8 20 b4 68 04 80 	movabs $0x800468b420,%rax
  8004217475:	00 00 00 
  8004217478:	48 8b 00             	mov    (%rax),%rax
  800421747b:	48 8d 90 00 38 00 00 	lea    0x3800(%rax),%rdx
  8004217482:	48 b8 20 b0 68 04 80 	movabs $0x800468b020,%rax
  8004217489:	00 00 00 
  800421748c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004217490:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004217497:	00 00 00 
  800421749a:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421749e:	77 32                	ja     80042174d2 <pci_func_attach_E1000+0x148>
  80042174a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042174a4:	48 89 c1             	mov    %rax,%rcx
  80042174a7:	48 ba 90 ac 21 04 80 	movabs $0x800421ac90,%rdx
  80042174ae:	00 00 00 
  80042174b1:	be 3d 00 00 00       	mov    $0x3d,%esi
  80042174b6:	48 bf b4 ac 21 04 80 	movabs $0x800421acb4,%rdi
  80042174bd:	00 00 00 
  80042174c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042174c5:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042174cc:	00 00 00 
  80042174cf:	41 ff d0             	callq  *%r8
  80042174d2:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042174d9:	ff ff ff 
  80042174dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042174e0:	48 01 c8             	add    %rcx,%rax
  80042174e3:	89 02                	mov    %eax,(%rdx)
    map_region[0x3808 >> 2] = 0x400; //TDLEN set to 1024 = 64*16
  80042174e5:	48 b8 20 b4 68 04 80 	movabs $0x800468b420,%rax
  80042174ec:	00 00 00 
  80042174ef:	48 8b 00             	mov    (%rax),%rax
  80042174f2:	48 05 08 38 00 00    	add    $0x3808,%rax
  80042174f8:	c7 00 00 04 00 00    	movl   $0x400,(%rax)

    initializeDescriptors();
  80042174fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217503:	48 ba 1c 71 21 04 80 	movabs $0x800421711c,%rdx
  800421750a:	00 00 00 
  800421750d:	ff d2                	callq  *%rdx
    cprintf("Trying to send a packet\n");
  800421750f:	48 bf c1 ac 21 04 80 	movabs $0x800421acc1,%rdi
  8004217516:	00 00 00 
  8004217519:	b8 00 00 00 00       	mov    $0x0,%eax
  800421751e:	48 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%rdx
  8004217525:	00 00 00 
  8004217528:	ff d2                	callq  *%rdx
	//sys_page_map(0,UTEMP,0,UTEMP,PTE_P|PTE_U);

    return 0;
  800421752a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421752f:	c9                   	leaveq 
  8004217530:	c3                   	retq   

0000008004217531 <pci_conf1_set_addr>:
static void
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  8004217531:	55                   	push   %rbp
  8004217532:	48 89 e5             	mov    %rsp,%rbp
  8004217535:	48 83 ec 20          	sub    $0x20,%rsp
  8004217539:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800421753c:	89 75 e8             	mov    %esi,-0x18(%rbp)
  800421753f:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  8004217542:	89 4d e0             	mov    %ecx,-0x20(%rbp)
	assert(bus < 256);
  8004217545:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  800421754c:	76 35                	jbe    8004217583 <pci_conf1_set_addr+0x52>
  800421754e:	48 b9 e0 ac 21 04 80 	movabs $0x800421ace0,%rcx
  8004217555:	00 00 00 
  8004217558:	48 ba ea ac 21 04 80 	movabs $0x800421acea,%rdx
  800421755f:	00 00 00 
  8004217562:	be 2a 00 00 00       	mov    $0x2a,%esi
  8004217567:	48 bf ff ac 21 04 80 	movabs $0x800421acff,%rdi
  800421756e:	00 00 00 
  8004217571:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217576:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  800421757d:	00 00 00 
  8004217580:	41 ff d0             	callq  *%r8
	assert(dev < 32);
  8004217583:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  8004217587:	76 35                	jbe    80042175be <pci_conf1_set_addr+0x8d>
  8004217589:	48 b9 0a ad 21 04 80 	movabs $0x800421ad0a,%rcx
  8004217590:	00 00 00 
  8004217593:	48 ba ea ac 21 04 80 	movabs $0x800421acea,%rdx
  800421759a:	00 00 00 
  800421759d:	be 2b 00 00 00       	mov    $0x2b,%esi
  80042175a2:	48 bf ff ac 21 04 80 	movabs $0x800421acff,%rdi
  80042175a9:	00 00 00 
  80042175ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042175b1:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042175b8:	00 00 00 
  80042175bb:	41 ff d0             	callq  *%r8
	assert(func < 8);
  80042175be:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
  80042175c2:	76 35                	jbe    80042175f9 <pci_conf1_set_addr+0xc8>
  80042175c4:	48 b9 13 ad 21 04 80 	movabs $0x800421ad13,%rcx
  80042175cb:	00 00 00 
  80042175ce:	48 ba ea ac 21 04 80 	movabs $0x800421acea,%rdx
  80042175d5:	00 00 00 
  80042175d8:	be 2c 00 00 00       	mov    $0x2c,%esi
  80042175dd:	48 bf ff ac 21 04 80 	movabs $0x800421acff,%rdi
  80042175e4:	00 00 00 
  80042175e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042175ec:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  80042175f3:	00 00 00 
  80042175f6:	41 ff d0             	callq  *%r8
	assert(offset < 256);
  80042175f9:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%rbp)
  8004217600:	76 35                	jbe    8004217637 <pci_conf1_set_addr+0x106>
  8004217602:	48 b9 1c ad 21 04 80 	movabs $0x800421ad1c,%rcx
  8004217609:	00 00 00 
  800421760c:	48 ba ea ac 21 04 80 	movabs $0x800421acea,%rdx
  8004217613:	00 00 00 
  8004217616:	be 2d 00 00 00       	mov    $0x2d,%esi
  800421761b:	48 bf ff ac 21 04 80 	movabs $0x800421acff,%rdi
  8004217622:	00 00 00 
  8004217625:	b8 00 00 00 00       	mov    $0x0,%eax
  800421762a:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004217631:	00 00 00 
  8004217634:	41 ff d0             	callq  *%r8
	assert((offset & 0x3) == 0);
  8004217637:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421763a:	83 e0 03             	and    $0x3,%eax
  800421763d:	85 c0                	test   %eax,%eax
  800421763f:	74 35                	je     8004217676 <pci_conf1_set_addr+0x145>
  8004217641:	48 b9 29 ad 21 04 80 	movabs $0x800421ad29,%rcx
  8004217648:	00 00 00 
  800421764b:	48 ba ea ac 21 04 80 	movabs $0x800421acea,%rdx
  8004217652:	00 00 00 
  8004217655:	be 2e 00 00 00       	mov    $0x2e,%esi
  800421765a:	48 bf ff ac 21 04 80 	movabs $0x800421acff,%rdi
  8004217661:	00 00 00 
  8004217664:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217669:	49 b8 23 05 20 04 80 	movabs $0x8004200523,%r8
  8004217670:	00 00 00 
  8004217673:	41 ff d0             	callq  *%r8

	uint32_t v = (1 << 31) |		// config-space
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
  8004217676:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217679:	c1 e0 10             	shl    $0x10,%eax
  800421767c:	89 c2                	mov    %eax,%edx
  800421767e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004217681:	c1 e0 0b             	shl    $0xb,%eax
  8004217684:	09 c2                	or     %eax,%edx
  8004217686:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217689:	c1 e0 08             	shl    $0x8,%eax
  800421768c:	09 d0                	or     %edx,%eax
  800421768e:	0b 45 e0             	or     -0x20(%rbp),%eax
	assert(dev < 32);
	assert(func < 8);
	assert(offset < 256);
	assert((offset & 0x3) == 0);

	uint32_t v = (1 << 31) |		// config-space
  8004217691:	0d 00 00 00 80       	or     $0x80000000,%eax
  8004217696:	89 45 fc             	mov    %eax,-0x4(%rbp)
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
	outl(pci_conf1_addr_ioport, v);
  8004217699:	48 b8 04 d8 22 04 80 	movabs $0x800422d804,%rax
  80042176a0:	00 00 00 
  80042176a3:	8b 00                	mov    (%rax),%eax
  80042176a5:	89 45 f8             	mov    %eax,-0x8(%rbp)
  80042176a8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042176ab:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

static __inline void
outl(int port, uint32_t data)
{
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  80042176ae:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042176b1:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042176b4:	ef                   	out    %eax,(%dx)
}
  80042176b5:	c9                   	leaveq 
  80042176b6:	c3                   	retq   

00000080042176b7 <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  80042176b7:	55                   	push   %rbp
  80042176b8:	48 89 e5             	mov    %rsp,%rbp
  80042176bb:	48 83 ec 20          	sub    $0x20,%rsp
  80042176bf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042176c3:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  80042176c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042176ca:	8b 50 0c             	mov    0xc(%rax),%edx
  80042176cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042176d1:	8b 70 08             	mov    0x8(%rax),%esi
  80042176d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042176d8:	48 8b 00             	mov    (%rax),%rax
  80042176db:	8b 40 08             	mov    0x8(%rax),%eax
  80042176de:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  80042176e1:	89 c7                	mov    %eax,%edi
  80042176e3:	48 b8 31 75 21 04 80 	movabs $0x8004217531,%rax
  80042176ea:	00 00 00 
  80042176ed:	ff d0                	callq  *%rax
	return inl(pci_conf1_data_ioport);
  80042176ef:	48 b8 08 d8 22 04 80 	movabs $0x800422d808,%rax
  80042176f6:	00 00 00 
  80042176f9:	8b 00                	mov    (%rax),%eax
  80042176fb:	89 45 fc             	mov    %eax,-0x4(%rbp)

static __inline uint32_t
inl(int port)
{
	uint32_t data;
	__asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
  80042176fe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217701:	89 c2                	mov    %eax,%edx
  8004217703:	ed                   	in     (%dx),%eax
  8004217704:	89 45 f8             	mov    %eax,-0x8(%rbp)
	return data;
  8004217707:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  800421770a:	c9                   	leaveq 
  800421770b:	c3                   	retq   

000000800421770c <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  800421770c:	55                   	push   %rbp
  800421770d:	48 89 e5             	mov    %rsp,%rbp
  8004217710:	48 83 ec 20          	sub    $0x20,%rsp
  8004217714:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004217718:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800421771b:	89 55 e0             	mov    %edx,-0x20(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  800421771e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217722:	8b 50 0c             	mov    0xc(%rax),%edx
  8004217725:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217729:	8b 70 08             	mov    0x8(%rax),%esi
  800421772c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217730:	48 8b 00             	mov    (%rax),%rax
  8004217733:	8b 40 08             	mov    0x8(%rax),%eax
  8004217736:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004217739:	89 c7                	mov    %eax,%edi
  800421773b:	48 b8 31 75 21 04 80 	movabs $0x8004217531,%rax
  8004217742:	00 00 00 
  8004217745:	ff d0                	callq  *%rax
	outl(pci_conf1_data_ioport, v);
  8004217747:	48 b8 08 d8 22 04 80 	movabs $0x800422d808,%rax
  800421774e:	00 00 00 
  8004217751:	8b 00                	mov    (%rax),%eax
  8004217753:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004217756:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004217759:	89 45 f8             	mov    %eax,-0x8(%rbp)
}

static __inline void
outl(int port, uint32_t data)
{
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  800421775c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421775f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217762:	ef                   	out    %eax,(%dx)
}
  8004217763:	c9                   	leaveq 
  8004217764:	c3                   	retq   

0000008004217765 <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  8004217765:	55                   	push   %rbp
  8004217766:	48 89 e5             	mov    %rsp,%rbp
  8004217769:	48 83 ec 30          	sub    $0x30,%rsp
  800421776d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004217770:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004217773:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8004217777:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  800421777b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004217782:	e9 aa 00 00 00       	jmpq   8004217831 <pci_attach_match+0xcc>
		if (list[i].key1 == key1 && list[i].key2 == key2) {
  8004217787:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421778a:	48 c1 e0 04          	shl    $0x4,%rax
  800421778e:	48 89 c2             	mov    %rax,%rdx
  8004217791:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217795:	48 01 d0             	add    %rdx,%rax
  8004217798:	8b 00                	mov    (%rax),%eax
  800421779a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421779d:	0f 85 8a 00 00 00    	jne    800421782d <pci_attach_match+0xc8>
  80042177a3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042177a6:	48 c1 e0 04          	shl    $0x4,%rax
  80042177aa:	48 89 c2             	mov    %rax,%rdx
  80042177ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042177b1:	48 01 d0             	add    %rdx,%rax
  80042177b4:	8b 40 04             	mov    0x4(%rax),%eax
  80042177b7:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  80042177ba:	75 71                	jne    800421782d <pci_attach_match+0xc8>
			int r = list[i].attachfn(pcif);
  80042177bc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042177bf:	48 c1 e0 04          	shl    $0x4,%rax
  80042177c3:	48 89 c2             	mov    %rax,%rdx
  80042177c6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042177ca:	48 01 d0             	add    %rdx,%rax
  80042177cd:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042177d1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042177d5:	48 89 d7             	mov    %rdx,%rdi
  80042177d8:	ff d0                	callq  *%rax
  80042177da:	89 45 f8             	mov    %eax,-0x8(%rbp)
			if (r > 0)
  80042177dd:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042177e1:	7e 05                	jle    80042177e8 <pci_attach_match+0x83>
				return r;
  80042177e3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042177e6:	eb 6c                	jmp    8004217854 <pci_attach_match+0xef>
			if (r < 0)
  80042177e8:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042177ec:	79 3f                	jns    800421782d <pci_attach_match+0xc8>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
  80042177ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042177f1:	48 c1 e0 04          	shl    $0x4,%rax
  80042177f5:	48 89 c2             	mov    %rax,%rdx
  80042177f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042177fc:	48 01 d0             	add    %rdx,%rax
		if (list[i].key1 == key1 && list[i].key2 == key2) {
			int r = list[i].attachfn(pcif);
			if (r > 0)
				return r;
			if (r < 0)
				cprintf("pci_attach_match: attaching "
  80042177ff:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004217803:	8b 75 f8             	mov    -0x8(%rbp),%esi
  8004217806:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004217809:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421780c:	41 89 f0             	mov    %esi,%r8d
  800421780f:	89 c6                	mov    %eax,%esi
  8004217811:	48 bf 40 ad 21 04 80 	movabs $0x800421ad40,%rdi
  8004217818:	00 00 00 
  800421781b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217820:	49 b9 c3 8d 20 04 80 	movabs $0x8004208dc3,%r9
  8004217827:	00 00 00 
  800421782a:	41 ff d1             	callq  *%r9
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  800421782d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004217831:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217834:	48 c1 e0 04          	shl    $0x4,%rax
  8004217838:	48 89 c2             	mov    %rax,%rdx
  800421783b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421783f:	48 01 d0             	add    %rdx,%rax
  8004217842:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004217846:	48 85 c0             	test   %rax,%rax
  8004217849:	0f 85 38 ff ff ff    	jne    8004217787 <pci_attach_match+0x22>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
		}
	}
	return 0;
  800421784f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217854:	c9                   	leaveq 
  8004217855:	c3                   	retq   

0000008004217856 <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  8004217856:	55                   	push   %rbp
  8004217857:	48 89 e5             	mov    %rsp,%rbp
  800421785a:	48 83 ec 10          	sub    $0x10,%rsp
  800421785e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
  8004217862:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217866:	8b 40 14             	mov    0x14(%rax),%eax
  8004217869:	c1 e8 10             	shr    $0x10,%eax

static int
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
  800421786c:	0f b6 c0             	movzbl %al,%eax
  800421786f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004217873:	8b 52 14             	mov    0x14(%rdx),%edx
  8004217876:	89 d7                	mov    %edx,%edi
  8004217878:	c1 ef 18             	shr    $0x18,%edi
  800421787b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421787f:	48 89 d1             	mov    %rdx,%rcx
  8004217882:	48 ba 20 d8 22 04 80 	movabs $0x800422d820,%rdx
  8004217889:	00 00 00 
  800421788c:	89 c6                	mov    %eax,%esi
  800421788e:	48 b8 65 77 21 04 80 	movabs $0x8004217765,%rax
  8004217895:	00 00 00 
  8004217898:	ff d0                	callq  *%rax
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  800421789a:	85 c0                	test   %eax,%eax
  800421789c:	75 39                	jne    80042178d7 <pci_attach+0x81>
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
  800421789e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042178a2:	8b 40 10             	mov    0x10(%rax),%eax
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
  80042178a5:	c1 e8 10             	shr    $0x10,%eax
  80042178a8:	89 c6                	mov    %eax,%esi
  80042178aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042178ae:	8b 40 10             	mov    0x10(%rax),%eax
  80042178b1:	0f b7 c0             	movzwl %ax,%eax
  80042178b4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042178b8:	48 89 d1             	mov    %rdx,%rcx
  80042178bb:	48 ba 40 d8 22 04 80 	movabs $0x800422d840,%rdx
  80042178c2:	00 00 00 
  80042178c5:	89 c7                	mov    %eax,%edi
  80042178c7:	48 b8 65 77 21 04 80 	movabs $0x8004217765,%rax
  80042178ce:	00 00 00 
  80042178d1:	ff d0                	callq  *%rax
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  80042178d3:	85 c0                	test   %eax,%eax
  80042178d5:	74 07                	je     80042178de <pci_attach+0x88>
  80042178d7:	b8 01 00 00 00       	mov    $0x1,%eax
  80042178dc:	eb 05                	jmp    80042178e3 <pci_attach+0x8d>
  80042178de:	b8 00 00 00 00       	mov    $0x0,%eax
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
				 &pci_attach_vendor[0], f);
}
  80042178e3:	c9                   	leaveq 
  80042178e4:	c3                   	retq   

00000080042178e5 <pci_print_func>:
	[0x6] = "Bridge device",
};

static void
pci_print_func(struct pci_func *f)
{
  80042178e5:	55                   	push   %rbp
  80042178e6:	48 89 e5             	mov    %rsp,%rbp
  80042178e9:	48 83 ec 40          	sub    $0x40,%rsp
  80042178ed:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *class = pci_class[0];
  80042178f1:	48 b8 60 d8 22 04 80 	movabs $0x800422d860,%rax
  80042178f8:	00 00 00 
  80042178fb:	48 8b 00             	mov    (%rax),%rax
  80042178fe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
  8004217902:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217906:	8b 40 14             	mov    0x14(%rax),%eax
  8004217909:	c1 e8 18             	shr    $0x18,%eax
  800421790c:	83 f8 06             	cmp    $0x6,%eax
  800421790f:	77 20                	ja     8004217931 <pci_print_func+0x4c>
		class = pci_class[PCI_CLASS(f->dev_class)];
  8004217911:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217915:	8b 40 14             	mov    0x14(%rax),%eax
  8004217918:	c1 e8 18             	shr    $0x18,%eax
  800421791b:	89 c2                	mov    %eax,%edx
  800421791d:	48 b8 60 d8 22 04 80 	movabs $0x800422d860,%rax
  8004217924:	00 00 00 
  8004217927:	89 d2                	mov    %edx,%edx
  8004217929:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800421792d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
  8004217931:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217935:	0f b6 40 48          	movzbl 0x48(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217939:	0f b6 f8             	movzbl %al,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  800421793c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217940:	8b 40 14             	mov    0x14(%rax),%eax
  8004217943:	c1 e8 10             	shr    $0x10,%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217946:	0f b6 f0             	movzbl %al,%esi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004217949:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421794d:	8b 40 14             	mov    0x14(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217950:	c1 e8 18             	shr    $0x18,%eax
  8004217953:	41 89 c1             	mov    %eax,%r9d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004217956:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421795a:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421795d:	c1 e8 10             	shr    $0x10,%eax
  8004217960:	41 89 c2             	mov    %eax,%r10d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004217963:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217967:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421796a:	44 0f b7 c0          	movzwl %ax,%r8d
  800421796e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217972:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004217975:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217979:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  800421797c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217980:	48 8b 00             	mov    (%rax),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217983:	8b 40 08             	mov    0x8(%rax),%eax
  8004217986:	89 7c 24 18          	mov    %edi,0x18(%rsp)
  800421798a:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  800421798e:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004217993:	89 74 24 08          	mov    %esi,0x8(%rsp)
  8004217997:	44 89 0c 24          	mov    %r9d,(%rsp)
  800421799b:	45 89 d1             	mov    %r10d,%r9d
  800421799e:	89 c6                	mov    %eax,%esi
  80042179a0:	48 bf e0 ad 21 04 80 	movabs $0x800421ade0,%rdi
  80042179a7:	00 00 00 
  80042179aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042179af:	49 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%r10
  80042179b6:	00 00 00 
  80042179b9:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
}
  80042179bc:	c9                   	leaveq 
  80042179bd:	c3                   	retq   

00000080042179be <pci_scan_bus>:

static int
pci_scan_bus(struct pci_bus *bus)
{
  80042179be:	55                   	push   %rbp
  80042179bf:	48 89 e5             	mov    %rsp,%rbp
  80042179c2:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  80042179c9:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	int totaldev = 0;
  80042179d0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct pci_func df;
	memset(&df, 0, sizeof(df));
  80042179d7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042179db:	ba 50 00 00 00       	mov    $0x50,%edx
  80042179e0:	be 00 00 00 00       	mov    $0x0,%esi
  80042179e5:	48 89 c7             	mov    %rax,%rdi
  80042179e8:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  80042179ef:	00 00 00 
  80042179f2:	ff d0                	callq  *%rax
	df.bus = bus;
  80042179f4:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042179fb:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

	for (df.dev = 0; df.dev < 32; df.dev++) {
  80042179ff:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
  8004217a06:	e9 22 02 00 00       	jmpq   8004217c2d <pci_scan_bus+0x26f>
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  8004217a0b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004217a0f:	be 0c 00 00 00       	mov    $0xc,%esi
  8004217a14:	48 89 c7             	mov    %rax,%rdi
  8004217a17:	48 b8 b7 76 21 04 80 	movabs $0x80042176b7,%rax
  8004217a1e:	00 00 00 
  8004217a21:	ff d0                	callq  *%rax
  8004217a23:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  8004217a26:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217a29:	c1 e8 10             	shr    $0x10,%eax
  8004217a2c:	83 e0 7f             	and    $0x7f,%eax
  8004217a2f:	83 f8 01             	cmp    $0x1,%eax
  8004217a32:	0f 87 ec 01 00 00    	ja     8004217c24 <pci_scan_bus+0x266>
			continue;

		totaldev++;
  8004217a38:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)

		struct pci_func f = df;
  8004217a3c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004217a40:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004217a47:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004217a4b:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004217a52:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004217a56:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  8004217a5d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004217a61:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004217a68:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004217a6c:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004217a73:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004217a77:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004217a7e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217a82:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  8004217a89:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217a8d:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004217a94:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217a98:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004217a9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217aa3:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004217aaa:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  8004217ab1:	00 00 00 
  8004217ab4:	e9 45 01 00 00       	jmpq   8004217bfe <pci_scan_bus+0x240>
		     f.func++) {
			struct pci_func af = f;
  8004217ab9:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004217ac0:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004217ac7:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004217ace:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  8004217ad5:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004217adc:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004217ae3:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004217aea:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004217af1:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004217af8:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004217aff:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004217b06:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004217b0d:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004217b14:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004217b18:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004217b1f:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004217b23:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004217b2a:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004217b2e:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004217b35:	48 89 45 98          	mov    %rax,-0x68(%rbp)

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  8004217b39:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  8004217b40:	be 00 00 00 00       	mov    $0x0,%esi
  8004217b45:	48 89 c7             	mov    %rax,%rdi
  8004217b48:	48 b8 b7 76 21 04 80 	movabs $0x80042176b7,%rax
  8004217b4f:	00 00 00 
  8004217b52:	ff d0                	callq  *%rax
  8004217b54:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
			if (PCI_VENDOR(af.dev_id) == 0xffff)
  8004217b5a:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  8004217b60:	0f b7 c0             	movzwl %ax,%eax
  8004217b63:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004217b68:	0f 84 81 00 00 00    	je     8004217bef <pci_scan_bus+0x231>
				continue;

			uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  8004217b6e:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004217b75:	be 3c 00 00 00       	mov    $0x3c,%esi
  8004217b7a:	48 89 c7             	mov    %rax,%rdi
  8004217b7d:	48 b8 b7 76 21 04 80 	movabs $0x80042176b7,%rax
  8004217b84:	00 00 00 
  8004217b87:	ff d0                	callq  *%rax
  8004217b89:	89 45 f4             	mov    %eax,-0xc(%rbp)
			af.irq_line = PCI_INTERRUPT_LINE(intr);
  8004217b8c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217b8f:	88 45 98             	mov    %al,-0x68(%rbp)

			af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  8004217b92:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004217b99:	be 08 00 00 00       	mov    $0x8,%esi
  8004217b9e:	48 89 c7             	mov    %rax,%rdi
  8004217ba1:	48 b8 b7 76 21 04 80 	movabs $0x80042176b7,%rax
  8004217ba8:	00 00 00 
  8004217bab:	ff d0                	callq  *%rax
  8004217bad:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
			if (pci_show_devs)
  8004217bb3:	48 b8 00 d8 22 04 80 	movabs $0x800422d800,%rax
  8004217bba:	00 00 00 
  8004217bbd:	8b 00                	mov    (%rax),%eax
  8004217bbf:	85 c0                	test   %eax,%eax
  8004217bc1:	74 16                	je     8004217bd9 <pci_scan_bus+0x21b>
				pci_print_func(&af);
  8004217bc3:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004217bca:	48 89 c7             	mov    %rax,%rdi
  8004217bcd:	48 b8 e5 78 21 04 80 	movabs $0x80042178e5,%rax
  8004217bd4:	00 00 00 
  8004217bd7:	ff d0                	callq  *%rax
			pci_attach(&af);
  8004217bd9:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004217be0:	48 89 c7             	mov    %rax,%rdi
  8004217be3:	48 b8 56 78 21 04 80 	movabs $0x8004217856,%rax
  8004217bea:	00 00 00 
  8004217bed:	ff d0                	callq  *%rax

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
		     f.func++) {
  8004217bef:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  8004217bf5:	83 c0 01             	add    $0x1,%eax
  8004217bf8:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
			continue;

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004217bfe:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  8004217c04:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217c07:	25 00 00 80 00       	and    $0x800000,%eax
  8004217c0c:	85 c0                	test   %eax,%eax
  8004217c0e:	74 07                	je     8004217c17 <pci_scan_bus+0x259>
  8004217c10:	b8 08 00 00 00       	mov    $0x8,%eax
  8004217c15:	eb 05                	jmp    8004217c1c <pci_scan_bus+0x25e>
  8004217c17:	b8 01 00 00 00       	mov    $0x1,%eax
  8004217c1c:	39 c2                	cmp    %eax,%edx
  8004217c1e:	0f 82 95 fe ff ff    	jb     8004217ab9 <pci_scan_bus+0xfb>
	int totaldev = 0;
	struct pci_func df;
	memset(&df, 0, sizeof(df));
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004217c24:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004217c27:	83 c0 01             	add    $0x1,%eax
  8004217c2a:	89 45 a8             	mov    %eax,-0x58(%rbp)
  8004217c2d:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004217c30:	83 f8 1f             	cmp    $0x1f,%eax
  8004217c33:	0f 86 d2 fd ff ff    	jbe    8004217a0b <pci_scan_bus+0x4d>
				pci_print_func(&af);
			pci_attach(&af);
		}
	}

	return totaldev;
  8004217c39:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004217c3c:	c9                   	leaveq 
  8004217c3d:	c3                   	retq   

0000008004217c3e <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  8004217c3e:	55                   	push   %rbp
  8004217c3f:	48 89 e5             	mov    %rsp,%rbp
  8004217c42:	48 83 ec 30          	sub    $0x30,%rsp
  8004217c46:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  8004217c4a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217c4e:	be 1c 00 00 00       	mov    $0x1c,%esi
  8004217c53:	48 89 c7             	mov    %rax,%rdi
  8004217c56:	48 b8 b7 76 21 04 80 	movabs $0x80042176b7,%rax
  8004217c5d:	00 00 00 
  8004217c60:	ff d0                	callq  *%rax
  8004217c62:	89 45 fc             	mov    %eax,-0x4(%rbp)
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  8004217c65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217c69:	be 18 00 00 00       	mov    $0x18,%esi
  8004217c6e:	48 89 c7             	mov    %rax,%rdi
  8004217c71:	48 b8 b7 76 21 04 80 	movabs $0x80042176b7,%rax
  8004217c78:	00 00 00 
  8004217c7b:	ff d0                	callq  *%rax
  8004217c7d:	89 45 f8             	mov    %eax,-0x8(%rbp)

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  8004217c80:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217c83:	83 e0 0f             	and    $0xf,%eax
  8004217c86:	83 f8 01             	cmp    $0x1,%eax
  8004217c89:	75 40                	jne    8004217ccb <pci_bridge_attach+0x8d>
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004217c8b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217c8f:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004217c92:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217c96:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func);
  8004217c99:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217c9d:	48 8b 00             	mov    (%rax),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004217ca0:	8b 40 08             	mov    0x8(%rax),%eax
  8004217ca3:	89 c6                	mov    %eax,%esi
  8004217ca5:	48 bf 20 ae 21 04 80 	movabs $0x800421ae20,%rdi
  8004217cac:	00 00 00 
  8004217caf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217cb4:	49 b8 c3 8d 20 04 80 	movabs $0x8004208dc3,%r8
  8004217cbb:	00 00 00 
  8004217cbe:	41 ff d0             	callq  *%r8
			pcif->bus->busno, pcif->dev, pcif->func);
		return 0;
  8004217cc1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217cc6:	e9 a1 00 00 00       	jmpq   8004217d6c <pci_bridge_attach+0x12e>
	}

	struct pci_bus nbus;
	memset(&nbus, 0, sizeof(nbus));
  8004217ccb:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004217ccf:	ba 10 00 00 00       	mov    $0x10,%edx
  8004217cd4:	be 00 00 00 00       	mov    $0x0,%esi
  8004217cd9:	48 89 c7             	mov    %rax,%rdi
  8004217cdc:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  8004217ce3:	00 00 00 
  8004217ce6:	ff d0                	callq  *%rax
	nbus.parent_bridge = pcif;
  8004217ce8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217cec:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  8004217cf0:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217cf3:	c1 e8 08             	shr    $0x8,%eax
  8004217cf6:	0f b6 c0             	movzbl %al,%eax
  8004217cf9:	89 45 e8             	mov    %eax,-0x18(%rbp)

	if (pci_show_devs)
  8004217cfc:	48 b8 00 d8 22 04 80 	movabs $0x800422d800,%rax
  8004217d03:	00 00 00 
  8004217d06:	8b 00                	mov    (%rax),%eax
  8004217d08:	85 c0                	test   %eax,%eax
  8004217d0a:	74 48                	je     8004217d54 <pci_bridge_attach+0x116>
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);
  8004217d0c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217d0f:	c1 e8 10             	shr    $0x10,%eax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004217d12:	0f b6 f8             	movzbl %al,%edi
  8004217d15:	8b 75 e8             	mov    -0x18(%rbp),%esi
  8004217d18:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217d1c:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004217d1f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217d23:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func,
  8004217d26:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217d2a:	48 8b 00             	mov    (%rax),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004217d2d:	8b 40 08             	mov    0x8(%rax),%eax
  8004217d30:	41 89 f9             	mov    %edi,%r9d
  8004217d33:	41 89 f0             	mov    %esi,%r8d
  8004217d36:	89 c6                	mov    %eax,%esi
  8004217d38:	48 bf 58 ae 21 04 80 	movabs $0x800421ae58,%rdi
  8004217d3f:	00 00 00 
  8004217d42:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217d47:	49 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%r10
  8004217d4e:	00 00 00 
  8004217d51:	41 ff d2             	callq  *%r10
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);

	pci_scan_bus(&nbus);
  8004217d54:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004217d58:	48 89 c7             	mov    %rax,%rdi
  8004217d5b:	48 b8 be 79 21 04 80 	movabs $0x80042179be,%rax
  8004217d62:	00 00 00 
  8004217d65:	ff d0                	callq  *%rax
	return 1;
  8004217d67:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004217d6c:	c9                   	leaveq 
  8004217d6d:	c3                   	retq   

0000008004217d6e <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  8004217d6e:	55                   	push   %rbp
  8004217d6f:	48 89 e5             	mov    %rsp,%rbp
  8004217d72:	48 83 ec 40          	sub    $0x40,%rsp
  8004217d76:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  8004217d7a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217d7e:	ba 07 00 00 00       	mov    $0x7,%edx
  8004217d83:	be 04 00 00 00       	mov    $0x4,%esi
  8004217d88:	48 89 c7             	mov    %rax,%rdi
  8004217d8b:	48 b8 0c 77 21 04 80 	movabs $0x800421770c,%rax
  8004217d92:	00 00 00 
  8004217d95:	ff d0                	callq  *%rax
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004217d97:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
  8004217d9e:	e9 ee 01 00 00       	jmpq   8004217f91 <pci_func_enable+0x223>
	     bar += bar_width)
	{
		uint32_t oldv = pci_conf_read(f, bar);
  8004217da3:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004217da6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217daa:	89 d6                	mov    %edx,%esi
  8004217dac:	48 89 c7             	mov    %rax,%rdi
  8004217daf:	48 b8 b7 76 21 04 80 	movabs $0x80042176b7,%rax
  8004217db6:	00 00 00 
  8004217db9:	ff d0                	callq  *%rax
  8004217dbb:	89 45 ec             	mov    %eax,-0x14(%rbp)

		bar_width = 4;
  8004217dbe:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%rbp)
		pci_conf_write(f, bar, 0xffffffff);
  8004217dc5:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004217dc8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217dcc:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004217dd1:	89 ce                	mov    %ecx,%esi
  8004217dd3:	48 89 c7             	mov    %rax,%rdi
  8004217dd6:	48 b8 0c 77 21 04 80 	movabs $0x800421770c,%rax
  8004217ddd:	00 00 00 
  8004217de0:	ff d0                	callq  *%rax
		uint32_t rv = pci_conf_read(f, bar);
  8004217de2:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004217de5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217de9:	89 d6                	mov    %edx,%esi
  8004217deb:	48 89 c7             	mov    %rax,%rdi
  8004217dee:	48 b8 b7 76 21 04 80 	movabs $0x80042176b7,%rax
  8004217df5:	00 00 00 
  8004217df8:	ff d0                	callq  *%rax
  8004217dfa:	89 45 e8             	mov    %eax,-0x18(%rbp)

		if (rv == 0)
  8004217dfd:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004217e01:	75 05                	jne    8004217e08 <pci_func_enable+0x9a>
			continue;
  8004217e03:	e9 83 01 00 00       	jmpq   8004217f8b <pci_func_enable+0x21d>

		int regnum = PCI_MAPREG_NUM(bar);
  8004217e08:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217e0b:	83 e8 10             	sub    $0x10,%eax
  8004217e0e:	c1 e8 02             	shr    $0x2,%eax
  8004217e11:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		uint32_t base, size;
		if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  8004217e14:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004217e17:	83 e0 01             	and    $0x1,%eax
  8004217e1a:	85 c0                	test   %eax,%eax
  8004217e1c:	75 65                	jne    8004217e83 <pci_func_enable+0x115>
			if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  8004217e1e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004217e21:	83 e0 06             	and    $0x6,%eax
  8004217e24:	83 f8 04             	cmp    $0x4,%eax
  8004217e27:	75 07                	jne    8004217e30 <pci_func_enable+0xc2>
				bar_width = 8;
  8004217e29:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%rbp)

			size = PCI_MAPREG_MEM_SIZE(rv);
  8004217e30:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004217e33:	83 e0 f0             	and    $0xfffffff0,%eax
  8004217e36:	f7 d8                	neg    %eax
  8004217e38:	23 45 e8             	and    -0x18(%rbp),%eax
  8004217e3b:	83 e0 f0             	and    $0xfffffff0,%eax
  8004217e3e:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_MEM_ADDR(oldv);
  8004217e41:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217e44:	83 e0 f0             	and    $0xfffffff0,%eax
  8004217e47:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004217e4a:	48 b8 30 87 60 04 80 	movabs $0x8004608730,%rax
  8004217e51:	00 00 00 
  8004217e54:	8b 00                	mov    (%rax),%eax
  8004217e56:	85 c0                	test   %eax,%eax
  8004217e58:	74 7a                	je     8004217ed4 <pci_func_enable+0x166>
				cprintf("  mem region %d: %d bytes at 0x%x\n",
  8004217e5a:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004217e5d:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004217e60:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217e63:	89 c6                	mov    %eax,%esi
  8004217e65:	48 bf 88 ae 21 04 80 	movabs $0x800421ae88,%rdi
  8004217e6c:	00 00 00 
  8004217e6f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217e74:	49 b8 c3 8d 20 04 80 	movabs $0x8004208dc3,%r8
  8004217e7b:	00 00 00 
  8004217e7e:	41 ff d0             	callq  *%r8
  8004217e81:	eb 51                	jmp    8004217ed4 <pci_func_enable+0x166>
					regnum, size, base);
		} else {
			size = PCI_MAPREG_IO_SIZE(rv);
  8004217e83:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004217e86:	83 e0 fc             	and    $0xfffffffc,%eax
  8004217e89:	f7 d8                	neg    %eax
  8004217e8b:	23 45 e8             	and    -0x18(%rbp),%eax
  8004217e8e:	83 e0 fc             	and    $0xfffffffc,%eax
  8004217e91:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_IO_ADDR(oldv);
  8004217e94:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217e97:	83 e0 fc             	and    $0xfffffffc,%eax
  8004217e9a:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004217e9d:	48 b8 30 87 60 04 80 	movabs $0x8004608730,%rax
  8004217ea4:	00 00 00 
  8004217ea7:	8b 00                	mov    (%rax),%eax
  8004217ea9:	85 c0                	test   %eax,%eax
  8004217eab:	74 27                	je     8004217ed4 <pci_func_enable+0x166>
				cprintf("  io region %d: %d bytes at 0x%x\n",
  8004217ead:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004217eb0:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004217eb3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217eb6:	89 c6                	mov    %eax,%esi
  8004217eb8:	48 bf b0 ae 21 04 80 	movabs $0x800421aeb0,%rdi
  8004217ebf:	00 00 00 
  8004217ec2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217ec7:	49 b8 c3 8d 20 04 80 	movabs $0x8004208dc3,%r8
  8004217ece:	00 00 00 
  8004217ed1:	41 ff d0             	callq  *%r8
					regnum, size, base);
		}

		pci_conf_write(f, bar, oldv);
  8004217ed4:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004217ed7:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004217eda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217ede:	89 ce                	mov    %ecx,%esi
  8004217ee0:	48 89 c7             	mov    %rax,%rdi
  8004217ee3:	48 b8 0c 77 21 04 80 	movabs $0x800421770c,%rax
  8004217eea:	00 00 00 
  8004217eed:	ff d0                	callq  *%rax
		f->reg_base[regnum] = base;
  8004217eef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217ef3:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004217ef6:	48 63 d2             	movslq %edx,%rdx
  8004217ef9:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  8004217efd:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004217f00:	89 54 88 08          	mov    %edx,0x8(%rax,%rcx,4)
		f->reg_size[regnum] = size;
  8004217f04:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217f08:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004217f0b:	48 63 d2             	movslq %edx,%rdx
  8004217f0e:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  8004217f12:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004217f15:	89 14 88             	mov    %edx,(%rax,%rcx,4)

		if (size && !base)
  8004217f18:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004217f1c:	74 6d                	je     8004217f8b <pci_func_enable+0x21d>
  8004217f1e:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004217f22:	75 67                	jne    8004217f8b <pci_func_enable+0x21d>
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004217f24:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217f28:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004217f2b:	c1 e8 10             	shr    $0x10,%eax
  8004217f2e:	41 89 c0             	mov    %eax,%r8d
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004217f31:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217f35:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004217f38:	0f b7 f8             	movzwl %ax,%edi
  8004217f3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217f3f:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004217f42:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217f46:	8b 50 08             	mov    0x8(%rax),%edx
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  8004217f49:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217f4d:	48 8b 00             	mov    (%rax),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004217f50:	8b 40 08             	mov    0x8(%rax),%eax
  8004217f53:	8b 75 f0             	mov    -0x10(%rbp),%esi
  8004217f56:	89 74 24 10          	mov    %esi,0x10(%rsp)
  8004217f5a:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8004217f5d:	89 74 24 08          	mov    %esi,0x8(%rsp)
  8004217f61:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  8004217f64:	89 34 24             	mov    %esi,(%rsp)
  8004217f67:	45 89 c1             	mov    %r8d,%r9d
  8004217f6a:	41 89 f8             	mov    %edi,%r8d
  8004217f6d:	89 c6                	mov    %eax,%esi
  8004217f6f:	48 bf d8 ae 21 04 80 	movabs $0x800421aed8,%rdi
  8004217f76:	00 00 00 
  8004217f79:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217f7e:	49 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%r10
  8004217f85:	00 00 00 
  8004217f88:	41 ff d2             	callq  *%r10
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
	     bar += bar_width)
  8004217f8b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217f8e:	01 45 f8             	add    %eax,-0x8(%rbp)
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004217f91:	83 7d f8 27          	cmpl   $0x27,-0x8(%rbp)
  8004217f95:	0f 86 08 fe ff ff    	jbe    8004217da3 <pci_func_enable+0x35>
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004217f9b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217f9f:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004217fa2:	c1 e8 10             	shr    $0x10,%eax
  8004217fa5:	89 c7                	mov    %eax,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004217fa7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217fab:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004217fae:	0f b7 f0             	movzwl %ax,%esi
  8004217fb1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217fb5:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004217fb8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217fbc:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004217fbf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217fc3:	48 8b 00             	mov    (%rax),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004217fc6:	8b 40 08             	mov    0x8(%rax),%eax
  8004217fc9:	41 89 f9             	mov    %edi,%r9d
  8004217fcc:	41 89 f0             	mov    %esi,%r8d
  8004217fcf:	89 c6                	mov    %eax,%esi
  8004217fd1:	48 bf 38 af 21 04 80 	movabs $0x800421af38,%rdi
  8004217fd8:	00 00 00 
  8004217fdb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217fe0:	49 ba c3 8d 20 04 80 	movabs $0x8004208dc3,%r10
  8004217fe7:	00 00 00 
  8004217fea:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
}
  8004217fed:	c9                   	leaveq 
  8004217fee:	c3                   	retq   

0000008004217fef <pci_init>:

int
pci_init(void)
{
  8004217fef:	55                   	push   %rbp
  8004217ff0:	48 89 e5             	mov    %rsp,%rbp
	static struct pci_bus root_bus;
	memset(&root_bus, 0, sizeof(root_bus));
  8004217ff3:	ba 10 00 00 00       	mov    $0x10,%edx
  8004217ff8:	be 00 00 00 00       	mov    $0x0,%esi
  8004217ffd:	48 bf 40 87 60 04 80 	movabs $0x8004608740,%rdi
  8004218004:	00 00 00 
  8004218007:	48 b8 88 f9 20 04 80 	movabs $0x800420f988,%rax
  800421800e:	00 00 00 
  8004218011:	ff d0                	callq  *%rax

	return pci_scan_bus(&root_bus);
  8004218013:	48 bf 40 87 60 04 80 	movabs $0x8004608740,%rdi
  800421801a:	00 00 00 
  800421801d:	48 b8 be 79 21 04 80 	movabs $0x80042179be,%rax
  8004218024:	00 00 00 
  8004218027:	ff d0                	callq  *%rax
}
  8004218029:	5d                   	pop    %rbp
  800421802a:	c3                   	retq   

000000800421802b <time_init>:

static unsigned int ticks;

void
time_init(void)
{
  800421802b:	55                   	push   %rbp
  800421802c:	48 89 e5             	mov    %rsp,%rbp
	ticks = 0;
  800421802f:	48 b8 50 87 60 04 80 	movabs $0x8004608750,%rax
  8004218036:	00 00 00 
  8004218039:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  800421803f:	5d                   	pop    %rbp
  8004218040:	c3                   	retq   

0000008004218041 <time_tick>:

// This should be called once per timer interrupt.  A timer interrupt
// fires every 10 ms.
void
time_tick(void)
{
  8004218041:	55                   	push   %rbp
  8004218042:	48 89 e5             	mov    %rsp,%rbp
	ticks++;
  8004218045:	48 b8 50 87 60 04 80 	movabs $0x8004608750,%rax
  800421804c:	00 00 00 
  800421804f:	8b 00                	mov    (%rax),%eax
  8004218051:	8d 50 01             	lea    0x1(%rax),%edx
  8004218054:	48 b8 50 87 60 04 80 	movabs $0x8004608750,%rax
  800421805b:	00 00 00 
  800421805e:	89 10                	mov    %edx,(%rax)
	if (ticks * 10 < ticks)
  8004218060:	48 b8 50 87 60 04 80 	movabs $0x8004608750,%rax
  8004218067:	00 00 00 
  800421806a:	8b 10                	mov    (%rax),%edx
  800421806c:	89 d0                	mov    %edx,%eax
  800421806e:	c1 e0 02             	shl    $0x2,%eax
  8004218071:	01 d0                	add    %edx,%eax
  8004218073:	01 c0                	add    %eax,%eax
  8004218075:	89 c2                	mov    %eax,%edx
  8004218077:	48 b8 50 87 60 04 80 	movabs $0x8004608750,%rax
  800421807e:	00 00 00 
  8004218081:	8b 00                	mov    (%rax),%eax
  8004218083:	39 c2                	cmp    %eax,%edx
  8004218085:	73 2a                	jae    80042180b1 <time_tick+0x70>
		panic("time_tick: time overflowed");
  8004218087:	48 ba 67 af 21 04 80 	movabs $0x800421af67,%rdx
  800421808e:	00 00 00 
  8004218091:	be 13 00 00 00       	mov    $0x13,%esi
  8004218096:	48 bf 82 af 21 04 80 	movabs $0x800421af82,%rdi
  800421809d:	00 00 00 
  80042180a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042180a5:	48 b9 23 05 20 04 80 	movabs $0x8004200523,%rcx
  80042180ac:	00 00 00 
  80042180af:	ff d1                	callq  *%rcx
}
  80042180b1:	5d                   	pop    %rbp
  80042180b2:	c3                   	retq   

00000080042180b3 <time_msec>:

unsigned int
time_msec(void)
{
  80042180b3:	55                   	push   %rbp
  80042180b4:	48 89 e5             	mov    %rsp,%rbp
	return ticks * 10;
  80042180b7:	48 b8 50 87 60 04 80 	movabs $0x8004608750,%rax
  80042180be:	00 00 00 
  80042180c1:	8b 10                	mov    (%rax),%edx
  80042180c3:	89 d0                	mov    %edx,%eax
  80042180c5:	c1 e0 02             	shl    $0x2,%eax
  80042180c8:	01 d0                	add    %edx,%eax
  80042180ca:	01 c0                	add    %eax,%eax
}
  80042180cc:	5d                   	pop    %rbp
  80042180cd:	c3                   	retq   
