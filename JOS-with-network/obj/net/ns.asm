
obj/net/ns:     file format elf64-x86-64


Disassembly of section .text:

0000000000800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	movabs $USTACKTOP, %rax
  800020:	48 b8 00 e0 7f ef 00 	movabs $0xef7fe000,%rax
  800027:	00 00 00 
	cmpq %rax,%rsp
  80002a:	48 39 c4             	cmp    %rax,%rsp
	jne args_exist
  80002d:	75 04                	jne    800033 <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushq $0
  80002f:	6a 00                	pushq  $0x0
	pushq $0
  800031:	6a 00                	pushq  $0x0

0000000000800033 <args_exist>:

args_exist:
	movq 8(%rsp), %rsi
  800033:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
	movq (%rsp), %rdi
  800038:	48 8b 3c 24          	mov    (%rsp),%rdi
	call libmain
  80003c:	e8 51 0e 00 00       	callq  800e92 <libmain>
1:	jmp 1b
  800041:	eb fe                	jmp    800041 <args_exist+0xe>

0000000000800043 <next_i>:
static envid_t timer_envid;
static envid_t input_envid;
static envid_t output_envid;

static bool buse[QUEUE_SIZE];
static int next_i(int i) { return (i+1) % QUEUE_SIZE; }
  800043:	55                   	push   %rbp
  800044:	48 89 e5             	mov    %rsp,%rbp
  800047:	48 83 ec 04          	sub    $0x4,%rsp
  80004b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80004e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800051:	8d 48 01             	lea    0x1(%rax),%ecx
  800054:	ba 67 66 66 66       	mov    $0x66666667,%edx
  800059:	89 c8                	mov    %ecx,%eax
  80005b:	f7 ea                	imul   %edx
  80005d:	c1 fa 03             	sar    $0x3,%edx
  800060:	89 c8                	mov    %ecx,%eax
  800062:	c1 f8 1f             	sar    $0x1f,%eax
  800065:	29 c2                	sub    %eax,%edx
  800067:	89 d0                	mov    %edx,%eax
  800069:	c1 e0 02             	shl    $0x2,%eax
  80006c:	01 d0                	add    %edx,%eax
  80006e:	c1 e0 02             	shl    $0x2,%eax
  800071:	29 c1                	sub    %eax,%ecx
  800073:	89 ca                	mov    %ecx,%edx
  800075:	89 d0                	mov    %edx,%eax
  800077:	c9                   	leaveq 
  800078:	c3                   	retq   

0000000000800079 <prev_i>:
static int prev_i(int i) { return (i ? i-1 : QUEUE_SIZE-1); }
  800079:	55                   	push   %rbp
  80007a:	48 89 e5             	mov    %rsp,%rbp
  80007d:	48 83 ec 04          	sub    $0x4,%rsp
  800081:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800084:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800088:	74 08                	je     800092 <prev_i+0x19>
  80008a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80008d:	83 e8 01             	sub    $0x1,%eax
  800090:	eb 05                	jmp    800097 <prev_i+0x1e>
  800092:	b8 13 00 00 00       	mov    $0x13,%eax
  800097:	c9                   	leaveq 
  800098:	c3                   	retq   

0000000000800099 <get_buffer>:

static void *
get_buffer(void) {
  800099:	55                   	push   %rbp
  80009a:	48 89 e5             	mov    %rsp,%rbp
  80009d:	48 83 ec 10          	sub    $0x10,%rsp
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000a1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8000a8:	00 
  8000a9:	eb 22                	jmp    8000cd <get_buffer+0x34>
        if (!buse[i]) break;
  8000ab:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  8000b2:	00 00 00 
  8000b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8000b9:	48 01 d0             	add    %rdx,%rax
  8000bc:	0f b6 00             	movzbl (%rax),%eax
  8000bf:	83 f0 01             	xor    $0x1,%eax
  8000c2:	84 c0                	test   %al,%al
  8000c4:	74 02                	je     8000c8 <get_buffer+0x2f>
  8000c6:	eb 0c                	jmp    8000d4 <get_buffer+0x3b>
static void *
get_buffer(void) {
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000c8:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8000cd:	48 83 7d f8 13       	cmpq   $0x13,-0x8(%rbp)
  8000d2:	7e d7                	jle    8000ab <get_buffer+0x12>
        if (!buse[i]) break;

    if (i == QUEUE_SIZE) {
  8000d4:	48 83 7d f8 14       	cmpq   $0x14,-0x8(%rbp)
  8000d9:	75 2a                	jne    800105 <get_buffer+0x6c>
        panic("NS: buffer overflow");
  8000db:	48 ba 20 07 82 00 00 	movabs $0x820720,%rdx
  8000e2:	00 00 00 
  8000e5:	be 3f 00 00 00       	mov    $0x3f,%esi
  8000ea:	48 bf 34 07 82 00 00 	movabs $0x820734,%rdi
  8000f1:	00 00 00 
  8000f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8000f9:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  800100:	00 00 00 
  800103:	ff d1                	callq  *%rcx
        return 0;
    }

    va = (void *)(REQVA + i * PGSIZE);
  800105:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800109:	48 05 eb ff 00 00    	add    $0xffeb,%rax
  80010f:	48 c1 e0 0c          	shl    $0xc,%rax
  800113:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    buse[i] = 1;
  800117:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  80011e:	00 00 00 
  800121:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800125:	48 01 d0             	add    %rdx,%rax
  800128:	c6 00 01             	movb   $0x1,(%rax)

    return va;
  80012b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80012f:	c9                   	leaveq 
  800130:	c3                   	retq   

0000000000800131 <put_buffer>:

static void
put_buffer(void *va) {
  800131:	55                   	push   %rbp
  800132:	48 89 e5             	mov    %rsp,%rbp
  800135:	48 83 ec 18          	sub    $0x18,%rsp
  800139:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    int64_t i = ((uint64_t)va - REQVA) / PGSIZE;
  80013d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800141:	48 2d 00 b0 fe 0f    	sub    $0xffeb000,%rax
  800147:	48 c1 e8 0c          	shr    $0xc,%rax
  80014b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    buse[i] = 0;
  80014f:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  800156:	00 00 00 
  800159:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80015d:	48 01 d0             	add    %rdx,%rax
  800160:	c6 00 00             	movb   $0x0,(%rax)
}
  800163:	c9                   	leaveq 
  800164:	c3                   	retq   

0000000000800165 <lwip_init>:

    static void
lwip_init(struct netif *nif, void *if_state,
        uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
  800165:	55                   	push   %rbp
  800166:	48 89 e5             	mov    %rsp,%rbp
  800169:	53                   	push   %rbx
  80016a:	48 83 ec 68          	sub    $0x68,%rsp
  80016e:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800172:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800176:	89 55 ac             	mov    %edx,-0x54(%rbp)
  800179:	89 4d a8             	mov    %ecx,-0x58(%rbp)
  80017c:	44 89 45 a4          	mov    %r8d,-0x5c(%rbp)
    struct ip_addr ipaddr, netmask, gateway;
    ipaddr.addr  = init_addr;
  800180:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800183:	89 45 e0             	mov    %eax,-0x20(%rbp)
    netmask.addr = init_mask;
  800186:	8b 45 a8             	mov    -0x58(%rbp),%eax
  800189:	89 45 d0             	mov    %eax,-0x30(%rbp)
    gateway.addr = init_gw;
  80018c:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80018f:	89 45 c0             	mov    %eax,-0x40(%rbp)

    if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  800192:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  800196:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  80019a:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80019e:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8001a2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8001a6:	48 bb 5f 0b 81 00 00 	movabs $0x810b5f,%rbx
  8001ad:	00 00 00 
  8001b0:	48 89 1c 24          	mov    %rbx,(%rsp)
  8001b4:	49 b9 f3 95 81 00 00 	movabs $0x8195f3,%r9
  8001bb:	00 00 00 
  8001be:	49 89 f8             	mov    %rdi,%r8
  8001c1:	48 89 c7             	mov    %rax,%rdi
  8001c4:	48 b8 53 cc 80 00 00 	movabs $0x80cc53,%rax
  8001cb:	00 00 00 
  8001ce:	ff d0                	callq  *%rax
  8001d0:	48 85 c0             	test   %rax,%rax
  8001d3:	75 2a                	jne    8001ff <lwip_init+0x9a>
                if_state,
                jif_init,
                ip_input))
        panic("lwip_init: error in netif_add\n");
  8001d5:	48 ba 40 07 82 00 00 	movabs $0x820740,%rdx
  8001dc:	00 00 00 
  8001df:	be 5c 00 00 00       	mov    $0x5c,%esi
  8001e4:	48 bf 34 07 82 00 00 	movabs $0x820734,%rdi
  8001eb:	00 00 00 
  8001ee:	b8 00 00 00 00       	mov    $0x0,%eax
  8001f3:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8001fa:	00 00 00 
  8001fd:	ff d1                	callq  *%rcx

    netif_set_default(nif);
  8001ff:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800203:	48 89 c7             	mov    %rax,%rdi
  800206:	48 b8 53 d0 80 00 00 	movabs $0x80d053,%rax
  80020d:	00 00 00 
  800210:	ff d0                	callq  *%rax
    netif_set_up(nif);
  800212:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800216:	48 89 c7             	mov    %rax,%rdi
  800219:	48 b8 72 d0 80 00 00 	movabs $0x80d072,%rax
  800220:	00 00 00 
  800223:	ff d0                	callq  *%rax
}
  800225:	48 83 c4 68          	add    $0x68,%rsp
  800229:	5b                   	pop    %rbx
  80022a:	5d                   	pop    %rbp
  80022b:	c3                   	retq   

000000000080022c <net_timer>:

    static void __attribute__((noreturn))
net_timer(uint64_t arg)
{
  80022c:	55                   	push   %rbp
  80022d:	48 89 e5             	mov    %rsp,%rbp
  800230:	48 83 ec 20          	sub    $0x20,%rsp
  800234:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct timer_thread *t = (struct timer_thread *) arg;
  800238:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80023c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    for (;;) {
        uint32_t cur = sys_time_msec();
  800240:	48 b8 56 29 80 00 00 	movabs $0x802956,%rax
  800247:	00 00 00 
  80024a:	ff d0                	callq  *%rax
  80024c:	89 45 f4             	mov    %eax,-0xc(%rbp)

        lwip_core_lock();
  80024f:	48 b8 6d 87 81 00 00 	movabs $0x81876d,%rax
  800256:	00 00 00 
  800259:	ff d0                	callq  *%rax
        t->func();
  80025b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80025f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800263:	ff d0                	callq  *%rax
        lwip_core_unlock();
  800265:	48 b8 73 87 81 00 00 	movabs $0x818773,%rax
  80026c:	00 00 00 
  80026f:	ff d0                	callq  *%rax

        thread_wait(0, 0, cur + t->msec);
  800271:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800275:	8b 10                	mov    (%rax),%edx
  800277:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80027a:	01 d0                	add    %edx,%eax
  80027c:	89 c2                	mov    %eax,%edx
  80027e:	be 00 00 00 00       	mov    $0x0,%esi
  800283:	bf 00 00 00 00       	mov    $0x0,%edi
  800288:	48 b8 e8 88 81 00 00 	movabs $0x8188e8,%rax
  80028f:	00 00 00 
  800292:	ff d0                	callq  *%rax
    }
  800294:	eb aa                	jmp    800240 <net_timer+0x14>

0000000000800296 <start_timer>:
}

    static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800296:	55                   	push   %rbp
  800297:	48 89 e5             	mov    %rsp,%rbp
  80029a:	48 83 ec 30          	sub    $0x30,%rsp
  80029e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8002a2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8002a6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8002aa:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    t->msec = msec;
  8002ad:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8002b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002b4:	89 10                	mov    %edx,(%rax)
    t->func = func;
  8002b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002ba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8002be:	48 89 50 08          	mov    %rdx,0x8(%rax)
    t->name = name;
  8002c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002c6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8002ca:	48 89 50 10          	mov    %rdx,0x10(%rax)
    int r = thread_create(0, name, &net_timer, (uint64_t)t);
  8002ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8002d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8002d6:	48 89 d1             	mov    %rdx,%rcx
  8002d9:	48 ba 2c 02 80 00 00 	movabs $0x80022c,%rdx
  8002e0:	00 00 00 
  8002e3:	48 89 c6             	mov    %rax,%rsi
  8002e6:	bf 00 00 00 00       	mov    $0x0,%edi
  8002eb:	48 b8 5d 8b 81 00 00 	movabs $0x818b5d,%rax
  8002f2:	00 00 00 
  8002f5:	ff d0                	callq  *%rax
  8002f7:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (r < 0)
  8002fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8002fe:	79 3f                	jns    80033f <start_timer+0xa9>
        panic("cannot create timer thread: %s", e2s(r));
  800300:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800303:	89 c7                	mov    %eax,%edi
  800305:	48 b8 e5 91 81 00 00 	movabs $0x8191e5,%rax
  80030c:	00 00 00 
  80030f:	ff d0                	callq  *%rax
  800311:	48 89 c1             	mov    %rax,%rcx
  800314:	48 ba 60 07 82 00 00 	movabs $0x820760,%rdx
  80031b:	00 00 00 
  80031e:	be 7a 00 00 00       	mov    $0x7a,%esi
  800323:	48 bf 34 07 82 00 00 	movabs $0x820734,%rdi
  80032a:	00 00 00 
  80032d:	b8 00 00 00 00       	mov    $0x0,%eax
  800332:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  800339:	00 00 00 
  80033c:	41 ff d0             	callq  *%r8
}
  80033f:	c9                   	leaveq 
  800340:	c3                   	retq   

0000000000800341 <tcpip_init_done>:

    static void
tcpip_init_done(void *arg)
{
  800341:	55                   	push   %rbp
  800342:	48 89 e5             	mov    %rsp,%rbp
  800345:	48 83 ec 20          	sub    $0x20,%rsp
  800349:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    uint32_t *done = arg;
  80034d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800351:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    *done = 1;
  800355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800359:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    thread_wakeup(done);
  80035f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800363:	48 89 c7             	mov    %rax,%rdi
  800366:	48 b8 95 88 81 00 00 	movabs $0x818895,%rax
  80036d:	00 00 00 
  800370:	ff d0                	callq  *%rax
}
  800372:	c9                   	leaveq 
  800373:	c3                   	retq   

0000000000800374 <serve_init>:

    void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800374:	55                   	push   %rbp
  800375:	48 89 e5             	mov    %rsp,%rbp
  800378:	48 83 ec 30          	sub    $0x30,%rsp
  80037c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80037f:	89 75 e8             	mov    %esi,-0x18(%rbp)
  800382:	89 55 e4             	mov    %edx,-0x1c(%rbp)
    int r;
    lwip_core_lock();
  800385:	48 b8 6d 87 81 00 00 	movabs $0x81876d,%rax
  80038c:	00 00 00 
  80038f:	ff d0                	callq  *%rax

    uint32_t done = 0;
  800391:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    tcpip_init(&tcpip_init_done, &done);
  800398:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80039c:	48 89 c6             	mov    %rax,%rsi
  80039f:	48 bf 41 03 80 00 00 	movabs $0x800341,%rdi
  8003a6:	00 00 00 
  8003a9:	48 b8 1a 8a 80 00 00 	movabs $0x808a1a,%rax
  8003b0:	00 00 00 
  8003b3:	ff d0                	callq  *%rax
    lwip_core_unlock();
  8003b5:	48 b8 73 87 81 00 00 	movabs $0x818773,%rax
  8003bc:	00 00 00 
  8003bf:	ff d0                	callq  *%rax
    thread_wait(&done, 0, (uint32_t)~0);
  8003c1:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8003c5:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8003ca:	be 00 00 00 00       	mov    $0x0,%esi
  8003cf:	48 89 c7             	mov    %rax,%rdi
  8003d2:	48 b8 e8 88 81 00 00 	movabs $0x8188e8,%rax
  8003d9:	00 00 00 
  8003dc:	ff d0                	callq  *%rax
    lwip_core_lock();
  8003de:	48 b8 6d 87 81 00 00 	movabs $0x81876d,%rax
  8003e5:	00 00 00 
  8003e8:	ff d0                	callq  *%rax

    lwip_init(&nif, &output_envid, ipaddr, netmask, gw);
  8003ea:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8003ed:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8003f0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8003f3:	41 89 c8             	mov    %ecx,%r8d
  8003f6:	89 d1                	mov    %edx,%ecx
  8003f8:	89 c2                	mov    %eax,%edx
  8003fa:	48 be 60 90 82 00 00 	movabs $0x829060,%rsi
  800401:	00 00 00 
  800404:	48 bf 20 75 b5 00 00 	movabs $0xb57520,%rdi
  80040b:	00 00 00 
  80040e:	48 b8 65 01 80 00 00 	movabs $0x800165,%rax
  800415:	00 00 00 
  800418:	ff d0                	callq  *%rax

    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80041a:	b9 88 13 00 00       	mov    $0x1388,%ecx
  80041f:	48 ba 7f 07 82 00 00 	movabs $0x82077f,%rdx
  800426:	00 00 00 
  800429:	48 be 5c 57 81 00 00 	movabs $0x81575c,%rsi
  800430:	00 00 00 
  800433:	48 bf 00 90 82 00 00 	movabs $0x829000,%rdi
  80043a:	00 00 00 
  80043d:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  800444:	00 00 00 
  800447:	ff d0                	callq  *%rax
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800449:	b9 fa 00 00 00       	mov    $0xfa,%ecx
  80044e:	48 ba 89 07 82 00 00 	movabs $0x820789,%rdx
  800455:	00 00 00 
  800458:	48 be ea ff 80 00 00 	movabs $0x80ffea,%rsi
  80045f:	00 00 00 
  800462:	48 bf 20 90 82 00 00 	movabs $0x829020,%rdi
  800469:	00 00 00 
  80046c:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  800473:	00 00 00 
  800476:	ff d0                	callq  *%rax
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800478:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
  80047d:	48 ba 95 07 82 00 00 	movabs $0x820795,%rdx
  800484:	00 00 00 
  800487:	48 be ae f7 80 00 00 	movabs $0x80f7ae,%rsi
  80048e:	00 00 00 
  800491:	48 bf 40 90 82 00 00 	movabs $0x829040,%rdi
  800498:	00 00 00 
  80049b:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  8004a2:	00 00 00 
  8004a5:	ff d0                	callq  *%rax

    struct in_addr ia = {ipaddr};
  8004a7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004aa:	89 45 f0             	mov    %eax,-0x10(%rbp)
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004ad:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004b0:	89 c7                	mov    %eax,%edi
  8004b2:	48 b8 ac 2b 81 00 00 	movabs $0x812bac,%rax
  8004b9:	00 00 00 
  8004bc:	ff d0                	callq  *%rax
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004be:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004c5:	00 00 00 
  8004c8:	0f b6 52 46          	movzbl 0x46(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004cc:	0f b6 fa             	movzbl %dl,%edi
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004cf:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004d6:	00 00 00 
  8004d9:	0f b6 52 45          	movzbl 0x45(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004dd:	44 0f b6 ca          	movzbl %dl,%r9d
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004e1:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004e8:	00 00 00 
  8004eb:	0f b6 52 44          	movzbl 0x44(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004ef:	44 0f b6 c2          	movzbl %dl,%r8d
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  8004f3:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004fa:	00 00 00 
  8004fd:	0f b6 52 43          	movzbl 0x43(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800501:	0f b6 ca             	movzbl %dl,%ecx
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  800504:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  80050b:	00 00 00 
  80050e:	0f b6 52 42          	movzbl 0x42(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800512:	0f b6 d2             	movzbl %dl,%edx
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  800515:	48 be 20 75 b5 00 00 	movabs $0xb57520,%rsi
  80051c:	00 00 00 
  80051f:	0f b6 76 41          	movzbl 0x41(%rsi),%esi
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800523:	40 0f b6 f6          	movzbl %sil,%esi
  800527:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  80052c:	89 3c 24             	mov    %edi,(%rsp)
  80052f:	48 bf a8 07 82 00 00 	movabs $0x8207a8,%rdi
  800536:	00 00 00 
  800539:	b8 00 00 00 00       	mov    $0x0,%eax
  80053e:	49 ba 79 11 80 00 00 	movabs $0x801179,%r10
  800545:	00 00 00 
  800548:	41 ff d2             	callq  *%r10
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
            inet_ntoa(ia));

    lwip_core_unlock();
  80054b:	48 b8 73 87 81 00 00 	movabs $0x818773,%rax
  800552:	00 00 00 
  800555:	ff d0                	callq  *%rax

    cprintf("NS: TCP/IP initialized.\n");
  800557:	48 bf e1 07 82 00 00 	movabs $0x8207e1,%rdi
  80055e:	00 00 00 
  800561:	b8 00 00 00 00       	mov    $0x0,%eax
  800566:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  80056d:	00 00 00 
  800570:	ff d2                	callq  *%rdx
}
  800572:	c9                   	leaveq 
  800573:	c3                   	retq   

0000000000800574 <process_timer>:

static void
process_timer(envid_t envid) {
  800574:	55                   	push   %rbp
  800575:	48 89 e5             	mov    %rsp,%rbp
  800578:	48 83 ec 20          	sub    $0x20,%rsp
  80057c:	89 7d ec             	mov    %edi,-0x14(%rbp)
    uint32_t start, now, to;

    if (envid != timer_envid) {
  80057f:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800586:	00 00 00 
  800589:	8b 00                	mov    (%rax),%eax
  80058b:	39 45 ec             	cmp    %eax,-0x14(%rbp)
  80058e:	74 22                	je     8005b2 <process_timer+0x3e>
        cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800590:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800593:	89 c6                	mov    %eax,%esi
  800595:	48 bf 00 08 82 00 00 	movabs $0x820800,%rdi
  80059c:	00 00 00 
  80059f:	b8 00 00 00 00       	mov    $0x0,%eax
  8005a4:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  8005ab:	00 00 00 
  8005ae:	ff d2                	callq  *%rdx
        return;
  8005b0:	eb 5a                	jmp    80060c <process_timer+0x98>
    }

    start = sys_time_msec();
  8005b2:	48 b8 56 29 80 00 00 	movabs $0x802956,%rax
  8005b9:	00 00 00 
  8005bc:	ff d0                	callq  *%rax
  8005be:	89 45 fc             	mov    %eax,-0x4(%rbp)
    thread_yield();
  8005c1:	48 b8 dd 8d 81 00 00 	movabs $0x818ddd,%rax
  8005c8:	00 00 00 
  8005cb:	ff d0                	callq  *%rax
    now = sys_time_msec();
  8005cd:	48 b8 56 29 80 00 00 	movabs $0x802956,%rax
  8005d4:	00 00 00 
  8005d7:	ff d0                	callq  *%rax
  8005d9:	89 45 f8             	mov    %eax,-0x8(%rbp)

    to = TIMER_INTERVAL - (now - start);
  8005dc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8005df:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8005e2:	29 c2                	sub    %eax,%edx
  8005e4:	89 d0                	mov    %edx,%eax
  8005e6:	05 fa 00 00 00       	add    $0xfa,%eax
  8005eb:	89 45 f4             	mov    %eax,-0xc(%rbp)
    ipc_send(envid, to, 0, 0);
  8005ee:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8005f1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8005f4:	b9 00 00 00 00       	mov    $0x0,%ecx
  8005f9:	ba 00 00 00 00       	mov    $0x0,%edx
  8005fe:	89 c7                	mov    %eax,%edi
  800600:	48 b8 34 31 80 00 00 	movabs $0x803134,%rax
  800607:	00 00 00 
  80060a:	ff d0                	callq  *%rax
}
  80060c:	c9                   	leaveq 
  80060d:	c3                   	retq   

000000000080060e <serve_thread>:
    uint32_t whom;
    union Nsipc *req;
};

static void
serve_thread(uint64_t a) {
  80060e:	55                   	push   %rbp
  80060f:	48 89 e5             	mov    %rsp,%rbp
  800612:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  800619:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
    struct st_args *args = (struct st_args *)a;
  800620:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800627:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    union Nsipc *req = args->req;
  80062b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80062f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800633:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    int r;

    switch (args->reqno) {
  800637:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80063b:	8b 00                	mov    (%rax),%eax
  80063d:	83 f8 0a             	cmp    $0xa,%eax
  800640:	0f 87 d8 01 00 00    	ja     80081e <serve_thread+0x210>
  800646:	89 c0                	mov    %eax,%eax
  800648:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80064f:	00 
  800650:	48 b8 78 08 82 00 00 	movabs $0x820878,%rax
  800657:	00 00 00 
  80065a:	48 01 d0             	add    %rdx,%rax
  80065d:	48 8b 00             	mov    (%rax),%rax
  800660:	ff e0                	jmpq   *%rax
        case NSREQ_ACCEPT:
            {
                struct Nsret_accept ret;
                r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  800662:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800666:	8b 00                	mov    (%rax),%eax
  800668:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80066c:	48 83 c2 10          	add    $0x10,%rdx
  800670:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800674:	48 89 ce             	mov    %rcx,%rsi
  800677:	89 c7                	mov    %eax,%edi
  800679:	48 b8 30 5c 80 00 00 	movabs $0x805c30,%rax
  800680:	00 00 00 
  800683:	ff d0                	callq  *%rax
  800685:	89 45 fc             	mov    %eax,-0x4(%rbp)
                        &ret.ret_addrlen);
                memmove(req, &ret, sizeof ret);
  800688:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80068c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800690:	ba 14 00 00 00       	mov    $0x14,%edx
  800695:	48 89 ce             	mov    %rcx,%rsi
  800698:	48 89 c7             	mov    %rax,%rdi
  80069b:	48 b8 52 20 80 00 00 	movabs $0x802052,%rax
  8006a2:	00 00 00 
  8006a5:	ff d0                	callq  *%rax
                break;
  8006a7:	90                   	nop
  8006a8:	e9 a5 01 00 00       	jmpq   800852 <serve_thread+0x244>
            }
        case NSREQ_BIND:
            r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  8006ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006b1:	8b 50 14             	mov    0x14(%rax),%edx
  8006b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006b8:	48 8d 48 04          	lea    0x4(%rax),%rcx
  8006bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006c0:	8b 00                	mov    (%rax),%eax
  8006c2:	48 89 ce             	mov    %rcx,%rsi
  8006c5:	89 c7                	mov    %eax,%edi
  8006c7:	48 b8 63 5f 80 00 00 	movabs $0x805f63,%rax
  8006ce:	00 00 00 
  8006d1:	ff d0                	callq  *%rax
  8006d3:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->bind.req_namelen);
            break;
  8006d6:	e9 77 01 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_SHUTDOWN:
            r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  8006db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006df:	8b 50 04             	mov    0x4(%rax),%edx
  8006e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006e6:	8b 00                	mov    (%rax),%eax
  8006e8:	89 d6                	mov    %edx,%esi
  8006ea:	89 c7                	mov    %eax,%edi
  8006ec:	48 b8 c7 76 80 00 00 	movabs $0x8076c7,%rax
  8006f3:	00 00 00 
  8006f6:	ff d0                	callq  *%rax
  8006f8:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  8006fb:	e9 52 01 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_CLOSE:
            r = lwip_close(req->close.req_s);
  800700:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800704:	8b 00                	mov    (%rax),%eax
  800706:	89 c7                	mov    %eax,%edi
  800708:	48 b8 98 60 80 00 00 	movabs $0x806098,%rax
  80070f:	00 00 00 
  800712:	ff d0                	callq  *%rax
  800714:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  800717:	e9 36 01 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_CONNECT:
            r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80071c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800720:	8b 50 14             	mov    0x14(%rax),%edx
  800723:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800727:	48 8d 48 04          	lea    0x4(%rax),%rcx
  80072b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80072f:	8b 00                	mov    (%rax),%eax
  800731:	48 89 ce             	mov    %rcx,%rsi
  800734:	89 c7                	mov    %eax,%edi
  800736:	48 b8 7d 61 80 00 00 	movabs $0x80617d,%rax
  80073d:	00 00 00 
  800740:	ff d0                	callq  *%rax
  800742:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->connect.req_namelen);
            break;
  800745:	e9 08 01 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_LISTEN:
            r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  80074a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80074e:	8b 50 04             	mov    0x4(%rax),%edx
  800751:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800755:	8b 00                	mov    (%rax),%eax
  800757:	89 d6                	mov    %edx,%esi
  800759:	89 c7                	mov    %eax,%edi
  80075b:	48 b8 d9 62 80 00 00 	movabs $0x8062d9,%rax
  800762:	00 00 00 
  800765:	ff d0                	callq  *%rax
  800767:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  80076a:	e9 e3 00 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_RECV:
            // Note that we read the request fields before we
            // overwrite it with the response data.
            r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  80076f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800773:	8b 48 08             	mov    0x8(%rax),%ecx
  800776:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80077a:	8b 50 04             	mov    0x4(%rax),%edx
  80077d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800781:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800785:	8b 00                	mov    (%rax),%eax
  800787:	89 c7                	mov    %eax,%edi
  800789:	48 b8 d8 67 80 00 00 	movabs $0x8067d8,%rax
  800790:	00 00 00 
  800793:	ff d0                	callq  *%rax
  800795:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->recv.req_len, req->recv.req_flags);
            break;
  800798:	e9 b5 00 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_SEND:
            r = lwip_send(req->send.req_s, &req->send.req_buf,
  80079d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007a1:	8b 48 08             	mov    0x8(%rax),%ecx
  8007a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007a8:	8b 50 04             	mov    0x4(%rax),%edx
  8007ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007af:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  8007b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007b7:	8b 00                	mov    (%rax),%eax
  8007b9:	89 c7                	mov    %eax,%edi
  8007bb:	48 b8 16 68 80 00 00 	movabs $0x806816,%rax
  8007c2:	00 00 00 
  8007c5:	ff d0                	callq  *%rax
  8007c7:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->send.req_size, req->send.req_flags);
            break;
  8007ca:	e9 83 00 00 00       	jmpq   800852 <serve_thread+0x244>
        case NSREQ_SOCKET:
            r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8007cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007d3:	8b 50 08             	mov    0x8(%rax),%edx
  8007d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007da:	8b 48 04             	mov    0x4(%rax),%ecx
  8007dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007e1:	8b 00                	mov    (%rax),%eax
  8007e3:	89 ce                	mov    %ecx,%esi
  8007e5:	89 c7                	mov    %eax,%edi
  8007e7:	48 b8 33 6b 80 00 00 	movabs $0x806b33,%rax
  8007ee:	00 00 00 
  8007f1:	ff d0                	callq  *%rax
  8007f3:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->socket.req_protocol);
            break;
  8007f6:	eb 5a                	jmp    800852 <serve_thread+0x244>
        case NSREQ_INPUT:
            jif_input(&nif, (void *)&req->pkt);
  8007f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007fc:	48 89 c6             	mov    %rax,%rsi
  8007ff:	48 bf 20 75 b5 00 00 	movabs $0xb57520,%rdi
  800806:	00 00 00 
  800809:	48 b8 f8 94 81 00 00 	movabs $0x8194f8,%rax
  800810:	00 00 00 
  800813:	ff d0                	callq  *%rax
            r = 0;
  800815:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
            break;
  80081c:	eb 34                	jmp    800852 <serve_thread+0x244>
        default:
            cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80081e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800822:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800826:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80082a:	8b 40 04             	mov    0x4(%rax),%eax
  80082d:	89 c6                	mov    %eax,%esi
  80082f:	48 bf 40 08 82 00 00 	movabs $0x820840,%rdi
  800836:	00 00 00 
  800839:	b8 00 00 00 00       	mov    $0x0,%eax
  80083e:	48 b9 79 11 80 00 00 	movabs $0x801179,%rcx
  800845:	00 00 00 
  800848:	ff d1                	callq  *%rcx
            r = -E_INVAL;
  80084a:	c7 45 fc fd ff ff ff 	movl   $0xfffffffd,-0x4(%rbp)
            break;
  800851:	90                   	nop
    }

    if (r == -1) {
  800852:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800856:	75 49                	jne    8008a1 <serve_thread+0x293>
        char buf[100];
        snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800858:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80085c:	8b 10                	mov    (%rax),%edx
  80085e:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  800865:	89 d1                	mov    %edx,%ecx
  800867:	48 ba 63 08 82 00 00 	movabs $0x820863,%rdx
  80086e:	00 00 00 
  800871:	be 64 00 00 00       	mov    $0x64,%esi
  800876:	48 89 c7             	mov    %rax,%rdi
  800879:	b8 00 00 00 00       	mov    $0x0,%eax
  80087e:	49 b8 e1 1b 80 00 00 	movabs $0x801be1,%r8
  800885:	00 00 00 
  800888:	41 ff d0             	callq  *%r8
        perror(buf);
  80088b:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  800892:	48 89 c7             	mov    %rax,%rdi
  800895:	48 b8 92 91 81 00 00 	movabs $0x819192,%rax
  80089c:	00 00 00 
  80089f:	ff d0                	callq  *%rax
    }

    if (args->reqno != NSREQ_INPUT)
  8008a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008a5:	8b 00                	mov    (%rax),%eax
  8008a7:	83 f8 0a             	cmp    $0xa,%eax
  8008aa:	74 22                	je     8008ce <serve_thread+0x2c0>
        ipc_send(args->whom, r, 0, 0);
  8008ac:	8b 75 fc             	mov    -0x4(%rbp),%esi
  8008af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008b3:	8b 40 04             	mov    0x4(%rax),%eax
  8008b6:	b9 00 00 00 00       	mov    $0x0,%ecx
  8008bb:	ba 00 00 00 00       	mov    $0x0,%edx
  8008c0:	89 c7                	mov    %eax,%edi
  8008c2:	48 b8 34 31 80 00 00 	movabs $0x803134,%rax
  8008c9:	00 00 00 
  8008cc:	ff d0                	callq  *%rax

    put_buffer(args->req);
  8008ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008d2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008d6:	48 89 c7             	mov    %rax,%rdi
  8008d9:	48 b8 31 01 80 00 00 	movabs $0x800131,%rax
  8008e0:	00 00 00 
  8008e3:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void*) args->req);
  8008e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008ed:	48 89 c6             	mov    %rax,%rsi
  8008f0:	bf 00 00 00 00       	mov    $0x0,%edi
  8008f5:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  8008fc:	00 00 00 
  8008ff:	ff d0                	callq  *%rax
    free(args);
  800901:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800905:	48 89 c7             	mov    %rax,%rdi
  800908:	48 b8 44 4e 80 00 00 	movabs $0x804e44,%rax
  80090f:	00 00 00 
  800912:	ff d0                	callq  *%rax
}
  800914:	c9                   	leaveq 
  800915:	c3                   	retq   

0000000000800916 <serve>:

void
serve(void) {
  800916:	55                   	push   %rbp
  800917:	48 89 e5             	mov    %rsp,%rbp
  80091a:	48 83 ec 30          	sub    $0x30,%rsp

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80091e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800925:	eb 10                	jmp    800937 <serve+0x21>
            thread_yield();
  800927:	48 b8 dd 8d 81 00 00 	movabs $0x818ddd,%rax
  80092e:	00 00 00 
  800931:	ff d0                	callq  *%rax

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800933:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800937:	48 b8 c6 89 81 00 00 	movabs $0x8189c6,%rax
  80093e:	00 00 00 
  800941:	ff d0                	callq  *%rax
  800943:	85 c0                	test   %eax,%eax
  800945:	74 06                	je     80094d <serve+0x37>
  800947:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80094b:	7e da                	jle    800927 <serve+0x11>
            thread_yield();

        perm = 0;
  80094d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        va = get_buffer();
  800954:	48 b8 99 00 80 00 00 	movabs $0x800099,%rax
  80095b:	00 00 00 
  80095e:	ff d0                	callq  *%rax
  800960:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800964:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800968:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80096c:	48 8d 45 dc          	lea    -0x24(%rbp),%rax
  800970:	48 89 ce             	mov    %rcx,%rsi
  800973:	48 89 c7             	mov    %rax,%rdi
  800976:	48 b8 2e 30 80 00 00 	movabs $0x80302e,%rax
  80097d:	00 00 00 
  800980:	ff d0                	callq  *%rax
  800982:	89 45 ec             	mov    %eax,-0x14(%rbp)
        if (debug) {
            cprintf("ns req %d from %08x\n", reqno, whom);
        }

        // first take care of requests that do not contain an argument page
        if (reqno == NSREQ_TIMER) {
  800985:	83 7d ec 0c          	cmpl   $0xc,-0x14(%rbp)
  800989:	75 29                	jne    8009b4 <serve+0x9e>
            process_timer(whom);
  80098b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80098e:	89 c7                	mov    %eax,%edi
  800990:	48 b8 74 05 80 00 00 	movabs $0x800574,%rax
  800997:	00 00 00 
  80099a:	ff d0                	callq  *%rax
            put_buffer(va);
  80099c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8009a0:	48 89 c7             	mov    %rax,%rdi
  8009a3:	48 b8 31 01 80 00 00 	movabs $0x800131,%rax
  8009aa:	00 00 00 
  8009ad:	ff d0                	callq  *%rax
            continue;
  8009af:	e9 d1 00 00 00       	jmpq   800a85 <serve+0x16f>
        }

        // All remaining requests must contain an argument page
        if (!(perm & PTE_P)) {
  8009b4:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8009b7:	83 e0 01             	and    $0x1,%eax
  8009ba:	85 c0                	test   %eax,%eax
  8009bc:	75 25                	jne    8009e3 <serve+0xcd>
            cprintf("Invalid request from %08x: no argument page\n", whom);
  8009be:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8009c1:	89 c6                	mov    %eax,%esi
  8009c3:	48 bf d0 08 82 00 00 	movabs $0x8208d0,%rdi
  8009ca:	00 00 00 
  8009cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8009d2:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  8009d9:	00 00 00 
  8009dc:	ff d2                	callq  *%rdx
            continue; // just leave it hanging...
  8009de:	e9 a2 00 00 00       	jmpq   800a85 <serve+0x16f>
        }

        // Since some lwIP socket calls will block, create a thread and
        // process the rest of the request in the thread.
        struct st_args *args = malloc(sizeof(struct st_args));
  8009e3:	bf 10 00 00 00       	mov    $0x10,%edi
  8009e8:	48 b8 c6 4a 80 00 00 	movabs $0x804ac6,%rax
  8009ef:	00 00 00 
  8009f2:	ff d0                	callq  *%rax
  8009f4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if (!args)
  8009f8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8009fd:	75 2a                	jne    800a29 <serve+0x113>
            panic("could not allocate thread args structure");
  8009ff:	48 ba 00 09 82 00 00 	movabs $0x820900,%rdx
  800a06:	00 00 00 
  800a09:	be 26 01 00 00       	mov    $0x126,%esi
  800a0e:	48 bf 34 07 82 00 00 	movabs $0x820734,%rdi
  800a15:	00 00 00 
  800a18:	b8 00 00 00 00       	mov    $0x0,%eax
  800a1d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  800a24:	00 00 00 
  800a27:	ff d1                	callq  *%rcx

        args->reqno = reqno;
  800a29:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a2d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800a30:	89 10                	mov    %edx,(%rax)
        args->whom = whom;
  800a32:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800a35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a39:	89 50 04             	mov    %edx,0x4(%rax)
        args->req = va;
  800a3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a40:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800a44:	48 89 50 08          	mov    %rdx,0x8(%rax)

        thread_create(0, "serve_thread", serve_thread, (uint64_t)args);
  800a48:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a4c:	48 89 c1             	mov    %rax,%rcx
  800a4f:	48 ba 0e 06 80 00 00 	movabs $0x80060e,%rdx
  800a56:	00 00 00 
  800a59:	48 be 29 09 82 00 00 	movabs $0x820929,%rsi
  800a60:	00 00 00 
  800a63:	bf 00 00 00 00       	mov    $0x0,%edi
  800a68:	48 b8 5d 8b 81 00 00 	movabs $0x818b5d,%rax
  800a6f:	00 00 00 
  800a72:	ff d0                	callq  *%rax
        thread_yield(); // let the thread created run
  800a74:	48 b8 dd 8d 81 00 00 	movabs $0x818ddd,%rax
  800a7b:	00 00 00 
  800a7e:	ff d0                	callq  *%rax
    }
  800a80:	e9 99 fe ff ff       	jmpq   80091e <serve+0x8>
  800a85:	e9 94 fe ff ff       	jmpq   80091e <serve+0x8>

0000000000800a8a <tmain>:
}

static void
tmain(uint64_t arg) {
  800a8a:	55                   	push   %rbp
  800a8b:	48 89 e5             	mov    %rsp,%rbp
  800a8e:	41 54                	push   %r12
  800a90:	53                   	push   %rbx
  800a91:	48 83 ec 10          	sub    $0x10,%rsp
  800a95:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    serve_init(inet_addr(IP),
  800a99:	48 bf 36 09 82 00 00 	movabs $0x820936,%rdi
  800aa0:	00 00 00 
  800aa3:	48 b8 cf 28 81 00 00 	movabs $0x8128cf,%rax
  800aaa:	00 00 00 
  800aad:	ff d0                	callq  *%rax
  800aaf:	41 89 c4             	mov    %eax,%r12d
  800ab2:	48 bf 3f 09 82 00 00 	movabs $0x82093f,%rdi
  800ab9:	00 00 00 
  800abc:	48 b8 cf 28 81 00 00 	movabs $0x8128cf,%rax
  800ac3:	00 00 00 
  800ac6:	ff d0                	callq  *%rax
  800ac8:	89 c3                	mov    %eax,%ebx
  800aca:	48 bf 4d 09 82 00 00 	movabs $0x82094d,%rdi
  800ad1:	00 00 00 
  800ad4:	48 b8 cf 28 81 00 00 	movabs $0x8128cf,%rax
  800adb:	00 00 00 
  800ade:	ff d0                	callq  *%rax
  800ae0:	44 89 e2             	mov    %r12d,%edx
  800ae3:	89 de                	mov    %ebx,%esi
  800ae5:	89 c7                	mov    %eax,%edi
  800ae7:	48 b8 74 03 80 00 00 	movabs $0x800374,%rax
  800aee:	00 00 00 
  800af1:	ff d0                	callq  *%rax
            inet_addr(MASK),
            inet_addr(DEFAULT));
    serve();
  800af3:	48 b8 16 09 80 00 00 	movabs $0x800916,%rax
  800afa:	00 00 00 
  800afd:	ff d0                	callq  *%rax
}
  800aff:	48 83 c4 10          	add    $0x10,%rsp
  800b03:	5b                   	pop    %rbx
  800b04:	41 5c                	pop    %r12
  800b06:	5d                   	pop    %rbp
  800b07:	c3                   	retq   

0000000000800b08 <umain>:

    void
umain(int argc, char **argv)
{
  800b08:	55                   	push   %rbp
  800b09:	48 89 e5             	mov    %rsp,%rbp
  800b0c:	53                   	push   %rbx
  800b0d:	48 83 ec 28          	sub    $0x28,%rsp
  800b11:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800b14:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    envid_t ns_envid = sys_getenvid();
  800b18:	48 b8 e1 25 80 00 00 	movabs $0x8025e1,%rax
  800b1f:	00 00 00 
  800b22:	ff d0                	callq  *%rax
  800b24:	89 45 ec             	mov    %eax,-0x14(%rbp)

    binaryname = "ns";
  800b27:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800b2e:	00 00 00 
  800b31:	48 bb 57 09 82 00 00 	movabs $0x820957,%rbx
  800b38:	00 00 00 
  800b3b:	48 89 18             	mov    %rbx,(%rax)

    // fork off the timer thread which will send us periodic messages
    timer_envid = fork();
  800b3e:	48 b8 7d 2d 80 00 00 	movabs $0x802d7d,%rax
  800b45:	00 00 00 
  800b48:	ff d0                	callq  *%rax
  800b4a:	48 ba 58 90 82 00 00 	movabs $0x829058,%rdx
  800b51:	00 00 00 
  800b54:	89 02                	mov    %eax,(%rdx)
    if (timer_envid < 0)
  800b56:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800b5d:	00 00 00 
  800b60:	8b 00                	mov    (%rax),%eax
  800b62:	85 c0                	test   %eax,%eax
  800b64:	79 2a                	jns    800b90 <umain+0x88>
        panic("error forking");
  800b66:	48 ba 5a 09 82 00 00 	movabs $0x82095a,%rdx
  800b6d:	00 00 00 
  800b70:	be 43 01 00 00       	mov    $0x143,%esi
  800b75:	48 bf 34 07 82 00 00 	movabs $0x820734,%rdi
  800b7c:	00 00 00 
  800b7f:	b8 00 00 00 00       	mov    $0x0,%eax
  800b84:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  800b8b:	00 00 00 
  800b8e:	ff d1                	callq  *%rcx
    else if (timer_envid == 0) {
  800b90:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800b97:	00 00 00 
  800b9a:	8b 00                	mov    (%rax),%eax
  800b9c:	85 c0                	test   %eax,%eax
  800b9e:	75 1b                	jne    800bbb <umain+0xb3>
        timer(ns_envid, TIMER_INTERVAL);
  800ba0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800ba3:	be fa 00 00 00       	mov    $0xfa,%esi
  800ba8:	89 c7                	mov    %eax,%edi
  800baa:	48 b8 f1 0c 80 00 00 	movabs $0x800cf1,%rax
  800bb1:	00 00 00 
  800bb4:	ff d0                	callq  *%rax
        return;
  800bb6:	e9 2f 01 00 00       	jmpq   800cea <umain+0x1e2>
    }

    // fork off the input thread which will poll the NIC driver for input
    // packets
    input_envid = fork();
  800bbb:	48 b8 7d 2d 80 00 00 	movabs $0x802d7d,%rax
  800bc2:	00 00 00 
  800bc5:	ff d0                	callq  *%rax
  800bc7:	48 ba 5c 90 82 00 00 	movabs $0x82905c,%rdx
  800bce:	00 00 00 
  800bd1:	89 02                	mov    %eax,(%rdx)
    if (input_envid < 0)
  800bd3:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800bda:	00 00 00 
  800bdd:	8b 00                	mov    (%rax),%eax
  800bdf:	85 c0                	test   %eax,%eax
  800be1:	79 2a                	jns    800c0d <umain+0x105>
        panic("error forking");
  800be3:	48 ba 5a 09 82 00 00 	movabs $0x82095a,%rdx
  800bea:	00 00 00 
  800bed:	be 4d 01 00 00       	mov    $0x14d,%esi
  800bf2:	48 bf 34 07 82 00 00 	movabs $0x820734,%rdi
  800bf9:	00 00 00 
  800bfc:	b8 00 00 00 00       	mov    $0x0,%eax
  800c01:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  800c08:	00 00 00 
  800c0b:	ff d1                	callq  *%rcx
    else if (input_envid == 0) {
  800c0d:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800c14:	00 00 00 
  800c17:	8b 00                	mov    (%rax),%eax
  800c19:	85 c0                	test   %eax,%eax
  800c1b:	75 16                	jne    800c33 <umain+0x12b>
        input(ns_envid);
  800c1d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800c20:	89 c7                	mov    %eax,%edi
  800c22:	48 b8 12 0e 80 00 00 	movabs $0x800e12,%rax
  800c29:	00 00 00 
  800c2c:	ff d0                	callq  *%rax
        return;
  800c2e:	e9 b7 00 00 00       	jmpq   800cea <umain+0x1e2>
    }

    // fork off the output thread that will send the packets to the NIC
    // driver
    output_envid = fork();
  800c33:	48 b8 7d 2d 80 00 00 	movabs $0x802d7d,%rax
  800c3a:	00 00 00 
  800c3d:	ff d0                	callq  *%rax
  800c3f:	48 ba 60 90 82 00 00 	movabs $0x829060,%rdx
  800c46:	00 00 00 
  800c49:	89 02                	mov    %eax,(%rdx)
    if (output_envid < 0)
  800c4b:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c52:	00 00 00 
  800c55:	8b 00                	mov    (%rax),%eax
  800c57:	85 c0                	test   %eax,%eax
  800c59:	79 2a                	jns    800c85 <umain+0x17d>
        panic("error forking");
  800c5b:	48 ba 5a 09 82 00 00 	movabs $0x82095a,%rdx
  800c62:	00 00 00 
  800c65:	be 57 01 00 00       	mov    $0x157,%esi
  800c6a:	48 bf 34 07 82 00 00 	movabs $0x820734,%rdi
  800c71:	00 00 00 
  800c74:	b8 00 00 00 00       	mov    $0x0,%eax
  800c79:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  800c80:	00 00 00 
  800c83:	ff d1                	callq  *%rcx
    else if (output_envid == 0) {
  800c85:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c8c:	00 00 00 
  800c8f:	8b 00                	mov    (%rax),%eax
  800c91:	85 c0                	test   %eax,%eax
  800c93:	75 13                	jne    800ca8 <umain+0x1a0>
        output(ns_envid);
  800c95:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800c98:	89 c7                	mov    %eax,%edi
  800c9a:	48 b8 36 0e 80 00 00 	movabs $0x800e36,%rax
  800ca1:	00 00 00 
  800ca4:	ff d0                	callq  *%rax
        return;
  800ca6:	eb 42                	jmp    800cea <umain+0x1e2>
    }

    // lwIP requires a user threading library; start the library and jump
    // into a thread to continue initialization.
    thread_init();
  800ca8:	48 b8 54 88 81 00 00 	movabs $0x818854,%rax
  800caf:	00 00 00 
  800cb2:	ff d0                	callq  *%rax
    thread_create(0, "main", tmain, 0);
  800cb4:	b9 00 00 00 00       	mov    $0x0,%ecx
  800cb9:	48 ba 8a 0a 80 00 00 	movabs $0x800a8a,%rdx
  800cc0:	00 00 00 
  800cc3:	48 be 68 09 82 00 00 	movabs $0x820968,%rsi
  800cca:	00 00 00 
  800ccd:	bf 00 00 00 00       	mov    $0x0,%edi
  800cd2:	48 b8 5d 8b 81 00 00 	movabs $0x818b5d,%rax
  800cd9:	00 00 00 
  800cdc:	ff d0                	callq  *%rax
    thread_yield();
  800cde:	48 b8 dd 8d 81 00 00 	movabs $0x818ddd,%rax
  800ce5:	00 00 00 
  800ce8:	ff d0                	callq  *%rax
    // never coming here!
}
  800cea:	48 83 c4 28          	add    $0x28,%rsp
  800cee:	5b                   	pop    %rbx
  800cef:	5d                   	pop    %rbp
  800cf0:	c3                   	retq   

0000000000800cf1 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800cf1:	55                   	push   %rbp
  800cf2:	48 89 e5             	mov    %rsp,%rbp
  800cf5:	53                   	push   %rbx
  800cf6:	48 83 ec 28          	sub    $0x28,%rsp
  800cfa:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800cfd:	89 75 d8             	mov    %esi,-0x28(%rbp)
    int r;
    uint32_t stop = sys_time_msec() + initial_to;
  800d00:	48 b8 56 29 80 00 00 	movabs $0x802956,%rax
  800d07:	00 00 00 
  800d0a:	ff d0                	callq  *%rax
  800d0c:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800d0f:	01 d0                	add    %edx,%eax
  800d11:	89 45 ec             	mov    %eax,-0x14(%rbp)

    binaryname = "ns_timer";
  800d14:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800d1b:	00 00 00 
  800d1e:	48 bb 70 09 82 00 00 	movabs $0x820970,%rbx
  800d25:	00 00 00 
  800d28:	48 89 18             	mov    %rbx,(%rax)

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d2b:	eb 0c                	jmp    800d39 <timer+0x48>
            sys_yield();
  800d2d:	48 b8 1f 26 80 00 00 	movabs $0x80261f,%rax
  800d34:	00 00 00 
  800d37:	ff d0                	callq  *%rax
    uint32_t stop = sys_time_msec() + initial_to;

    binaryname = "ns_timer";

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d39:	48 b8 56 29 80 00 00 	movabs $0x802956,%rax
  800d40:	00 00 00 
  800d43:	ff d0                	callq  *%rax
  800d45:	89 45 e8             	mov    %eax,-0x18(%rbp)
  800d48:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800d4b:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800d4e:	73 06                	jae    800d56 <timer+0x65>
  800d50:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800d54:	79 d7                	jns    800d2d <timer+0x3c>
            sys_yield();
        }
        if (r < 0)
  800d56:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800d5a:	79 30                	jns    800d8c <timer+0x9b>
            panic("sys_time_msec: %e", r);
  800d5c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800d5f:	89 c1                	mov    %eax,%ecx
  800d61:	48 ba 79 09 82 00 00 	movabs $0x820979,%rdx
  800d68:	00 00 00 
  800d6b:	be 0f 00 00 00       	mov    $0xf,%esi
  800d70:	48 bf 8b 09 82 00 00 	movabs $0x82098b,%rdi
  800d77:	00 00 00 
  800d7a:	b8 00 00 00 00       	mov    $0x0,%eax
  800d7f:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  800d86:	00 00 00 
  800d89:	41 ff d0             	callq  *%r8

        ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  800d8c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800d8f:	b9 00 00 00 00       	mov    $0x0,%ecx
  800d94:	ba 00 00 00 00       	mov    $0x0,%edx
  800d99:	be 0c 00 00 00       	mov    $0xc,%esi
  800d9e:	89 c7                	mov    %eax,%edi
  800da0:	48 b8 34 31 80 00 00 	movabs $0x803134,%rax
  800da7:	00 00 00 
  800daa:	ff d0                	callq  *%rax

        while (1) {
            uint32_t to, whom;
            to = ipc_recv((int32_t *) &whom, 0, 0);
  800dac:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800db0:	ba 00 00 00 00       	mov    $0x0,%edx
  800db5:	be 00 00 00 00       	mov    $0x0,%esi
  800dba:	48 89 c7             	mov    %rax,%rdi
  800dbd:	48 b8 2e 30 80 00 00 	movabs $0x80302e,%rax
  800dc4:	00 00 00 
  800dc7:	ff d0                	callq  *%rax
  800dc9:	89 45 e4             	mov    %eax,-0x1c(%rbp)

            if (whom != ns_envid) {
  800dcc:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800dcf:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800dd2:	39 c2                	cmp    %eax,%edx
  800dd4:	74 22                	je     800df8 <timer+0x107>
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800dd6:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800dd9:	89 c6                	mov    %eax,%esi
  800ddb:	48 bf 98 09 82 00 00 	movabs $0x820998,%rdi
  800de2:	00 00 00 
  800de5:	b8 00 00 00 00       	mov    $0x0,%eax
  800dea:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  800df1:	00 00 00 
  800df4:	ff d2                	callq  *%rdx
                continue;
            }

            stop = sys_time_msec() + to;
            break;
        }
  800df6:	eb b4                	jmp    800dac <timer+0xbb>
            if (whom != ns_envid) {
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
                continue;
            }

            stop = sys_time_msec() + to;
  800df8:	48 b8 56 29 80 00 00 	movabs $0x802956,%rax
  800dff:	00 00 00 
  800e02:	ff d0                	callq  *%rax
  800e04:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800e07:	01 d0                	add    %edx,%eax
  800e09:	89 45 ec             	mov    %eax,-0x14(%rbp)
            break;
        }
    }
  800e0c:	90                   	nop
    uint32_t stop = sys_time_msec() + initial_to;

    binaryname = "ns_timer";

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800e0d:	e9 27 ff ff ff       	jmpq   800d39 <timer+0x48>

0000000000800e12 <input>:

extern union Nsipc nsipcbuf;

    void
input(envid_t ns_envid)
{
  800e12:	55                   	push   %rbp
  800e13:	48 89 e5             	mov    %rsp,%rbp
  800e16:	48 83 ec 04          	sub    $0x4,%rsp
  800e1a:	89 7d fc             	mov    %edi,-0x4(%rbp)
    binaryname = "ns_input";
  800e1d:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800e24:	00 00 00 
  800e27:	48 ba d3 09 82 00 00 	movabs $0x8209d3,%rdx
  800e2e:	00 00 00 
  800e31:	48 89 10             	mov    %rdx,(%rax)
    // 	- read a packet from the device driver
    //	- send it to the network server
    // Hint: When you IPC a page to the network server, it will be
    // reading from it for a while, so don't immediately receive
    // another packet in to the same physical page.
}
  800e34:	c9                   	leaveq 
  800e35:	c3                   	retq   

0000000000800e36 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  800e36:	55                   	push   %rbp
  800e37:	48 89 e5             	mov    %rsp,%rbp
  800e3a:	48 83 ec 20          	sub    $0x20,%rsp
  800e3e:	89 7d ec             	mov    %edi,-0x14(%rbp)
    binaryname = "ns_output";
  800e41:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800e48:	00 00 00 
  800e4b:	48 ba dc 09 82 00 00 	movabs $0x8209dc,%rdx
  800e52:	00 00 00 
  800e55:	48 89 10             	mov    %rdx,(%rax)

    // LAB 6: Your code here:
    // 	- read a packet from the network server
    //	- send the packet to the device driver
	void* buf = NULL;
  800e58:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800e5f:	00 
	size_t len = 0;
  800e60:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800e67:	00 
	sys_net_tx((void*)nsipcbuf.send.req_buf, nsipcbuf.send.req_size);
  800e68:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  800e6f:	00 00 00 
  800e72:	8b 40 04             	mov    0x4(%rax),%eax
  800e75:	48 98                	cltq   
  800e77:	48 89 c6             	mov    %rax,%rsi
  800e7a:	48 bf 0c a0 b5 00 00 	movabs $0xb5a00c,%rdi
  800e81:	00 00 00 
  800e84:	48 b8 ca 28 80 00 00 	movabs $0x8028ca,%rax
  800e8b:	00 00 00 
  800e8e:	ff d0                	callq  *%rax
}
  800e90:	c9                   	leaveq 
  800e91:	c3                   	retq   

0000000000800e92 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  800e92:	55                   	push   %rbp
  800e93:	48 89 e5             	mov    %rsp,%rbp
  800e96:	48 83 ec 10          	sub    $0x10,%rsp
  800e9a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800e9d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = &envs[ENVX(sys_getenvid())];
  800ea1:	48 b8 e1 25 80 00 00 	movabs $0x8025e1,%rax
  800ea8:	00 00 00 
  800eab:	ff d0                	callq  *%rax
  800ead:	25 ff 03 00 00       	and    $0x3ff,%eax
  800eb2:	48 63 d0             	movslq %eax,%rdx
  800eb5:	48 89 d0             	mov    %rdx,%rax
  800eb8:	48 c1 e0 03          	shl    $0x3,%rax
  800ebc:	48 01 d0             	add    %rdx,%rax
  800ebf:	48 c1 e0 05          	shl    $0x5,%rax
  800ec3:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  800eca:	00 00 00 
  800ecd:	48 01 c2             	add    %rax,%rdx
  800ed0:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  800ed7:	00 00 00 
  800eda:	48 89 10             	mov    %rdx,(%rax)
	//cprintf("I am entering libmain\n");
	// save the name of the program so that panic() can use it
	if (argc > 0)
  800edd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800ee1:	7e 14                	jle    800ef7 <libmain+0x65>
		binaryname = argv[0];
  800ee3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800ee7:	48 8b 10             	mov    (%rax),%rdx
  800eea:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800ef1:	00 00 00 
  800ef4:	48 89 10             	mov    %rdx,(%rax)

	// call user main routine
	umain(argc, argv);
  800ef7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800efb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800efe:	48 89 d6             	mov    %rdx,%rsi
  800f01:	89 c7                	mov    %eax,%edi
  800f03:	48 b8 08 0b 80 00 00 	movabs $0x800b08,%rax
  800f0a:	00 00 00 
  800f0d:	ff d0                	callq  *%rax
	// exit gracefully
	exit();
  800f0f:	48 b8 1d 0f 80 00 00 	movabs $0x800f1d,%rax
  800f16:	00 00 00 
  800f19:	ff d0                	callq  *%rax
}
  800f1b:	c9                   	leaveq 
  800f1c:	c3                   	retq   

0000000000800f1d <exit>:

#include <inc/lib.h>

void
exit(void)
{
  800f1d:	55                   	push   %rbp
  800f1e:	48 89 e5             	mov    %rsp,%rbp
	close_all();
  800f21:	48 b8 59 35 80 00 00 	movabs $0x803559,%rax
  800f28:	00 00 00 
  800f2b:	ff d0                	callq  *%rax
	sys_env_destroy(0);
  800f2d:	bf 00 00 00 00       	mov    $0x0,%edi
  800f32:	48 b8 9d 25 80 00 00 	movabs $0x80259d,%rax
  800f39:	00 00 00 
  800f3c:	ff d0                	callq  *%rax

}
  800f3e:	5d                   	pop    %rbp
  800f3f:	c3                   	retq   

0000000000800f40 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  800f40:	55                   	push   %rbp
  800f41:	48 89 e5             	mov    %rsp,%rbp
  800f44:	53                   	push   %rbx
  800f45:	48 81 ec f8 00 00 00 	sub    $0xf8,%rsp
  800f4c:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  800f53:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%rbp)
  800f59:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
  800f60:	4c 89 85 60 ff ff ff 	mov    %r8,-0xa0(%rbp)
  800f67:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
  800f6e:	84 c0                	test   %al,%al
  800f70:	74 23                	je     800f95 <_panic+0x55>
  800f72:	0f 29 85 70 ff ff ff 	movaps %xmm0,-0x90(%rbp)
  800f79:	0f 29 4d 80          	movaps %xmm1,-0x80(%rbp)
  800f7d:	0f 29 55 90          	movaps %xmm2,-0x70(%rbp)
  800f81:	0f 29 5d a0          	movaps %xmm3,-0x60(%rbp)
  800f85:	0f 29 65 b0          	movaps %xmm4,-0x50(%rbp)
  800f89:	0f 29 6d c0          	movaps %xmm5,-0x40(%rbp)
  800f8d:	0f 29 75 d0          	movaps %xmm6,-0x30(%rbp)
  800f91:	0f 29 7d e0          	movaps %xmm7,-0x20(%rbp)
  800f95:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800f9c:	c7 85 28 ff ff ff 18 	movl   $0x18,-0xd8(%rbp)
  800fa3:	00 00 00 
  800fa6:	c7 85 2c ff ff ff 30 	movl   $0x30,-0xd4(%rbp)
  800fad:	00 00 00 
  800fb0:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800fb4:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  800fbb:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
  800fc2:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  800fc9:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800fd0:	00 00 00 
  800fd3:	48 8b 18             	mov    (%rax),%rbx
  800fd6:	48 b8 e1 25 80 00 00 	movabs $0x8025e1,%rax
  800fdd:	00 00 00 
  800fe0:	ff d0                	callq  *%rax
  800fe2:	8b 8d 14 ff ff ff    	mov    -0xec(%rbp),%ecx
  800fe8:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800fef:	41 89 c8             	mov    %ecx,%r8d
  800ff2:	48 89 d1             	mov    %rdx,%rcx
  800ff5:	48 89 da             	mov    %rbx,%rdx
  800ff8:	89 c6                	mov    %eax,%esi
  800ffa:	48 bf f0 09 82 00 00 	movabs $0x8209f0,%rdi
  801001:	00 00 00 
  801004:	b8 00 00 00 00       	mov    $0x0,%eax
  801009:	49 b9 79 11 80 00 00 	movabs $0x801179,%r9
  801010:	00 00 00 
  801013:	41 ff d1             	callq  *%r9
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  801016:	48 8d 95 28 ff ff ff 	lea    -0xd8(%rbp),%rdx
  80101d:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801024:	48 89 d6             	mov    %rdx,%rsi
  801027:	48 89 c7             	mov    %rax,%rdi
  80102a:	48 b8 cd 10 80 00 00 	movabs $0x8010cd,%rax
  801031:	00 00 00 
  801034:	ff d0                	callq  *%rax
	cprintf("\n");
  801036:	48 bf 13 0a 82 00 00 	movabs $0x820a13,%rdi
  80103d:	00 00 00 
  801040:	b8 00 00 00 00       	mov    $0x0,%eax
  801045:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  80104c:	00 00 00 
  80104f:	ff d2                	callq  *%rdx

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  801051:	cc                   	int3   
  801052:	eb fd                	jmp    801051 <_panic+0x111>

0000000000801054 <putch>:
};


    static void
putch(int ch, struct printbuf *b)
{
  801054:	55                   	push   %rbp
  801055:	48 89 e5             	mov    %rsp,%rbp
  801058:	48 83 ec 10          	sub    $0x10,%rsp
  80105c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80105f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    b->buf[b->idx++] = ch;
  801063:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801067:	8b 00                	mov    (%rax),%eax
  801069:	8d 48 01             	lea    0x1(%rax),%ecx
  80106c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801070:	89 0a                	mov    %ecx,(%rdx)
  801072:	8b 55 fc             	mov    -0x4(%rbp),%edx
  801075:	89 d1                	mov    %edx,%ecx
  801077:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80107b:	48 98                	cltq   
  80107d:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
    if (b->idx == 256-1) {
  801081:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801085:	8b 00                	mov    (%rax),%eax
  801087:	3d ff 00 00 00       	cmp    $0xff,%eax
  80108c:	75 2c                	jne    8010ba <putch+0x66>
        sys_cputs(b->buf, b->idx);
  80108e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801092:	8b 00                	mov    (%rax),%eax
  801094:	48 98                	cltq   
  801096:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80109a:	48 83 c2 08          	add    $0x8,%rdx
  80109e:	48 89 c6             	mov    %rax,%rsi
  8010a1:	48 89 d7             	mov    %rdx,%rdi
  8010a4:	48 b8 15 25 80 00 00 	movabs $0x802515,%rax
  8010ab:	00 00 00 
  8010ae:	ff d0                	callq  *%rax
        b->idx = 0;
  8010b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8010b4:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    }
    b->cnt++;
  8010ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8010be:	8b 40 04             	mov    0x4(%rax),%eax
  8010c1:	8d 50 01             	lea    0x1(%rax),%edx
  8010c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8010c8:	89 50 04             	mov    %edx,0x4(%rax)
}
  8010cb:	c9                   	leaveq 
  8010cc:	c3                   	retq   

00000000008010cd <vcprintf>:

    int
vcprintf(const char *fmt, va_list ap)
{
  8010cd:	55                   	push   %rbp
  8010ce:	48 89 e5             	mov    %rsp,%rbp
  8010d1:	48 81 ec 40 01 00 00 	sub    $0x140,%rsp
  8010d8:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
  8010df:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
    struct printbuf b;
    va_list aq;
    va_copy(aq,ap);
  8010e6:	48 8d 85 d8 fe ff ff 	lea    -0x128(%rbp),%rax
  8010ed:	48 8b 95 c0 fe ff ff 	mov    -0x140(%rbp),%rdx
  8010f4:	48 8b 0a             	mov    (%rdx),%rcx
  8010f7:	48 89 08             	mov    %rcx,(%rax)
  8010fa:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8010fe:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801102:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801106:	48 89 50 10          	mov    %rdx,0x10(%rax)
    b.idx = 0;
  80110a:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%rbp)
  801111:	00 00 00 
    b.cnt = 0;
  801114:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%rbp)
  80111b:	00 00 00 
    vprintfmt((void*)putch, &b, fmt, aq);
  80111e:	48 8d 8d d8 fe ff ff 	lea    -0x128(%rbp),%rcx
  801125:	48 8b 95 c8 fe ff ff 	mov    -0x138(%rbp),%rdx
  80112c:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  801133:	48 89 c6             	mov    %rax,%rsi
  801136:	48 bf 54 10 80 00 00 	movabs $0x801054,%rdi
  80113d:	00 00 00 
  801140:	48 b8 2c 15 80 00 00 	movabs $0x80152c,%rax
  801147:	00 00 00 
  80114a:	ff d0                	callq  *%rax
    sys_cputs(b.buf, b.idx);
  80114c:	8b 85 f0 fe ff ff    	mov    -0x110(%rbp),%eax
  801152:	48 98                	cltq   
  801154:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  80115b:	48 83 c2 08          	add    $0x8,%rdx
  80115f:	48 89 c6             	mov    %rax,%rsi
  801162:	48 89 d7             	mov    %rdx,%rdi
  801165:	48 b8 15 25 80 00 00 	movabs $0x802515,%rax
  80116c:	00 00 00 
  80116f:	ff d0                	callq  *%rax
    va_end(aq);

    return b.cnt;
  801171:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
}
  801177:	c9                   	leaveq 
  801178:	c3                   	retq   

0000000000801179 <cprintf>:

    int
cprintf(const char *fmt, ...)
{
  801179:	55                   	push   %rbp
  80117a:	48 89 e5             	mov    %rsp,%rbp
  80117d:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  801184:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  80118b:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  801192:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801199:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8011a0:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8011a7:	84 c0                	test   %al,%al
  8011a9:	74 20                	je     8011cb <cprintf+0x52>
  8011ab:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8011af:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8011b3:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8011b7:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8011bb:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8011bf:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8011c3:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8011c7:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8011cb:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
    va_list ap;
    int cnt;
    va_list aq;
    va_start(ap, fmt);
  8011d2:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8011d9:	00 00 00 
  8011dc:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8011e3:	00 00 00 
  8011e6:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8011ea:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8011f1:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8011f8:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    va_copy(aq,ap);
  8011ff:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  801206:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  80120d:	48 8b 0a             	mov    (%rdx),%rcx
  801210:	48 89 08             	mov    %rcx,(%rax)
  801213:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801217:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80121b:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80121f:	48 89 50 10          	mov    %rdx,0x10(%rax)
    cnt = vcprintf(fmt, aq);
  801223:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  80122a:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801231:	48 89 d6             	mov    %rdx,%rsi
  801234:	48 89 c7             	mov    %rax,%rdi
  801237:	48 b8 cd 10 80 00 00 	movabs $0x8010cd,%rax
  80123e:	00 00 00 
  801241:	ff d0                	callq  *%rax
  801243:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
    va_end(aq);

    return cnt;
  801249:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  80124f:	c9                   	leaveq 
  801250:	c3                   	retq   

0000000000801251 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  801251:	55                   	push   %rbp
  801252:	48 89 e5             	mov    %rsp,%rbp
  801255:	53                   	push   %rbx
  801256:	48 83 ec 38          	sub    $0x38,%rsp
  80125a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80125e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801262:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  801266:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  801269:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  80126d:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  801271:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  801274:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  801278:	77 3b                	ja     8012b5 <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80127a:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80127d:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  801281:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  801284:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  801288:	ba 00 00 00 00       	mov    $0x0,%edx
  80128d:	48 f7 f3             	div    %rbx
  801290:	48 89 c2             	mov    %rax,%rdx
  801293:	8b 7d cc             	mov    -0x34(%rbp),%edi
  801296:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  801299:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  80129d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8012a1:	41 89 f9             	mov    %edi,%r9d
  8012a4:	48 89 c7             	mov    %rax,%rdi
  8012a7:	48 b8 51 12 80 00 00 	movabs $0x801251,%rax
  8012ae:	00 00 00 
  8012b1:	ff d0                	callq  *%rax
  8012b3:	eb 1e                	jmp    8012d3 <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  8012b5:	eb 12                	jmp    8012c9 <printnum+0x78>
			putch(padc, putdat);
  8012b7:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8012bb:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8012be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8012c2:	48 89 ce             	mov    %rcx,%rsi
  8012c5:	89 d7                	mov    %edx,%edi
  8012c7:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  8012c9:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  8012cd:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  8012d1:	7f e4                	jg     8012b7 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  8012d3:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  8012d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8012da:	ba 00 00 00 00       	mov    $0x0,%edx
  8012df:	48 f7 f1             	div    %rcx
  8012e2:	48 89 d0             	mov    %rdx,%rax
  8012e5:	48 ba 10 0c 82 00 00 	movabs $0x820c10,%rdx
  8012ec:	00 00 00 
  8012ef:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8012f3:	0f be d0             	movsbl %al,%edx
  8012f6:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8012fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8012fe:	48 89 ce             	mov    %rcx,%rsi
  801301:	89 d7                	mov    %edx,%edi
  801303:	ff d0                	callq  *%rax
}
  801305:	48 83 c4 38          	add    $0x38,%rsp
  801309:	5b                   	pop    %rbx
  80130a:	5d                   	pop    %rbp
  80130b:	c3                   	retq   

000000000080130c <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80130c:	55                   	push   %rbp
  80130d:	48 89 e5             	mov    %rsp,%rbp
  801310:	48 83 ec 1c          	sub    $0x1c,%rsp
  801314:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801318:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  80131b:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80131f:	7e 52                	jle    801373 <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  801321:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801325:	8b 00                	mov    (%rax),%eax
  801327:	83 f8 30             	cmp    $0x30,%eax
  80132a:	73 24                	jae    801350 <getuint+0x44>
  80132c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801330:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801334:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801338:	8b 00                	mov    (%rax),%eax
  80133a:	89 c0                	mov    %eax,%eax
  80133c:	48 01 d0             	add    %rdx,%rax
  80133f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801343:	8b 12                	mov    (%rdx),%edx
  801345:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801348:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80134c:	89 0a                	mov    %ecx,(%rdx)
  80134e:	eb 17                	jmp    801367 <getuint+0x5b>
  801350:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801354:	48 8b 50 08          	mov    0x8(%rax),%rdx
  801358:	48 89 d0             	mov    %rdx,%rax
  80135b:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  80135f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801363:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801367:	48 8b 00             	mov    (%rax),%rax
  80136a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80136e:	e9 a3 00 00 00       	jmpq   801416 <getuint+0x10a>
	else if (lflag)
  801373:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801377:	74 4f                	je     8013c8 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  801379:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80137d:	8b 00                	mov    (%rax),%eax
  80137f:	83 f8 30             	cmp    $0x30,%eax
  801382:	73 24                	jae    8013a8 <getuint+0x9c>
  801384:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801388:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80138c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801390:	8b 00                	mov    (%rax),%eax
  801392:	89 c0                	mov    %eax,%eax
  801394:	48 01 d0             	add    %rdx,%rax
  801397:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80139b:	8b 12                	mov    (%rdx),%edx
  80139d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8013a0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8013a4:	89 0a                	mov    %ecx,(%rdx)
  8013a6:	eb 17                	jmp    8013bf <getuint+0xb3>
  8013a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013ac:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8013b0:	48 89 d0             	mov    %rdx,%rax
  8013b3:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8013b7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8013bb:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8013bf:	48 8b 00             	mov    (%rax),%rax
  8013c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8013c6:	eb 4e                	jmp    801416 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  8013c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013cc:	8b 00                	mov    (%rax),%eax
  8013ce:	83 f8 30             	cmp    $0x30,%eax
  8013d1:	73 24                	jae    8013f7 <getuint+0xeb>
  8013d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013d7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8013db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013df:	8b 00                	mov    (%rax),%eax
  8013e1:	89 c0                	mov    %eax,%eax
  8013e3:	48 01 d0             	add    %rdx,%rax
  8013e6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8013ea:	8b 12                	mov    (%rdx),%edx
  8013ec:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8013ef:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8013f3:	89 0a                	mov    %ecx,(%rdx)
  8013f5:	eb 17                	jmp    80140e <getuint+0x102>
  8013f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013fb:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8013ff:	48 89 d0             	mov    %rdx,%rax
  801402:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  801406:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80140a:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80140e:	8b 00                	mov    (%rax),%eax
  801410:	89 c0                	mov    %eax,%eax
  801412:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  801416:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80141a:	c9                   	leaveq 
  80141b:	c3                   	retq   

000000000080141c <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  80141c:	55                   	push   %rbp
  80141d:	48 89 e5             	mov    %rsp,%rbp
  801420:	48 83 ec 1c          	sub    $0x1c,%rsp
  801424:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801428:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  80142b:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80142f:	7e 52                	jle    801483 <getint+0x67>
		x=va_arg(*ap, long long);
  801431:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801435:	8b 00                	mov    (%rax),%eax
  801437:	83 f8 30             	cmp    $0x30,%eax
  80143a:	73 24                	jae    801460 <getint+0x44>
  80143c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801440:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801444:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801448:	8b 00                	mov    (%rax),%eax
  80144a:	89 c0                	mov    %eax,%eax
  80144c:	48 01 d0             	add    %rdx,%rax
  80144f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801453:	8b 12                	mov    (%rdx),%edx
  801455:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801458:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80145c:	89 0a                	mov    %ecx,(%rdx)
  80145e:	eb 17                	jmp    801477 <getint+0x5b>
  801460:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801464:	48 8b 50 08          	mov    0x8(%rax),%rdx
  801468:	48 89 d0             	mov    %rdx,%rax
  80146b:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  80146f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801473:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801477:	48 8b 00             	mov    (%rax),%rax
  80147a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80147e:	e9 a3 00 00 00       	jmpq   801526 <getint+0x10a>
	else if (lflag)
  801483:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801487:	74 4f                	je     8014d8 <getint+0xbc>
		x=va_arg(*ap, long);
  801489:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80148d:	8b 00                	mov    (%rax),%eax
  80148f:	83 f8 30             	cmp    $0x30,%eax
  801492:	73 24                	jae    8014b8 <getint+0x9c>
  801494:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801498:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80149c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014a0:	8b 00                	mov    (%rax),%eax
  8014a2:	89 c0                	mov    %eax,%eax
  8014a4:	48 01 d0             	add    %rdx,%rax
  8014a7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014ab:	8b 12                	mov    (%rdx),%edx
  8014ad:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8014b0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014b4:	89 0a                	mov    %ecx,(%rdx)
  8014b6:	eb 17                	jmp    8014cf <getint+0xb3>
  8014b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014bc:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8014c0:	48 89 d0             	mov    %rdx,%rax
  8014c3:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8014c7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014cb:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8014cf:	48 8b 00             	mov    (%rax),%rax
  8014d2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8014d6:	eb 4e                	jmp    801526 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  8014d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014dc:	8b 00                	mov    (%rax),%eax
  8014de:	83 f8 30             	cmp    $0x30,%eax
  8014e1:	73 24                	jae    801507 <getint+0xeb>
  8014e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014e7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8014eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014ef:	8b 00                	mov    (%rax),%eax
  8014f1:	89 c0                	mov    %eax,%eax
  8014f3:	48 01 d0             	add    %rdx,%rax
  8014f6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014fa:	8b 12                	mov    (%rdx),%edx
  8014fc:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8014ff:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801503:	89 0a                	mov    %ecx,(%rdx)
  801505:	eb 17                	jmp    80151e <getint+0x102>
  801507:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80150b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80150f:	48 89 d0             	mov    %rdx,%rax
  801512:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  801516:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80151a:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80151e:	8b 00                	mov    (%rax),%eax
  801520:	48 98                	cltq   
  801522:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  801526:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80152a:	c9                   	leaveq 
  80152b:	c3                   	retq   

000000000080152c <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80152c:	55                   	push   %rbp
  80152d:	48 89 e5             	mov    %rsp,%rbp
  801530:	41 54                	push   %r12
  801532:	53                   	push   %rbx
  801533:	48 83 ec 60          	sub    $0x60,%rsp
  801537:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80153b:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80153f:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  801543:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  801547:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  80154b:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80154f:	48 8b 0a             	mov    (%rdx),%rcx
  801552:	48 89 08             	mov    %rcx,(%rax)
  801555:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801559:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80155d:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801561:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801565:	eb 17                	jmp    80157e <vprintfmt+0x52>
			if (ch == '\0')
  801567:	85 db                	test   %ebx,%ebx
  801569:	0f 84 cc 04 00 00    	je     801a3b <vprintfmt+0x50f>
				return;
			putch(ch, putdat);
  80156f:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801573:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801577:	48 89 d6             	mov    %rdx,%rsi
  80157a:	89 df                	mov    %ebx,%edi
  80157c:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80157e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801582:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801586:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  80158a:	0f b6 00             	movzbl (%rax),%eax
  80158d:	0f b6 d8             	movzbl %al,%ebx
  801590:	83 fb 25             	cmp    $0x25,%ebx
  801593:	75 d2                	jne    801567 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  801595:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  801599:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  8015a0:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  8015a7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  8015ae:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  8015b5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8015b9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8015bd:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8015c1:	0f b6 00             	movzbl (%rax),%eax
  8015c4:	0f b6 d8             	movzbl %al,%ebx
  8015c7:	8d 43 dd             	lea    -0x23(%rbx),%eax
  8015ca:	83 f8 55             	cmp    $0x55,%eax
  8015cd:	0f 87 34 04 00 00    	ja     801a07 <vprintfmt+0x4db>
  8015d3:	89 c0                	mov    %eax,%eax
  8015d5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8015dc:	00 
  8015dd:	48 b8 38 0c 82 00 00 	movabs $0x820c38,%rax
  8015e4:	00 00 00 
  8015e7:	48 01 d0             	add    %rdx,%rax
  8015ea:	48 8b 00             	mov    (%rax),%rax
  8015ed:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  8015ef:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  8015f3:	eb c0                	jmp    8015b5 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  8015f5:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  8015f9:	eb ba                	jmp    8015b5 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  8015fb:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  801602:	8b 55 d8             	mov    -0x28(%rbp),%edx
  801605:	89 d0                	mov    %edx,%eax
  801607:	c1 e0 02             	shl    $0x2,%eax
  80160a:	01 d0                	add    %edx,%eax
  80160c:	01 c0                	add    %eax,%eax
  80160e:	01 d8                	add    %ebx,%eax
  801610:	83 e8 30             	sub    $0x30,%eax
  801613:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  801616:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80161a:	0f b6 00             	movzbl (%rax),%eax
  80161d:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  801620:	83 fb 2f             	cmp    $0x2f,%ebx
  801623:	7e 0c                	jle    801631 <vprintfmt+0x105>
  801625:	83 fb 39             	cmp    $0x39,%ebx
  801628:	7f 07                	jg     801631 <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80162a:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80162f:	eb d1                	jmp    801602 <vprintfmt+0xd6>
			goto process_precision;
  801631:	eb 58                	jmp    80168b <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  801633:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801636:	83 f8 30             	cmp    $0x30,%eax
  801639:	73 17                	jae    801652 <vprintfmt+0x126>
  80163b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80163f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801642:	89 c0                	mov    %eax,%eax
  801644:	48 01 d0             	add    %rdx,%rax
  801647:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80164a:	83 c2 08             	add    $0x8,%edx
  80164d:	89 55 b8             	mov    %edx,-0x48(%rbp)
  801650:	eb 0f                	jmp    801661 <vprintfmt+0x135>
  801652:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  801656:	48 89 d0             	mov    %rdx,%rax
  801659:	48 83 c2 08          	add    $0x8,%rdx
  80165d:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801661:	8b 00                	mov    (%rax),%eax
  801663:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  801666:	eb 23                	jmp    80168b <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  801668:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80166c:	79 0c                	jns    80167a <vprintfmt+0x14e>
				width = 0;
  80166e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  801675:	e9 3b ff ff ff       	jmpq   8015b5 <vprintfmt+0x89>
  80167a:	e9 36 ff ff ff       	jmpq   8015b5 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  80167f:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  801686:	e9 2a ff ff ff       	jmpq   8015b5 <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  80168b:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80168f:	79 12                	jns    8016a3 <vprintfmt+0x177>
				width = precision, precision = -1;
  801691:	8b 45 d8             	mov    -0x28(%rbp),%eax
  801694:	89 45 dc             	mov    %eax,-0x24(%rbp)
  801697:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  80169e:	e9 12 ff ff ff       	jmpq   8015b5 <vprintfmt+0x89>
  8016a3:	e9 0d ff ff ff       	jmpq   8015b5 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  8016a8:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  8016ac:	e9 04 ff ff ff       	jmpq   8015b5 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  8016b1:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8016b4:	83 f8 30             	cmp    $0x30,%eax
  8016b7:	73 17                	jae    8016d0 <vprintfmt+0x1a4>
  8016b9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8016bd:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8016c0:	89 c0                	mov    %eax,%eax
  8016c2:	48 01 d0             	add    %rdx,%rax
  8016c5:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8016c8:	83 c2 08             	add    $0x8,%edx
  8016cb:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8016ce:	eb 0f                	jmp    8016df <vprintfmt+0x1b3>
  8016d0:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8016d4:	48 89 d0             	mov    %rdx,%rax
  8016d7:	48 83 c2 08          	add    $0x8,%rdx
  8016db:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8016df:	8b 10                	mov    (%rax),%edx
  8016e1:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8016e5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8016e9:	48 89 ce             	mov    %rcx,%rsi
  8016ec:	89 d7                	mov    %edx,%edi
  8016ee:	ff d0                	callq  *%rax
			break;
  8016f0:	e9 40 03 00 00       	jmpq   801a35 <vprintfmt+0x509>

			// error message
		case 'e':
			err = va_arg(aq, int);
  8016f5:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8016f8:	83 f8 30             	cmp    $0x30,%eax
  8016fb:	73 17                	jae    801714 <vprintfmt+0x1e8>
  8016fd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  801701:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801704:	89 c0                	mov    %eax,%eax
  801706:	48 01 d0             	add    %rdx,%rax
  801709:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80170c:	83 c2 08             	add    $0x8,%edx
  80170f:	89 55 b8             	mov    %edx,-0x48(%rbp)
  801712:	eb 0f                	jmp    801723 <vprintfmt+0x1f7>
  801714:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  801718:	48 89 d0             	mov    %rdx,%rax
  80171b:	48 83 c2 08          	add    $0x8,%rdx
  80171f:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801723:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  801725:	85 db                	test   %ebx,%ebx
  801727:	79 02                	jns    80172b <vprintfmt+0x1ff>
				err = -err;
  801729:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80172b:	83 fb 15             	cmp    $0x15,%ebx
  80172e:	7f 16                	jg     801746 <vprintfmt+0x21a>
  801730:	48 b8 60 0b 82 00 00 	movabs $0x820b60,%rax
  801737:	00 00 00 
  80173a:	48 63 d3             	movslq %ebx,%rdx
  80173d:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  801741:	4d 85 e4             	test   %r12,%r12
  801744:	75 2e                	jne    801774 <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  801746:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  80174a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80174e:	89 d9                	mov    %ebx,%ecx
  801750:	48 ba 21 0c 82 00 00 	movabs $0x820c21,%rdx
  801757:	00 00 00 
  80175a:	48 89 c7             	mov    %rax,%rdi
  80175d:	b8 00 00 00 00       	mov    $0x0,%eax
  801762:	49 b8 44 1a 80 00 00 	movabs $0x801a44,%r8
  801769:	00 00 00 
  80176c:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  80176f:	e9 c1 02 00 00       	jmpq   801a35 <vprintfmt+0x509>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  801774:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801778:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80177c:	4c 89 e1             	mov    %r12,%rcx
  80177f:	48 ba 2a 0c 82 00 00 	movabs $0x820c2a,%rdx
  801786:	00 00 00 
  801789:	48 89 c7             	mov    %rax,%rdi
  80178c:	b8 00 00 00 00       	mov    $0x0,%eax
  801791:	49 b8 44 1a 80 00 00 	movabs $0x801a44,%r8
  801798:	00 00 00 
  80179b:	41 ff d0             	callq  *%r8
			break;
  80179e:	e9 92 02 00 00       	jmpq   801a35 <vprintfmt+0x509>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  8017a3:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8017a6:	83 f8 30             	cmp    $0x30,%eax
  8017a9:	73 17                	jae    8017c2 <vprintfmt+0x296>
  8017ab:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8017af:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8017b2:	89 c0                	mov    %eax,%eax
  8017b4:	48 01 d0             	add    %rdx,%rax
  8017b7:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8017ba:	83 c2 08             	add    $0x8,%edx
  8017bd:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8017c0:	eb 0f                	jmp    8017d1 <vprintfmt+0x2a5>
  8017c2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8017c6:	48 89 d0             	mov    %rdx,%rax
  8017c9:	48 83 c2 08          	add    $0x8,%rdx
  8017cd:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8017d1:	4c 8b 20             	mov    (%rax),%r12
  8017d4:	4d 85 e4             	test   %r12,%r12
  8017d7:	75 0a                	jne    8017e3 <vprintfmt+0x2b7>
				p = "(null)";
  8017d9:	49 bc 2d 0c 82 00 00 	movabs $0x820c2d,%r12
  8017e0:	00 00 00 
			if (width > 0 && padc != '-')
  8017e3:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8017e7:	7e 3f                	jle    801828 <vprintfmt+0x2fc>
  8017e9:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  8017ed:	74 39                	je     801828 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  8017ef:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8017f2:	48 98                	cltq   
  8017f4:	48 89 c6             	mov    %rax,%rsi
  8017f7:	4c 89 e7             	mov    %r12,%rdi
  8017fa:	48 b8 f0 1c 80 00 00 	movabs $0x801cf0,%rax
  801801:	00 00 00 
  801804:	ff d0                	callq  *%rax
  801806:	29 45 dc             	sub    %eax,-0x24(%rbp)
  801809:	eb 17                	jmp    801822 <vprintfmt+0x2f6>
					putch(padc, putdat);
  80180b:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  80180f:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  801813:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801817:	48 89 ce             	mov    %rcx,%rsi
  80181a:	89 d7                	mov    %edx,%edi
  80181c:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80181e:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801822:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801826:	7f e3                	jg     80180b <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  801828:	eb 37                	jmp    801861 <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  80182a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  80182e:	74 1e                	je     80184e <vprintfmt+0x322>
  801830:	83 fb 1f             	cmp    $0x1f,%ebx
  801833:	7e 05                	jle    80183a <vprintfmt+0x30e>
  801835:	83 fb 7e             	cmp    $0x7e,%ebx
  801838:	7e 14                	jle    80184e <vprintfmt+0x322>
					putch('?', putdat);
  80183a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80183e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801842:	48 89 d6             	mov    %rdx,%rsi
  801845:	bf 3f 00 00 00       	mov    $0x3f,%edi
  80184a:	ff d0                	callq  *%rax
  80184c:	eb 0f                	jmp    80185d <vprintfmt+0x331>
				else
					putch(ch, putdat);
  80184e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801852:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801856:	48 89 d6             	mov    %rdx,%rsi
  801859:	89 df                	mov    %ebx,%edi
  80185b:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80185d:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801861:	4c 89 e0             	mov    %r12,%rax
  801864:	4c 8d 60 01          	lea    0x1(%rax),%r12
  801868:	0f b6 00             	movzbl (%rax),%eax
  80186b:	0f be d8             	movsbl %al,%ebx
  80186e:	85 db                	test   %ebx,%ebx
  801870:	74 10                	je     801882 <vprintfmt+0x356>
  801872:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801876:	78 b2                	js     80182a <vprintfmt+0x2fe>
  801878:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  80187c:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801880:	79 a8                	jns    80182a <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801882:	eb 16                	jmp    80189a <vprintfmt+0x36e>
				putch(' ', putdat);
  801884:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801888:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80188c:	48 89 d6             	mov    %rdx,%rsi
  80188f:	bf 20 00 00 00       	mov    $0x20,%edi
  801894:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801896:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  80189a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80189e:	7f e4                	jg     801884 <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  8018a0:	e9 90 01 00 00       	jmpq   801a35 <vprintfmt+0x509>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  8018a5:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8018a9:	be 03 00 00 00       	mov    $0x3,%esi
  8018ae:	48 89 c7             	mov    %rax,%rdi
  8018b1:	48 b8 1c 14 80 00 00 	movabs $0x80141c,%rax
  8018b8:	00 00 00 
  8018bb:	ff d0                	callq  *%rax
  8018bd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  8018c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8018c5:	48 85 c0             	test   %rax,%rax
  8018c8:	79 1d                	jns    8018e7 <vprintfmt+0x3bb>
				putch('-', putdat);
  8018ca:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8018ce:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8018d2:	48 89 d6             	mov    %rdx,%rsi
  8018d5:	bf 2d 00 00 00       	mov    $0x2d,%edi
  8018da:	ff d0                	callq  *%rax
				num = -(long long) num;
  8018dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8018e0:	48 f7 d8             	neg    %rax
  8018e3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  8018e7:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  8018ee:	e9 d5 00 00 00       	jmpq   8019c8 <vprintfmt+0x49c>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  8018f3:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8018f7:	be 03 00 00 00       	mov    $0x3,%esi
  8018fc:	48 89 c7             	mov    %rax,%rdi
  8018ff:	48 b8 0c 13 80 00 00 	movabs $0x80130c,%rax
  801906:	00 00 00 
  801909:	ff d0                	callq  *%rax
  80190b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  80190f:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801916:	e9 ad 00 00 00       	jmpq   8019c8 <vprintfmt+0x49c>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getint(&aq, lflag);
  80191b:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80191e:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801922:	89 d6                	mov    %edx,%esi
  801924:	48 89 c7             	mov    %rax,%rdi
  801927:	48 b8 1c 14 80 00 00 	movabs $0x80141c,%rax
  80192e:	00 00 00 
  801931:	ff d0                	callq  *%rax
  801933:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  801937:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  80193e:	e9 85 00 00 00       	jmpq   8019c8 <vprintfmt+0x49c>


			// pointer
		case 'p':
			putch('0', putdat);
  801943:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801947:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80194b:	48 89 d6             	mov    %rdx,%rsi
  80194e:	bf 30 00 00 00       	mov    $0x30,%edi
  801953:	ff d0                	callq  *%rax
			putch('x', putdat);
  801955:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801959:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80195d:	48 89 d6             	mov    %rdx,%rsi
  801960:	bf 78 00 00 00       	mov    $0x78,%edi
  801965:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  801967:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80196a:	83 f8 30             	cmp    $0x30,%eax
  80196d:	73 17                	jae    801986 <vprintfmt+0x45a>
  80196f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  801973:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801976:	89 c0                	mov    %eax,%eax
  801978:	48 01 d0             	add    %rdx,%rax
  80197b:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80197e:	83 c2 08             	add    $0x8,%edx
  801981:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801984:	eb 0f                	jmp    801995 <vprintfmt+0x469>
				(uintptr_t) va_arg(aq, void *);
  801986:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80198a:	48 89 d0             	mov    %rdx,%rax
  80198d:	48 83 c2 08          	add    $0x8,%rdx
  801991:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801995:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801998:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  80199c:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  8019a3:	eb 23                	jmp    8019c8 <vprintfmt+0x49c>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  8019a5:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8019a9:	be 03 00 00 00       	mov    $0x3,%esi
  8019ae:	48 89 c7             	mov    %rax,%rdi
  8019b1:	48 b8 0c 13 80 00 00 	movabs $0x80130c,%rax
  8019b8:	00 00 00 
  8019bb:	ff d0                	callq  *%rax
  8019bd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  8019c1:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  8019c8:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  8019cd:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8019d0:	8b 7d dc             	mov    -0x24(%rbp),%edi
  8019d3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8019d7:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8019db:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8019df:	45 89 c1             	mov    %r8d,%r9d
  8019e2:	41 89 f8             	mov    %edi,%r8d
  8019e5:	48 89 c7             	mov    %rax,%rdi
  8019e8:	48 b8 51 12 80 00 00 	movabs $0x801251,%rax
  8019ef:	00 00 00 
  8019f2:	ff d0                	callq  *%rax
			break;
  8019f4:	eb 3f                	jmp    801a35 <vprintfmt+0x509>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  8019f6:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8019fa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8019fe:	48 89 d6             	mov    %rdx,%rsi
  801a01:	89 df                	mov    %ebx,%edi
  801a03:	ff d0                	callq  *%rax
			break;
  801a05:	eb 2e                	jmp    801a35 <vprintfmt+0x509>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  801a07:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801a0b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801a0f:	48 89 d6             	mov    %rdx,%rsi
  801a12:	bf 25 00 00 00       	mov    $0x25,%edi
  801a17:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  801a19:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801a1e:	eb 05                	jmp    801a25 <vprintfmt+0x4f9>
  801a20:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801a25:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801a29:	48 83 e8 01          	sub    $0x1,%rax
  801a2d:	0f b6 00             	movzbl (%rax),%eax
  801a30:	3c 25                	cmp    $0x25,%al
  801a32:	75 ec                	jne    801a20 <vprintfmt+0x4f4>
				/* do nothing */;
			break;
  801a34:	90                   	nop
		}
	}
  801a35:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801a36:	e9 43 fb ff ff       	jmpq   80157e <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  801a3b:	48 83 c4 60          	add    $0x60,%rsp
  801a3f:	5b                   	pop    %rbx
  801a40:	41 5c                	pop    %r12
  801a42:	5d                   	pop    %rbp
  801a43:	c3                   	retq   

0000000000801a44 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  801a44:	55                   	push   %rbp
  801a45:	48 89 e5             	mov    %rsp,%rbp
  801a48:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  801a4f:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  801a56:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  801a5d:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801a64:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801a6b:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801a72:	84 c0                	test   %al,%al
  801a74:	74 20                	je     801a96 <printfmt+0x52>
  801a76:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801a7a:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801a7e:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801a82:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801a86:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801a8a:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801a8e:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801a92:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801a96:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  801a9d:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  801aa4:	00 00 00 
  801aa7:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  801aae:	00 00 00 
  801ab1:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801ab5:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  801abc:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801ac3:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  801aca:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  801ad1:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  801ad8:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  801adf:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  801ae6:	48 89 c7             	mov    %rax,%rdi
  801ae9:	48 b8 2c 15 80 00 00 	movabs $0x80152c,%rax
  801af0:	00 00 00 
  801af3:	ff d0                	callq  *%rax
	va_end(ap);
}
  801af5:	c9                   	leaveq 
  801af6:	c3                   	retq   

0000000000801af7 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  801af7:	55                   	push   %rbp
  801af8:	48 89 e5             	mov    %rsp,%rbp
  801afb:	48 83 ec 10          	sub    $0x10,%rsp
  801aff:	89 7d fc             	mov    %edi,-0x4(%rbp)
  801b02:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  801b06:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801b0a:	8b 40 10             	mov    0x10(%rax),%eax
  801b0d:	8d 50 01             	lea    0x1(%rax),%edx
  801b10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801b14:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  801b17:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801b1b:	48 8b 10             	mov    (%rax),%rdx
  801b1e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801b22:	48 8b 40 08          	mov    0x8(%rax),%rax
  801b26:	48 39 c2             	cmp    %rax,%rdx
  801b29:	73 17                	jae    801b42 <sprintputch+0x4b>
		*b->buf++ = ch;
  801b2b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801b2f:	48 8b 00             	mov    (%rax),%rax
  801b32:	48 8d 48 01          	lea    0x1(%rax),%rcx
  801b36:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801b3a:	48 89 0a             	mov    %rcx,(%rdx)
  801b3d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  801b40:	88 10                	mov    %dl,(%rax)
}
  801b42:	c9                   	leaveq 
  801b43:	c3                   	retq   

0000000000801b44 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801b44:	55                   	push   %rbp
  801b45:	48 89 e5             	mov    %rsp,%rbp
  801b48:	48 83 ec 50          	sub    $0x50,%rsp
  801b4c:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  801b50:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  801b53:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  801b57:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  801b5b:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  801b5f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  801b63:	48 8b 0a             	mov    (%rdx),%rcx
  801b66:	48 89 08             	mov    %rcx,(%rax)
  801b69:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801b6d:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801b71:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801b75:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  801b79:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801b7d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  801b81:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  801b84:	48 98                	cltq   
  801b86:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  801b8a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801b8e:	48 01 d0             	add    %rdx,%rax
  801b91:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  801b95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  801b9c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  801ba1:	74 06                	je     801ba9 <vsnprintf+0x65>
  801ba3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  801ba7:	7f 07                	jg     801bb0 <vsnprintf+0x6c>
		return -E_INVAL;
  801ba9:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  801bae:	eb 2f                	jmp    801bdf <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  801bb0:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  801bb4:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  801bb8:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  801bbc:	48 89 c6             	mov    %rax,%rsi
  801bbf:	48 bf f7 1a 80 00 00 	movabs $0x801af7,%rdi
  801bc6:	00 00 00 
  801bc9:	48 b8 2c 15 80 00 00 	movabs $0x80152c,%rax
  801bd0:	00 00 00 
  801bd3:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  801bd5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  801bd9:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  801bdc:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  801bdf:	c9                   	leaveq 
  801be0:	c3                   	retq   

0000000000801be1 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801be1:	55                   	push   %rbp
  801be2:	48 89 e5             	mov    %rsp,%rbp
  801be5:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  801bec:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  801bf3:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  801bf9:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801c00:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801c07:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801c0e:	84 c0                	test   %al,%al
  801c10:	74 20                	je     801c32 <snprintf+0x51>
  801c12:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801c16:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801c1a:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801c1e:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801c22:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801c26:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801c2a:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801c2e:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801c32:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  801c39:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  801c40:	00 00 00 
  801c43:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  801c4a:	00 00 00 
  801c4d:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801c51:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  801c58:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801c5f:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  801c66:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  801c6d:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  801c74:	48 8b 0a             	mov    (%rdx),%rcx
  801c77:	48 89 08             	mov    %rcx,(%rax)
  801c7a:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801c7e:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801c82:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801c86:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  801c8a:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  801c91:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  801c98:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  801c9e:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801ca5:	48 89 c7             	mov    %rax,%rdi
  801ca8:	48 b8 44 1b 80 00 00 	movabs $0x801b44,%rax
  801caf:	00 00 00 
  801cb2:	ff d0                	callq  *%rax
  801cb4:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  801cba:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  801cc0:	c9                   	leaveq 
  801cc1:	c3                   	retq   

0000000000801cc2 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  801cc2:	55                   	push   %rbp
  801cc3:	48 89 e5             	mov    %rsp,%rbp
  801cc6:	48 83 ec 18          	sub    $0x18,%rsp
  801cca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  801cce:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801cd5:	eb 09                	jmp    801ce0 <strlen+0x1e>
		n++;
  801cd7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  801cdb:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801ce0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ce4:	0f b6 00             	movzbl (%rax),%eax
  801ce7:	84 c0                	test   %al,%al
  801ce9:	75 ec                	jne    801cd7 <strlen+0x15>
		n++;
	return n;
  801ceb:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801cee:	c9                   	leaveq 
  801cef:	c3                   	retq   

0000000000801cf0 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  801cf0:	55                   	push   %rbp
  801cf1:	48 89 e5             	mov    %rsp,%rbp
  801cf4:	48 83 ec 20          	sub    $0x20,%rsp
  801cf8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801cfc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801d00:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801d07:	eb 0e                	jmp    801d17 <strnlen+0x27>
		n++;
  801d09:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801d0d:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801d12:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  801d17:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  801d1c:	74 0b                	je     801d29 <strnlen+0x39>
  801d1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d22:	0f b6 00             	movzbl (%rax),%eax
  801d25:	84 c0                	test   %al,%al
  801d27:	75 e0                	jne    801d09 <strnlen+0x19>
		n++;
	return n;
  801d29:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801d2c:	c9                   	leaveq 
  801d2d:	c3                   	retq   

0000000000801d2e <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  801d2e:	55                   	push   %rbp
  801d2f:	48 89 e5             	mov    %rsp,%rbp
  801d32:	48 83 ec 20          	sub    $0x20,%rsp
  801d36:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801d3a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  801d3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d42:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  801d46:	90                   	nop
  801d47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d4b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801d4f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801d53:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801d57:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  801d5b:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  801d5f:	0f b6 12             	movzbl (%rdx),%edx
  801d62:	88 10                	mov    %dl,(%rax)
  801d64:	0f b6 00             	movzbl (%rax),%eax
  801d67:	84 c0                	test   %al,%al
  801d69:	75 dc                	jne    801d47 <strcpy+0x19>
		/* do nothing */;
	return ret;
  801d6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801d6f:	c9                   	leaveq 
  801d70:	c3                   	retq   

0000000000801d71 <strcat>:

char *
strcat(char *dst, const char *src)
{
  801d71:	55                   	push   %rbp
  801d72:	48 89 e5             	mov    %rsp,%rbp
  801d75:	48 83 ec 20          	sub    $0x20,%rsp
  801d79:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801d7d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  801d81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d85:	48 89 c7             	mov    %rax,%rdi
  801d88:	48 b8 c2 1c 80 00 00 	movabs $0x801cc2,%rax
  801d8f:	00 00 00 
  801d92:	ff d0                	callq  *%rax
  801d94:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  801d97:	8b 45 fc             	mov    -0x4(%rbp),%eax
  801d9a:	48 63 d0             	movslq %eax,%rdx
  801d9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801da1:	48 01 c2             	add    %rax,%rdx
  801da4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801da8:	48 89 c6             	mov    %rax,%rsi
  801dab:	48 89 d7             	mov    %rdx,%rdi
  801dae:	48 b8 2e 1d 80 00 00 	movabs $0x801d2e,%rax
  801db5:	00 00 00 
  801db8:	ff d0                	callq  *%rax
	return dst;
  801dba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  801dbe:	c9                   	leaveq 
  801dbf:	c3                   	retq   

0000000000801dc0 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  801dc0:	55                   	push   %rbp
  801dc1:	48 89 e5             	mov    %rsp,%rbp
  801dc4:	48 83 ec 28          	sub    $0x28,%rsp
  801dc8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801dcc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801dd0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  801dd4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801dd8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  801ddc:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  801de3:	00 
  801de4:	eb 2a                	jmp    801e10 <strncpy+0x50>
		*dst++ = *src;
  801de6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801dea:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801dee:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801df2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801df6:	0f b6 12             	movzbl (%rdx),%edx
  801df9:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  801dfb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801dff:	0f b6 00             	movzbl (%rax),%eax
  801e02:	84 c0                	test   %al,%al
  801e04:	74 05                	je     801e0b <strncpy+0x4b>
			src++;
  801e06:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801e0b:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801e10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801e14:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  801e18:	72 cc                	jb     801de6 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  801e1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  801e1e:	c9                   	leaveq 
  801e1f:	c3                   	retq   

0000000000801e20 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801e20:	55                   	push   %rbp
  801e21:	48 89 e5             	mov    %rsp,%rbp
  801e24:	48 83 ec 28          	sub    $0x28,%rsp
  801e28:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801e2c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801e30:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  801e34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801e38:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  801e3c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  801e41:	74 3d                	je     801e80 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  801e43:	eb 1d                	jmp    801e62 <strlcpy+0x42>
			*dst++ = *src++;
  801e45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801e49:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801e4d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801e51:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801e55:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  801e59:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  801e5d:	0f b6 12             	movzbl (%rdx),%edx
  801e60:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  801e62:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  801e67:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  801e6c:	74 0b                	je     801e79 <strlcpy+0x59>
  801e6e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801e72:	0f b6 00             	movzbl (%rax),%eax
  801e75:	84 c0                	test   %al,%al
  801e77:	75 cc                	jne    801e45 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  801e79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801e7d:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  801e80:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801e84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801e88:	48 29 c2             	sub    %rax,%rdx
  801e8b:	48 89 d0             	mov    %rdx,%rax
}
  801e8e:	c9                   	leaveq 
  801e8f:	c3                   	retq   

0000000000801e90 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  801e90:	55                   	push   %rbp
  801e91:	48 89 e5             	mov    %rsp,%rbp
  801e94:	48 83 ec 10          	sub    $0x10,%rsp
  801e98:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801e9c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  801ea0:	eb 0a                	jmp    801eac <strcmp+0x1c>
		p++, q++;
  801ea2:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801ea7:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  801eac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801eb0:	0f b6 00             	movzbl (%rax),%eax
  801eb3:	84 c0                	test   %al,%al
  801eb5:	74 12                	je     801ec9 <strcmp+0x39>
  801eb7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801ebb:	0f b6 10             	movzbl (%rax),%edx
  801ebe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801ec2:	0f b6 00             	movzbl (%rax),%eax
  801ec5:	38 c2                	cmp    %al,%dl
  801ec7:	74 d9                	je     801ea2 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  801ec9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801ecd:	0f b6 00             	movzbl (%rax),%eax
  801ed0:	0f b6 d0             	movzbl %al,%edx
  801ed3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801ed7:	0f b6 00             	movzbl (%rax),%eax
  801eda:	0f b6 c0             	movzbl %al,%eax
  801edd:	29 c2                	sub    %eax,%edx
  801edf:	89 d0                	mov    %edx,%eax
}
  801ee1:	c9                   	leaveq 
  801ee2:	c3                   	retq   

0000000000801ee3 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  801ee3:	55                   	push   %rbp
  801ee4:	48 89 e5             	mov    %rsp,%rbp
  801ee7:	48 83 ec 18          	sub    $0x18,%rsp
  801eeb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801eef:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  801ef3:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  801ef7:	eb 0f                	jmp    801f08 <strncmp+0x25>
		n--, p++, q++;
  801ef9:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  801efe:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801f03:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  801f08:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  801f0d:	74 1d                	je     801f2c <strncmp+0x49>
  801f0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f13:	0f b6 00             	movzbl (%rax),%eax
  801f16:	84 c0                	test   %al,%al
  801f18:	74 12                	je     801f2c <strncmp+0x49>
  801f1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f1e:	0f b6 10             	movzbl (%rax),%edx
  801f21:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801f25:	0f b6 00             	movzbl (%rax),%eax
  801f28:	38 c2                	cmp    %al,%dl
  801f2a:	74 cd                	je     801ef9 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  801f2c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  801f31:	75 07                	jne    801f3a <strncmp+0x57>
		return 0;
  801f33:	b8 00 00 00 00       	mov    $0x0,%eax
  801f38:	eb 18                	jmp    801f52 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  801f3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f3e:	0f b6 00             	movzbl (%rax),%eax
  801f41:	0f b6 d0             	movzbl %al,%edx
  801f44:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801f48:	0f b6 00             	movzbl (%rax),%eax
  801f4b:	0f b6 c0             	movzbl %al,%eax
  801f4e:	29 c2                	sub    %eax,%edx
  801f50:	89 d0                	mov    %edx,%eax
}
  801f52:	c9                   	leaveq 
  801f53:	c3                   	retq   

0000000000801f54 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  801f54:	55                   	push   %rbp
  801f55:	48 89 e5             	mov    %rsp,%rbp
  801f58:	48 83 ec 0c          	sub    $0xc,%rsp
  801f5c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801f60:	89 f0                	mov    %esi,%eax
  801f62:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  801f65:	eb 17                	jmp    801f7e <strchr+0x2a>
		if (*s == c)
  801f67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f6b:	0f b6 00             	movzbl (%rax),%eax
  801f6e:	3a 45 f4             	cmp    -0xc(%rbp),%al
  801f71:	75 06                	jne    801f79 <strchr+0x25>
			return (char *) s;
  801f73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f77:	eb 15                	jmp    801f8e <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  801f79:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801f7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f82:	0f b6 00             	movzbl (%rax),%eax
  801f85:	84 c0                	test   %al,%al
  801f87:	75 de                	jne    801f67 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  801f89:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801f8e:	c9                   	leaveq 
  801f8f:	c3                   	retq   

0000000000801f90 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  801f90:	55                   	push   %rbp
  801f91:	48 89 e5             	mov    %rsp,%rbp
  801f94:	48 83 ec 0c          	sub    $0xc,%rsp
  801f98:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801f9c:	89 f0                	mov    %esi,%eax
  801f9e:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  801fa1:	eb 13                	jmp    801fb6 <strfind+0x26>
		if (*s == c)
  801fa3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801fa7:	0f b6 00             	movzbl (%rax),%eax
  801faa:	3a 45 f4             	cmp    -0xc(%rbp),%al
  801fad:	75 02                	jne    801fb1 <strfind+0x21>
			break;
  801faf:	eb 10                	jmp    801fc1 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  801fb1:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801fb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801fba:	0f b6 00             	movzbl (%rax),%eax
  801fbd:	84 c0                	test   %al,%al
  801fbf:	75 e2                	jne    801fa3 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  801fc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801fc5:	c9                   	leaveq 
  801fc6:	c3                   	retq   

0000000000801fc7 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  801fc7:	55                   	push   %rbp
  801fc8:	48 89 e5             	mov    %rsp,%rbp
  801fcb:	48 83 ec 18          	sub    $0x18,%rsp
  801fcf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801fd3:	89 75 f4             	mov    %esi,-0xc(%rbp)
  801fd6:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  801fda:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  801fdf:	75 06                	jne    801fe7 <memset+0x20>
		return v;
  801fe1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801fe5:	eb 69                	jmp    802050 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  801fe7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801feb:	83 e0 03             	and    $0x3,%eax
  801fee:	48 85 c0             	test   %rax,%rax
  801ff1:	75 48                	jne    80203b <memset+0x74>
  801ff3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ff7:	83 e0 03             	and    $0x3,%eax
  801ffa:	48 85 c0             	test   %rax,%rax
  801ffd:	75 3c                	jne    80203b <memset+0x74>
		c &= 0xFF;
  801fff:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  802006:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802009:	c1 e0 18             	shl    $0x18,%eax
  80200c:	89 c2                	mov    %eax,%edx
  80200e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802011:	c1 e0 10             	shl    $0x10,%eax
  802014:	09 c2                	or     %eax,%edx
  802016:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802019:	c1 e0 08             	shl    $0x8,%eax
  80201c:	09 d0                	or     %edx,%eax
  80201e:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  802021:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802025:	48 c1 e8 02          	shr    $0x2,%rax
  802029:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  80202c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802030:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802033:	48 89 d7             	mov    %rdx,%rdi
  802036:	fc                   	cld    
  802037:	f3 ab                	rep stos %eax,%es:(%rdi)
  802039:	eb 11                	jmp    80204c <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80203b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80203f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802042:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  802046:	48 89 d7             	mov    %rdx,%rdi
  802049:	fc                   	cld    
  80204a:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  80204c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  802050:	c9                   	leaveq 
  802051:	c3                   	retq   

0000000000802052 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  802052:	55                   	push   %rbp
  802053:	48 89 e5             	mov    %rsp,%rbp
  802056:	48 83 ec 28          	sub    $0x28,%rsp
  80205a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80205e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  802062:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  802066:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80206a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  80206e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802072:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  802076:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80207a:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80207e:	0f 83 88 00 00 00    	jae    80210c <memmove+0xba>
  802084:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802088:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80208c:	48 01 d0             	add    %rdx,%rax
  80208f:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  802093:	76 77                	jbe    80210c <memmove+0xba>
		s += n;
  802095:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802099:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  80209d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8020a1:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8020a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020a9:	83 e0 03             	and    $0x3,%eax
  8020ac:	48 85 c0             	test   %rax,%rax
  8020af:	75 3b                	jne    8020ec <memmove+0x9a>
  8020b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020b5:	83 e0 03             	and    $0x3,%eax
  8020b8:	48 85 c0             	test   %rax,%rax
  8020bb:	75 2f                	jne    8020ec <memmove+0x9a>
  8020bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8020c1:	83 e0 03             	and    $0x3,%eax
  8020c4:	48 85 c0             	test   %rax,%rax
  8020c7:	75 23                	jne    8020ec <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  8020c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020cd:	48 83 e8 04          	sub    $0x4,%rax
  8020d1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8020d5:	48 83 ea 04          	sub    $0x4,%rdx
  8020d9:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8020dd:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  8020e1:	48 89 c7             	mov    %rax,%rdi
  8020e4:	48 89 d6             	mov    %rdx,%rsi
  8020e7:	fd                   	std    
  8020e8:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  8020ea:	eb 1d                	jmp    802109 <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  8020ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020f0:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8020f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020f8:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  8020fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802100:	48 89 d7             	mov    %rdx,%rdi
  802103:	48 89 c1             	mov    %rax,%rcx
  802106:	fd                   	std    
  802107:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  802109:	fc                   	cld    
  80210a:	eb 57                	jmp    802163 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  80210c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802110:	83 e0 03             	and    $0x3,%eax
  802113:	48 85 c0             	test   %rax,%rax
  802116:	75 36                	jne    80214e <memmove+0xfc>
  802118:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80211c:	83 e0 03             	and    $0x3,%eax
  80211f:	48 85 c0             	test   %rax,%rax
  802122:	75 2a                	jne    80214e <memmove+0xfc>
  802124:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802128:	83 e0 03             	and    $0x3,%eax
  80212b:	48 85 c0             	test   %rax,%rax
  80212e:	75 1e                	jne    80214e <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  802130:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802134:	48 c1 e8 02          	shr    $0x2,%rax
  802138:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  80213b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80213f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802143:	48 89 c7             	mov    %rax,%rdi
  802146:	48 89 d6             	mov    %rdx,%rsi
  802149:	fc                   	cld    
  80214a:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  80214c:	eb 15                	jmp    802163 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80214e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802152:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802156:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80215a:	48 89 c7             	mov    %rax,%rdi
  80215d:	48 89 d6             	mov    %rdx,%rsi
  802160:	fc                   	cld    
  802161:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  802163:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  802167:	c9                   	leaveq 
  802168:	c3                   	retq   

0000000000802169 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  802169:	55                   	push   %rbp
  80216a:	48 89 e5             	mov    %rsp,%rbp
  80216d:	48 83 ec 18          	sub    $0x18,%rsp
  802171:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802175:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802179:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  80217d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802181:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802185:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802189:	48 89 ce             	mov    %rcx,%rsi
  80218c:	48 89 c7             	mov    %rax,%rdi
  80218f:	48 b8 52 20 80 00 00 	movabs $0x802052,%rax
  802196:	00 00 00 
  802199:	ff d0                	callq  *%rax
}
  80219b:	c9                   	leaveq 
  80219c:	c3                   	retq   

000000000080219d <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80219d:	55                   	push   %rbp
  80219e:	48 89 e5             	mov    %rsp,%rbp
  8021a1:	48 83 ec 28          	sub    $0x28,%rsp
  8021a5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8021a9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8021ad:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  8021b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8021b5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  8021b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8021bd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  8021c1:	eb 36                	jmp    8021f9 <memcmp+0x5c>
		if (*s1 != *s2)
  8021c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8021c7:	0f b6 10             	movzbl (%rax),%edx
  8021ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8021ce:	0f b6 00             	movzbl (%rax),%eax
  8021d1:	38 c2                	cmp    %al,%dl
  8021d3:	74 1a                	je     8021ef <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  8021d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8021d9:	0f b6 00             	movzbl (%rax),%eax
  8021dc:	0f b6 d0             	movzbl %al,%edx
  8021df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8021e3:	0f b6 00             	movzbl (%rax),%eax
  8021e6:	0f b6 c0             	movzbl %al,%eax
  8021e9:	29 c2                	sub    %eax,%edx
  8021eb:	89 d0                	mov    %edx,%eax
  8021ed:	eb 20                	jmp    80220f <memcmp+0x72>
		s1++, s2++;
  8021ef:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8021f4:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8021f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8021fd:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  802201:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  802205:	48 85 c0             	test   %rax,%rax
  802208:	75 b9                	jne    8021c3 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80220a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80220f:	c9                   	leaveq 
  802210:	c3                   	retq   

0000000000802211 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  802211:	55                   	push   %rbp
  802212:	48 89 e5             	mov    %rsp,%rbp
  802215:	48 83 ec 28          	sub    $0x28,%rsp
  802219:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80221d:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  802220:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  802224:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802228:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80222c:	48 01 d0             	add    %rdx,%rax
  80222f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  802233:	eb 15                	jmp    80224a <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  802235:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802239:	0f b6 10             	movzbl (%rax),%edx
  80223c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80223f:	38 c2                	cmp    %al,%dl
  802241:	75 02                	jne    802245 <memfind+0x34>
			break;
  802243:	eb 0f                	jmp    802254 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  802245:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80224a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80224e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  802252:	72 e1                	jb     802235 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  802254:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  802258:	c9                   	leaveq 
  802259:	c3                   	retq   

000000000080225a <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80225a:	55                   	push   %rbp
  80225b:	48 89 e5             	mov    %rsp,%rbp
  80225e:	48 83 ec 34          	sub    $0x34,%rsp
  802262:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  802266:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80226a:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  80226d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  802274:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80227b:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80227c:	eb 05                	jmp    802283 <strtol+0x29>
		s++;
  80227e:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  802283:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802287:	0f b6 00             	movzbl (%rax),%eax
  80228a:	3c 20                	cmp    $0x20,%al
  80228c:	74 f0                	je     80227e <strtol+0x24>
  80228e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802292:	0f b6 00             	movzbl (%rax),%eax
  802295:	3c 09                	cmp    $0x9,%al
  802297:	74 e5                	je     80227e <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  802299:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80229d:	0f b6 00             	movzbl (%rax),%eax
  8022a0:	3c 2b                	cmp    $0x2b,%al
  8022a2:	75 07                	jne    8022ab <strtol+0x51>
		s++;
  8022a4:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8022a9:	eb 17                	jmp    8022c2 <strtol+0x68>
	else if (*s == '-')
  8022ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022af:	0f b6 00             	movzbl (%rax),%eax
  8022b2:	3c 2d                	cmp    $0x2d,%al
  8022b4:	75 0c                	jne    8022c2 <strtol+0x68>
		s++, neg = 1;
  8022b6:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8022bb:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  8022c2:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8022c6:	74 06                	je     8022ce <strtol+0x74>
  8022c8:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  8022cc:	75 28                	jne    8022f6 <strtol+0x9c>
  8022ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022d2:	0f b6 00             	movzbl (%rax),%eax
  8022d5:	3c 30                	cmp    $0x30,%al
  8022d7:	75 1d                	jne    8022f6 <strtol+0x9c>
  8022d9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022dd:	48 83 c0 01          	add    $0x1,%rax
  8022e1:	0f b6 00             	movzbl (%rax),%eax
  8022e4:	3c 78                	cmp    $0x78,%al
  8022e6:	75 0e                	jne    8022f6 <strtol+0x9c>
		s += 2, base = 16;
  8022e8:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  8022ed:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  8022f4:	eb 2c                	jmp    802322 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  8022f6:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8022fa:	75 19                	jne    802315 <strtol+0xbb>
  8022fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802300:	0f b6 00             	movzbl (%rax),%eax
  802303:	3c 30                	cmp    $0x30,%al
  802305:	75 0e                	jne    802315 <strtol+0xbb>
		s++, base = 8;
  802307:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  80230c:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  802313:	eb 0d                	jmp    802322 <strtol+0xc8>
	else if (base == 0)
  802315:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  802319:	75 07                	jne    802322 <strtol+0xc8>
		base = 10;
  80231b:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  802322:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802326:	0f b6 00             	movzbl (%rax),%eax
  802329:	3c 2f                	cmp    $0x2f,%al
  80232b:	7e 1d                	jle    80234a <strtol+0xf0>
  80232d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802331:	0f b6 00             	movzbl (%rax),%eax
  802334:	3c 39                	cmp    $0x39,%al
  802336:	7f 12                	jg     80234a <strtol+0xf0>
			dig = *s - '0';
  802338:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80233c:	0f b6 00             	movzbl (%rax),%eax
  80233f:	0f be c0             	movsbl %al,%eax
  802342:	83 e8 30             	sub    $0x30,%eax
  802345:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802348:	eb 4e                	jmp    802398 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  80234a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80234e:	0f b6 00             	movzbl (%rax),%eax
  802351:	3c 60                	cmp    $0x60,%al
  802353:	7e 1d                	jle    802372 <strtol+0x118>
  802355:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802359:	0f b6 00             	movzbl (%rax),%eax
  80235c:	3c 7a                	cmp    $0x7a,%al
  80235e:	7f 12                	jg     802372 <strtol+0x118>
			dig = *s - 'a' + 10;
  802360:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802364:	0f b6 00             	movzbl (%rax),%eax
  802367:	0f be c0             	movsbl %al,%eax
  80236a:	83 e8 57             	sub    $0x57,%eax
  80236d:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802370:	eb 26                	jmp    802398 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  802372:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802376:	0f b6 00             	movzbl (%rax),%eax
  802379:	3c 40                	cmp    $0x40,%al
  80237b:	7e 48                	jle    8023c5 <strtol+0x16b>
  80237d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802381:	0f b6 00             	movzbl (%rax),%eax
  802384:	3c 5a                	cmp    $0x5a,%al
  802386:	7f 3d                	jg     8023c5 <strtol+0x16b>
			dig = *s - 'A' + 10;
  802388:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80238c:	0f b6 00             	movzbl (%rax),%eax
  80238f:	0f be c0             	movsbl %al,%eax
  802392:	83 e8 37             	sub    $0x37,%eax
  802395:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  802398:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80239b:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  80239e:	7c 02                	jl     8023a2 <strtol+0x148>
			break;
  8023a0:	eb 23                	jmp    8023c5 <strtol+0x16b>
		s++, val = (val * base) + dig;
  8023a2:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8023a7:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8023aa:	48 98                	cltq   
  8023ac:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  8023b1:	48 89 c2             	mov    %rax,%rdx
  8023b4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8023b7:	48 98                	cltq   
  8023b9:	48 01 d0             	add    %rdx,%rax
  8023bc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  8023c0:	e9 5d ff ff ff       	jmpq   802322 <strtol+0xc8>

	if (endptr)
  8023c5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8023ca:	74 0b                	je     8023d7 <strtol+0x17d>
		*endptr = (char *) s;
  8023cc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8023d0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8023d4:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  8023d7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8023db:	74 09                	je     8023e6 <strtol+0x18c>
  8023dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8023e1:	48 f7 d8             	neg    %rax
  8023e4:	eb 04                	jmp    8023ea <strtol+0x190>
  8023e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8023ea:	c9                   	leaveq 
  8023eb:	c3                   	retq   

00000000008023ec <strstr>:

char * strstr(const char *in, const char *str)
{
  8023ec:	55                   	push   %rbp
  8023ed:	48 89 e5             	mov    %rsp,%rbp
  8023f0:	48 83 ec 30          	sub    $0x30,%rsp
  8023f4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8023f8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  8023fc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  802400:	48 8d 50 01          	lea    0x1(%rax),%rdx
  802404:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  802408:	0f b6 00             	movzbl (%rax),%eax
  80240b:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  80240e:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  802412:	75 06                	jne    80241a <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  802414:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802418:	eb 6b                	jmp    802485 <strstr+0x99>

	len = strlen(str);
  80241a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80241e:	48 89 c7             	mov    %rax,%rdi
  802421:	48 b8 c2 1c 80 00 00 	movabs $0x801cc2,%rax
  802428:	00 00 00 
  80242b:	ff d0                	callq  *%rax
  80242d:	48 98                	cltq   
  80242f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  802433:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802437:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80243b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80243f:	0f b6 00             	movzbl (%rax),%eax
  802442:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  802445:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  802449:	75 07                	jne    802452 <strstr+0x66>
				return (char *) 0;
  80244b:	b8 00 00 00 00       	mov    $0x0,%eax
  802450:	eb 33                	jmp    802485 <strstr+0x99>
		} while (sc != c);
  802452:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  802456:	3a 45 ff             	cmp    -0x1(%rbp),%al
  802459:	75 d8                	jne    802433 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  80245b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80245f:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  802463:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802467:	48 89 ce             	mov    %rcx,%rsi
  80246a:	48 89 c7             	mov    %rax,%rdi
  80246d:	48 b8 e3 1e 80 00 00 	movabs $0x801ee3,%rax
  802474:	00 00 00 
  802477:	ff d0                	callq  *%rax
  802479:	85 c0                	test   %eax,%eax
  80247b:	75 b6                	jne    802433 <strstr+0x47>

	return (char *) (in - 1);
  80247d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802481:	48 83 e8 01          	sub    $0x1,%rax
}
  802485:	c9                   	leaveq 
  802486:	c3                   	retq   

0000000000802487 <syscall>:
#include <inc/syscall.h>
#include <inc/lib.h>

static inline int64_t
syscall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  802487:	55                   	push   %rbp
  802488:	48 89 e5             	mov    %rsp,%rbp
  80248b:	53                   	push   %rbx
  80248c:	48 83 ec 48          	sub    $0x48,%rsp
  802490:	89 7d dc             	mov    %edi,-0x24(%rbp)
  802493:	89 75 d8             	mov    %esi,-0x28(%rbp)
  802496:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80249a:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  80249e:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  8024a2:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8024a6:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8024a9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8024ad:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8024b1:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  8024b5:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8024b9:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8024bd:	4c 89 c3             	mov    %r8,%rbx
  8024c0:	cd 30                	int    $0x30
  8024c2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  8024c6:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8024ca:	74 3e                	je     80250a <syscall+0x83>
  8024cc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8024d1:	7e 37                	jle    80250a <syscall+0x83>
		panic("syscall %d returned %d (> 0)", num, ret);
  8024d3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8024d7:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8024da:	49 89 d0             	mov    %rdx,%r8
  8024dd:	89 c1                	mov    %eax,%ecx
  8024df:	48 ba e8 0e 82 00 00 	movabs $0x820ee8,%rdx
  8024e6:	00 00 00 
  8024e9:	be 23 00 00 00       	mov    $0x23,%esi
  8024ee:	48 bf 05 0f 82 00 00 	movabs $0x820f05,%rdi
  8024f5:	00 00 00 
  8024f8:	b8 00 00 00 00       	mov    $0x0,%eax
  8024fd:	49 b9 40 0f 80 00 00 	movabs $0x800f40,%r9
  802504:	00 00 00 
  802507:	41 ff d1             	callq  *%r9

	return ret;
  80250a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80250e:	48 83 c4 48          	add    $0x48,%rsp
  802512:	5b                   	pop    %rbx
  802513:	5d                   	pop    %rbp
  802514:	c3                   	retq   

0000000000802515 <sys_cputs>:

void
sys_cputs(const char *s, size_t len)
{
  802515:	55                   	push   %rbp
  802516:	48 89 e5             	mov    %rsp,%rbp
  802519:	48 83 ec 20          	sub    $0x20,%rsp
  80251d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802521:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	syscall(SYS_cputs, 0, (uint64_t)s, len, 0, 0, 0);
  802525:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802529:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80252d:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802534:	00 
  802535:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80253b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802541:	48 89 d1             	mov    %rdx,%rcx
  802544:	48 89 c2             	mov    %rax,%rdx
  802547:	be 00 00 00 00       	mov    $0x0,%esi
  80254c:	bf 00 00 00 00       	mov    $0x0,%edi
  802551:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  802558:	00 00 00 
  80255b:	ff d0                	callq  *%rax
}
  80255d:	c9                   	leaveq 
  80255e:	c3                   	retq   

000000000080255f <sys_cgetc>:

int
sys_cgetc(void)
{
  80255f:	55                   	push   %rbp
  802560:	48 89 e5             	mov    %rsp,%rbp
  802563:	48 83 ec 10          	sub    $0x10,%rsp
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
  802567:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80256e:	00 
  80256f:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802575:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80257b:	b9 00 00 00 00       	mov    $0x0,%ecx
  802580:	ba 00 00 00 00       	mov    $0x0,%edx
  802585:	be 00 00 00 00       	mov    $0x0,%esi
  80258a:	bf 01 00 00 00       	mov    $0x1,%edi
  80258f:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  802596:	00 00 00 
  802599:	ff d0                	callq  *%rax
}
  80259b:	c9                   	leaveq 
  80259c:	c3                   	retq   

000000000080259d <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80259d:	55                   	push   %rbp
  80259e:	48 89 e5             	mov    %rsp,%rbp
  8025a1:	48 83 ec 10          	sub    $0x10,%rsp
  8025a5:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
  8025a8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8025ab:	48 98                	cltq   
  8025ad:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8025b4:	00 
  8025b5:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8025bb:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8025c1:	b9 00 00 00 00       	mov    $0x0,%ecx
  8025c6:	48 89 c2             	mov    %rax,%rdx
  8025c9:	be 01 00 00 00       	mov    $0x1,%esi
  8025ce:	bf 03 00 00 00       	mov    $0x3,%edi
  8025d3:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  8025da:	00 00 00 
  8025dd:	ff d0                	callq  *%rax
}
  8025df:	c9                   	leaveq 
  8025e0:	c3                   	retq   

00000000008025e1 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  8025e1:	55                   	push   %rbp
  8025e2:	48 89 e5             	mov    %rsp,%rbp
  8025e5:	48 83 ec 10          	sub    $0x10,%rsp
	return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
  8025e9:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8025f0:	00 
  8025f1:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8025f7:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8025fd:	b9 00 00 00 00       	mov    $0x0,%ecx
  802602:	ba 00 00 00 00       	mov    $0x0,%edx
  802607:	be 00 00 00 00       	mov    $0x0,%esi
  80260c:	bf 02 00 00 00       	mov    $0x2,%edi
  802611:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  802618:	00 00 00 
  80261b:	ff d0                	callq  *%rax
}
  80261d:	c9                   	leaveq 
  80261e:	c3                   	retq   

000000000080261f <sys_yield>:

void
sys_yield(void)
{
  80261f:	55                   	push   %rbp
  802620:	48 89 e5             	mov    %rsp,%rbp
  802623:	48 83 ec 10          	sub    $0x10,%rsp
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
  802627:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80262e:	00 
  80262f:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802635:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80263b:	b9 00 00 00 00       	mov    $0x0,%ecx
  802640:	ba 00 00 00 00       	mov    $0x0,%edx
  802645:	be 00 00 00 00       	mov    $0x0,%esi
  80264a:	bf 0b 00 00 00       	mov    $0xb,%edi
  80264f:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  802656:	00 00 00 
  802659:	ff d0                	callq  *%rax
}
  80265b:	c9                   	leaveq 
  80265c:	c3                   	retq   

000000000080265d <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80265d:	55                   	push   %rbp
  80265e:	48 89 e5             	mov    %rsp,%rbp
  802661:	48 83 ec 20          	sub    $0x20,%rsp
  802665:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802668:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80266c:	89 55 f8             	mov    %edx,-0x8(%rbp)
	return syscall(SYS_page_alloc, 1, envid, (uint64_t) va, perm, 0, 0);
  80266f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802672:	48 63 c8             	movslq %eax,%rcx
  802675:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802679:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80267c:	48 98                	cltq   
  80267e:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802685:	00 
  802686:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80268c:	49 89 c8             	mov    %rcx,%r8
  80268f:	48 89 d1             	mov    %rdx,%rcx
  802692:	48 89 c2             	mov    %rax,%rdx
  802695:	be 01 00 00 00       	mov    $0x1,%esi
  80269a:	bf 04 00 00 00       	mov    $0x4,%edi
  80269f:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  8026a6:	00 00 00 
  8026a9:	ff d0                	callq  *%rax
}
  8026ab:	c9                   	leaveq 
  8026ac:	c3                   	retq   

00000000008026ad <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  8026ad:	55                   	push   %rbp
  8026ae:	48 89 e5             	mov    %rsp,%rbp
  8026b1:	48 83 ec 30          	sub    $0x30,%rsp
  8026b5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8026b8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8026bc:	89 55 f8             	mov    %edx,-0x8(%rbp)
  8026bf:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  8026c3:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_page_map, 1, srcenv, (uint64_t) srcva, dstenv, (uint64_t) dstva, perm);
  8026c7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8026ca:	48 63 c8             	movslq %eax,%rcx
  8026cd:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8026d1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8026d4:	48 63 f0             	movslq %eax,%rsi
  8026d7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8026db:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8026de:	48 98                	cltq   
  8026e0:	48 89 0c 24          	mov    %rcx,(%rsp)
  8026e4:	49 89 f9             	mov    %rdi,%r9
  8026e7:	49 89 f0             	mov    %rsi,%r8
  8026ea:	48 89 d1             	mov    %rdx,%rcx
  8026ed:	48 89 c2             	mov    %rax,%rdx
  8026f0:	be 01 00 00 00       	mov    $0x1,%esi
  8026f5:	bf 05 00 00 00       	mov    $0x5,%edi
  8026fa:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  802701:	00 00 00 
  802704:	ff d0                	callq  *%rax
}
  802706:	c9                   	leaveq 
  802707:	c3                   	retq   

0000000000802708 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  802708:	55                   	push   %rbp
  802709:	48 89 e5             	mov    %rsp,%rbp
  80270c:	48 83 ec 20          	sub    $0x20,%rsp
  802710:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802713:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_page_unmap, 1, envid, (uint64_t) va, 0, 0, 0);
  802717:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80271b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80271e:	48 98                	cltq   
  802720:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802727:	00 
  802728:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80272e:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802734:	48 89 d1             	mov    %rdx,%rcx
  802737:	48 89 c2             	mov    %rax,%rdx
  80273a:	be 01 00 00 00       	mov    $0x1,%esi
  80273f:	bf 06 00 00 00       	mov    $0x6,%edi
  802744:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  80274b:	00 00 00 
  80274e:	ff d0                	callq  *%rax
}
  802750:	c9                   	leaveq 
  802751:	c3                   	retq   

0000000000802752 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  802752:	55                   	push   %rbp
  802753:	48 89 e5             	mov    %rsp,%rbp
  802756:	48 83 ec 10          	sub    $0x10,%rsp
  80275a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80275d:	89 75 f8             	mov    %esi,-0x8(%rbp)
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
  802760:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802763:	48 63 d0             	movslq %eax,%rdx
  802766:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802769:	48 98                	cltq   
  80276b:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802772:	00 
  802773:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802779:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80277f:	48 89 d1             	mov    %rdx,%rcx
  802782:	48 89 c2             	mov    %rax,%rdx
  802785:	be 01 00 00 00       	mov    $0x1,%esi
  80278a:	bf 08 00 00 00       	mov    $0x8,%edi
  80278f:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  802796:	00 00 00 
  802799:	ff d0                	callq  *%rax
}
  80279b:	c9                   	leaveq 
  80279c:	c3                   	retq   

000000000080279d <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80279d:	55                   	push   %rbp
  80279e:	48 89 e5             	mov    %rsp,%rbp
  8027a1:	48 83 ec 20          	sub    $0x20,%rsp
  8027a5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8027a8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_trapframe, 1, envid, (uint64_t) tf, 0, 0, 0);
  8027ac:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8027b0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8027b3:	48 98                	cltq   
  8027b5:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8027bc:	00 
  8027bd:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8027c3:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8027c9:	48 89 d1             	mov    %rdx,%rcx
  8027cc:	48 89 c2             	mov    %rax,%rdx
  8027cf:	be 01 00 00 00       	mov    $0x1,%esi
  8027d4:	bf 09 00 00 00       	mov    $0x9,%edi
  8027d9:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  8027e0:	00 00 00 
  8027e3:	ff d0                	callq  *%rax
}
  8027e5:	c9                   	leaveq 
  8027e6:	c3                   	retq   

00000000008027e7 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  8027e7:	55                   	push   %rbp
  8027e8:	48 89 e5             	mov    %rsp,%rbp
  8027eb:	48 83 ec 20          	sub    $0x20,%rsp
  8027ef:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8027f2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint64_t) upcall, 0, 0, 0);
  8027f6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8027fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8027fd:	48 98                	cltq   
  8027ff:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802806:	00 
  802807:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80280d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802813:	48 89 d1             	mov    %rdx,%rcx
  802816:	48 89 c2             	mov    %rax,%rdx
  802819:	be 01 00 00 00       	mov    $0x1,%esi
  80281e:	bf 0a 00 00 00       	mov    $0xa,%edi
  802823:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  80282a:	00 00 00 
  80282d:	ff d0                	callq  *%rax
}
  80282f:	c9                   	leaveq 
  802830:	c3                   	retq   

0000000000802831 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint64_t value, void *srcva, int perm)
{
  802831:	55                   	push   %rbp
  802832:	48 89 e5             	mov    %rsp,%rbp
  802835:	48 83 ec 20          	sub    $0x20,%rsp
  802839:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80283c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802840:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  802844:	89 4d f8             	mov    %ecx,-0x8(%rbp)
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint64_t) srcva, perm, 0);
  802847:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80284a:	48 63 f0             	movslq %eax,%rsi
  80284d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  802851:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802854:	48 98                	cltq   
  802856:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80285a:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802861:	00 
  802862:	49 89 f1             	mov    %rsi,%r9
  802865:	49 89 c8             	mov    %rcx,%r8
  802868:	48 89 d1             	mov    %rdx,%rcx
  80286b:	48 89 c2             	mov    %rax,%rdx
  80286e:	be 00 00 00 00       	mov    $0x0,%esi
  802873:	bf 0c 00 00 00       	mov    $0xc,%edi
  802878:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  80287f:	00 00 00 
  802882:	ff d0                	callq  *%rax
}
  802884:	c9                   	leaveq 
  802885:	c3                   	retq   

0000000000802886 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  802886:	55                   	push   %rbp
  802887:	48 89 e5             	mov    %rsp,%rbp
  80288a:	48 83 ec 10          	sub    $0x10,%rsp
  80288e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return syscall(SYS_ipc_recv, 1, (uint64_t)dstva, 0, 0, 0, 0);
  802892:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802896:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80289d:	00 
  80289e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8028a4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8028aa:	b9 00 00 00 00       	mov    $0x0,%ecx
  8028af:	48 89 c2             	mov    %rax,%rdx
  8028b2:	be 01 00 00 00       	mov    $0x1,%esi
  8028b7:	bf 0d 00 00 00       	mov    $0xd,%edi
  8028bc:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  8028c3:	00 00 00 
  8028c6:	ff d0                	callq  *%rax
}
  8028c8:	c9                   	leaveq 
  8028c9:	c3                   	retq   

00000000008028ca <sys_net_tx>:

int
sys_net_tx(void *buf, size_t len)
{
  8028ca:	55                   	push   %rbp
  8028cb:	48 89 e5             	mov    %rsp,%rbp
  8028ce:	48 83 ec 20          	sub    $0x20,%rsp
  8028d2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8028d6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_net_tx, (uint64_t)buf, len, 0, 0, 0, 0);
  8028da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8028de:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8028e2:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8028e9:	00 
  8028ea:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8028f0:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8028f6:	b9 00 00 00 00       	mov    $0x0,%ecx
  8028fb:	89 c6                	mov    %eax,%esi
  8028fd:	bf 0f 00 00 00       	mov    $0xf,%edi
  802902:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  802909:	00 00 00 
  80290c:	ff d0                	callq  *%rax
}
  80290e:	c9                   	leaveq 
  80290f:	c3                   	retq   

0000000000802910 <sys_net_rx>:

int
sys_net_rx(void *buf, size_t len)
{
  802910:	55                   	push   %rbp
  802911:	48 89 e5             	mov    %rsp,%rbp
  802914:	48 83 ec 20          	sub    $0x20,%rsp
  802918:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80291c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_net_rx, (uint64_t)buf, len, 0, 0, 0, 0);
  802920:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802924:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802928:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80292f:	00 
  802930:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802936:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80293c:	b9 00 00 00 00       	mov    $0x0,%ecx
  802941:	89 c6                	mov    %eax,%esi
  802943:	bf 10 00 00 00       	mov    $0x10,%edi
  802948:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  80294f:	00 00 00 
  802952:	ff d0                	callq  *%rax
}
  802954:	c9                   	leaveq 
  802955:	c3                   	retq   

0000000000802956 <sys_time_msec>:


unsigned int
sys_time_msec(void)
{
  802956:	55                   	push   %rbp
  802957:	48 89 e5             	mov    %rsp,%rbp
  80295a:	48 83 ec 10          	sub    $0x10,%rsp
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
  80295e:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802965:	00 
  802966:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80296c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802972:	b9 00 00 00 00       	mov    $0x0,%ecx
  802977:	ba 00 00 00 00       	mov    $0x0,%edx
  80297c:	be 00 00 00 00       	mov    $0x0,%esi
  802981:	bf 0e 00 00 00       	mov    $0xe,%edi
  802986:	48 b8 87 24 80 00 00 	movabs $0x802487,%rax
  80298d:	00 00 00 
  802990:	ff d0                	callq  *%rax
}
  802992:	c9                   	leaveq 
  802993:	c3                   	retq   

0000000000802994 <pgfault>:
        return esp;
}

static void
pgfault(struct UTrapframe *utf)
{
  802994:	55                   	push   %rbp
  802995:	48 89 e5             	mov    %rsp,%rbp
  802998:	48 83 ec 30          	sub    $0x30,%rsp
  80299c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	void *addr = (void *) utf->utf_fault_va;
  8029a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8029a4:	48 8b 00             	mov    (%rax),%rax
  8029a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uint32_t err = utf->utf_err;
  8029ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8029af:	48 8b 40 08          	mov    0x8(%rax),%rax
  8029b3:	89 45 f4             	mov    %eax,-0xc(%rbp)
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
	//cprintf("I am in user's page fault handler\n");
	if(!(err &FEC_WR)&&(uvpt[PPN(addr)]& PTE_COW))
  8029b6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8029b9:	83 e0 02             	and    $0x2,%eax
  8029bc:	85 c0                	test   %eax,%eax
  8029be:	75 4d                	jne    802a0d <pgfault+0x79>
  8029c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8029c4:	48 c1 e8 0c          	shr    $0xc,%rax
  8029c8:	48 89 c2             	mov    %rax,%rdx
  8029cb:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8029d2:	01 00 00 
  8029d5:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8029d9:	25 00 08 00 00       	and    $0x800,%eax
  8029de:	48 85 c0             	test   %rax,%rax
  8029e1:	74 2a                	je     802a0d <pgfault+0x79>
		panic("Page isnt writable/ COW, why did I get a pagefault \n");
  8029e3:	48 ba 18 0f 82 00 00 	movabs $0x820f18,%rdx
  8029ea:	00 00 00 
  8029ed:	be 23 00 00 00       	mov    $0x23,%esi
  8029f2:	48 bf 4d 0f 82 00 00 	movabs $0x820f4d,%rdi
  8029f9:	00 00 00 
  8029fc:	b8 00 00 00 00       	mov    $0x0,%eax
  802a01:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  802a08:	00 00 00 
  802a0b:	ff d1                	callq  *%rcx
	// copy the data from the old page to the new page, then move the new
	// page to the old page's address.
	// Hint:
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.
	if(0 == sys_page_alloc(0,(void*)PFTEMP,PTE_U|PTE_P|PTE_W)){
  802a0d:	ba 07 00 00 00       	mov    $0x7,%edx
  802a12:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802a17:	bf 00 00 00 00       	mov    $0x0,%edi
  802a1c:	48 b8 5d 26 80 00 00 	movabs $0x80265d,%rax
  802a23:	00 00 00 
  802a26:	ff d0                	callq  *%rax
  802a28:	85 c0                	test   %eax,%eax
  802a2a:	0f 85 cd 00 00 00    	jne    802afd <pgfault+0x169>
		Pageaddr = ROUNDDOWN(addr,PGSIZE);
  802a30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802a34:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  802a38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802a3c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  802a42:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		memmove(PFTEMP, Pageaddr, PGSIZE);
  802a46:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802a4a:	ba 00 10 00 00       	mov    $0x1000,%edx
  802a4f:	48 89 c6             	mov    %rax,%rsi
  802a52:	bf 00 f0 5f 00       	mov    $0x5ff000,%edi
  802a57:	48 b8 52 20 80 00 00 	movabs $0x802052,%rax
  802a5e:	00 00 00 
  802a61:	ff d0                	callq  *%rax
		if(0> sys_page_map(0,PFTEMP,0,Pageaddr,PTE_U|PTE_P|PTE_W))
  802a63:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802a67:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  802a6d:	48 89 c1             	mov    %rax,%rcx
  802a70:	ba 00 00 00 00       	mov    $0x0,%edx
  802a75:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802a7a:	bf 00 00 00 00       	mov    $0x0,%edi
  802a7f:	48 b8 ad 26 80 00 00 	movabs $0x8026ad,%rax
  802a86:	00 00 00 
  802a89:	ff d0                	callq  *%rax
  802a8b:	85 c0                	test   %eax,%eax
  802a8d:	79 2a                	jns    802ab9 <pgfault+0x125>
				panic("Page map at temp address failed");
  802a8f:	48 ba 58 0f 82 00 00 	movabs $0x820f58,%rdx
  802a96:	00 00 00 
  802a99:	be 30 00 00 00       	mov    $0x30,%esi
  802a9e:	48 bf 4d 0f 82 00 00 	movabs $0x820f4d,%rdi
  802aa5:	00 00 00 
  802aa8:	b8 00 00 00 00       	mov    $0x0,%eax
  802aad:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  802ab4:	00 00 00 
  802ab7:	ff d1                	callq  *%rcx
		if(0> sys_page_unmap(0,PFTEMP))
  802ab9:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802abe:	bf 00 00 00 00       	mov    $0x0,%edi
  802ac3:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  802aca:	00 00 00 
  802acd:	ff d0                	callq  *%rax
  802acf:	85 c0                	test   %eax,%eax
  802ad1:	79 54                	jns    802b27 <pgfault+0x193>
				panic("Page unmap from temp location failed");
  802ad3:	48 ba 78 0f 82 00 00 	movabs $0x820f78,%rdx
  802ada:	00 00 00 
  802add:	be 32 00 00 00       	mov    $0x32,%esi
  802ae2:	48 bf 4d 0f 82 00 00 	movabs $0x820f4d,%rdi
  802ae9:	00 00 00 
  802aec:	b8 00 00 00 00       	mov    $0x0,%eax
  802af1:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  802af8:	00 00 00 
  802afb:	ff d1                	callq  *%rcx
	}else{
		panic("Page Allocation Failed during handling page fault");
  802afd:	48 ba a0 0f 82 00 00 	movabs $0x820fa0,%rdx
  802b04:	00 00 00 
  802b07:	be 34 00 00 00       	mov    $0x34,%esi
  802b0c:	48 bf 4d 0f 82 00 00 	movabs $0x820f4d,%rdi
  802b13:	00 00 00 
  802b16:	b8 00 00 00 00       	mov    $0x0,%eax
  802b1b:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  802b22:	00 00 00 
  802b25:	ff d1                	callq  *%rcx
	}
	//panic("pgfault not implemented");
}
  802b27:	c9                   	leaveq 
  802b28:	c3                   	retq   

0000000000802b29 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  802b29:	55                   	push   %rbp
  802b2a:	48 89 e5             	mov    %rsp,%rbp
  802b2d:	48 83 ec 20          	sub    $0x20,%rsp
  802b31:	89 7d ec             	mov    %edi,-0x14(%rbp)
  802b34:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	int perm = (uvpt[pn]) & PTE_SYSCALL; // Doubtful..
  802b37:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802b3e:	01 00 00 
  802b41:	8b 55 e8             	mov    -0x18(%rbp),%edx
  802b44:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802b48:	25 07 0e 00 00       	and    $0xe07,%eax
  802b4d:	89 45 fc             	mov    %eax,-0x4(%rbp)
	void* addr = (void*)((uint64_t)pn *PGSIZE);
  802b50:	8b 45 e8             	mov    -0x18(%rbp),%eax
  802b53:	48 c1 e0 0c          	shl    $0xc,%rax
  802b57:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	//cprintf("DuPpage: Incoming addr = [%x], permission = [%d]\n", addr,perm);
	// LAB 4: Your code  here.
	if(perm & PTE_SHARE){
  802b5b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802b5e:	25 00 04 00 00       	and    $0x400,%eax
  802b63:	85 c0                	test   %eax,%eax
  802b65:	74 57                	je     802bbe <duppage+0x95>
		if(0 < sys_page_map(0,addr,envid,addr,perm))
  802b67:	8b 75 fc             	mov    -0x4(%rbp),%esi
  802b6a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802b6e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  802b71:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802b75:	41 89 f0             	mov    %esi,%r8d
  802b78:	48 89 c6             	mov    %rax,%rsi
  802b7b:	bf 00 00 00 00       	mov    $0x0,%edi
  802b80:	48 b8 ad 26 80 00 00 	movabs $0x8026ad,%rax
  802b87:	00 00 00 
  802b8a:	ff d0                	callq  *%rax
  802b8c:	85 c0                	test   %eax,%eax
  802b8e:	0f 8e 52 01 00 00    	jle    802ce6 <duppage+0x1bd>
			panic("Page alloc with COW  failed.\n");
  802b94:	48 ba d2 0f 82 00 00 	movabs $0x820fd2,%rdx
  802b9b:	00 00 00 
  802b9e:	be 4e 00 00 00       	mov    $0x4e,%esi
  802ba3:	48 bf 4d 0f 82 00 00 	movabs $0x820f4d,%rdi
  802baa:	00 00 00 
  802bad:	b8 00 00 00 00       	mov    $0x0,%eax
  802bb2:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  802bb9:	00 00 00 
  802bbc:	ff d1                	callq  *%rcx

	}else{
	if((perm & PTE_W || perm & PTE_COW)){
  802bbe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802bc1:	83 e0 02             	and    $0x2,%eax
  802bc4:	85 c0                	test   %eax,%eax
  802bc6:	75 10                	jne    802bd8 <duppage+0xaf>
  802bc8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802bcb:	25 00 08 00 00       	and    $0x800,%eax
  802bd0:	85 c0                	test   %eax,%eax
  802bd2:	0f 84 bb 00 00 00    	je     802c93 <duppage+0x16a>
		perm = (perm|PTE_COW)&(~PTE_W);
  802bd8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802bdb:	25 fd f7 ff ff       	and    $0xfffff7fd,%eax
  802be0:	80 cc 08             	or     $0x8,%ah
  802be3:	89 45 fc             	mov    %eax,-0x4(%rbp)

		if(0 < sys_page_map(0,addr,envid,addr,perm))
  802be6:	8b 75 fc             	mov    -0x4(%rbp),%esi
  802be9:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802bed:	8b 55 ec             	mov    -0x14(%rbp),%edx
  802bf0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802bf4:	41 89 f0             	mov    %esi,%r8d
  802bf7:	48 89 c6             	mov    %rax,%rsi
  802bfa:	bf 00 00 00 00       	mov    $0x0,%edi
  802bff:	48 b8 ad 26 80 00 00 	movabs $0x8026ad,%rax
  802c06:	00 00 00 
  802c09:	ff d0                	callq  *%rax
  802c0b:	85 c0                	test   %eax,%eax
  802c0d:	7e 2a                	jle    802c39 <duppage+0x110>
			panic("Page alloc with COW  failed.\n");
  802c0f:	48 ba d2 0f 82 00 00 	movabs $0x820fd2,%rdx
  802c16:	00 00 00 
  802c19:	be 55 00 00 00       	mov    $0x55,%esi
  802c1e:	48 bf 4d 0f 82 00 00 	movabs $0x820f4d,%rdi
  802c25:	00 00 00 
  802c28:	b8 00 00 00 00       	mov    $0x0,%eax
  802c2d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  802c34:	00 00 00 
  802c37:	ff d1                	callq  *%rcx
		if(0 <  sys_page_map(0,addr,0,addr,perm))
  802c39:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  802c3c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802c40:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802c44:	41 89 c8             	mov    %ecx,%r8d
  802c47:	48 89 d1             	mov    %rdx,%rcx
  802c4a:	ba 00 00 00 00       	mov    $0x0,%edx
  802c4f:	48 89 c6             	mov    %rax,%rsi
  802c52:	bf 00 00 00 00       	mov    $0x0,%edi
  802c57:	48 b8 ad 26 80 00 00 	movabs $0x8026ad,%rax
  802c5e:	00 00 00 
  802c61:	ff d0                	callq  *%rax
  802c63:	85 c0                	test   %eax,%eax
  802c65:	7e 2a                	jle    802c91 <duppage+0x168>
			panic("Page alloc with COW  failed.\n");
  802c67:	48 ba d2 0f 82 00 00 	movabs $0x820fd2,%rdx
  802c6e:	00 00 00 
  802c71:	be 57 00 00 00       	mov    $0x57,%esi
  802c76:	48 bf 4d 0f 82 00 00 	movabs $0x820f4d,%rdi
  802c7d:	00 00 00 
  802c80:	b8 00 00 00 00       	mov    $0x0,%eax
  802c85:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  802c8c:	00 00 00 
  802c8f:	ff d1                	callq  *%rcx
	if((perm & PTE_W || perm & PTE_COW)){
		perm = (perm|PTE_COW)&(~PTE_W);

		if(0 < sys_page_map(0,addr,envid,addr,perm))
			panic("Page alloc with COW  failed.\n");
		if(0 <  sys_page_map(0,addr,0,addr,perm))
  802c91:	eb 53                	jmp    802ce6 <duppage+0x1bd>
			panic("Page alloc with COW  failed.\n");
	}else{
	
		if(0 < sys_page_map(0,addr,envid,addr,perm))
  802c93:	8b 75 fc             	mov    -0x4(%rbp),%esi
  802c96:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802c9a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  802c9d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802ca1:	41 89 f0             	mov    %esi,%r8d
  802ca4:	48 89 c6             	mov    %rax,%rsi
  802ca7:	bf 00 00 00 00       	mov    $0x0,%edi
  802cac:	48 b8 ad 26 80 00 00 	movabs $0x8026ad,%rax
  802cb3:	00 00 00 
  802cb6:	ff d0                	callq  *%rax
  802cb8:	85 c0                	test   %eax,%eax
  802cba:	7e 2a                	jle    802ce6 <duppage+0x1bd>
			panic("Page alloc with COW  failed.\n");
  802cbc:	48 ba d2 0f 82 00 00 	movabs $0x820fd2,%rdx
  802cc3:	00 00 00 
  802cc6:	be 5b 00 00 00       	mov    $0x5b,%esi
  802ccb:	48 bf 4d 0f 82 00 00 	movabs $0x820f4d,%rdi
  802cd2:	00 00 00 
  802cd5:	b8 00 00 00 00       	mov    $0x0,%eax
  802cda:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  802ce1:	00 00 00 
  802ce4:	ff d1                	callq  *%rcx
		}
	}

	//panic("duppage not implemented");
	
	return 0;
  802ce6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802ceb:	c9                   	leaveq 
  802cec:	c3                   	retq   

0000000000802ced <pt_is_mapped>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
bool
pt_is_mapped(void *va)
{
  802ced:	55                   	push   %rbp
  802cee:	48 89 e5             	mov    %rsp,%rbp
  802cf1:	48 83 ec 18          	sub    $0x18,%rsp
  802cf5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	uint64_t addr = (uint64_t)va;
  802cf9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802cfd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return (uvpml4e[VPML4E(addr)] & PTE_P) && (uvpde[VPDPE(addr<<12)] & PTE_P) && (uvpd[VPD(addr<<12)] & PTE_P);
  802d01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802d05:	48 c1 e8 27          	shr    $0x27,%rax
  802d09:	48 89 c2             	mov    %rax,%rdx
  802d0c:	48 b8 00 20 40 80 00 	movabs $0x10080402000,%rax
  802d13:	01 00 00 
  802d16:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802d1a:	83 e0 01             	and    $0x1,%eax
  802d1d:	48 85 c0             	test   %rax,%rax
  802d20:	74 51                	je     802d73 <pt_is_mapped+0x86>
  802d22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802d26:	48 c1 e0 0c          	shl    $0xc,%rax
  802d2a:	48 c1 e8 1e          	shr    $0x1e,%rax
  802d2e:	48 89 c2             	mov    %rax,%rdx
  802d31:	48 b8 00 00 40 80 00 	movabs $0x10080400000,%rax
  802d38:	01 00 00 
  802d3b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802d3f:	83 e0 01             	and    $0x1,%eax
  802d42:	48 85 c0             	test   %rax,%rax
  802d45:	74 2c                	je     802d73 <pt_is_mapped+0x86>
  802d47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802d4b:	48 c1 e0 0c          	shl    $0xc,%rax
  802d4f:	48 c1 e8 15          	shr    $0x15,%rax
  802d53:	48 89 c2             	mov    %rax,%rdx
  802d56:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  802d5d:	01 00 00 
  802d60:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802d64:	83 e0 01             	and    $0x1,%eax
  802d67:	48 85 c0             	test   %rax,%rax
  802d6a:	74 07                	je     802d73 <pt_is_mapped+0x86>
  802d6c:	b8 01 00 00 00       	mov    $0x1,%eax
  802d71:	eb 05                	jmp    802d78 <pt_is_mapped+0x8b>
  802d73:	b8 00 00 00 00       	mov    $0x0,%eax
  802d78:	83 e0 01             	and    $0x1,%eax
}
  802d7b:	c9                   	leaveq 
  802d7c:	c3                   	retq   

0000000000802d7d <fork>:

envid_t
fork(void)
{
  802d7d:	55                   	push   %rbp
  802d7e:	48 89 e5             	mov    %rsp,%rbp
  802d81:	48 83 ec 20          	sub    $0x20,%rsp
	// LAB 4: Your code here.
	envid_t envid;
	int r;
	uint64_t i;
	uint64_t addr, last;
	set_pgfault_handler(pgfault);
  802d85:	48 bf 94 29 80 00 00 	movabs $0x802994,%rdi
  802d8c:	00 00 00 
  802d8f:	48 b8 2e 58 80 00 00 	movabs $0x80582e,%rax
  802d96:	00 00 00 
  802d99:	ff d0                	callq  *%rax
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  802d9b:	b8 07 00 00 00       	mov    $0x7,%eax
  802da0:	cd 30                	int    $0x30
  802da2:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		: "=a" (ret)
		: "a" (SYS_exofork),
		  "i" (T_SYSCALL)
	);
	return ret;
  802da5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
	envid = sys_exofork();
  802da8:	89 45 f4             	mov    %eax,-0xc(%rbp)
	if(envid < 0)
  802dab:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  802daf:	79 30                	jns    802de1 <fork+0x64>
		panic("\nsys_exofork error: %e\n", envid);
  802db1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802db4:	89 c1                	mov    %eax,%ecx
  802db6:	48 ba f0 0f 82 00 00 	movabs $0x820ff0,%rdx
  802dbd:	00 00 00 
  802dc0:	be 86 00 00 00       	mov    $0x86,%esi
  802dc5:	48 bf 4d 0f 82 00 00 	movabs $0x820f4d,%rdi
  802dcc:	00 00 00 
  802dcf:	b8 00 00 00 00       	mov    $0x0,%eax
  802dd4:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  802ddb:	00 00 00 
  802dde:	41 ff d0             	callq  *%r8
    else if(envid == 0)
  802de1:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  802de5:	75 46                	jne    802e2d <fork+0xb0>
	{
		thisenv = &envs[ENVX(sys_getenvid())];
  802de7:	48 b8 e1 25 80 00 00 	movabs $0x8025e1,%rax
  802dee:	00 00 00 
  802df1:	ff d0                	callq  *%rax
  802df3:	25 ff 03 00 00       	and    $0x3ff,%eax
  802df8:	48 63 d0             	movslq %eax,%rdx
  802dfb:	48 89 d0             	mov    %rdx,%rax
  802dfe:	48 c1 e0 03          	shl    $0x3,%rax
  802e02:	48 01 d0             	add    %rdx,%rax
  802e05:	48 c1 e0 05          	shl    $0x5,%rax
  802e09:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  802e10:	00 00 00 
  802e13:	48 01 c2             	add    %rax,%rdx
  802e16:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  802e1d:	00 00 00 
  802e20:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  802e23:	b8 00 00 00 00       	mov    $0x0,%eax
  802e28:	e9 d1 01 00 00       	jmpq   802ffe <fork+0x281>
	}
	uint64_t ad = 0;
  802e2d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  802e34:	00 
	for (addr = (uint64_t)USTACKTOP-PGSIZE; addr >=(uint64_t)UTEXT; addr -= PGSIZE){  // Is this enough, am I leaving a bug for future here???	
  802e35:	b8 00 d0 7f ef       	mov    $0xef7fd000,%eax
  802e3a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  802e3e:	e9 df 00 00 00       	jmpq   802f22 <fork+0x1a5>
	/*Do we really need to scan all the pages????*/
		if(uvpml4e[VPML4E(addr)]& PTE_P){
  802e43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802e47:	48 c1 e8 27          	shr    $0x27,%rax
  802e4b:	48 89 c2             	mov    %rax,%rdx
  802e4e:	48 b8 00 20 40 80 00 	movabs $0x10080402000,%rax
  802e55:	01 00 00 
  802e58:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802e5c:	83 e0 01             	and    $0x1,%eax
  802e5f:	48 85 c0             	test   %rax,%rax
  802e62:	0f 84 9e 00 00 00    	je     802f06 <fork+0x189>
			if( uvpde[VPDPE(addr)] & PTE_P){
  802e68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802e6c:	48 c1 e8 1e          	shr    $0x1e,%rax
  802e70:	48 89 c2             	mov    %rax,%rdx
  802e73:	48 b8 00 00 40 80 00 	movabs $0x10080400000,%rax
  802e7a:	01 00 00 
  802e7d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802e81:	83 e0 01             	and    $0x1,%eax
  802e84:	48 85 c0             	test   %rax,%rax
  802e87:	74 73                	je     802efc <fork+0x17f>
				if( uvpd[VPD(addr)] & PTE_P){
  802e89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802e8d:	48 c1 e8 15          	shr    $0x15,%rax
  802e91:	48 89 c2             	mov    %rax,%rdx
  802e94:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  802e9b:	01 00 00 
  802e9e:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802ea2:	83 e0 01             	and    $0x1,%eax
  802ea5:	48 85 c0             	test   %rax,%rax
  802ea8:	74 48                	je     802ef2 <fork+0x175>
					if((ad =uvpt[VPN(addr)])& PTE_P){
  802eaa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802eae:	48 c1 e8 0c          	shr    $0xc,%rax
  802eb2:	48 89 c2             	mov    %rax,%rdx
  802eb5:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802ebc:	01 00 00 
  802ebf:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802ec3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  802ec7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802ecb:	83 e0 01             	and    $0x1,%eax
  802ece:	48 85 c0             	test   %rax,%rax
  802ed1:	74 47                	je     802f1a <fork+0x19d>
						//cprintf("hi\n");
						//cprintf("addr = [%x]\n",ad);
						duppage(envid, VPN(addr));	
  802ed3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802ed7:	48 c1 e8 0c          	shr    $0xc,%rax
  802edb:	89 c2                	mov    %eax,%edx
  802edd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802ee0:	89 d6                	mov    %edx,%esi
  802ee2:	89 c7                	mov    %eax,%edi
  802ee4:	48 b8 29 2b 80 00 00 	movabs $0x802b29,%rax
  802eeb:	00 00 00 
  802eee:	ff d0                	callq  *%rax
  802ef0:	eb 28                	jmp    802f1a <fork+0x19d>
					}
				}else{
					addr -= NPDENTRIES*PGSIZE;
  802ef2:	48 81 6d f8 00 00 20 	subq   $0x200000,-0x8(%rbp)
  802ef9:	00 
  802efa:	eb 1e                	jmp    802f1a <fork+0x19d>
					//addr -= ((VPD(addr)+1)<<PDXSHIFT);
				}
			}else{
				addr -= NPDENTRIES*NPDENTRIES*PGSIZE;
  802efc:	48 81 6d f8 00 00 00 	subq   $0x40000000,-0x8(%rbp)
  802f03:	40 
  802f04:	eb 14                	jmp    802f1a <fork+0x19d>
				//addr -= ((VPDPE(addr)+1)<<PDPESHIFT);
			}
	
		}else{
		/*uvpml4e.. move by */
			addr -= ((VPML4E(addr)+1)<<PML4SHIFT)
  802f06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802f0a:	48 c1 e8 27          	shr    $0x27,%rax
  802f0e:	48 83 c0 01          	add    $0x1,%rax
  802f12:	48 c1 e0 27          	shl    $0x27,%rax
  802f16:	48 29 45 f8          	sub    %rax,-0x8(%rbp)
	{
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	uint64_t ad = 0;
	for (addr = (uint64_t)USTACKTOP-PGSIZE; addr >=(uint64_t)UTEXT; addr -= PGSIZE){  // Is this enough, am I leaving a bug for future here???	
  802f1a:	48 81 6d f8 00 10 00 	subq   $0x1000,-0x8(%rbp)
  802f21:	00 
  802f22:	48 81 7d f8 ff ff 7f 	cmpq   $0x7fffff,-0x8(%rbp)
  802f29:	00 
  802f2a:	0f 87 13 ff ff ff    	ja     802e43 <fork+0xc6>
		}
	
	}


	sys_page_alloc(envid, (void *)(UXSTACKTOP - PGSIZE),PTE_P|PTE_U|PTE_W); 
  802f30:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802f33:	ba 07 00 00 00       	mov    $0x7,%edx
  802f38:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  802f3d:	89 c7                	mov    %eax,%edi
  802f3f:	48 b8 5d 26 80 00 00 	movabs $0x80265d,%rax
  802f46:	00 00 00 
  802f49:	ff d0                	callq  *%rax

	sys_page_alloc(envid, (void*)(USTACKTOP - PGSIZE),PTE_P|PTE_U|PTE_W); 
  802f4b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802f4e:	ba 07 00 00 00       	mov    $0x7,%edx
  802f53:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  802f58:	89 c7                	mov    %eax,%edi
  802f5a:	48 b8 5d 26 80 00 00 	movabs $0x80265d,%rax
  802f61:	00 00 00 
  802f64:	ff d0                	callq  *%rax

	sys_page_map(envid, (void*)(USTACKTOP - PGSIZE), 0, PFTEMP,PTE_P|PTE_U|PTE_W);
  802f66:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802f69:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  802f6f:	b9 00 f0 5f 00       	mov    $0x5ff000,%ecx
  802f74:	ba 00 00 00 00       	mov    $0x0,%edx
  802f79:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  802f7e:	89 c7                	mov    %eax,%edi
  802f80:	48 b8 ad 26 80 00 00 	movabs $0x8026ad,%rax
  802f87:	00 00 00 
  802f8a:	ff d0                	callq  *%rax

	memmove(PFTEMP, (void*)(USTACKTOP-PGSIZE), PGSIZE);
  802f8c:	ba 00 10 00 00       	mov    $0x1000,%edx
  802f91:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  802f96:	bf 00 f0 5f 00       	mov    $0x5ff000,%edi
  802f9b:	48 b8 52 20 80 00 00 	movabs $0x802052,%rax
  802fa2:	00 00 00 
  802fa5:	ff d0                	callq  *%rax

	sys_page_unmap(0, PFTEMP);
  802fa7:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802fac:	bf 00 00 00 00       	mov    $0x0,%edi
  802fb1:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  802fb8:	00 00 00 
  802fbb:	ff d0                	callq  *%rax

    sys_env_set_pgfault_upcall(envid, thisenv->env_pgfault_upcall); 
  802fbd:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  802fc4:	00 00 00 
  802fc7:	48 8b 00             	mov    (%rax),%rax
  802fca:	48 8b 90 f0 00 00 00 	mov    0xf0(%rax),%rdx
  802fd1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802fd4:	48 89 d6             	mov    %rdx,%rsi
  802fd7:	89 c7                	mov    %eax,%edi
  802fd9:	48 b8 e7 27 80 00 00 	movabs $0x8027e7,%rax
  802fe0:	00 00 00 
  802fe3:	ff d0                	callq  *%rax
	
	sys_env_set_status(envid, ENV_RUNNABLE);
  802fe5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802fe8:	be 02 00 00 00       	mov    $0x2,%esi
  802fed:	89 c7                	mov    %eax,%edi
  802fef:	48 b8 52 27 80 00 00 	movabs $0x802752,%rax
  802ff6:	00 00 00 
  802ff9:	ff d0                	callq  *%rax

	return envid;
  802ffb:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  802ffe:	c9                   	leaveq 
  802fff:	c3                   	retq   

0000000000803000 <sfork>:

	
// Challenge!
int
sfork(void)
{
  803000:	55                   	push   %rbp
  803001:	48 89 e5             	mov    %rsp,%rbp
	panic("sfork not implemented");
  803004:	48 ba 08 10 82 00 00 	movabs $0x821008,%rdx
  80300b:	00 00 00 
  80300e:	be bf 00 00 00       	mov    $0xbf,%esi
  803013:	48 bf 4d 0f 82 00 00 	movabs $0x820f4d,%rdi
  80301a:	00 00 00 
  80301d:	b8 00 00 00 00       	mov    $0x0,%eax
  803022:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  803029:	00 00 00 
  80302c:	ff d1                	callq  *%rcx

000000000080302e <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80302e:	55                   	push   %rbp
  80302f:	48 89 e5             	mov    %rsp,%rbp
  803032:	48 83 ec 30          	sub    $0x30,%rsp
  803036:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80303a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80303e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// LAB 4: Your code here.
	int result;
	if(thisenv->env_status== 0){
  803042:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803049:	00 00 00 
  80304c:	48 8b 00             	mov    (%rax),%rax
  80304f:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  803055:	85 c0                	test   %eax,%eax
  803057:	75 3c                	jne    803095 <ipc_recv+0x67>
		thisenv = &envs[ENVX(sys_getenvid())];
  803059:	48 b8 e1 25 80 00 00 	movabs $0x8025e1,%rax
  803060:	00 00 00 
  803063:	ff d0                	callq  *%rax
  803065:	25 ff 03 00 00       	and    $0x3ff,%eax
  80306a:	48 63 d0             	movslq %eax,%rdx
  80306d:	48 89 d0             	mov    %rdx,%rax
  803070:	48 c1 e0 03          	shl    $0x3,%rax
  803074:	48 01 d0             	add    %rdx,%rax
  803077:	48 c1 e0 05          	shl    $0x5,%rax
  80307b:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  803082:	00 00 00 
  803085:	48 01 c2             	add    %rax,%rdx
  803088:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  80308f:	00 00 00 
  803092:	48 89 10             	mov    %rdx,(%rax)
	}
	if(!pg)
  803095:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80309a:	75 0e                	jne    8030aa <ipc_recv+0x7c>
		pg = (void*) UTOP;
  80309c:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  8030a3:	00 00 00 
  8030a6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	result = sys_ipc_recv(pg);
  8030aa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8030ae:	48 89 c7             	mov    %rax,%rdi
  8030b1:	48 b8 86 28 80 00 00 	movabs $0x802886,%rax
  8030b8:	00 00 00 
  8030bb:	ff d0                	callq  *%rax
  8030bd:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result< 0){
  8030c0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8030c4:	79 19                	jns    8030df <ipc_recv+0xb1>
		*from_env_store = 0;
  8030c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8030ca:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
		*perm_store =0;
  8030d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8030d4:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
		return result;
  8030da:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8030dd:	eb 53                	jmp    803132 <ipc_recv+0x104>
	}
	if(from_env_store)
  8030df:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8030e4:	74 19                	je     8030ff <ipc_recv+0xd1>
		*from_env_store = thisenv->env_ipc_from;
  8030e6:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8030ed:	00 00 00 
  8030f0:	48 8b 00             	mov    (%rax),%rax
  8030f3:	8b 90 0c 01 00 00    	mov    0x10c(%rax),%edx
  8030f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8030fd:	89 10                	mov    %edx,(%rax)
	if(perm_store)
  8030ff:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  803104:	74 19                	je     80311f <ipc_recv+0xf1>
		*perm_store = thisenv->env_ipc_perm;
  803106:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  80310d:	00 00 00 
  803110:	48 8b 00             	mov    (%rax),%rax
  803113:	8b 90 10 01 00 00    	mov    0x110(%rax),%edx
  803119:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80311d:	89 10                	mov    %edx,(%rax)
	
	//cprintf("I am IPC Recv, sending value[%d] my env id is [%d]and status is [%d] and I am sending to [%d]",thisenv->env_ipc_value,thisenv->env_id,thisenv->env_status,thisenv->env_ipc_from);	
	return thisenv->env_ipc_value;
  80311f:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803126:	00 00 00 
  803129:	48 8b 00             	mov    (%rax),%rax
  80312c:	8b 80 08 01 00 00    	mov    0x108(%rax),%eax

	//panic("ipc_recv not implemented");
}
  803132:	c9                   	leaveq 
  803133:	c3                   	retq   

0000000000803134 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  803134:	55                   	push   %rbp
  803135:	48 89 e5             	mov    %rsp,%rbp
  803138:	48 83 ec 30          	sub    $0x30,%rsp
  80313c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80313f:	89 75 e8             	mov    %esi,-0x18(%rbp)
  803142:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  803146:	89 4d dc             	mov    %ecx,-0x24(%rbp)
	// LAB 4: Your code here.
	int result;
	if(!pg)
  803149:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80314e:	75 0e                	jne    80315e <ipc_send+0x2a>
		pg = (void*)UTOP;
  803150:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  803157:	00 00 00 
  80315a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	do{
	 	result = sys_ipc_try_send(to_env,val,pg,perm);
  80315e:	8b 75 e8             	mov    -0x18(%rbp),%esi
  803161:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  803164:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803168:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80316b:	89 c7                	mov    %eax,%edi
  80316d:	48 b8 31 28 80 00 00 	movabs $0x802831,%rax
  803174:	00 00 00 
  803177:	ff d0                	callq  *%rax
  803179:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(-E_IPC_NOT_RECV == result)
  80317c:	83 7d fc f8          	cmpl   $0xfffffff8,-0x4(%rbp)
  803180:	75 0c                	jne    80318e <ipc_send+0x5a>
			sys_yield();
  803182:	48 b8 1f 26 80 00 00 	movabs $0x80261f,%rax
  803189:	00 00 00 
  80318c:	ff d0                	callq  *%rax
	}while(-E_IPC_NOT_RECV == result);
  80318e:	83 7d fc f8          	cmpl   $0xfffffff8,-0x4(%rbp)
  803192:	74 ca                	je     80315e <ipc_send+0x2a>
	
	//panic("ipc_send not implemented");
}
  803194:	c9                   	leaveq 
  803195:	c3                   	retq   

0000000000803196 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  803196:	55                   	push   %rbp
  803197:	48 89 e5             	mov    %rsp,%rbp
  80319a:	48 83 ec 14          	sub    $0x14,%rsp
  80319e:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	for (i = 0; i < NENV; i++) {
  8031a1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8031a8:	eb 5e                	jmp    803208 <ipc_find_env+0x72>
		if (envs[i].env_type == type)
  8031aa:	48 b9 00 00 80 00 80 	movabs $0x8000800000,%rcx
  8031b1:	00 00 00 
  8031b4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8031b7:	48 63 d0             	movslq %eax,%rdx
  8031ba:	48 89 d0             	mov    %rdx,%rax
  8031bd:	48 c1 e0 03          	shl    $0x3,%rax
  8031c1:	48 01 d0             	add    %rdx,%rax
  8031c4:	48 c1 e0 05          	shl    $0x5,%rax
  8031c8:	48 01 c8             	add    %rcx,%rax
  8031cb:	48 05 d0 00 00 00    	add    $0xd0,%rax
  8031d1:	8b 00                	mov    (%rax),%eax
  8031d3:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8031d6:	75 2c                	jne    803204 <ipc_find_env+0x6e>
			return envs[i].env_id;
  8031d8:	48 b9 00 00 80 00 80 	movabs $0x8000800000,%rcx
  8031df:	00 00 00 
  8031e2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8031e5:	48 63 d0             	movslq %eax,%rdx
  8031e8:	48 89 d0             	mov    %rdx,%rax
  8031eb:	48 c1 e0 03          	shl    $0x3,%rax
  8031ef:	48 01 d0             	add    %rdx,%rax
  8031f2:	48 c1 e0 05          	shl    $0x5,%rax
  8031f6:	48 01 c8             	add    %rcx,%rax
  8031f9:	48 05 c0 00 00 00    	add    $0xc0,%rax
  8031ff:	8b 40 08             	mov    0x8(%rax),%eax
  803202:	eb 12                	jmp    803216 <ipc_find_env+0x80>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++) {
  803204:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  803208:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  80320f:	7e 99                	jle    8031aa <ipc_find_env+0x14>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	}
	return 0;
  803211:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803216:	c9                   	leaveq 
  803217:	c3                   	retq   

0000000000803218 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

uint64_t
fd2num(struct Fd *fd)
{
  803218:	55                   	push   %rbp
  803219:	48 89 e5             	mov    %rsp,%rbp
  80321c:	48 83 ec 08          	sub    $0x8,%rsp
  803220:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  803224:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  803228:	48 b8 00 00 00 30 ff 	movabs $0xffffffff30000000,%rax
  80322f:	ff ff ff 
  803232:	48 01 d0             	add    %rdx,%rax
  803235:	48 c1 e8 0c          	shr    $0xc,%rax
}
  803239:	c9                   	leaveq 
  80323a:	c3                   	retq   

000000000080323b <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80323b:	55                   	push   %rbp
  80323c:	48 89 e5             	mov    %rsp,%rbp
  80323f:	48 83 ec 08          	sub    $0x8,%rsp
  803243:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return INDEX2DATA(fd2num(fd));
  803247:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80324b:	48 89 c7             	mov    %rax,%rdi
  80324e:	48 b8 18 32 80 00 00 	movabs $0x803218,%rax
  803255:	00 00 00 
  803258:	ff d0                	callq  *%rax
  80325a:	48 05 20 00 0d 00    	add    $0xd0020,%rax
  803260:	48 c1 e0 0c          	shl    $0xc,%rax
}
  803264:	c9                   	leaveq 
  803265:	c3                   	retq   

0000000000803266 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  803266:	55                   	push   %rbp
  803267:	48 89 e5             	mov    %rsp,%rbp
  80326a:	48 83 ec 18          	sub    $0x18,%rsp
  80326e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  803272:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803279:	eb 6b                	jmp    8032e6 <fd_alloc+0x80>
		fd = INDEX2FD(i);
  80327b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80327e:	48 98                	cltq   
  803280:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  803286:	48 c1 e0 0c          	shl    $0xc,%rax
  80328a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80328e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803292:	48 c1 e8 15          	shr    $0x15,%rax
  803296:	48 89 c2             	mov    %rax,%rdx
  803299:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  8032a0:	01 00 00 
  8032a3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8032a7:	83 e0 01             	and    $0x1,%eax
  8032aa:	48 85 c0             	test   %rax,%rax
  8032ad:	74 21                	je     8032d0 <fd_alloc+0x6a>
  8032af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8032b3:	48 c1 e8 0c          	shr    $0xc,%rax
  8032b7:	48 89 c2             	mov    %rax,%rdx
  8032ba:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8032c1:	01 00 00 
  8032c4:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8032c8:	83 e0 01             	and    $0x1,%eax
  8032cb:	48 85 c0             	test   %rax,%rax
  8032ce:	75 12                	jne    8032e2 <fd_alloc+0x7c>
			*fd_store = fd;
  8032d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8032d4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8032d8:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  8032db:	b8 00 00 00 00       	mov    $0x0,%eax
  8032e0:	eb 1a                	jmp    8032fc <fd_alloc+0x96>
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  8032e2:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8032e6:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8032ea:	7e 8f                	jle    80327b <fd_alloc+0x15>
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  8032ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8032f0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_MAX_OPEN;
  8032f7:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  8032fc:	c9                   	leaveq 
  8032fd:	c3                   	retq   

00000000008032fe <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  8032fe:	55                   	push   %rbp
  8032ff:	48 89 e5             	mov    %rsp,%rbp
  803302:	48 83 ec 20          	sub    $0x20,%rsp
  803306:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803309:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80330d:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  803311:	78 06                	js     803319 <fd_lookup+0x1b>
  803313:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  803317:	7e 07                	jle    803320 <fd_lookup+0x22>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  803319:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80331e:	eb 6c                	jmp    80338c <fd_lookup+0x8e>
	}
	fd = INDEX2FD(fdnum);
  803320:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803323:	48 98                	cltq   
  803325:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  80332b:	48 c1 e0 0c          	shl    $0xc,%rax
  80332f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(uvpd[VPD(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  803333:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803337:	48 c1 e8 15          	shr    $0x15,%rax
  80333b:	48 89 c2             	mov    %rax,%rdx
  80333e:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803345:	01 00 00 
  803348:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80334c:	83 e0 01             	and    $0x1,%eax
  80334f:	48 85 c0             	test   %rax,%rax
  803352:	74 21                	je     803375 <fd_lookup+0x77>
  803354:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803358:	48 c1 e8 0c          	shr    $0xc,%rax
  80335c:	48 89 c2             	mov    %rax,%rdx
  80335f:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803366:	01 00 00 
  803369:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80336d:	83 e0 01             	and    $0x1,%eax
  803370:	48 85 c0             	test   %rax,%rax
  803373:	75 07                	jne    80337c <fd_lookup+0x7e>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  803375:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80337a:	eb 10                	jmp    80338c <fd_lookup+0x8e>
	}
	*fd_store = fd;
  80337c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803380:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  803384:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  803387:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80338c:	c9                   	leaveq 
  80338d:	c3                   	retq   

000000000080338e <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  80338e:	55                   	push   %rbp
  80338f:	48 89 e5             	mov    %rsp,%rbp
  803392:	48 83 ec 30          	sub    $0x30,%rsp
  803396:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80339a:	89 f0                	mov    %esi,%eax
  80339c:	88 45 d4             	mov    %al,-0x2c(%rbp)
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80339f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8033a3:	48 89 c7             	mov    %rax,%rdi
  8033a6:	48 b8 18 32 80 00 00 	movabs $0x803218,%rax
  8033ad:	00 00 00 
  8033b0:	ff d0                	callq  *%rax
  8033b2:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8033b6:	48 89 d6             	mov    %rdx,%rsi
  8033b9:	89 c7                	mov    %eax,%edi
  8033bb:	48 b8 fe 32 80 00 00 	movabs $0x8032fe,%rax
  8033c2:	00 00 00 
  8033c5:	ff d0                	callq  *%rax
  8033c7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8033ca:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8033ce:	78 0a                	js     8033da <fd_close+0x4c>
	    || fd != fd2)
  8033d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8033d4:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8033d8:	74 12                	je     8033ec <fd_close+0x5e>
		return (must_exist ? r : 0);
  8033da:	80 7d d4 00          	cmpb   $0x0,-0x2c(%rbp)
  8033de:	74 05                	je     8033e5 <fd_close+0x57>
  8033e0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8033e3:	eb 05                	jmp    8033ea <fd_close+0x5c>
  8033e5:	b8 00 00 00 00       	mov    $0x0,%eax
  8033ea:	eb 69                	jmp    803455 <fd_close+0xc7>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  8033ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8033f0:	8b 00                	mov    (%rax),%eax
  8033f2:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8033f6:	48 89 d6             	mov    %rdx,%rsi
  8033f9:	89 c7                	mov    %eax,%edi
  8033fb:	48 b8 57 34 80 00 00 	movabs $0x803457,%rax
  803402:	00 00 00 
  803405:	ff d0                	callq  *%rax
  803407:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80340a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80340e:	78 2a                	js     80343a <fd_close+0xac>
		if (dev->dev_close)
  803410:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803414:	48 8b 40 20          	mov    0x20(%rax),%rax
  803418:	48 85 c0             	test   %rax,%rax
  80341b:	74 16                	je     803433 <fd_close+0xa5>
			r = (*dev->dev_close)(fd);
  80341d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803421:	48 8b 40 20          	mov    0x20(%rax),%rax
  803425:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803429:	48 89 d7             	mov    %rdx,%rdi
  80342c:	ff d0                	callq  *%rax
  80342e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803431:	eb 07                	jmp    80343a <fd_close+0xac>
		else
			r = 0;
  803433:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  80343a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80343e:	48 89 c6             	mov    %rax,%rsi
  803441:	bf 00 00 00 00       	mov    $0x0,%edi
  803446:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  80344d:	00 00 00 
  803450:	ff d0                	callq  *%rax
	return r;
  803452:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803455:	c9                   	leaveq 
  803456:	c3                   	retq   

0000000000803457 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  803457:	55                   	push   %rbp
  803458:	48 89 e5             	mov    %rsp,%rbp
  80345b:	48 83 ec 20          	sub    $0x20,%rsp
  80345f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803462:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int i;
	for (i = 0; devtab[i]; i++)
  803466:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80346d:	eb 41                	jmp    8034b0 <dev_lookup+0x59>
		if (devtab[i]->dev_id == dev_id) {
  80346f:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  803476:	00 00 00 
  803479:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80347c:	48 63 d2             	movslq %edx,%rdx
  80347f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803483:	8b 00                	mov    (%rax),%eax
  803485:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  803488:	75 22                	jne    8034ac <dev_lookup+0x55>
			*dev = devtab[i];
  80348a:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  803491:	00 00 00 
  803494:	8b 55 fc             	mov    -0x4(%rbp),%edx
  803497:	48 63 d2             	movslq %edx,%rdx
  80349a:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80349e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8034a2:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  8034a5:	b8 00 00 00 00       	mov    $0x0,%eax
  8034aa:	eb 60                	jmp    80350c <dev_lookup+0xb5>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  8034ac:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8034b0:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  8034b7:	00 00 00 
  8034ba:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8034bd:	48 63 d2             	movslq %edx,%rdx
  8034c0:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8034c4:	48 85 c0             	test   %rax,%rax
  8034c7:	75 a6                	jne    80346f <dev_lookup+0x18>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  8034c9:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8034d0:	00 00 00 
  8034d3:	48 8b 00             	mov    (%rax),%rax
  8034d6:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8034dc:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8034df:	89 c6                	mov    %eax,%esi
  8034e1:	48 bf 20 10 82 00 00 	movabs $0x821020,%rdi
  8034e8:	00 00 00 
  8034eb:	b8 00 00 00 00       	mov    $0x0,%eax
  8034f0:	48 b9 79 11 80 00 00 	movabs $0x801179,%rcx
  8034f7:	00 00 00 
  8034fa:	ff d1                	callq  *%rcx
	*dev = 0;
  8034fc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803500:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_INVAL;
  803507:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80350c:	c9                   	leaveq 
  80350d:	c3                   	retq   

000000000080350e <close>:

int
close(int fdnum)
{
  80350e:	55                   	push   %rbp
  80350f:	48 89 e5             	mov    %rsp,%rbp
  803512:	48 83 ec 20          	sub    $0x20,%rsp
  803516:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  803519:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80351d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803520:	48 89 d6             	mov    %rdx,%rsi
  803523:	89 c7                	mov    %eax,%edi
  803525:	48 b8 fe 32 80 00 00 	movabs $0x8032fe,%rax
  80352c:	00 00 00 
  80352f:	ff d0                	callq  *%rax
  803531:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803534:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803538:	79 05                	jns    80353f <close+0x31>
		return r;
  80353a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80353d:	eb 18                	jmp    803557 <close+0x49>
	else
		return fd_close(fd, 1);
  80353f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803543:	be 01 00 00 00       	mov    $0x1,%esi
  803548:	48 89 c7             	mov    %rax,%rdi
  80354b:	48 b8 8e 33 80 00 00 	movabs $0x80338e,%rax
  803552:	00 00 00 
  803555:	ff d0                	callq  *%rax
}
  803557:	c9                   	leaveq 
  803558:	c3                   	retq   

0000000000803559 <close_all>:

void
close_all(void)
{
  803559:	55                   	push   %rbp
  80355a:	48 89 e5             	mov    %rsp,%rbp
  80355d:	48 83 ec 10          	sub    $0x10,%rsp
	int i;
	for (i = 0; i < MAXFD; i++)
  803561:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803568:	eb 15                	jmp    80357f <close_all+0x26>
		close(i);
  80356a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80356d:	89 c7                	mov    %eax,%edi
  80356f:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  803576:	00 00 00 
  803579:	ff d0                	callq  *%rax

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80357b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80357f:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  803583:	7e e5                	jle    80356a <close_all+0x11>
		close(i);
}
  803585:	c9                   	leaveq 
  803586:	c3                   	retq   

0000000000803587 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  803587:	55                   	push   %rbp
  803588:	48 89 e5             	mov    %rsp,%rbp
  80358b:	48 83 ec 40          	sub    $0x40,%rsp
  80358f:	89 7d cc             	mov    %edi,-0x34(%rbp)
  803592:	89 75 c8             	mov    %esi,-0x38(%rbp)
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  803595:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  803599:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80359c:	48 89 d6             	mov    %rdx,%rsi
  80359f:	89 c7                	mov    %eax,%edi
  8035a1:	48 b8 fe 32 80 00 00 	movabs $0x8032fe,%rax
  8035a8:	00 00 00 
  8035ab:	ff d0                	callq  *%rax
  8035ad:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8035b0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8035b4:	79 08                	jns    8035be <dup+0x37>
		return r;
  8035b6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8035b9:	e9 70 01 00 00       	jmpq   80372e <dup+0x1a7>
	close(newfdnum);
  8035be:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8035c1:	89 c7                	mov    %eax,%edi
  8035c3:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  8035ca:	00 00 00 
  8035cd:	ff d0                	callq  *%rax

	newfd = INDEX2FD(newfdnum);
  8035cf:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8035d2:	48 98                	cltq   
  8035d4:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  8035da:	48 c1 e0 0c          	shl    $0xc,%rax
  8035de:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	ova = fd2data(oldfd);
  8035e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8035e6:	48 89 c7             	mov    %rax,%rdi
  8035e9:	48 b8 3b 32 80 00 00 	movabs $0x80323b,%rax
  8035f0:	00 00 00 
  8035f3:	ff d0                	callq  *%rax
  8035f5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nva = fd2data(newfd);
  8035f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8035fd:	48 89 c7             	mov    %rax,%rdi
  803600:	48 b8 3b 32 80 00 00 	movabs $0x80323b,%rax
  803607:	00 00 00 
  80360a:	ff d0                	callq  *%rax
  80360c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if ((uvpd[VPD(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  803610:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803614:	48 c1 e8 15          	shr    $0x15,%rax
  803618:	48 89 c2             	mov    %rax,%rdx
  80361b:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803622:	01 00 00 
  803625:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803629:	83 e0 01             	and    $0x1,%eax
  80362c:	48 85 c0             	test   %rax,%rax
  80362f:	74 73                	je     8036a4 <dup+0x11d>
  803631:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803635:	48 c1 e8 0c          	shr    $0xc,%rax
  803639:	48 89 c2             	mov    %rax,%rdx
  80363c:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803643:	01 00 00 
  803646:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80364a:	83 e0 01             	and    $0x1,%eax
  80364d:	48 85 c0             	test   %rax,%rax
  803650:	74 52                	je     8036a4 <dup+0x11d>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  803652:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803656:	48 c1 e8 0c          	shr    $0xc,%rax
  80365a:	48 89 c2             	mov    %rax,%rdx
  80365d:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803664:	01 00 00 
  803667:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80366b:	25 07 0e 00 00       	and    $0xe07,%eax
  803670:	89 c1                	mov    %eax,%ecx
  803672:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803676:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80367a:	41 89 c8             	mov    %ecx,%r8d
  80367d:	48 89 d1             	mov    %rdx,%rcx
  803680:	ba 00 00 00 00       	mov    $0x0,%edx
  803685:	48 89 c6             	mov    %rax,%rsi
  803688:	bf 00 00 00 00       	mov    $0x0,%edi
  80368d:	48 b8 ad 26 80 00 00 	movabs $0x8026ad,%rax
  803694:	00 00 00 
  803697:	ff d0                	callq  *%rax
  803699:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80369c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8036a0:	79 02                	jns    8036a4 <dup+0x11d>
			goto err;
  8036a2:	eb 57                	jmp    8036fb <dup+0x174>
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  8036a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8036a8:	48 c1 e8 0c          	shr    $0xc,%rax
  8036ac:	48 89 c2             	mov    %rax,%rdx
  8036af:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8036b6:	01 00 00 
  8036b9:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8036bd:	25 07 0e 00 00       	and    $0xe07,%eax
  8036c2:	89 c1                	mov    %eax,%ecx
  8036c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8036c8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8036cc:	41 89 c8             	mov    %ecx,%r8d
  8036cf:	48 89 d1             	mov    %rdx,%rcx
  8036d2:	ba 00 00 00 00       	mov    $0x0,%edx
  8036d7:	48 89 c6             	mov    %rax,%rsi
  8036da:	bf 00 00 00 00       	mov    $0x0,%edi
  8036df:	48 b8 ad 26 80 00 00 	movabs $0x8026ad,%rax
  8036e6:	00 00 00 
  8036e9:	ff d0                	callq  *%rax
  8036eb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8036ee:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8036f2:	79 02                	jns    8036f6 <dup+0x16f>
		goto err;
  8036f4:	eb 05                	jmp    8036fb <dup+0x174>

	return newfdnum;
  8036f6:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8036f9:	eb 33                	jmp    80372e <dup+0x1a7>

err:
	sys_page_unmap(0, newfd);
  8036fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8036ff:	48 89 c6             	mov    %rax,%rsi
  803702:	bf 00 00 00 00       	mov    $0x0,%edi
  803707:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  80370e:	00 00 00 
  803711:	ff d0                	callq  *%rax
	sys_page_unmap(0, nva);
  803713:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803717:	48 89 c6             	mov    %rax,%rsi
  80371a:	bf 00 00 00 00       	mov    $0x0,%edi
  80371f:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  803726:	00 00 00 
  803729:	ff d0                	callq  *%rax
	return r;
  80372b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80372e:	c9                   	leaveq 
  80372f:	c3                   	retq   

0000000000803730 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  803730:	55                   	push   %rbp
  803731:	48 89 e5             	mov    %rsp,%rbp
  803734:	48 83 ec 40          	sub    $0x40,%rsp
  803738:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80373b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80373f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;
	//cprintf("Inside Read");
	if ((r = fd_lookup(fdnum, &fd)) < 0
  803743:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803747:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80374a:	48 89 d6             	mov    %rdx,%rsi
  80374d:	89 c7                	mov    %eax,%edi
  80374f:	48 b8 fe 32 80 00 00 	movabs $0x8032fe,%rax
  803756:	00 00 00 
  803759:	ff d0                	callq  *%rax
  80375b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80375e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803762:	78 24                	js     803788 <read+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803764:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803768:	8b 00                	mov    (%rax),%eax
  80376a:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80376e:	48 89 d6             	mov    %rdx,%rsi
  803771:	89 c7                	mov    %eax,%edi
  803773:	48 b8 57 34 80 00 00 	movabs $0x803457,%rax
  80377a:	00 00 00 
  80377d:	ff d0                	callq  *%rax
  80377f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803782:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803786:	79 05                	jns    80378d <read+0x5d>
		return r;
  803788:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80378b:	eb 76                	jmp    803803 <read+0xd3>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80378d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803791:	8b 40 08             	mov    0x8(%rax),%eax
  803794:	83 e0 03             	and    $0x3,%eax
  803797:	83 f8 01             	cmp    $0x1,%eax
  80379a:	75 3a                	jne    8037d6 <read+0xa6>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80379c:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8037a3:	00 00 00 
  8037a6:	48 8b 00             	mov    (%rax),%rax
  8037a9:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8037af:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8037b2:	89 c6                	mov    %eax,%esi
  8037b4:	48 bf 3f 10 82 00 00 	movabs $0x82103f,%rdi
  8037bb:	00 00 00 
  8037be:	b8 00 00 00 00       	mov    $0x0,%eax
  8037c3:	48 b9 79 11 80 00 00 	movabs $0x801179,%rcx
  8037ca:	00 00 00 
  8037cd:	ff d1                	callq  *%rcx
		return -E_INVAL;
  8037cf:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8037d4:	eb 2d                	jmp    803803 <read+0xd3>
	}
	if (!dev->dev_read)
  8037d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8037da:	48 8b 40 10          	mov    0x10(%rax),%rax
  8037de:	48 85 c0             	test   %rax,%rax
  8037e1:	75 07                	jne    8037ea <read+0xba>
		return -E_NOT_SUPP;
  8037e3:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  8037e8:	eb 19                	jmp    803803 <read+0xd3>
	return (*dev->dev_read)(fd, buf, n);
  8037ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8037ee:	48 8b 40 10          	mov    0x10(%rax),%rax
  8037f2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8037f6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8037fa:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8037fe:	48 89 cf             	mov    %rcx,%rdi
  803801:	ff d0                	callq  *%rax
}
  803803:	c9                   	leaveq 
  803804:	c3                   	retq   

0000000000803805 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  803805:	55                   	push   %rbp
  803806:	48 89 e5             	mov    %rsp,%rbp
  803809:	48 83 ec 30          	sub    $0x30,%rsp
  80380d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803810:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803814:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803818:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80381f:	eb 49                	jmp    80386a <readn+0x65>
		m = read(fdnum, (char*)buf + tot, n - tot);
  803821:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803824:	48 98                	cltq   
  803826:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80382a:	48 29 c2             	sub    %rax,%rdx
  80382d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803830:	48 63 c8             	movslq %eax,%rcx
  803833:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803837:	48 01 c1             	add    %rax,%rcx
  80383a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80383d:	48 89 ce             	mov    %rcx,%rsi
  803840:	89 c7                	mov    %eax,%edi
  803842:	48 b8 30 37 80 00 00 	movabs $0x803730,%rax
  803849:	00 00 00 
  80384c:	ff d0                	callq  *%rax
  80384e:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m < 0)
  803851:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803855:	79 05                	jns    80385c <readn+0x57>
			return m;
  803857:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80385a:	eb 1c                	jmp    803878 <readn+0x73>
		if (m == 0)
  80385c:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803860:	75 02                	jne    803864 <readn+0x5f>
			break;
  803862:	eb 11                	jmp    803875 <readn+0x70>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803864:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803867:	01 45 fc             	add    %eax,-0x4(%rbp)
  80386a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80386d:	48 98                	cltq   
  80386f:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  803873:	72 ac                	jb     803821 <readn+0x1c>
		if (m < 0)
			return m;
		if (m == 0)
			break;
	}
	return tot;
  803875:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803878:	c9                   	leaveq 
  803879:	c3                   	retq   

000000000080387a <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80387a:	55                   	push   %rbp
  80387b:	48 89 e5             	mov    %rsp,%rbp
  80387e:	48 83 ec 40          	sub    $0x40,%rsp
  803882:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803885:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  803889:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80388d:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803891:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803894:	48 89 d6             	mov    %rdx,%rsi
  803897:	89 c7                	mov    %eax,%edi
  803899:	48 b8 fe 32 80 00 00 	movabs $0x8032fe,%rax
  8038a0:	00 00 00 
  8038a3:	ff d0                	callq  *%rax
  8038a5:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8038a8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8038ac:	78 24                	js     8038d2 <write+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8038ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8038b2:	8b 00                	mov    (%rax),%eax
  8038b4:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8038b8:	48 89 d6             	mov    %rdx,%rsi
  8038bb:	89 c7                	mov    %eax,%edi
  8038bd:	48 b8 57 34 80 00 00 	movabs $0x803457,%rax
  8038c4:	00 00 00 
  8038c7:	ff d0                	callq  *%rax
  8038c9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8038cc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8038d0:	79 05                	jns    8038d7 <write+0x5d>
		return r;
  8038d2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8038d5:	eb 75                	jmp    80394c <write+0xd2>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8038d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8038db:	8b 40 08             	mov    0x8(%rax),%eax
  8038de:	83 e0 03             	and    $0x3,%eax
  8038e1:	85 c0                	test   %eax,%eax
  8038e3:	75 3a                	jne    80391f <write+0xa5>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  8038e5:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8038ec:	00 00 00 
  8038ef:	48 8b 00             	mov    (%rax),%rax
  8038f2:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8038f8:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8038fb:	89 c6                	mov    %eax,%esi
  8038fd:	48 bf 5b 10 82 00 00 	movabs $0x82105b,%rdi
  803904:	00 00 00 
  803907:	b8 00 00 00 00       	mov    $0x0,%eax
  80390c:	48 b9 79 11 80 00 00 	movabs $0x801179,%rcx
  803913:	00 00 00 
  803916:	ff d1                	callq  *%rcx
		return -E_INVAL;
  803918:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80391d:	eb 2d                	jmp    80394c <write+0xd2>
	{
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
		sys_cputs(buf, n);
	}
	if (!dev->dev_write)
  80391f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803923:	48 8b 40 18          	mov    0x18(%rax),%rax
  803927:	48 85 c0             	test   %rax,%rax
  80392a:	75 07                	jne    803933 <write+0xb9>
		return -E_NOT_SUPP;
  80392c:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803931:	eb 19                	jmp    80394c <write+0xd2>
	return (*dev->dev_write)(fd, buf, n);
  803933:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803937:	48 8b 40 18          	mov    0x18(%rax),%rax
  80393b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80393f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803943:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  803947:	48 89 cf             	mov    %rcx,%rdi
  80394a:	ff d0                	callq  *%rax
}
  80394c:	c9                   	leaveq 
  80394d:	c3                   	retq   

000000000080394e <seek>:

int
seek(int fdnum, off_t offset)
{
  80394e:	55                   	push   %rbp
  80394f:	48 89 e5             	mov    %rsp,%rbp
  803952:	48 83 ec 18          	sub    $0x18,%rsp
  803956:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803959:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80395c:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803960:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803963:	48 89 d6             	mov    %rdx,%rsi
  803966:	89 c7                	mov    %eax,%edi
  803968:	48 b8 fe 32 80 00 00 	movabs $0x8032fe,%rax
  80396f:	00 00 00 
  803972:	ff d0                	callq  *%rax
  803974:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803977:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80397b:	79 05                	jns    803982 <seek+0x34>
		return r;
  80397d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803980:	eb 0f                	jmp    803991 <seek+0x43>
	fd->fd_offset = offset;
  803982:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803986:	8b 55 e8             	mov    -0x18(%rbp),%edx
  803989:	89 50 04             	mov    %edx,0x4(%rax)
	return 0;
  80398c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803991:	c9                   	leaveq 
  803992:	c3                   	retq   

0000000000803993 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  803993:	55                   	push   %rbp
  803994:	48 89 e5             	mov    %rsp,%rbp
  803997:	48 83 ec 30          	sub    $0x30,%rsp
  80399b:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80399e:	89 75 d8             	mov    %esi,-0x28(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  8039a1:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8039a5:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8039a8:	48 89 d6             	mov    %rdx,%rsi
  8039ab:	89 c7                	mov    %eax,%edi
  8039ad:	48 b8 fe 32 80 00 00 	movabs $0x8032fe,%rax
  8039b4:	00 00 00 
  8039b7:	ff d0                	callq  *%rax
  8039b9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8039bc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8039c0:	78 24                	js     8039e6 <ftruncate+0x53>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8039c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8039c6:	8b 00                	mov    (%rax),%eax
  8039c8:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8039cc:	48 89 d6             	mov    %rdx,%rsi
  8039cf:	89 c7                	mov    %eax,%edi
  8039d1:	48 b8 57 34 80 00 00 	movabs $0x803457,%rax
  8039d8:	00 00 00 
  8039db:	ff d0                	callq  *%rax
  8039dd:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8039e0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8039e4:	79 05                	jns    8039eb <ftruncate+0x58>
		return r;
  8039e6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8039e9:	eb 72                	jmp    803a5d <ftruncate+0xca>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8039eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8039ef:	8b 40 08             	mov    0x8(%rax),%eax
  8039f2:	83 e0 03             	and    $0x3,%eax
  8039f5:	85 c0                	test   %eax,%eax
  8039f7:	75 3a                	jne    803a33 <ftruncate+0xa0>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  8039f9:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803a00:	00 00 00 
  803a03:	48 8b 00             	mov    (%rax),%rax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  803a06:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803a0c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803a0f:	89 c6                	mov    %eax,%esi
  803a11:	48 bf 78 10 82 00 00 	movabs $0x821078,%rdi
  803a18:	00 00 00 
  803a1b:	b8 00 00 00 00       	mov    $0x0,%eax
  803a20:	48 b9 79 11 80 00 00 	movabs $0x801179,%rcx
  803a27:	00 00 00 
  803a2a:	ff d1                	callq  *%rcx
			thisenv->env_id, fdnum);
		return -E_INVAL;
  803a2c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803a31:	eb 2a                	jmp    803a5d <ftruncate+0xca>
	}
	if (!dev->dev_trunc)
  803a33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803a37:	48 8b 40 30          	mov    0x30(%rax),%rax
  803a3b:	48 85 c0             	test   %rax,%rax
  803a3e:	75 07                	jne    803a47 <ftruncate+0xb4>
		return -E_NOT_SUPP;
  803a40:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803a45:	eb 16                	jmp    803a5d <ftruncate+0xca>
	return (*dev->dev_trunc)(fd, newsize);
  803a47:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803a4b:	48 8b 40 30          	mov    0x30(%rax),%rax
  803a4f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  803a53:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  803a56:	89 ce                	mov    %ecx,%esi
  803a58:	48 89 d7             	mov    %rdx,%rdi
  803a5b:	ff d0                	callq  *%rax
}
  803a5d:	c9                   	leaveq 
  803a5e:	c3                   	retq   

0000000000803a5f <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  803a5f:	55                   	push   %rbp
  803a60:	48 89 e5             	mov    %rsp,%rbp
  803a63:	48 83 ec 30          	sub    $0x30,%rsp
  803a67:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803a6a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803a6e:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803a72:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803a75:	48 89 d6             	mov    %rdx,%rsi
  803a78:	89 c7                	mov    %eax,%edi
  803a7a:	48 b8 fe 32 80 00 00 	movabs $0x8032fe,%rax
  803a81:	00 00 00 
  803a84:	ff d0                	callq  *%rax
  803a86:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803a89:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803a8d:	78 24                	js     803ab3 <fstat+0x54>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803a8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803a93:	8b 00                	mov    (%rax),%eax
  803a95:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803a99:	48 89 d6             	mov    %rdx,%rsi
  803a9c:	89 c7                	mov    %eax,%edi
  803a9e:	48 b8 57 34 80 00 00 	movabs $0x803457,%rax
  803aa5:	00 00 00 
  803aa8:	ff d0                	callq  *%rax
  803aaa:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803aad:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803ab1:	79 05                	jns    803ab8 <fstat+0x59>
		return r;
  803ab3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ab6:	eb 5e                	jmp    803b16 <fstat+0xb7>
	if (!dev->dev_stat)
  803ab8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803abc:	48 8b 40 28          	mov    0x28(%rax),%rax
  803ac0:	48 85 c0             	test   %rax,%rax
  803ac3:	75 07                	jne    803acc <fstat+0x6d>
		return -E_NOT_SUPP;
  803ac5:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803aca:	eb 4a                	jmp    803b16 <fstat+0xb7>
	stat->st_name[0] = 0;
  803acc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803ad0:	c6 00 00             	movb   $0x0,(%rax)
	stat->st_size = 0;
  803ad3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803ad7:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%rax)
  803ade:	00 00 00 
	stat->st_isdir = 0;
  803ae1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803ae5:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  803aec:	00 00 00 
	stat->st_dev = dev;
  803aef:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  803af3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803af7:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	return (*dev->dev_stat)(fd, stat);
  803afe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b02:	48 8b 40 28          	mov    0x28(%rax),%rax
  803b06:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  803b0a:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  803b0e:	48 89 ce             	mov    %rcx,%rsi
  803b11:	48 89 d7             	mov    %rdx,%rdi
  803b14:	ff d0                	callq  *%rax
}
  803b16:	c9                   	leaveq 
  803b17:	c3                   	retq   

0000000000803b18 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  803b18:	55                   	push   %rbp
  803b19:	48 89 e5             	mov    %rsp,%rbp
  803b1c:	48 83 ec 20          	sub    $0x20,%rsp
  803b20:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803b24:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  803b28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803b2c:	be 00 00 00 00       	mov    $0x0,%esi
  803b31:	48 89 c7             	mov    %rax,%rdi
  803b34:	48 b8 06 3c 80 00 00 	movabs $0x803c06,%rax
  803b3b:	00 00 00 
  803b3e:	ff d0                	callq  *%rax
  803b40:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803b43:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803b47:	79 05                	jns    803b4e <stat+0x36>
		return fd;
  803b49:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b4c:	eb 2f                	jmp    803b7d <stat+0x65>
	r = fstat(fd, stat);
  803b4e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803b52:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b55:	48 89 d6             	mov    %rdx,%rsi
  803b58:	89 c7                	mov    %eax,%edi
  803b5a:	48 b8 5f 3a 80 00 00 	movabs $0x803a5f,%rax
  803b61:	00 00 00 
  803b64:	ff d0                	callq  *%rax
  803b66:	89 45 f8             	mov    %eax,-0x8(%rbp)
	close(fd);
  803b69:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b6c:	89 c7                	mov    %eax,%edi
  803b6e:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  803b75:	00 00 00 
  803b78:	ff d0                	callq  *%rax
	return r;
  803b7a:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  803b7d:	c9                   	leaveq 
  803b7e:	c3                   	retq   

0000000000803b7f <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  803b7f:	55                   	push   %rbp
  803b80:	48 89 e5             	mov    %rsp,%rbp
  803b83:	48 83 ec 10          	sub    $0x10,%rsp
  803b87:	89 7d fc             	mov    %edi,-0x4(%rbp)
  803b8a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	static envid_t fsenv;
	if (fsenv == 0)
  803b8e:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803b95:	00 00 00 
  803b98:	8b 00                	mov    (%rax),%eax
  803b9a:	85 c0                	test   %eax,%eax
  803b9c:	75 1d                	jne    803bbb <fsipc+0x3c>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  803b9e:	bf 01 00 00 00       	mov    $0x1,%edi
  803ba3:	48 b8 96 31 80 00 00 	movabs $0x803196,%rax
  803baa:	00 00 00 
  803bad:	ff d0                	callq  *%rax
  803baf:	48 ba 84 90 82 00 00 	movabs $0x829084,%rdx
  803bb6:	00 00 00 
  803bb9:	89 02                	mov    %eax,(%rdx)
	//static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  803bbb:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803bc2:	00 00 00 
  803bc5:	8b 00                	mov    (%rax),%eax
  803bc7:	8b 75 fc             	mov    -0x4(%rbp),%esi
  803bca:	b9 07 00 00 00       	mov    $0x7,%ecx
  803bcf:	48 ba 00 80 b5 00 00 	movabs $0xb58000,%rdx
  803bd6:	00 00 00 
  803bd9:	89 c7                	mov    %eax,%edi
  803bdb:	48 b8 34 31 80 00 00 	movabs $0x803134,%rax
  803be2:	00 00 00 
  803be5:	ff d0                	callq  *%rax
	return ipc_recv(NULL, dstva, NULL);
  803be7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803beb:	ba 00 00 00 00       	mov    $0x0,%edx
  803bf0:	48 89 c6             	mov    %rax,%rsi
  803bf3:	bf 00 00 00 00       	mov    $0x0,%edi
  803bf8:	48 b8 2e 30 80 00 00 	movabs $0x80302e,%rax
  803bff:	00 00 00 
  803c02:	ff d0                	callq  *%rax
}
  803c04:	c9                   	leaveq 
  803c05:	c3                   	retq   

0000000000803c06 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  803c06:	55                   	push   %rbp
  803c07:	48 89 e5             	mov    %rsp,%rbp
  803c0a:	48 83 ec 30          	sub    $0x30,%rsp
  803c0e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  803c12:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	// Return the file descriptor index.
	// If any step after fd_alloc fails, use fd_close to free the
	// file descriptor.

	// LAB 5: Your code here
	int r = -1;
  803c15:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
	int d = -1;
  803c1c:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%rbp)
	int len = 0;
  803c23:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	void *va;
	if(!path)
  803c2a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  803c2f:	75 08                	jne    803c39 <open+0x33>
	{
		return r;
  803c31:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803c34:	e9 f2 00 00 00       	jmpq   803d2b <open+0x125>
	}	
	else if((len = strlen(path)) >= MAXPATHLEN) 
  803c39:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803c3d:	48 89 c7             	mov    %rax,%rdi
  803c40:	48 b8 c2 1c 80 00 00 	movabs $0x801cc2,%rax
  803c47:	00 00 00 
  803c4a:	ff d0                	callq  *%rax
  803c4c:	89 45 f4             	mov    %eax,-0xc(%rbp)
  803c4f:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%rbp)
  803c56:	7e 0a                	jle    803c62 <open+0x5c>
	{
		return -E_BAD_PATH;
  803c58:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  803c5d:	e9 c9 00 00 00       	jmpq   803d2b <open+0x125>
	}
	else
	{
		struct Fd *fd_store = NULL;
  803c62:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  803c69:	00 
		if((r = fd_alloc(&fd_store)) < 0 || fd_store == NULL)
  803c6a:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  803c6e:	48 89 c7             	mov    %rax,%rdi
  803c71:	48 b8 66 32 80 00 00 	movabs $0x803266,%rax
  803c78:	00 00 00 
  803c7b:	ff d0                	callq  *%rax
  803c7d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803c80:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803c84:	78 09                	js     803c8f <open+0x89>
  803c86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803c8a:	48 85 c0             	test   %rax,%rax
  803c8d:	75 08                	jne    803c97 <open+0x91>
		{
			return r;
  803c8f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803c92:	e9 94 00 00 00       	jmpq   803d2b <open+0x125>
		}	
		strncpy(fsipcbuf.open.req_path,  path, MAXPATHLEN);
  803c97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803c9b:	ba 00 04 00 00       	mov    $0x400,%edx
  803ca0:	48 89 c6             	mov    %rax,%rsi
  803ca3:	48 bf 00 80 b5 00 00 	movabs $0xb58000,%rdi
  803caa:	00 00 00 
  803cad:	48 b8 c0 1d 80 00 00 	movabs $0x801dc0,%rax
  803cb4:	00 00 00 
  803cb7:	ff d0                	callq  *%rax
		fsipcbuf.open.req_omode = mode;
  803cb9:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803cc0:	00 00 00 
  803cc3:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  803cc6:	89 90 00 04 00 00    	mov    %edx,0x400(%rax)
		if ((r = fsipc(FSREQ_OPEN, fd_store)) < 0)
  803ccc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803cd0:	48 89 c6             	mov    %rax,%rsi
  803cd3:	bf 01 00 00 00       	mov    $0x1,%edi
  803cd8:	48 b8 7f 3b 80 00 00 	movabs $0x803b7f,%rax
  803cdf:	00 00 00 
  803ce2:	ff d0                	callq  *%rax
  803ce4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803ce7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803ceb:	79 2b                	jns    803d18 <open+0x112>
		{
			if((d = fd_close(fd_store, 0)) < 0)
  803ced:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803cf1:	be 00 00 00 00       	mov    $0x0,%esi
  803cf6:	48 89 c7             	mov    %rax,%rdi
  803cf9:	48 b8 8e 33 80 00 00 	movabs $0x80338e,%rax
  803d00:	00 00 00 
  803d03:	ff d0                	callq  *%rax
  803d05:	89 45 f8             	mov    %eax,-0x8(%rbp)
  803d08:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803d0c:	79 05                	jns    803d13 <open+0x10d>
			{
				return d;
  803d0e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803d11:	eb 18                	jmp    803d2b <open+0x125>
			}
			return r;
  803d13:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d16:	eb 13                	jmp    803d2b <open+0x125>
		}	
		return fd2num(fd_store);
  803d18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803d1c:	48 89 c7             	mov    %rax,%rdi
  803d1f:	48 b8 18 32 80 00 00 	movabs $0x803218,%rax
  803d26:	00 00 00 
  803d29:	ff d0                	callq  *%rax
	}
	//panic ("open not implemented");
}
  803d2b:	c9                   	leaveq 
  803d2c:	c3                   	retq   

0000000000803d2d <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  803d2d:	55                   	push   %rbp
  803d2e:	48 89 e5             	mov    %rsp,%rbp
  803d31:	48 83 ec 10          	sub    $0x10,%rsp
  803d35:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  803d39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803d3d:	8b 50 0c             	mov    0xc(%rax),%edx
  803d40:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803d47:	00 00 00 
  803d4a:	89 10                	mov    %edx,(%rax)
	return fsipc(FSREQ_FLUSH, NULL);
  803d4c:	be 00 00 00 00       	mov    $0x0,%esi
  803d51:	bf 06 00 00 00       	mov    $0x6,%edi
  803d56:	48 b8 7f 3b 80 00 00 	movabs $0x803b7f,%rax
  803d5d:	00 00 00 
  803d60:	ff d0                	callq  *%rax
}
  803d62:	c9                   	leaveq 
  803d63:	c3                   	retq   

0000000000803d64 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  803d64:	55                   	push   %rbp
  803d65:	48 89 e5             	mov    %rsp,%rbp
  803d68:	48 83 ec 30          	sub    $0x30,%rsp
  803d6c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803d70:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803d74:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Make an FSREQ_READ request to the file system server after
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	// LAB 5: Your code here
	int r = 0;
  803d78:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	if(!fd || !buf)
  803d7f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  803d84:	74 07                	je     803d8d <devfile_read+0x29>
  803d86:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  803d8b:	75 07                	jne    803d94 <devfile_read+0x30>
		return -E_INVAL;
  803d8d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803d92:	eb 77                	jmp    803e0b <devfile_read+0xa7>
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  803d94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803d98:	8b 50 0c             	mov    0xc(%rax),%edx
  803d9b:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803da2:	00 00 00 
  803da5:	89 10                	mov    %edx,(%rax)
	fsipcbuf.read.req_n = n;
  803da7:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803dae:	00 00 00 
  803db1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803db5:	48 89 50 08          	mov    %rdx,0x8(%rax)
	if ((r = fsipc(FSREQ_READ, NULL)) <= 0){
  803db9:	be 00 00 00 00       	mov    $0x0,%esi
  803dbe:	bf 03 00 00 00       	mov    $0x3,%edi
  803dc3:	48 b8 7f 3b 80 00 00 	movabs $0x803b7f,%rax
  803dca:	00 00 00 
  803dcd:	ff d0                	callq  *%rax
  803dcf:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803dd2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803dd6:	7f 05                	jg     803ddd <devfile_read+0x79>
		//cprintf("devfile_read r is [%d]\n",r);
		return r;
  803dd8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ddb:	eb 2e                	jmp    803e0b <devfile_read+0xa7>
	}
	//cprintf("devfile_read %x %x %x %x\n",fsipcbuf.readRet.ret_buf[0], fsipcbuf.readRet.ret_buf[1], fsipcbuf.readRet.ret_buf[2], fsipcbuf.readRet.ret_buf[3]);
	memmove(buf, (char*)fsipcbuf.readRet.ret_buf, r);
  803ddd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803de0:	48 63 d0             	movslq %eax,%rdx
  803de3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803de7:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  803dee:	00 00 00 
  803df1:	48 89 c7             	mov    %rax,%rdi
  803df4:	48 b8 52 20 80 00 00 	movabs $0x802052,%rax
  803dfb:	00 00 00 
  803dfe:	ff d0                	callq  *%rax
	char* buf1 = (char*)buf;
  803e00:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803e04:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	//cprintf("devfile_read ri is [%d] %x %x %x %x\n",r,buf1[0],buf1[1],buf1[2],buf1[3]);
	return r;
  803e08:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("devfile_read not implemented");
}
  803e0b:	c9                   	leaveq 
  803e0c:	c3                   	retq   

0000000000803e0d <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  803e0d:	55                   	push   %rbp
  803e0e:	48 89 e5             	mov    %rsp,%rbp
  803e11:	48 83 ec 30          	sub    $0x30,%rsp
  803e15:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803e19:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803e1d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Make an FSREQ_WRITE request to the file system server.  Be
	// careful: fsipcbuf.write.req_buf is only so large, but
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
	int r = -1;
  803e21:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
	if(!fd || !buf)
  803e28:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  803e2d:	74 07                	je     803e36 <devfile_write+0x29>
  803e2f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  803e34:	75 08                	jne    803e3e <devfile_write+0x31>
		return r;
  803e36:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e39:	e9 9a 00 00 00       	jmpq   803ed8 <devfile_write+0xcb>
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  803e3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803e42:	8b 50 0c             	mov    0xc(%rax),%edx
  803e45:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803e4c:	00 00 00 
  803e4f:	89 10                	mov    %edx,(%rax)
	if(n > PGSIZE - (sizeof(int) + sizeof(size_t)))
  803e51:	48 81 7d d8 f4 0f 00 	cmpq   $0xff4,-0x28(%rbp)
  803e58:	00 
  803e59:	76 08                	jbe    803e63 <devfile_write+0x56>
	{
		n = PGSIZE - (sizeof(int) + sizeof(size_t));
  803e5b:	48 c7 45 d8 f4 0f 00 	movq   $0xff4,-0x28(%rbp)
  803e62:	00 
	}
	fsipcbuf.write.req_n = n;
  803e63:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803e6a:	00 00 00 
  803e6d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803e71:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	memmove((void*)fsipcbuf.write.req_buf, (void*)buf, n);
  803e75:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803e79:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803e7d:	48 89 c6             	mov    %rax,%rsi
  803e80:	48 bf 10 80 b5 00 00 	movabs $0xb58010,%rdi
  803e87:	00 00 00 
  803e8a:	48 b8 52 20 80 00 00 	movabs $0x802052,%rax
  803e91:	00 00 00 
  803e94:	ff d0                	callq  *%rax
	if ((r = fsipc(FSREQ_WRITE, NULL)) <= 0){
  803e96:	be 00 00 00 00       	mov    $0x0,%esi
  803e9b:	bf 04 00 00 00       	mov    $0x4,%edi
  803ea0:	48 b8 7f 3b 80 00 00 	movabs $0x803b7f,%rax
  803ea7:	00 00 00 
  803eaa:	ff d0                	callq  *%rax
  803eac:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803eaf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803eb3:	7f 20                	jg     803ed5 <devfile_write+0xc8>
		cprintf("fsipc-FSREQ_WRITE returns 0");
  803eb5:	48 bf 9e 10 82 00 00 	movabs $0x82109e,%rdi
  803ebc:	00 00 00 
  803ebf:	b8 00 00 00 00       	mov    $0x0,%eax
  803ec4:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  803ecb:	00 00 00 
  803ece:	ff d2                	callq  *%rdx
		return r;
  803ed0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ed3:	eb 03                	jmp    803ed8 <devfile_write+0xcb>
	}
	return r;
  803ed5:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("devfile_write not implemented");
}
  803ed8:	c9                   	leaveq 
  803ed9:	c3                   	retq   

0000000000803eda <devfile_stat>:


static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  803eda:	55                   	push   %rbp
  803edb:	48 89 e5             	mov    %rsp,%rbp
  803ede:	48 83 ec 20          	sub    $0x20,%rsp
  803ee2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803ee6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  803eea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803eee:	8b 50 0c             	mov    0xc(%rax),%edx
  803ef1:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803ef8:	00 00 00 
  803efb:	89 10                	mov    %edx,(%rax)
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  803efd:	be 00 00 00 00       	mov    $0x0,%esi
  803f02:	bf 05 00 00 00       	mov    $0x5,%edi
  803f07:	48 b8 7f 3b 80 00 00 	movabs $0x803b7f,%rax
  803f0e:	00 00 00 
  803f11:	ff d0                	callq  *%rax
  803f13:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803f16:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803f1a:	79 05                	jns    803f21 <devfile_stat+0x47>
		return r;
  803f1c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803f1f:	eb 56                	jmp    803f77 <devfile_stat+0x9d>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  803f21:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803f25:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  803f2c:	00 00 00 
  803f2f:	48 89 c7             	mov    %rax,%rdi
  803f32:	48 b8 2e 1d 80 00 00 	movabs $0x801d2e,%rax
  803f39:	00 00 00 
  803f3c:	ff d0                	callq  *%rax
	st->st_size = fsipcbuf.statRet.ret_size;
  803f3e:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803f45:	00 00 00 
  803f48:	8b 90 80 00 00 00    	mov    0x80(%rax),%edx
  803f4e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803f52:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  803f58:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803f5f:	00 00 00 
  803f62:	8b 90 84 00 00 00    	mov    0x84(%rax),%edx
  803f68:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803f6c:	89 90 84 00 00 00    	mov    %edx,0x84(%rax)
	return 0;
  803f72:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803f77:	c9                   	leaveq 
  803f78:	c3                   	retq   

0000000000803f79 <devfile_trunc>:

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  803f79:	55                   	push   %rbp
  803f7a:	48 89 e5             	mov    %rsp,%rbp
  803f7d:	48 83 ec 10          	sub    $0x10,%rsp
  803f81:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  803f85:	89 75 f4             	mov    %esi,-0xc(%rbp)
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  803f88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803f8c:	8b 50 0c             	mov    0xc(%rax),%edx
  803f8f:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803f96:	00 00 00 
  803f99:	89 10                	mov    %edx,(%rax)
	fsipcbuf.set_size.req_size = newsize;
  803f9b:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803fa2:	00 00 00 
  803fa5:	8b 55 f4             	mov    -0xc(%rbp),%edx
  803fa8:	89 50 04             	mov    %edx,0x4(%rax)
	return fsipc(FSREQ_SET_SIZE, NULL);
  803fab:	be 00 00 00 00       	mov    $0x0,%esi
  803fb0:	bf 02 00 00 00       	mov    $0x2,%edi
  803fb5:	48 b8 7f 3b 80 00 00 	movabs $0x803b7f,%rax
  803fbc:	00 00 00 
  803fbf:	ff d0                	callq  *%rax
}
  803fc1:	c9                   	leaveq 
  803fc2:	c3                   	retq   

0000000000803fc3 <remove>:

// Delete a file
int
remove(const char *path)
{
  803fc3:	55                   	push   %rbp
  803fc4:	48 89 e5             	mov    %rsp,%rbp
  803fc7:	48 83 ec 10          	sub    $0x10,%rsp
  803fcb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (strlen(path) >= MAXPATHLEN)
  803fcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803fd3:	48 89 c7             	mov    %rax,%rdi
  803fd6:	48 b8 c2 1c 80 00 00 	movabs $0x801cc2,%rax
  803fdd:	00 00 00 
  803fe0:	ff d0                	callq  *%rax
  803fe2:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  803fe7:	7e 07                	jle    803ff0 <remove+0x2d>
		return -E_BAD_PATH;
  803fe9:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  803fee:	eb 33                	jmp    804023 <remove+0x60>
	strcpy(fsipcbuf.remove.req_path, path);
  803ff0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803ff4:	48 89 c6             	mov    %rax,%rsi
  803ff7:	48 bf 00 80 b5 00 00 	movabs $0xb58000,%rdi
  803ffe:	00 00 00 
  804001:	48 b8 2e 1d 80 00 00 	movabs $0x801d2e,%rax
  804008:	00 00 00 
  80400b:	ff d0                	callq  *%rax
	return fsipc(FSREQ_REMOVE, NULL);
  80400d:	be 00 00 00 00       	mov    $0x0,%esi
  804012:	bf 07 00 00 00       	mov    $0x7,%edi
  804017:	48 b8 7f 3b 80 00 00 	movabs $0x803b7f,%rax
  80401e:	00 00 00 
  804021:	ff d0                	callq  *%rax
}
  804023:	c9                   	leaveq 
  804024:	c3                   	retq   

0000000000804025 <sync>:

// Synchronize disk with buffer cache
int
sync(void)
{
  804025:	55                   	push   %rbp
  804026:	48 89 e5             	mov    %rsp,%rbp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  804029:	be 00 00 00 00       	mov    $0x0,%esi
  80402e:	bf 08 00 00 00       	mov    $0x8,%edi
  804033:	48 b8 7f 3b 80 00 00 	movabs $0x803b7f,%rax
  80403a:	00 00 00 
  80403d:	ff d0                	callq  *%rax
}
  80403f:	5d                   	pop    %rbp
  804040:	c3                   	retq   

0000000000804041 <copy>:

//Copy a file from src to dest
int
copy(char *src, char *dest)
{
  804041:	55                   	push   %rbp
  804042:	48 89 e5             	mov    %rsp,%rbp
  804045:	48 81 ec 20 02 00 00 	sub    $0x220,%rsp
  80404c:	48 89 bd e8 fd ff ff 	mov    %rdi,-0x218(%rbp)
  804053:	48 89 b5 e0 fd ff ff 	mov    %rsi,-0x220(%rbp)
	int r;
	int fd_src, fd_dest;
	char buffer[512];	//keep this small
	ssize_t read_size;
	ssize_t write_size;
	fd_src = open(src, O_RDONLY);
  80405a:	48 8b 85 e8 fd ff ff 	mov    -0x218(%rbp),%rax
  804061:	be 00 00 00 00       	mov    $0x0,%esi
  804066:	48 89 c7             	mov    %rax,%rdi
  804069:	48 b8 06 3c 80 00 00 	movabs $0x803c06,%rax
  804070:	00 00 00 
  804073:	ff d0                	callq  *%rax
  804075:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (fd_src < 0) {	//error
  804078:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80407c:	79 28                	jns    8040a6 <copy+0x65>
		cprintf("cp open src error:%e\n", fd_src);
  80407e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804081:	89 c6                	mov    %eax,%esi
  804083:	48 bf ba 10 82 00 00 	movabs $0x8210ba,%rdi
  80408a:	00 00 00 
  80408d:	b8 00 00 00 00       	mov    $0x0,%eax
  804092:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  804099:	00 00 00 
  80409c:	ff d2                	callq  *%rdx
		return fd_src;
  80409e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8040a1:	e9 74 01 00 00       	jmpq   80421a <copy+0x1d9>
	}
	
	fd_dest = open(dest, O_CREAT | O_WRONLY);
  8040a6:	48 8b 85 e0 fd ff ff 	mov    -0x220(%rbp),%rax
  8040ad:	be 01 01 00 00       	mov    $0x101,%esi
  8040b2:	48 89 c7             	mov    %rax,%rdi
  8040b5:	48 b8 06 3c 80 00 00 	movabs $0x803c06,%rax
  8040bc:	00 00 00 
  8040bf:	ff d0                	callq  *%rax
  8040c1:	89 45 f8             	mov    %eax,-0x8(%rbp)
	if (fd_dest < 0) {	//error
  8040c4:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8040c8:	79 39                	jns    804103 <copy+0xc2>
		cprintf("cp create dest  error:%e\n", fd_dest);
  8040ca:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8040cd:	89 c6                	mov    %eax,%esi
  8040cf:	48 bf d0 10 82 00 00 	movabs $0x8210d0,%rdi
  8040d6:	00 00 00 
  8040d9:	b8 00 00 00 00       	mov    $0x0,%eax
  8040de:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  8040e5:	00 00 00 
  8040e8:	ff d2                	callq  *%rdx
		close(fd_src);
  8040ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8040ed:	89 c7                	mov    %eax,%edi
  8040ef:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  8040f6:	00 00 00 
  8040f9:	ff d0                	callq  *%rax
		return fd_dest;
  8040fb:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8040fe:	e9 17 01 00 00       	jmpq   80421a <copy+0x1d9>
	}
	
	while ((read_size = read(fd_src, buffer, 512)) > 0) {
  804103:	eb 74                	jmp    804179 <copy+0x138>
		write_size = write(fd_dest, buffer, read_size);
  804105:	8b 45 f4             	mov    -0xc(%rbp),%eax
  804108:	48 63 d0             	movslq %eax,%rdx
  80410b:	48 8d 8d f0 fd ff ff 	lea    -0x210(%rbp),%rcx
  804112:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804115:	48 89 ce             	mov    %rcx,%rsi
  804118:	89 c7                	mov    %eax,%edi
  80411a:	48 b8 7a 38 80 00 00 	movabs $0x80387a,%rax
  804121:	00 00 00 
  804124:	ff d0                	callq  *%rax
  804126:	89 45 f0             	mov    %eax,-0x10(%rbp)
		if (write_size < 0) {
  804129:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  80412d:	79 4a                	jns    804179 <copy+0x138>
			cprintf("cp write error:%e\n", write_size);
  80412f:	8b 45 f0             	mov    -0x10(%rbp),%eax
  804132:	89 c6                	mov    %eax,%esi
  804134:	48 bf ea 10 82 00 00 	movabs $0x8210ea,%rdi
  80413b:	00 00 00 
  80413e:	b8 00 00 00 00       	mov    $0x0,%eax
  804143:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  80414a:	00 00 00 
  80414d:	ff d2                	callq  *%rdx
			close(fd_src);
  80414f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804152:	89 c7                	mov    %eax,%edi
  804154:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  80415b:	00 00 00 
  80415e:	ff d0                	callq  *%rax
			close(fd_dest);
  804160:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804163:	89 c7                	mov    %eax,%edi
  804165:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  80416c:	00 00 00 
  80416f:	ff d0                	callq  *%rax
			return write_size;
  804171:	8b 45 f0             	mov    -0x10(%rbp),%eax
  804174:	e9 a1 00 00 00       	jmpq   80421a <copy+0x1d9>
		cprintf("cp create dest  error:%e\n", fd_dest);
		close(fd_src);
		return fd_dest;
	}
	
	while ((read_size = read(fd_src, buffer, 512)) > 0) {
  804179:	48 8d 8d f0 fd ff ff 	lea    -0x210(%rbp),%rcx
  804180:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804183:	ba 00 02 00 00       	mov    $0x200,%edx
  804188:	48 89 ce             	mov    %rcx,%rsi
  80418b:	89 c7                	mov    %eax,%edi
  80418d:	48 b8 30 37 80 00 00 	movabs $0x803730,%rax
  804194:	00 00 00 
  804197:	ff d0                	callq  *%rax
  804199:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80419c:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8041a0:	0f 8f 5f ff ff ff    	jg     804105 <copy+0xc4>
			close(fd_src);
			close(fd_dest);
			return write_size;
		}		
	}
	if (read_size < 0) {
  8041a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8041aa:	79 47                	jns    8041f3 <copy+0x1b2>
		cprintf("cp read src error:%e\n", read_size);
  8041ac:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8041af:	89 c6                	mov    %eax,%esi
  8041b1:	48 bf fd 10 82 00 00 	movabs $0x8210fd,%rdi
  8041b8:	00 00 00 
  8041bb:	b8 00 00 00 00       	mov    $0x0,%eax
  8041c0:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  8041c7:	00 00 00 
  8041ca:	ff d2                	callq  *%rdx
		close(fd_src);
  8041cc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8041cf:	89 c7                	mov    %eax,%edi
  8041d1:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  8041d8:	00 00 00 
  8041db:	ff d0                	callq  *%rax
		close(fd_dest);
  8041dd:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8041e0:	89 c7                	mov    %eax,%edi
  8041e2:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  8041e9:	00 00 00 
  8041ec:	ff d0                	callq  *%rax
		return read_size;
  8041ee:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8041f1:	eb 27                	jmp    80421a <copy+0x1d9>
	}
	close(fd_src);
  8041f3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8041f6:	89 c7                	mov    %eax,%edi
  8041f8:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  8041ff:	00 00 00 
  804202:	ff d0                	callq  *%rax
	close(fd_dest);
  804204:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804207:	89 c7                	mov    %eax,%edi
  804209:	48 b8 0e 35 80 00 00 	movabs $0x80350e,%rax
  804210:	00 00 00 
  804213:	ff d0                	callq  *%rax
	return 0;
  804215:	b8 00 00 00 00       	mov    $0x0,%eax
	
}
  80421a:	c9                   	leaveq 
  80421b:	c3                   	retq   

000000000080421c <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  80421c:	55                   	push   %rbp
  80421d:	48 89 e5             	mov    %rsp,%rbp
  804220:	48 83 ec 20          	sub    $0x20,%rsp
  804224:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  804227:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80422b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80422e:	48 89 d6             	mov    %rdx,%rsi
  804231:	89 c7                	mov    %eax,%edi
  804233:	48 b8 fe 32 80 00 00 	movabs $0x8032fe,%rax
  80423a:	00 00 00 
  80423d:	ff d0                	callq  *%rax
  80423f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804242:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804246:	79 05                	jns    80424d <fd2sockid+0x31>
		return r;
  804248:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80424b:	eb 24                	jmp    804271 <fd2sockid+0x55>
	if (sfd->fd_dev_id != devsock.dev_id)
  80424d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804251:	8b 10                	mov    (%rax),%edx
  804253:	48 b8 a0 80 82 00 00 	movabs $0x8280a0,%rax
  80425a:	00 00 00 
  80425d:	8b 00                	mov    (%rax),%eax
  80425f:	39 c2                	cmp    %eax,%edx
  804261:	74 07                	je     80426a <fd2sockid+0x4e>
		return -E_NOT_SUPP;
  804263:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  804268:	eb 07                	jmp    804271 <fd2sockid+0x55>
	return sfd->fd_sock.sockid;
  80426a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80426e:	8b 40 0c             	mov    0xc(%rax),%eax
}
  804271:	c9                   	leaveq 
  804272:	c3                   	retq   

0000000000804273 <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  804273:	55                   	push   %rbp
  804274:	48 89 e5             	mov    %rsp,%rbp
  804277:	48 83 ec 20          	sub    $0x20,%rsp
  80427b:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  80427e:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  804282:	48 89 c7             	mov    %rax,%rdi
  804285:	48 b8 66 32 80 00 00 	movabs $0x803266,%rax
  80428c:	00 00 00 
  80428f:	ff d0                	callq  *%rax
  804291:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804294:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804298:	78 26                	js     8042c0 <alloc_sockfd+0x4d>
            || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  80429a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80429e:	ba 07 04 00 00       	mov    $0x407,%edx
  8042a3:	48 89 c6             	mov    %rax,%rsi
  8042a6:	bf 00 00 00 00       	mov    $0x0,%edi
  8042ab:	48 b8 5d 26 80 00 00 	movabs $0x80265d,%rax
  8042b2:	00 00 00 
  8042b5:	ff d0                	callq  *%rax
  8042b7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8042ba:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8042be:	79 16                	jns    8042d6 <alloc_sockfd+0x63>
		nsipc_close(sockid);
  8042c0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8042c3:	89 c7                	mov    %eax,%edi
  8042c5:	48 b8 80 47 80 00 00 	movabs $0x804780,%rax
  8042cc:	00 00 00 
  8042cf:	ff d0                	callq  *%rax
		return r;
  8042d1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8042d4:	eb 3a                	jmp    804310 <alloc_sockfd+0x9d>
	}

	sfd->fd_dev_id = devsock.dev_id;
  8042d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8042da:	48 ba a0 80 82 00 00 	movabs $0x8280a0,%rdx
  8042e1:	00 00 00 
  8042e4:	8b 12                	mov    (%rdx),%edx
  8042e6:	89 10                	mov    %edx,(%rax)
	sfd->fd_omode = O_RDWR;
  8042e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8042ec:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	sfd->fd_sock.sockid = sockid;
  8042f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8042f7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8042fa:	89 50 0c             	mov    %edx,0xc(%rax)
	return fd2num(sfd);
  8042fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804301:	48 89 c7             	mov    %rax,%rdi
  804304:	48 b8 18 32 80 00 00 	movabs $0x803218,%rax
  80430b:	00 00 00 
  80430e:	ff d0                	callq  *%rax
}
  804310:	c9                   	leaveq 
  804311:	c3                   	retq   

0000000000804312 <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  804312:	55                   	push   %rbp
  804313:	48 89 e5             	mov    %rsp,%rbp
  804316:	48 83 ec 30          	sub    $0x30,%rsp
  80431a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80431d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804321:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804325:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804328:	89 c7                	mov    %eax,%edi
  80432a:	48 b8 1c 42 80 00 00 	movabs $0x80421c,%rax
  804331:	00 00 00 
  804334:	ff d0                	callq  *%rax
  804336:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804339:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80433d:	79 05                	jns    804344 <accept+0x32>
		return r;
  80433f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804342:	eb 3b                	jmp    80437f <accept+0x6d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  804344:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  804348:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80434c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80434f:	48 89 ce             	mov    %rcx,%rsi
  804352:	89 c7                	mov    %eax,%edi
  804354:	48 b8 5d 46 80 00 00 	movabs $0x80465d,%rax
  80435b:	00 00 00 
  80435e:	ff d0                	callq  *%rax
  804360:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804363:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804367:	79 05                	jns    80436e <accept+0x5c>
		return r;
  804369:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80436c:	eb 11                	jmp    80437f <accept+0x6d>
	return alloc_sockfd(r);
  80436e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804371:	89 c7                	mov    %eax,%edi
  804373:	48 b8 73 42 80 00 00 	movabs $0x804273,%rax
  80437a:	00 00 00 
  80437d:	ff d0                	callq  *%rax
}
  80437f:	c9                   	leaveq 
  804380:	c3                   	retq   

0000000000804381 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  804381:	55                   	push   %rbp
  804382:	48 89 e5             	mov    %rsp,%rbp
  804385:	48 83 ec 20          	sub    $0x20,%rsp
  804389:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80438c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804390:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804393:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804396:	89 c7                	mov    %eax,%edi
  804398:	48 b8 1c 42 80 00 00 	movabs $0x80421c,%rax
  80439f:	00 00 00 
  8043a2:	ff d0                	callq  *%rax
  8043a4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8043a7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8043ab:	79 05                	jns    8043b2 <bind+0x31>
		return r;
  8043ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8043b0:	eb 1b                	jmp    8043cd <bind+0x4c>
	return nsipc_bind(r, name, namelen);
  8043b2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8043b5:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8043b9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8043bc:	48 89 ce             	mov    %rcx,%rsi
  8043bf:	89 c7                	mov    %eax,%edi
  8043c1:	48 b8 dc 46 80 00 00 	movabs $0x8046dc,%rax
  8043c8:	00 00 00 
  8043cb:	ff d0                	callq  *%rax
}
  8043cd:	c9                   	leaveq 
  8043ce:	c3                   	retq   

00000000008043cf <shutdown>:

int
shutdown(int s, int how)
{
  8043cf:	55                   	push   %rbp
  8043d0:	48 89 e5             	mov    %rsp,%rbp
  8043d3:	48 83 ec 20          	sub    $0x20,%rsp
  8043d7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8043da:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8043dd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8043e0:	89 c7                	mov    %eax,%edi
  8043e2:	48 b8 1c 42 80 00 00 	movabs $0x80421c,%rax
  8043e9:	00 00 00 
  8043ec:	ff d0                	callq  *%rax
  8043ee:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8043f1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8043f5:	79 05                	jns    8043fc <shutdown+0x2d>
		return r;
  8043f7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8043fa:	eb 16                	jmp    804412 <shutdown+0x43>
	return nsipc_shutdown(r, how);
  8043fc:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8043ff:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804402:	89 d6                	mov    %edx,%esi
  804404:	89 c7                	mov    %eax,%edi
  804406:	48 b8 40 47 80 00 00 	movabs $0x804740,%rax
  80440d:	00 00 00 
  804410:	ff d0                	callq  *%rax
}
  804412:	c9                   	leaveq 
  804413:	c3                   	retq   

0000000000804414 <devsock_close>:

static int
devsock_close(struct Fd *fd)
{
  804414:	55                   	push   %rbp
  804415:	48 89 e5             	mov    %rsp,%rbp
  804418:	48 83 ec 10          	sub    $0x10,%rsp
  80441c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (pageref(fd) == 1)
  804420:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804424:	48 89 c7             	mov    %rax,%rdi
  804427:	48 b8 6e 59 80 00 00 	movabs $0x80596e,%rax
  80442e:	00 00 00 
  804431:	ff d0                	callq  *%rax
  804433:	83 f8 01             	cmp    $0x1,%eax
  804436:	75 17                	jne    80444f <devsock_close+0x3b>
		return nsipc_close(fd->fd_sock.sockid);
  804438:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80443c:	8b 40 0c             	mov    0xc(%rax),%eax
  80443f:	89 c7                	mov    %eax,%edi
  804441:	48 b8 80 47 80 00 00 	movabs $0x804780,%rax
  804448:	00 00 00 
  80444b:	ff d0                	callq  *%rax
  80444d:	eb 05                	jmp    804454 <devsock_close+0x40>
	else
		return 0;
  80444f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804454:	c9                   	leaveq 
  804455:	c3                   	retq   

0000000000804456 <connect>:

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804456:	55                   	push   %rbp
  804457:	48 89 e5             	mov    %rsp,%rbp
  80445a:	48 83 ec 20          	sub    $0x20,%rsp
  80445e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804461:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804465:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804468:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80446b:	89 c7                	mov    %eax,%edi
  80446d:	48 b8 1c 42 80 00 00 	movabs $0x80421c,%rax
  804474:	00 00 00 
  804477:	ff d0                	callq  *%rax
  804479:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80447c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804480:	79 05                	jns    804487 <connect+0x31>
		return r;
  804482:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804485:	eb 1b                	jmp    8044a2 <connect+0x4c>
	return nsipc_connect(r, name, namelen);
  804487:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80448a:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80448e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804491:	48 89 ce             	mov    %rcx,%rsi
  804494:	89 c7                	mov    %eax,%edi
  804496:	48 b8 ad 47 80 00 00 	movabs $0x8047ad,%rax
  80449d:	00 00 00 
  8044a0:	ff d0                	callq  *%rax
}
  8044a2:	c9                   	leaveq 
  8044a3:	c3                   	retq   

00000000008044a4 <listen>:

int
listen(int s, int backlog)
{
  8044a4:	55                   	push   %rbp
  8044a5:	48 89 e5             	mov    %rsp,%rbp
  8044a8:	48 83 ec 20          	sub    $0x20,%rsp
  8044ac:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8044af:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8044b2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8044b5:	89 c7                	mov    %eax,%edi
  8044b7:	48 b8 1c 42 80 00 00 	movabs $0x80421c,%rax
  8044be:	00 00 00 
  8044c1:	ff d0                	callq  *%rax
  8044c3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8044c6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8044ca:	79 05                	jns    8044d1 <listen+0x2d>
		return r;
  8044cc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8044cf:	eb 16                	jmp    8044e7 <listen+0x43>
	return nsipc_listen(r, backlog);
  8044d1:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8044d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8044d7:	89 d6                	mov    %edx,%esi
  8044d9:	89 c7                	mov    %eax,%edi
  8044db:	48 b8 11 48 80 00 00 	movabs $0x804811,%rax
  8044e2:	00 00 00 
  8044e5:	ff d0                	callq  *%rax
}
  8044e7:	c9                   	leaveq 
  8044e8:	c3                   	retq   

00000000008044e9 <devsock_read>:

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  8044e9:	55                   	push   %rbp
  8044ea:	48 89 e5             	mov    %rsp,%rbp
  8044ed:	48 83 ec 20          	sub    $0x20,%rsp
  8044f1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8044f5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8044f9:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  8044fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804501:	89 c2                	mov    %eax,%edx
  804503:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804507:	8b 40 0c             	mov    0xc(%rax),%eax
  80450a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80450e:	b9 00 00 00 00       	mov    $0x0,%ecx
  804513:	89 c7                	mov    %eax,%edi
  804515:	48 b8 51 48 80 00 00 	movabs $0x804851,%rax
  80451c:	00 00 00 
  80451f:	ff d0                	callq  *%rax
}
  804521:	c9                   	leaveq 
  804522:	c3                   	retq   

0000000000804523 <devsock_write>:

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  804523:	55                   	push   %rbp
  804524:	48 89 e5             	mov    %rsp,%rbp
  804527:	48 83 ec 20          	sub    $0x20,%rsp
  80452b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80452f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804533:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  804537:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80453b:	89 c2                	mov    %eax,%edx
  80453d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804541:	8b 40 0c             	mov    0xc(%rax),%eax
  804544:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  804548:	b9 00 00 00 00       	mov    $0x0,%ecx
  80454d:	89 c7                	mov    %eax,%edi
  80454f:	48 b8 1d 49 80 00 00 	movabs $0x80491d,%rax
  804556:	00 00 00 
  804559:	ff d0                	callq  *%rax
}
  80455b:	c9                   	leaveq 
  80455c:	c3                   	retq   

000000000080455d <devsock_stat>:

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  80455d:	55                   	push   %rbp
  80455e:	48 89 e5             	mov    %rsp,%rbp
  804561:	48 83 ec 10          	sub    $0x10,%rsp
  804565:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  804569:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<sock>");
  80456d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804571:	48 be 18 11 82 00 00 	movabs $0x821118,%rsi
  804578:	00 00 00 
  80457b:	48 89 c7             	mov    %rax,%rdi
  80457e:	48 b8 2e 1d 80 00 00 	movabs $0x801d2e,%rax
  804585:	00 00 00 
  804588:	ff d0                	callq  *%rax
	return 0;
  80458a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80458f:	c9                   	leaveq 
  804590:	c3                   	retq   

0000000000804591 <socket>:

int
socket(int domain, int type, int protocol)
{
  804591:	55                   	push   %rbp
  804592:	48 89 e5             	mov    %rsp,%rbp
  804595:	48 83 ec 20          	sub    $0x20,%rsp
  804599:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80459c:	89 75 e8             	mov    %esi,-0x18(%rbp)
  80459f:	89 55 e4             	mov    %edx,-0x1c(%rbp)
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  8045a2:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8045a5:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  8045a8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8045ab:	89 ce                	mov    %ecx,%esi
  8045ad:	89 c7                	mov    %eax,%edi
  8045af:	48 b8 d5 49 80 00 00 	movabs $0x8049d5,%rax
  8045b6:	00 00 00 
  8045b9:	ff d0                	callq  *%rax
  8045bb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8045be:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8045c2:	79 05                	jns    8045c9 <socket+0x38>
		return r;
  8045c4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8045c7:	eb 11                	jmp    8045da <socket+0x49>
	return alloc_sockfd(r);
  8045c9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8045cc:	89 c7                	mov    %eax,%edi
  8045ce:	48 b8 73 42 80 00 00 	movabs $0x804273,%rax
  8045d5:	00 00 00 
  8045d8:	ff d0                	callq  *%rax
}
  8045da:	c9                   	leaveq 
  8045db:	c3                   	retq   

00000000008045dc <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  8045dc:	55                   	push   %rbp
  8045dd:	48 89 e5             	mov    %rsp,%rbp
  8045e0:	48 83 ec 10          	sub    $0x10,%rsp
  8045e4:	89 7d fc             	mov    %edi,-0x4(%rbp)
	static envid_t nsenv;
	if (nsenv == 0)
  8045e7:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  8045ee:	00 00 00 
  8045f1:	8b 00                	mov    (%rax),%eax
  8045f3:	85 c0                	test   %eax,%eax
  8045f5:	75 1d                	jne    804614 <nsipc+0x38>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  8045f7:	bf 02 00 00 00       	mov    $0x2,%edi
  8045fc:	48 b8 96 31 80 00 00 	movabs $0x803196,%rax
  804603:	00 00 00 
  804606:	ff d0                	callq  *%rax
  804608:	48 ba 88 90 82 00 00 	movabs $0x829088,%rdx
  80460f:	00 00 00 
  804612:	89 02                	mov    %eax,(%rdx)
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  804614:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  80461b:	00 00 00 
  80461e:	8b 00                	mov    (%rax),%eax
  804620:	8b 75 fc             	mov    -0x4(%rbp),%esi
  804623:	b9 07 00 00 00       	mov    $0x7,%ecx
  804628:	48 ba 00 a0 b5 00 00 	movabs $0xb5a000,%rdx
  80462f:	00 00 00 
  804632:	89 c7                	mov    %eax,%edi
  804634:	48 b8 34 31 80 00 00 	movabs $0x803134,%rax
  80463b:	00 00 00 
  80463e:	ff d0                	callq  *%rax
	return ipc_recv(NULL, NULL, NULL);
  804640:	ba 00 00 00 00       	mov    $0x0,%edx
  804645:	be 00 00 00 00       	mov    $0x0,%esi
  80464a:	bf 00 00 00 00       	mov    $0x0,%edi
  80464f:	48 b8 2e 30 80 00 00 	movabs $0x80302e,%rax
  804656:	00 00 00 
  804659:	ff d0                	callq  *%rax
}
  80465b:	c9                   	leaveq 
  80465c:	c3                   	retq   

000000000080465d <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80465d:	55                   	push   %rbp
  80465e:	48 89 e5             	mov    %rsp,%rbp
  804661:	48 83 ec 30          	sub    $0x30,%rsp
  804665:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804668:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80466c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;

	nsipcbuf.accept.req_s = s;
  804670:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804677:	00 00 00 
  80467a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80467d:	89 10                	mov    %edx,(%rax)
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  80467f:	bf 01 00 00 00       	mov    $0x1,%edi
  804684:	48 b8 dc 45 80 00 00 	movabs $0x8045dc,%rax
  80468b:	00 00 00 
  80468e:	ff d0                	callq  *%rax
  804690:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804693:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804697:	78 3e                	js     8046d7 <nsipc_accept+0x7a>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
  804699:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8046a0:	00 00 00 
  8046a3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  8046a7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8046ab:	8b 40 10             	mov    0x10(%rax),%eax
  8046ae:	89 c2                	mov    %eax,%edx
  8046b0:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8046b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8046b8:	48 89 ce             	mov    %rcx,%rsi
  8046bb:	48 89 c7             	mov    %rax,%rdi
  8046be:	48 b8 52 20 80 00 00 	movabs $0x802052,%rax
  8046c5:	00 00 00 
  8046c8:	ff d0                	callq  *%rax
		*addrlen = ret->ret_addrlen;
  8046ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8046ce:	8b 50 10             	mov    0x10(%rax),%edx
  8046d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8046d5:	89 10                	mov    %edx,(%rax)
	}
	return r;
  8046d7:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8046da:	c9                   	leaveq 
  8046db:	c3                   	retq   

00000000008046dc <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8046dc:	55                   	push   %rbp
  8046dd:	48 89 e5             	mov    %rsp,%rbp
  8046e0:	48 83 ec 10          	sub    $0x10,%rsp
  8046e4:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8046e7:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8046eb:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.bind.req_s = s;
  8046ee:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8046f5:	00 00 00 
  8046f8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8046fb:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  8046fd:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804700:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804704:	48 89 c6             	mov    %rax,%rsi
  804707:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  80470e:	00 00 00 
  804711:	48 b8 52 20 80 00 00 	movabs $0x802052,%rax
  804718:	00 00 00 
  80471b:	ff d0                	callq  *%rax
	nsipcbuf.bind.req_namelen = namelen;
  80471d:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804724:	00 00 00 
  804727:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80472a:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_BIND);
  80472d:	bf 02 00 00 00       	mov    $0x2,%edi
  804732:	48 b8 dc 45 80 00 00 	movabs $0x8045dc,%rax
  804739:	00 00 00 
  80473c:	ff d0                	callq  *%rax
}
  80473e:	c9                   	leaveq 
  80473f:	c3                   	retq   

0000000000804740 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  804740:	55                   	push   %rbp
  804741:	48 89 e5             	mov    %rsp,%rbp
  804744:	48 83 ec 10          	sub    $0x10,%rsp
  804748:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80474b:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.shutdown.req_s = s;
  80474e:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804755:	00 00 00 
  804758:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80475b:	89 10                	mov    %edx,(%rax)
	nsipcbuf.shutdown.req_how = how;
  80475d:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804764:	00 00 00 
  804767:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80476a:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_SHUTDOWN);
  80476d:	bf 03 00 00 00       	mov    $0x3,%edi
  804772:	48 b8 dc 45 80 00 00 	movabs $0x8045dc,%rax
  804779:	00 00 00 
  80477c:	ff d0                	callq  *%rax
}
  80477e:	c9                   	leaveq 
  80477f:	c3                   	retq   

0000000000804780 <nsipc_close>:

int
nsipc_close(int s)
{
  804780:	55                   	push   %rbp
  804781:	48 89 e5             	mov    %rsp,%rbp
  804784:	48 83 ec 10          	sub    $0x10,%rsp
  804788:	89 7d fc             	mov    %edi,-0x4(%rbp)
	nsipcbuf.close.req_s = s;
  80478b:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804792:	00 00 00 
  804795:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804798:	89 10                	mov    %edx,(%rax)
	return nsipc(NSREQ_CLOSE);
  80479a:	bf 04 00 00 00       	mov    $0x4,%edi
  80479f:	48 b8 dc 45 80 00 00 	movabs $0x8045dc,%rax
  8047a6:	00 00 00 
  8047a9:	ff d0                	callq  *%rax
}
  8047ab:	c9                   	leaveq 
  8047ac:	c3                   	retq   

00000000008047ad <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8047ad:	55                   	push   %rbp
  8047ae:	48 89 e5             	mov    %rsp,%rbp
  8047b1:	48 83 ec 10          	sub    $0x10,%rsp
  8047b5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8047b8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8047bc:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.connect.req_s = s;
  8047bf:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8047c6:	00 00 00 
  8047c9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8047cc:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  8047ce:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8047d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8047d5:	48 89 c6             	mov    %rax,%rsi
  8047d8:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  8047df:	00 00 00 
  8047e2:	48 b8 52 20 80 00 00 	movabs $0x802052,%rax
  8047e9:	00 00 00 
  8047ec:	ff d0                	callq  *%rax
	nsipcbuf.connect.req_namelen = namelen;
  8047ee:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8047f5:	00 00 00 
  8047f8:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8047fb:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_CONNECT);
  8047fe:	bf 05 00 00 00       	mov    $0x5,%edi
  804803:	48 b8 dc 45 80 00 00 	movabs $0x8045dc,%rax
  80480a:	00 00 00 
  80480d:	ff d0                	callq  *%rax
}
  80480f:	c9                   	leaveq 
  804810:	c3                   	retq   

0000000000804811 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  804811:	55                   	push   %rbp
  804812:	48 89 e5             	mov    %rsp,%rbp
  804815:	48 83 ec 10          	sub    $0x10,%rsp
  804819:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80481c:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.listen.req_s = s;
  80481f:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804826:	00 00 00 
  804829:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80482c:	89 10                	mov    %edx,(%rax)
	nsipcbuf.listen.req_backlog = backlog;
  80482e:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804835:	00 00 00 
  804838:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80483b:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_LISTEN);
  80483e:	bf 06 00 00 00       	mov    $0x6,%edi
  804843:	48 b8 dc 45 80 00 00 	movabs $0x8045dc,%rax
  80484a:	00 00 00 
  80484d:	ff d0                	callq  *%rax
}
  80484f:	c9                   	leaveq 
  804850:	c3                   	retq   

0000000000804851 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  804851:	55                   	push   %rbp
  804852:	48 89 e5             	mov    %rsp,%rbp
  804855:	48 83 ec 30          	sub    $0x30,%rsp
  804859:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80485c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804860:	89 55 e8             	mov    %edx,-0x18(%rbp)
  804863:	89 4d dc             	mov    %ecx,-0x24(%rbp)
	int r;

	nsipcbuf.recv.req_s = s;
  804866:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80486d:	00 00 00 
  804870:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804873:	89 10                	mov    %edx,(%rax)
	nsipcbuf.recv.req_len = len;
  804875:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80487c:	00 00 00 
  80487f:	8b 55 e8             	mov    -0x18(%rbp),%edx
  804882:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.recv.req_flags = flags;
  804885:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80488c:	00 00 00 
  80488f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  804892:	89 50 08             	mov    %edx,0x8(%rax)

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  804895:	bf 07 00 00 00       	mov    $0x7,%edi
  80489a:	48 b8 dc 45 80 00 00 	movabs $0x8045dc,%rax
  8048a1:	00 00 00 
  8048a4:	ff d0                	callq  *%rax
  8048a6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8048a9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8048ad:	78 69                	js     804918 <nsipc_recv+0xc7>
		assert(r < 1600 && r <= len);
  8048af:	81 7d fc 3f 06 00 00 	cmpl   $0x63f,-0x4(%rbp)
  8048b6:	7f 08                	jg     8048c0 <nsipc_recv+0x6f>
  8048b8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8048bb:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8048be:	7e 35                	jle    8048f5 <nsipc_recv+0xa4>
  8048c0:	48 b9 1f 11 82 00 00 	movabs $0x82111f,%rcx
  8048c7:	00 00 00 
  8048ca:	48 ba 34 11 82 00 00 	movabs $0x821134,%rdx
  8048d1:	00 00 00 
  8048d4:	be 61 00 00 00       	mov    $0x61,%esi
  8048d9:	48 bf 49 11 82 00 00 	movabs $0x821149,%rdi
  8048e0:	00 00 00 
  8048e3:	b8 00 00 00 00       	mov    $0x0,%eax
  8048e8:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  8048ef:	00 00 00 
  8048f2:	41 ff d0             	callq  *%r8
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  8048f5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8048f8:	48 63 d0             	movslq %eax,%rdx
  8048fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8048ff:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  804906:	00 00 00 
  804909:	48 89 c7             	mov    %rax,%rdi
  80490c:	48 b8 52 20 80 00 00 	movabs $0x802052,%rax
  804913:	00 00 00 
  804916:	ff d0                	callq  *%rax
	}

	return r;
  804918:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80491b:	c9                   	leaveq 
  80491c:	c3                   	retq   

000000000080491d <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  80491d:	55                   	push   %rbp
  80491e:	48 89 e5             	mov    %rsp,%rbp
  804921:	48 83 ec 20          	sub    $0x20,%rsp
  804925:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804928:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80492c:	89 55 f8             	mov    %edx,-0x8(%rbp)
  80492f:	89 4d ec             	mov    %ecx,-0x14(%rbp)
	nsipcbuf.send.req_s = s;
  804932:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804939:	00 00 00 
  80493c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80493f:	89 10                	mov    %edx,(%rax)
	assert(size < 1600);
  804941:	81 7d f8 3f 06 00 00 	cmpl   $0x63f,-0x8(%rbp)
  804948:	7e 35                	jle    80497f <nsipc_send+0x62>
  80494a:	48 b9 55 11 82 00 00 	movabs $0x821155,%rcx
  804951:	00 00 00 
  804954:	48 ba 34 11 82 00 00 	movabs $0x821134,%rdx
  80495b:	00 00 00 
  80495e:	be 6c 00 00 00       	mov    $0x6c,%esi
  804963:	48 bf 49 11 82 00 00 	movabs $0x821149,%rdi
  80496a:	00 00 00 
  80496d:	b8 00 00 00 00       	mov    $0x0,%eax
  804972:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  804979:	00 00 00 
  80497c:	41 ff d0             	callq  *%r8
	memmove(&nsipcbuf.send.req_buf, buf, size);
  80497f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804982:	48 63 d0             	movslq %eax,%rdx
  804985:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804989:	48 89 c6             	mov    %rax,%rsi
  80498c:	48 bf 0c a0 b5 00 00 	movabs $0xb5a00c,%rdi
  804993:	00 00 00 
  804996:	48 b8 52 20 80 00 00 	movabs $0x802052,%rax
  80499d:	00 00 00 
  8049a0:	ff d0                	callq  *%rax
	nsipcbuf.send.req_size = size;
  8049a2:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8049a9:	00 00 00 
  8049ac:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8049af:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.send.req_flags = flags;
  8049b2:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8049b9:	00 00 00 
  8049bc:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8049bf:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SEND);
  8049c2:	bf 08 00 00 00       	mov    $0x8,%edi
  8049c7:	48 b8 dc 45 80 00 00 	movabs $0x8045dc,%rax
  8049ce:	00 00 00 
  8049d1:	ff d0                	callq  *%rax
}
  8049d3:	c9                   	leaveq 
  8049d4:	c3                   	retq   

00000000008049d5 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  8049d5:	55                   	push   %rbp
  8049d6:	48 89 e5             	mov    %rsp,%rbp
  8049d9:	48 83 ec 10          	sub    $0x10,%rsp
  8049dd:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8049e0:	89 75 f8             	mov    %esi,-0x8(%rbp)
  8049e3:	89 55 f4             	mov    %edx,-0xc(%rbp)
	nsipcbuf.socket.req_domain = domain;
  8049e6:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8049ed:	00 00 00 
  8049f0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8049f3:	89 10                	mov    %edx,(%rax)
	nsipcbuf.socket.req_type = type;
  8049f5:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8049fc:	00 00 00 
  8049ff:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804a02:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.socket.req_protocol = protocol;
  804a05:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a0c:	00 00 00 
  804a0f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  804a12:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SOCKET);
  804a15:	bf 09 00 00 00       	mov    $0x9,%edi
  804a1a:	48 b8 dc 45 80 00 00 	movabs $0x8045dc,%rax
  804a21:	00 00 00 
  804a24:	ff d0                	callq  *%rax
}
  804a26:	c9                   	leaveq 
  804a27:	c3                   	retq   

0000000000804a28 <isfree>:
static uint8_t *mend   = (uint8_t*) 0x10000000;
static uint8_t *mptr;

static int
isfree(void *v, size_t n)
{
  804a28:	55                   	push   %rbp
  804a29:	48 89 e5             	mov    %rsp,%rbp
  804a2c:	48 83 ec 20          	sub    $0x20,%rsp
  804a30:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  804a34:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uintptr_t va, end_va = (uintptr_t) v + n;
  804a38:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  804a3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804a40:	48 01 d0             	add    %rdx,%rax
  804a43:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804a47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804a4b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  804a4f:	eb 64                	jmp    804ab5 <isfree+0x8d>
		if (va >= (uintptr_t) mend
  804a51:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804a58:	00 00 00 
  804a5b:	48 8b 00             	mov    (%rax),%rax
  804a5e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  804a62:	76 42                	jbe    804aa6 <isfree+0x7e>
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  804a64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804a68:	48 c1 e8 15          	shr    $0x15,%rax
  804a6c:	48 89 c2             	mov    %rax,%rdx
  804a6f:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  804a76:	01 00 00 
  804a79:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804a7d:	83 e0 01             	and    $0x1,%eax
  804a80:	48 85 c0             	test   %rax,%rax
  804a83:	74 28                	je     804aad <isfree+0x85>
  804a85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804a89:	48 c1 e8 0c          	shr    $0xc,%rax
  804a8d:	48 89 c2             	mov    %rax,%rdx
  804a90:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  804a97:	01 00 00 
  804a9a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804a9e:	83 e0 01             	and    $0x1,%eax
  804aa1:	48 85 c0             	test   %rax,%rax
  804aa4:	74 07                	je     804aad <isfree+0x85>
			return 0;
  804aa6:	b8 00 00 00 00       	mov    $0x0,%eax
  804aab:	eb 17                	jmp    804ac4 <isfree+0x9c>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804aad:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  804ab4:	00 
  804ab5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804ab9:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  804abd:	72 92                	jb     804a51 <isfree+0x29>
		if (va >= (uintptr_t) mend
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
			return 0;
	return 1;
  804abf:	b8 01 00 00 00       	mov    $0x1,%eax
}
  804ac4:	c9                   	leaveq 
  804ac5:	c3                   	retq   

0000000000804ac6 <malloc>:

void*
malloc(size_t n)
{
  804ac6:	55                   	push   %rbp
  804ac7:	48 89 e5             	mov    %rsp,%rbp
  804aca:	48 83 ec 60          	sub    $0x60,%rsp
  804ace:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  804ad2:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ad9:	00 00 00 
  804adc:	48 8b 00             	mov    (%rax),%rax
  804adf:	48 85 c0             	test   %rax,%rax
  804ae2:	75 1a                	jne    804afe <malloc+0x38>
		mptr = mbegin;
  804ae4:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804aeb:	00 00 00 
  804aee:	48 8b 10             	mov    (%rax),%rdx
  804af1:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804af8:	00 00 00 
  804afb:	48 89 10             	mov    %rdx,(%rax)

	n = ROUNDUP(n, 4);
  804afe:	48 c7 45 f0 04 00 00 	movq   $0x4,-0x10(%rbp)
  804b05:	00 
  804b06:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804b0a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804b0e:	48 01 d0             	add    %rdx,%rax
  804b11:	48 83 e8 01          	sub    $0x1,%rax
  804b15:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  804b19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804b1d:	ba 00 00 00 00       	mov    $0x0,%edx
  804b22:	48 f7 75 f0          	divq   -0x10(%rbp)
  804b26:	48 89 d0             	mov    %rdx,%rax
  804b29:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  804b2d:	48 29 c2             	sub    %rax,%rdx
  804b30:	48 89 d0             	mov    %rdx,%rax
  804b33:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

	if (n >= MAXMALLOC)
  804b37:	48 81 7d a8 ff ff 0f 	cmpq   $0xfffff,-0x58(%rbp)
  804b3e:	00 
  804b3f:	76 0a                	jbe    804b4b <malloc+0x85>
		return 0;
  804b41:	b8 00 00 00 00       	mov    $0x0,%eax
  804b46:	e9 f7 02 00 00       	jmpq   804e42 <malloc+0x37c>

	if ((uintptr_t) mptr % PGSIZE){
  804b4b:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804b52:	00 00 00 
  804b55:	48 8b 00             	mov    (%rax),%rax
  804b58:	25 ff 0f 00 00       	and    $0xfff,%eax
  804b5d:	48 85 c0             	test   %rax,%rax
  804b60:	0f 84 15 01 00 00    	je     804c7b <malloc+0x1b5>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  804b66:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  804b6d:	00 
  804b6e:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804b75:	00 00 00 
  804b78:	48 8b 00             	mov    (%rax),%rax
  804b7b:	48 89 c2             	mov    %rax,%rdx
  804b7e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804b82:	48 01 d0             	add    %rdx,%rax
  804b85:	48 83 e8 01          	sub    $0x1,%rax
  804b89:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  804b8d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804b91:	ba 00 00 00 00       	mov    $0x0,%edx
  804b96:	48 f7 75 e0          	divq   -0x20(%rbp)
  804b9a:	48 89 d0             	mov    %rdx,%rax
  804b9d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  804ba1:	48 29 c2             	sub    %rax,%rdx
  804ba4:	48 89 d0             	mov    %rdx,%rax
  804ba7:	48 83 e8 04          	sub    $0x4,%rax
  804bab:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  804baf:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804bb6:	00 00 00 
  804bb9:	48 8b 00             	mov    (%rax),%rax
  804bbc:	48 c1 e8 0c          	shr    $0xc,%rax
  804bc0:	48 89 c1             	mov    %rax,%rcx
  804bc3:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804bca:	00 00 00 
  804bcd:	48 8b 00             	mov    (%rax),%rax
  804bd0:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804bd4:	48 83 c2 03          	add    $0x3,%rdx
  804bd8:	48 01 d0             	add    %rdx,%rax
  804bdb:	48 c1 e8 0c          	shr    $0xc,%rax
  804bdf:	48 39 c1             	cmp    %rax,%rcx
  804be2:	75 4a                	jne    804c2e <malloc+0x168>
			(*ref)++;
  804be4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804be8:	8b 00                	mov    (%rax),%eax
  804bea:	8d 50 01             	lea    0x1(%rax),%edx
  804bed:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804bf1:	89 10                	mov    %edx,(%rax)
			v = mptr;
  804bf3:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804bfa:	00 00 00 
  804bfd:	48 8b 00             	mov    (%rax),%rax
  804c00:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			mptr += n;
  804c04:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804c0b:	00 00 00 
  804c0e:	48 8b 10             	mov    (%rax),%rdx
  804c11:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804c15:	48 01 c2             	add    %rax,%rdx
  804c18:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804c1f:	00 00 00 
  804c22:	48 89 10             	mov    %rdx,(%rax)
			return v;
  804c25:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804c29:	e9 14 02 00 00       	jmpq   804e42 <malloc+0x37c>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  804c2e:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804c35:	00 00 00 
  804c38:	48 8b 00             	mov    (%rax),%rax
  804c3b:	48 89 c7             	mov    %rax,%rdi
  804c3e:	48 b8 44 4e 80 00 00 	movabs $0x804e44,%rax
  804c45:	00 00 00 
  804c48:	ff d0                	callq  *%rax
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  804c4a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804c51:	00 00 00 
  804c54:	48 8b 00             	mov    (%rax),%rax
  804c57:	48 05 00 10 00 00    	add    $0x1000,%rax
  804c5d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804c61:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804c65:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804c6b:	48 89 c2             	mov    %rax,%rdx
  804c6e:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804c75:	00 00 00 
  804c78:	48 89 10             	mov    %rdx,(%rax)
	 * now we need to find some address space for this chunk.
	 * if it's less than a page we leave it open for allocation.
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
  804c7b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	while (1) {
		if (isfree(mptr, n + 4))
  804c82:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804c86:	48 8d 50 04          	lea    0x4(%rax),%rdx
  804c8a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804c91:	00 00 00 
  804c94:	48 8b 00             	mov    (%rax),%rax
  804c97:	48 89 d6             	mov    %rdx,%rsi
  804c9a:	48 89 c7             	mov    %rax,%rdi
  804c9d:	48 b8 28 4a 80 00 00 	movabs $0x804a28,%rax
  804ca4:	00 00 00 
  804ca7:	ff d0                	callq  *%rax
  804ca9:	85 c0                	test   %eax,%eax
  804cab:	74 0d                	je     804cba <malloc+0x1f4>
			break;
  804cad:	90                   	nop
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  804cae:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  804cb5:	e9 14 01 00 00       	jmpq   804dce <malloc+0x308>
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
  804cba:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804cc1:	00 00 00 
  804cc4:	48 8b 00             	mov    (%rax),%rax
  804cc7:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  804cce:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804cd5:	00 00 00 
  804cd8:	48 89 10             	mov    %rdx,(%rax)
		if (mptr == mend) {
  804cdb:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ce2:	00 00 00 
  804ce5:	48 8b 10             	mov    (%rax),%rdx
  804ce8:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804cef:	00 00 00 
  804cf2:	48 8b 00             	mov    (%rax),%rax
  804cf5:	48 39 c2             	cmp    %rax,%rdx
  804cf8:	75 2e                	jne    804d28 <malloc+0x262>
			mptr = mbegin;
  804cfa:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804d01:	00 00 00 
  804d04:	48 8b 10             	mov    (%rax),%rdx
  804d07:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804d0e:	00 00 00 
  804d11:	48 89 10             	mov    %rdx,(%rax)
			if (++nwrap == 2)
  804d14:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  804d18:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  804d1c:	75 0a                	jne    804d28 <malloc+0x262>
				return 0;	/* out of address space */
  804d1e:	b8 00 00 00 00       	mov    $0x0,%eax
  804d23:	e9 1a 01 00 00       	jmpq   804e42 <malloc+0x37c>
		}
	}
  804d28:	e9 55 ff ff ff       	jmpq   804c82 <malloc+0x1bc>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  804d2d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804d30:	05 00 10 00 00       	add    $0x1000,%eax
  804d35:	48 98                	cltq   
  804d37:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804d3b:	48 83 c2 04          	add    $0x4,%rdx
  804d3f:	48 39 d0             	cmp    %rdx,%rax
  804d42:	73 07                	jae    804d4b <malloc+0x285>
  804d44:	b8 00 04 00 00       	mov    $0x400,%eax
  804d49:	eb 05                	jmp    804d50 <malloc+0x28a>
  804d4b:	b8 00 00 00 00       	mov    $0x0,%eax
  804d50:	89 45 bc             	mov    %eax,-0x44(%rbp)
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  804d53:	8b 45 bc             	mov    -0x44(%rbp),%eax
  804d56:	83 c8 07             	or     $0x7,%eax
  804d59:	89 c2                	mov    %eax,%edx
  804d5b:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804d62:	00 00 00 
  804d65:	48 8b 08             	mov    (%rax),%rcx
  804d68:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804d6b:	48 98                	cltq   
  804d6d:	48 01 c8             	add    %rcx,%rax
  804d70:	48 89 c6             	mov    %rax,%rsi
  804d73:	bf 00 00 00 00       	mov    $0x0,%edi
  804d78:	48 b8 5d 26 80 00 00 	movabs $0x80265d,%rax
  804d7f:	00 00 00 
  804d82:	ff d0                	callq  *%rax
  804d84:	85 c0                	test   %eax,%eax
  804d86:	79 3f                	jns    804dc7 <malloc+0x301>
			for (; i >= 0; i -= PGSIZE)
  804d88:	eb 30                	jmp    804dba <malloc+0x2f4>
				sys_page_unmap(0, mptr + i);
  804d8a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804d91:	00 00 00 
  804d94:	48 8b 10             	mov    (%rax),%rdx
  804d97:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804d9a:	48 98                	cltq   
  804d9c:	48 01 d0             	add    %rdx,%rax
  804d9f:	48 89 c6             	mov    %rax,%rsi
  804da2:	bf 00 00 00 00       	mov    $0x0,%edi
  804da7:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  804dae:	00 00 00 
  804db1:	ff d0                	callq  *%rax
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  804db3:	81 6d fc 00 10 00 00 	subl   $0x1000,-0x4(%rbp)
  804dba:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804dbe:	79 ca                	jns    804d8a <malloc+0x2c4>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  804dc0:	b8 00 00 00 00       	mov    $0x0,%eax
  804dc5:	eb 7b                	jmp    804e42 <malloc+0x37c>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  804dc7:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%rbp)
  804dce:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804dd1:	48 98                	cltq   
  804dd3:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804dd7:	48 83 c2 04          	add    $0x4,%rdx
  804ddb:	48 39 d0             	cmp    %rdx,%rax
  804dde:	0f 82 49 ff ff ff    	jb     804d2d <malloc+0x267>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  804de4:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804deb:	00 00 00 
  804dee:	48 8b 00             	mov    (%rax),%rax
  804df1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804df4:	48 63 d2             	movslq %edx,%rdx
  804df7:	48 83 ea 04          	sub    $0x4,%rdx
  804dfb:	48 01 d0             	add    %rdx,%rax
  804dfe:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	*ref = 2;	/* reference for mptr, reference for returned block */
  804e02:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804e06:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
	v = mptr;
  804e0c:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e13:	00 00 00 
  804e16:	48 8b 00             	mov    (%rax),%rax
  804e19:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	mptr += n;
  804e1d:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e24:	00 00 00 
  804e27:	48 8b 10             	mov    (%rax),%rdx
  804e2a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804e2e:	48 01 c2             	add    %rax,%rdx
  804e31:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e38:	00 00 00 
  804e3b:	48 89 10             	mov    %rdx,(%rax)
	return v;
  804e3e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  804e42:	c9                   	leaveq 
  804e43:	c3                   	retq   

0000000000804e44 <free>:

void
free(void *v)
{
  804e44:	55                   	push   %rbp
  804e45:	48 89 e5             	mov    %rsp,%rbp
  804e48:	48 83 ec 30          	sub    $0x30,%rsp
  804e4c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  804e50:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  804e55:	75 05                	jne    804e5c <free+0x18>
		return;
  804e57:	e9 54 01 00 00       	jmpq   804fb0 <free+0x16c>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  804e5c:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804e63:	00 00 00 
  804e66:	48 8b 00             	mov    (%rax),%rax
  804e69:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  804e6d:	77 13                	ja     804e82 <free+0x3e>
  804e6f:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804e76:	00 00 00 
  804e79:	48 8b 00             	mov    (%rax),%rax
  804e7c:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  804e80:	72 35                	jb     804eb7 <free+0x73>
  804e82:	48 b9 68 11 82 00 00 	movabs $0x821168,%rcx
  804e89:	00 00 00 
  804e8c:	48 ba 96 11 82 00 00 	movabs $0x821196,%rdx
  804e93:	00 00 00 
  804e96:	be 7a 00 00 00       	mov    $0x7a,%esi
  804e9b:	48 bf ab 11 82 00 00 	movabs $0x8211ab,%rdi
  804ea2:	00 00 00 
  804ea5:	b8 00 00 00 00       	mov    $0x0,%eax
  804eaa:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  804eb1:	00 00 00 
  804eb4:	41 ff d0             	callq  *%r8

	c = ROUNDDOWN(v, PGSIZE);
  804eb7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804ebb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  804ebf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804ec3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804ec9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  804ecd:	eb 7b                	jmp    804f4a <free+0x106>
		sys_page_unmap(0, c);
  804ecf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804ed3:	48 89 c6             	mov    %rax,%rsi
  804ed6:	bf 00 00 00 00       	mov    $0x0,%edi
  804edb:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  804ee2:	00 00 00 
  804ee5:	ff d0                	callq  *%rax
		c += PGSIZE;
  804ee7:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  804eee:	00 
		assert(mbegin <= c && c < mend);
  804eef:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804ef6:	00 00 00 
  804ef9:	48 8b 00             	mov    (%rax),%rax
  804efc:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  804f00:	77 13                	ja     804f15 <free+0xd1>
  804f02:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804f09:	00 00 00 
  804f0c:	48 8b 00             	mov    (%rax),%rax
  804f0f:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  804f13:	72 35                	jb     804f4a <free+0x106>
  804f15:	48 b9 b8 11 82 00 00 	movabs $0x8211b8,%rcx
  804f1c:	00 00 00 
  804f1f:	48 ba 96 11 82 00 00 	movabs $0x821196,%rdx
  804f26:	00 00 00 
  804f29:	be 81 00 00 00       	mov    $0x81,%esi
  804f2e:	48 bf ab 11 82 00 00 	movabs $0x8211ab,%rdi
  804f35:	00 00 00 
  804f38:	b8 00 00 00 00       	mov    $0x0,%eax
  804f3d:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  804f44:	00 00 00 
  804f47:	41 ff d0             	callq  *%r8
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  804f4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804f4e:	48 c1 e8 0c          	shr    $0xc,%rax
  804f52:	48 89 c2             	mov    %rax,%rdx
  804f55:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  804f5c:	01 00 00 
  804f5f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804f63:	25 00 04 00 00       	and    $0x400,%eax
  804f68:	48 85 c0             	test   %rax,%rax
  804f6b:	0f 85 5e ff ff ff    	jne    804ecf <free+0x8b>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  804f71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804f75:	48 05 fc 0f 00 00    	add    $0xffc,%rax
  804f7b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (--(*ref) == 0)
  804f7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804f83:	8b 00                	mov    (%rax),%eax
  804f85:	8d 50 ff             	lea    -0x1(%rax),%edx
  804f88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804f8c:	89 10                	mov    %edx,(%rax)
  804f8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804f92:	8b 00                	mov    (%rax),%eax
  804f94:	85 c0                	test   %eax,%eax
  804f96:	75 18                	jne    804fb0 <free+0x16c>
		sys_page_unmap(0, c);
  804f98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804f9c:	48 89 c6             	mov    %rax,%rsi
  804f9f:	bf 00 00 00 00       	mov    $0x0,%edi
  804fa4:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  804fab:	00 00 00 
  804fae:	ff d0                	callq  *%rax
}
  804fb0:	c9                   	leaveq 
  804fb1:	c3                   	retq   

0000000000804fb2 <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  804fb2:	55                   	push   %rbp
  804fb3:	48 89 e5             	mov    %rsp,%rbp
  804fb6:	53                   	push   %rbx
  804fb7:	48 83 ec 38          	sub    $0x38,%rsp
  804fbb:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  804fbf:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
  804fc3:	48 89 c7             	mov    %rax,%rdi
  804fc6:	48 b8 66 32 80 00 00 	movabs $0x803266,%rax
  804fcd:	00 00 00 
  804fd0:	ff d0                	callq  *%rax
  804fd2:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804fd5:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804fd9:	0f 88 bf 01 00 00    	js     80519e <pipe+0x1ec>
            || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  804fdf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804fe3:	ba 07 04 00 00       	mov    $0x407,%edx
  804fe8:	48 89 c6             	mov    %rax,%rsi
  804feb:	bf 00 00 00 00       	mov    $0x0,%edi
  804ff0:	48 b8 5d 26 80 00 00 	movabs $0x80265d,%rax
  804ff7:	00 00 00 
  804ffa:	ff d0                	callq  *%rax
  804ffc:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804fff:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805003:	0f 88 95 01 00 00    	js     80519e <pipe+0x1ec>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  805009:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  80500d:	48 89 c7             	mov    %rax,%rdi
  805010:	48 b8 66 32 80 00 00 	movabs $0x803266,%rax
  805017:	00 00 00 
  80501a:	ff d0                	callq  *%rax
  80501c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80501f:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805023:	0f 88 5d 01 00 00    	js     805186 <pipe+0x1d4>
            || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  805029:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80502d:	ba 07 04 00 00       	mov    $0x407,%edx
  805032:	48 89 c6             	mov    %rax,%rsi
  805035:	bf 00 00 00 00       	mov    $0x0,%edi
  80503a:	48 b8 5d 26 80 00 00 	movabs $0x80265d,%rax
  805041:	00 00 00 
  805044:	ff d0                	callq  *%rax
  805046:	89 45 ec             	mov    %eax,-0x14(%rbp)
  805049:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80504d:	0f 88 33 01 00 00    	js     805186 <pipe+0x1d4>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  805053:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805057:	48 89 c7             	mov    %rax,%rdi
  80505a:	48 b8 3b 32 80 00 00 	movabs $0x80323b,%rax
  805061:	00 00 00 
  805064:	ff d0                	callq  *%rax
  805066:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  80506a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80506e:	ba 07 04 00 00       	mov    $0x407,%edx
  805073:	48 89 c6             	mov    %rax,%rsi
  805076:	bf 00 00 00 00       	mov    $0x0,%edi
  80507b:	48 b8 5d 26 80 00 00 	movabs $0x80265d,%rax
  805082:	00 00 00 
  805085:	ff d0                	callq  *%rax
  805087:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80508a:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80508e:	79 05                	jns    805095 <pipe+0xe3>
		goto err2;
  805090:	e9 d9 00 00 00       	jmpq   80516e <pipe+0x1bc>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  805095:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805099:	48 89 c7             	mov    %rax,%rdi
  80509c:	48 b8 3b 32 80 00 00 	movabs $0x80323b,%rax
  8050a3:	00 00 00 
  8050a6:	ff d0                	callq  *%rax
  8050a8:	48 89 c2             	mov    %rax,%rdx
  8050ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8050af:	41 b8 07 04 00 00    	mov    $0x407,%r8d
  8050b5:	48 89 d1             	mov    %rdx,%rcx
  8050b8:	ba 00 00 00 00       	mov    $0x0,%edx
  8050bd:	48 89 c6             	mov    %rax,%rsi
  8050c0:	bf 00 00 00 00       	mov    $0x0,%edi
  8050c5:	48 b8 ad 26 80 00 00 	movabs $0x8026ad,%rax
  8050cc:	00 00 00 
  8050cf:	ff d0                	callq  *%rax
  8050d1:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8050d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8050d8:	79 1b                	jns    8050f5 <pipe+0x143>
		goto err3;
  8050da:	90                   	nop
	pfd[0] = fd2num(fd0);
	pfd[1] = fd2num(fd1);
	return 0;

err3:
	sys_page_unmap(0, va);
  8050db:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8050df:	48 89 c6             	mov    %rax,%rsi
  8050e2:	bf 00 00 00 00       	mov    $0x0,%edi
  8050e7:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  8050ee:	00 00 00 
  8050f1:	ff d0                	callq  *%rax
  8050f3:	eb 79                	jmp    80516e <pipe+0x1bc>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  8050f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8050f9:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  805100:	00 00 00 
  805103:	8b 12                	mov    (%rdx),%edx
  805105:	89 10                	mov    %edx,(%rax)
	fd0->fd_omode = O_RDONLY;
  805107:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80510b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)

	fd1->fd_dev_id = devpipe.dev_id;
  805112:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805116:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  80511d:	00 00 00 
  805120:	8b 12                	mov    (%rdx),%edx
  805122:	89 10                	mov    %edx,(%rax)
	fd1->fd_omode = O_WRONLY;
  805124:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805128:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  80512f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805133:	48 89 c7             	mov    %rax,%rdi
  805136:	48 b8 18 32 80 00 00 	movabs $0x803218,%rax
  80513d:	00 00 00 
  805140:	ff d0                	callq  *%rax
  805142:	89 c2                	mov    %eax,%edx
  805144:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  805148:	89 10                	mov    %edx,(%rax)
	pfd[1] = fd2num(fd1);
  80514a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80514e:	48 8d 58 04          	lea    0x4(%rax),%rbx
  805152:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805156:	48 89 c7             	mov    %rax,%rdi
  805159:	48 b8 18 32 80 00 00 	movabs $0x803218,%rax
  805160:	00 00 00 
  805163:	ff d0                	callq  *%rax
  805165:	89 03                	mov    %eax,(%rbx)
	return 0;
  805167:	b8 00 00 00 00       	mov    $0x0,%eax
  80516c:	eb 33                	jmp    8051a1 <pipe+0x1ef>

err3:
	sys_page_unmap(0, va);
err2:
	sys_page_unmap(0, fd1);
  80516e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805172:	48 89 c6             	mov    %rax,%rsi
  805175:	bf 00 00 00 00       	mov    $0x0,%edi
  80517a:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  805181:	00 00 00 
  805184:	ff d0                	callq  *%rax
err1:
	sys_page_unmap(0, fd0);
  805186:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80518a:	48 89 c6             	mov    %rax,%rsi
  80518d:	bf 00 00 00 00       	mov    $0x0,%edi
  805192:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  805199:	00 00 00 
  80519c:	ff d0                	callq  *%rax
err:
	return r;
  80519e:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  8051a1:	48 83 c4 38          	add    $0x38,%rsp
  8051a5:	5b                   	pop    %rbx
  8051a6:	5d                   	pop    %rbp
  8051a7:	c3                   	retq   

00000000008051a8 <_pipeisclosed>:

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  8051a8:	55                   	push   %rbp
  8051a9:	48 89 e5             	mov    %rsp,%rbp
  8051ac:	53                   	push   %rbx
  8051ad:	48 83 ec 28          	sub    $0x28,%rsp
  8051b1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8051b5:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  8051b9:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8051c0:	00 00 00 
  8051c3:	48 8b 00             	mov    (%rax),%rax
  8051c6:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  8051cc:	89 45 ec             	mov    %eax,-0x14(%rbp)
		ret = pageref(fd) == pageref(p);
  8051cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8051d3:	48 89 c7             	mov    %rax,%rdi
  8051d6:	48 b8 6e 59 80 00 00 	movabs $0x80596e,%rax
  8051dd:	00 00 00 
  8051e0:	ff d0                	callq  *%rax
  8051e2:	89 c3                	mov    %eax,%ebx
  8051e4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8051e8:	48 89 c7             	mov    %rax,%rdi
  8051eb:	48 b8 6e 59 80 00 00 	movabs $0x80596e,%rax
  8051f2:	00 00 00 
  8051f5:	ff d0                	callq  *%rax
  8051f7:	39 c3                	cmp    %eax,%ebx
  8051f9:	0f 94 c0             	sete   %al
  8051fc:	0f b6 c0             	movzbl %al,%eax
  8051ff:	89 45 e8             	mov    %eax,-0x18(%rbp)
		nn = thisenv->env_runs;
  805202:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  805209:	00 00 00 
  80520c:	48 8b 00             	mov    (%rax),%rax
  80520f:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  805215:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if (n == nn)
  805218:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80521b:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80521e:	75 05                	jne    805225 <_pipeisclosed+0x7d>
			return ret;
  805220:	8b 45 e8             	mov    -0x18(%rbp),%eax
  805223:	eb 4f                	jmp    805274 <_pipeisclosed+0xcc>
		if (n != nn && ret == 1)
  805225:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805228:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80522b:	74 42                	je     80526f <_pipeisclosed+0xc7>
  80522d:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
  805231:	75 3c                	jne    80526f <_pipeisclosed+0xc7>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  805233:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  80523a:	00 00 00 
  80523d:	48 8b 00             	mov    (%rax),%rax
  805240:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  805246:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  805249:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80524c:	89 c6                	mov    %eax,%esi
  80524e:	48 bf d5 11 82 00 00 	movabs $0x8211d5,%rdi
  805255:	00 00 00 
  805258:	b8 00 00 00 00       	mov    $0x0,%eax
  80525d:	49 b8 79 11 80 00 00 	movabs $0x801179,%r8
  805264:	00 00 00 
  805267:	41 ff d0             	callq  *%r8
	}
  80526a:	e9 4a ff ff ff       	jmpq   8051b9 <_pipeisclosed+0x11>
  80526f:	e9 45 ff ff ff       	jmpq   8051b9 <_pipeisclosed+0x11>
}
  805274:	48 83 c4 28          	add    $0x28,%rsp
  805278:	5b                   	pop    %rbx
  805279:	5d                   	pop    %rbp
  80527a:	c3                   	retq   

000000000080527b <pipeisclosed>:

int
pipeisclosed(int fdnum)
{
  80527b:	55                   	push   %rbp
  80527c:	48 89 e5             	mov    %rsp,%rbp
  80527f:	48 83 ec 30          	sub    $0x30,%rsp
  805283:	89 7d dc             	mov    %edi,-0x24(%rbp)
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  805286:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  80528a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80528d:	48 89 d6             	mov    %rdx,%rsi
  805290:	89 c7                	mov    %eax,%edi
  805292:	48 b8 fe 32 80 00 00 	movabs $0x8032fe,%rax
  805299:	00 00 00 
  80529c:	ff d0                	callq  *%rax
  80529e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8052a1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8052a5:	79 05                	jns    8052ac <pipeisclosed+0x31>
		return r;
  8052a7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8052aa:	eb 31                	jmp    8052dd <pipeisclosed+0x62>
	p = (struct Pipe*) fd2data(fd);
  8052ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8052b0:	48 89 c7             	mov    %rax,%rdi
  8052b3:	48 b8 3b 32 80 00 00 	movabs $0x80323b,%rax
  8052ba:	00 00 00 
  8052bd:	ff d0                	callq  *%rax
  8052bf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	return _pipeisclosed(fd, p);
  8052c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8052c7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8052cb:	48 89 d6             	mov    %rdx,%rsi
  8052ce:	48 89 c7             	mov    %rax,%rdi
  8052d1:	48 b8 a8 51 80 00 00 	movabs $0x8051a8,%rax
  8052d8:	00 00 00 
  8052db:	ff d0                	callq  *%rax
}
  8052dd:	c9                   	leaveq 
  8052de:	c3                   	retq   

00000000008052df <devpipe_read>:

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  8052df:	55                   	push   %rbp
  8052e0:	48 89 e5             	mov    %rsp,%rbp
  8052e3:	48 83 ec 40          	sub    $0x40,%rsp
  8052e7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8052eb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8052ef:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  8052f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8052f7:	48 89 c7             	mov    %rax,%rdi
  8052fa:	48 b8 3b 32 80 00 00 	movabs $0x80323b,%rax
  805301:	00 00 00 
  805304:	ff d0                	callq  *%rax
  805306:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  80530a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80530e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  805312:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  805319:	00 
  80531a:	e9 92 00 00 00       	jmpq   8053b1 <devpipe_read+0xd2>
		while (p->p_rpos == p->p_wpos) {
  80531f:	eb 41                	jmp    805362 <devpipe_read+0x83>
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  805321:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805326:	74 09                	je     805331 <devpipe_read+0x52>
				return i;
  805328:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80532c:	e9 92 00 00 00       	jmpq   8053c3 <devpipe_read+0xe4>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  805331:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805335:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805339:	48 89 d6             	mov    %rdx,%rsi
  80533c:	48 89 c7             	mov    %rax,%rdi
  80533f:	48 b8 a8 51 80 00 00 	movabs $0x8051a8,%rax
  805346:	00 00 00 
  805349:	ff d0                	callq  *%rax
  80534b:	85 c0                	test   %eax,%eax
  80534d:	74 07                	je     805356 <devpipe_read+0x77>
				return 0;
  80534f:	b8 00 00 00 00       	mov    $0x0,%eax
  805354:	eb 6d                	jmp    8053c3 <devpipe_read+0xe4>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  805356:	48 b8 1f 26 80 00 00 	movabs $0x80261f,%rax
  80535d:	00 00 00 
  805360:	ff d0                	callq  *%rax
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  805362:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805366:	8b 10                	mov    (%rax),%edx
  805368:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80536c:	8b 40 04             	mov    0x4(%rax),%eax
  80536f:	39 c2                	cmp    %eax,%edx
  805371:	74 ae                	je     805321 <devpipe_read+0x42>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  805373:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805377:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80537b:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80537f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805383:	8b 00                	mov    (%rax),%eax
  805385:	99                   	cltd   
  805386:	c1 ea 1b             	shr    $0x1b,%edx
  805389:	01 d0                	add    %edx,%eax
  80538b:	83 e0 1f             	and    $0x1f,%eax
  80538e:	29 d0                	sub    %edx,%eax
  805390:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805394:	48 98                	cltq   
  805396:	0f b6 44 02 08       	movzbl 0x8(%rdx,%rax,1),%eax
  80539b:	88 01                	mov    %al,(%rcx)
		p->p_rpos++;
  80539d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8053a1:	8b 00                	mov    (%rax),%eax
  8053a3:	8d 50 01             	lea    0x1(%rax),%edx
  8053a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8053aa:	89 10                	mov    %edx,(%rax)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8053ac:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8053b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8053b5:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8053b9:	0f 82 60 ff ff ff    	jb     80531f <devpipe_read+0x40>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  8053bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8053c3:	c9                   	leaveq 
  8053c4:	c3                   	retq   

00000000008053c5 <devpipe_write>:

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  8053c5:	55                   	push   %rbp
  8053c6:	48 89 e5             	mov    %rsp,%rbp
  8053c9:	48 83 ec 40          	sub    $0x40,%rsp
  8053cd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8053d1:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8053d5:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  8053d9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8053dd:	48 89 c7             	mov    %rax,%rdi
  8053e0:	48 b8 3b 32 80 00 00 	movabs $0x80323b,%rax
  8053e7:	00 00 00 
  8053ea:	ff d0                	callq  *%rax
  8053ec:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  8053f0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8053f4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  8053f8:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8053ff:	00 
  805400:	e9 8e 00 00 00       	jmpq   805493 <devpipe_write+0xce>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  805405:	eb 31                	jmp    805438 <devpipe_write+0x73>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  805407:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80540b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80540f:	48 89 d6             	mov    %rdx,%rsi
  805412:	48 89 c7             	mov    %rax,%rdi
  805415:	48 b8 a8 51 80 00 00 	movabs $0x8051a8,%rax
  80541c:	00 00 00 
  80541f:	ff d0                	callq  *%rax
  805421:	85 c0                	test   %eax,%eax
  805423:	74 07                	je     80542c <devpipe_write+0x67>
				return 0;
  805425:	b8 00 00 00 00       	mov    $0x0,%eax
  80542a:	eb 79                	jmp    8054a5 <devpipe_write+0xe0>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  80542c:	48 b8 1f 26 80 00 00 	movabs $0x80261f,%rax
  805433:	00 00 00 
  805436:	ff d0                	callq  *%rax
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  805438:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80543c:	8b 40 04             	mov    0x4(%rax),%eax
  80543f:	48 63 d0             	movslq %eax,%rdx
  805442:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805446:	8b 00                	mov    (%rax),%eax
  805448:	48 98                	cltq   
  80544a:	48 83 c0 20          	add    $0x20,%rax
  80544e:	48 39 c2             	cmp    %rax,%rdx
  805451:	73 b4                	jae    805407 <devpipe_write+0x42>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  805453:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805457:	8b 40 04             	mov    0x4(%rax),%eax
  80545a:	99                   	cltd   
  80545b:	c1 ea 1b             	shr    $0x1b,%edx
  80545e:	01 d0                	add    %edx,%eax
  805460:	83 e0 1f             	and    $0x1f,%eax
  805463:	29 d0                	sub    %edx,%eax
  805465:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805469:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80546d:	48 01 ca             	add    %rcx,%rdx
  805470:	0f b6 0a             	movzbl (%rdx),%ecx
  805473:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805477:	48 98                	cltq   
  805479:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
		p->p_wpos++;
  80547d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805481:	8b 40 04             	mov    0x4(%rax),%eax
  805484:	8d 50 01             	lea    0x1(%rax),%edx
  805487:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80548b:	89 50 04             	mov    %edx,0x4(%rax)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  80548e:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  805493:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805497:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80549b:	0f 82 64 ff ff ff    	jb     805405 <devpipe_write+0x40>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  8054a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8054a5:	c9                   	leaveq 
  8054a6:	c3                   	retq   

00000000008054a7 <devpipe_stat>:

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8054a7:	55                   	push   %rbp
  8054a8:	48 89 e5             	mov    %rsp,%rbp
  8054ab:	48 83 ec 20          	sub    $0x20,%rsp
  8054af:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8054b3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8054b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8054bb:	48 89 c7             	mov    %rax,%rdi
  8054be:	48 b8 3b 32 80 00 00 	movabs $0x80323b,%rax
  8054c5:	00 00 00 
  8054c8:	ff d0                	callq  *%rax
  8054ca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	strcpy(stat->st_name, "<pipe>");
  8054ce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8054d2:	48 be e8 11 82 00 00 	movabs $0x8211e8,%rsi
  8054d9:	00 00 00 
  8054dc:	48 89 c7             	mov    %rax,%rdi
  8054df:	48 b8 2e 1d 80 00 00 	movabs $0x801d2e,%rax
  8054e6:	00 00 00 
  8054e9:	ff d0                	callq  *%rax
	stat->st_size = p->p_wpos - p->p_rpos;
  8054eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8054ef:	8b 50 04             	mov    0x4(%rax),%edx
  8054f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8054f6:	8b 00                	mov    (%rax),%eax
  8054f8:	29 c2                	sub    %eax,%edx
  8054fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8054fe:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	stat->st_isdir = 0;
  805504:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805508:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  80550f:	00 00 00 
	stat->st_dev = &devpipe;
  805512:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805516:	48 b9 00 81 82 00 00 	movabs $0x828100,%rcx
  80551d:	00 00 00 
  805520:	48 89 88 88 00 00 00 	mov    %rcx,0x88(%rax)
	return 0;
  805527:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80552c:	c9                   	leaveq 
  80552d:	c3                   	retq   

000000000080552e <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  80552e:	55                   	push   %rbp
  80552f:	48 89 e5             	mov    %rsp,%rbp
  805532:	48 83 ec 10          	sub    $0x10,%rsp
  805536:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	(void) sys_page_unmap(0, fd);
  80553a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80553e:	48 89 c6             	mov    %rax,%rsi
  805541:	bf 00 00 00 00       	mov    $0x0,%edi
  805546:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  80554d:	00 00 00 
  805550:	ff d0                	callq  *%rax
	return sys_page_unmap(0, fd2data(fd));
  805552:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805556:	48 89 c7             	mov    %rax,%rdi
  805559:	48 b8 3b 32 80 00 00 	movabs $0x80323b,%rax
  805560:	00 00 00 
  805563:	ff d0                	callq  *%rax
  805565:	48 89 c6             	mov    %rax,%rsi
  805568:	bf 00 00 00 00       	mov    $0x0,%edi
  80556d:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  805574:	00 00 00 
  805577:	ff d0                	callq  *%rax
}
  805579:	c9                   	leaveq 
  80557a:	c3                   	retq   

000000000080557b <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  80557b:	55                   	push   %rbp
  80557c:	48 89 e5             	mov    %rsp,%rbp
  80557f:	48 83 ec 20          	sub    $0x20,%rsp
  805583:	89 7d ec             	mov    %edi,-0x14(%rbp)
	char c = ch;
  805586:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805589:	88 45 ff             	mov    %al,-0x1(%rbp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  80558c:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  805590:	be 01 00 00 00       	mov    $0x1,%esi
  805595:	48 89 c7             	mov    %rax,%rdi
  805598:	48 b8 15 25 80 00 00 	movabs $0x802515,%rax
  80559f:	00 00 00 
  8055a2:	ff d0                	callq  *%rax
}
  8055a4:	c9                   	leaveq 
  8055a5:	c3                   	retq   

00000000008055a6 <getchar>:

int
getchar(void)
{
  8055a6:	55                   	push   %rbp
  8055a7:	48 89 e5             	mov    %rsp,%rbp
  8055aa:	48 83 ec 10          	sub    $0x10,%rsp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  8055ae:	48 8d 45 fb          	lea    -0x5(%rbp),%rax
  8055b2:	ba 01 00 00 00       	mov    $0x1,%edx
  8055b7:	48 89 c6             	mov    %rax,%rsi
  8055ba:	bf 00 00 00 00       	mov    $0x0,%edi
  8055bf:	48 b8 30 37 80 00 00 	movabs $0x803730,%rax
  8055c6:	00 00 00 
  8055c9:	ff d0                	callq  *%rax
  8055cb:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r < 0)
  8055ce:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8055d2:	79 05                	jns    8055d9 <getchar+0x33>
		return r;
  8055d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8055d7:	eb 14                	jmp    8055ed <getchar+0x47>
	if (r < 1)
  8055d9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8055dd:	7f 07                	jg     8055e6 <getchar+0x40>
		return -E_EOF;
  8055df:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8055e4:	eb 07                	jmp    8055ed <getchar+0x47>
	return c;
  8055e6:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8055ea:	0f b6 c0             	movzbl %al,%eax
}
  8055ed:	c9                   	leaveq 
  8055ee:	c3                   	retq   

00000000008055ef <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  8055ef:	55                   	push   %rbp
  8055f0:	48 89 e5             	mov    %rsp,%rbp
  8055f3:	48 83 ec 20          	sub    $0x20,%rsp
  8055f7:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8055fa:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8055fe:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805601:	48 89 d6             	mov    %rdx,%rsi
  805604:	89 c7                	mov    %eax,%edi
  805606:	48 b8 fe 32 80 00 00 	movabs $0x8032fe,%rax
  80560d:	00 00 00 
  805610:	ff d0                	callq  *%rax
  805612:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805615:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805619:	79 05                	jns    805620 <iscons+0x31>
		return r;
  80561b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80561e:	eb 1a                	jmp    80563a <iscons+0x4b>
	return fd->fd_dev_id == devcons.dev_id;
  805620:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805624:	8b 10                	mov    (%rax),%edx
  805626:	48 b8 40 81 82 00 00 	movabs $0x828140,%rax
  80562d:	00 00 00 
  805630:	8b 00                	mov    (%rax),%eax
  805632:	39 c2                	cmp    %eax,%edx
  805634:	0f 94 c0             	sete   %al
  805637:	0f b6 c0             	movzbl %al,%eax
}
  80563a:	c9                   	leaveq 
  80563b:	c3                   	retq   

000000000080563c <opencons>:

int
opencons(void)
{
  80563c:	55                   	push   %rbp
  80563d:	48 89 e5             	mov    %rsp,%rbp
  805640:	48 83 ec 10          	sub    $0x10,%rsp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  805644:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  805648:	48 89 c7             	mov    %rax,%rdi
  80564b:	48 b8 66 32 80 00 00 	movabs $0x803266,%rax
  805652:	00 00 00 
  805655:	ff d0                	callq  *%rax
  805657:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80565a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80565e:	79 05                	jns    805665 <opencons+0x29>
		return r;
  805660:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805663:	eb 5b                	jmp    8056c0 <opencons+0x84>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  805665:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805669:	ba 07 04 00 00       	mov    $0x407,%edx
  80566e:	48 89 c6             	mov    %rax,%rsi
  805671:	bf 00 00 00 00       	mov    $0x0,%edi
  805676:	48 b8 5d 26 80 00 00 	movabs $0x80265d,%rax
  80567d:	00 00 00 
  805680:	ff d0                	callq  *%rax
  805682:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805685:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805689:	79 05                	jns    805690 <opencons+0x54>
		return r;
  80568b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80568e:	eb 30                	jmp    8056c0 <opencons+0x84>
	fd->fd_dev_id = devcons.dev_id;
  805690:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805694:	48 ba 40 81 82 00 00 	movabs $0x828140,%rdx
  80569b:	00 00 00 
  80569e:	8b 12                	mov    (%rdx),%edx
  8056a0:	89 10                	mov    %edx,(%rax)
	fd->fd_omode = O_RDWR;
  8056a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8056a6:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	return fd2num(fd);
  8056ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8056b1:	48 89 c7             	mov    %rax,%rdi
  8056b4:	48 b8 18 32 80 00 00 	movabs $0x803218,%rax
  8056bb:	00 00 00 
  8056be:	ff d0                	callq  *%rax
}
  8056c0:	c9                   	leaveq 
  8056c1:	c3                   	retq   

00000000008056c2 <devcons_read>:

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  8056c2:	55                   	push   %rbp
  8056c3:	48 89 e5             	mov    %rsp,%rbp
  8056c6:	48 83 ec 30          	sub    $0x30,%rsp
  8056ca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8056ce:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8056d2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int c;

	if (n == 0)
  8056d6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8056db:	75 07                	jne    8056e4 <devcons_read+0x22>
		return 0;
  8056dd:	b8 00 00 00 00       	mov    $0x0,%eax
  8056e2:	eb 4b                	jmp    80572f <devcons_read+0x6d>

	while ((c = sys_cgetc()) == 0)
  8056e4:	eb 0c                	jmp    8056f2 <devcons_read+0x30>
		sys_yield();
  8056e6:	48 b8 1f 26 80 00 00 	movabs $0x80261f,%rax
  8056ed:	00 00 00 
  8056f0:	ff d0                	callq  *%rax
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  8056f2:	48 b8 5f 25 80 00 00 	movabs $0x80255f,%rax
  8056f9:	00 00 00 
  8056fc:	ff d0                	callq  *%rax
  8056fe:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805701:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805705:	74 df                	je     8056e6 <devcons_read+0x24>
		sys_yield();
	if (c < 0)
  805707:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80570b:	79 05                	jns    805712 <devcons_read+0x50>
		return c;
  80570d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805710:	eb 1d                	jmp    80572f <devcons_read+0x6d>
	if (c == 0x04)	// ctl-d is eof
  805712:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  805716:	75 07                	jne    80571f <devcons_read+0x5d>
		return 0;
  805718:	b8 00 00 00 00       	mov    $0x0,%eax
  80571d:	eb 10                	jmp    80572f <devcons_read+0x6d>
	*(char*)vbuf = c;
  80571f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805722:	89 c2                	mov    %eax,%edx
  805724:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805728:	88 10                	mov    %dl,(%rax)
	return 1;
  80572a:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80572f:	c9                   	leaveq 
  805730:	c3                   	retq   

0000000000805731 <devcons_write>:

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  805731:	55                   	push   %rbp
  805732:	48 89 e5             	mov    %rsp,%rbp
  805735:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  80573c:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  805743:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  80574a:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  805751:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  805758:	eb 76                	jmp    8057d0 <devcons_write+0x9f>
		m = n - tot;
  80575a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  805761:	89 c2                	mov    %eax,%edx
  805763:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805766:	29 c2                	sub    %eax,%edx
  805768:	89 d0                	mov    %edx,%eax
  80576a:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m > sizeof(buf) - 1)
  80576d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805770:	83 f8 7f             	cmp    $0x7f,%eax
  805773:	76 07                	jbe    80577c <devcons_write+0x4b>
			m = sizeof(buf) - 1;
  805775:	c7 45 f8 7f 00 00 00 	movl   $0x7f,-0x8(%rbp)
		memmove(buf, (char*)vbuf + tot, m);
  80577c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80577f:	48 63 d0             	movslq %eax,%rdx
  805782:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805785:	48 63 c8             	movslq %eax,%rcx
  805788:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80578f:	48 01 c1             	add    %rax,%rcx
  805792:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  805799:	48 89 ce             	mov    %rcx,%rsi
  80579c:	48 89 c7             	mov    %rax,%rdi
  80579f:	48 b8 52 20 80 00 00 	movabs $0x802052,%rax
  8057a6:	00 00 00 
  8057a9:	ff d0                	callq  *%rax
		sys_cputs(buf, m);
  8057ab:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8057ae:	48 63 d0             	movslq %eax,%rdx
  8057b1:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8057b8:	48 89 d6             	mov    %rdx,%rsi
  8057bb:	48 89 c7             	mov    %rax,%rdi
  8057be:	48 b8 15 25 80 00 00 	movabs $0x802515,%rax
  8057c5:	00 00 00 
  8057c8:	ff d0                	callq  *%rax
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8057ca:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8057cd:	01 45 fc             	add    %eax,-0x4(%rbp)
  8057d0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8057d3:	48 98                	cltq   
  8057d5:	48 3b 85 58 ff ff ff 	cmp    -0xa8(%rbp),%rax
  8057dc:	0f 82 78 ff ff ff    	jb     80575a <devcons_write+0x29>
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
  8057e2:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8057e5:	c9                   	leaveq 
  8057e6:	c3                   	retq   

00000000008057e7 <devcons_close>:

static int
devcons_close(struct Fd *fd)
{
  8057e7:	55                   	push   %rbp
  8057e8:	48 89 e5             	mov    %rsp,%rbp
  8057eb:	48 83 ec 08          	sub    $0x8,%rsp
  8057ef:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	USED(fd);

	return 0;
  8057f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8057f8:	c9                   	leaveq 
  8057f9:	c3                   	retq   

00000000008057fa <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  8057fa:	55                   	push   %rbp
  8057fb:	48 89 e5             	mov    %rsp,%rbp
  8057fe:	48 83 ec 10          	sub    $0x10,%rsp
  805802:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  805806:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<cons>");
  80580a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80580e:	48 be f4 11 82 00 00 	movabs $0x8211f4,%rsi
  805815:	00 00 00 
  805818:	48 89 c7             	mov    %rax,%rdi
  80581b:	48 b8 2e 1d 80 00 00 	movabs $0x801d2e,%rax
  805822:	00 00 00 
  805825:	ff d0                	callq  *%rax
	return 0;
  805827:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80582c:	c9                   	leaveq 
  80582d:	c3                   	retq   

000000000080582e <set_pgfault_handler>:
// _pgfault_upcall routine when a page fault occurs.


void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  80582e:	55                   	push   %rbp
  80582f:	48 89 e5             	mov    %rsp,%rbp
  805832:	48 83 ec 10          	sub    $0x10,%rsp
  805836:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
        int r;
        //struct Env *thisenv = NULL;
        if (_pgfault_handler == 0) {
  80583a:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  805841:	00 00 00 
  805844:	48 8b 00             	mov    (%rax),%rax
  805847:	48 85 c0             	test   %rax,%rax
  80584a:	0f 85 84 00 00 00    	jne    8058d4 <set_pgfault_handler+0xa6>
                // First time through!
                // LAB 4: Your code here.
                //cprintf("Inside set_pgfault_handler");
                if(0> sys_page_alloc(thisenv->env_id, (void*)UXSTACKTOP - PGSIZE,PTE_U|PTE_P|PTE_W)){
  805850:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  805857:	00 00 00 
  80585a:	48 8b 00             	mov    (%rax),%rax
  80585d:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  805863:	ba 07 00 00 00       	mov    $0x7,%edx
  805868:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  80586d:	89 c7                	mov    %eax,%edi
  80586f:	48 b8 5d 26 80 00 00 	movabs $0x80265d,%rax
  805876:	00 00 00 
  805879:	ff d0                	callq  *%rax
  80587b:	85 c0                	test   %eax,%eax
  80587d:	79 2a                	jns    8058a9 <set_pgfault_handler+0x7b>
                        panic("Page not available for exception stack");
  80587f:	48 ba 00 12 82 00 00 	movabs $0x821200,%rdx
  805886:	00 00 00 
  805889:	be 23 00 00 00       	mov    $0x23,%esi
  80588e:	48 bf 27 12 82 00 00 	movabs $0x821227,%rdi
  805895:	00 00 00 
  805898:	b8 00 00 00 00       	mov    $0x0,%eax
  80589d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8058a4:	00 00 00 
  8058a7:	ff d1                	callq  *%rcx
                }
                sys_env_set_pgfault_upcall(thisenv->env_id, (void*)_pgfault_upcall);
  8058a9:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8058b0:	00 00 00 
  8058b3:	48 8b 00             	mov    (%rax),%rax
  8058b6:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8058bc:	48 be e7 58 80 00 00 	movabs $0x8058e7,%rsi
  8058c3:	00 00 00 
  8058c6:	89 c7                	mov    %eax,%edi
  8058c8:	48 b8 e7 27 80 00 00 	movabs $0x8027e7,%rax
  8058cf:	00 00 00 
  8058d2:	ff d0                	callq  *%rax
				
               // sys_env_set_pgfault_upcall(thisenv->env_id,handler);
        }

        // Save handler pointer for assembly to call.
        _pgfault_handler = handler;
  8058d4:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  8058db:	00 00 00 
  8058de:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8058e2:	48 89 10             	mov    %rdx,(%rax)
}
  8058e5:	c9                   	leaveq 
  8058e6:	c3                   	retq   

00000000008058e7 <_pgfault_upcall>:
.globl _pgfault_upcall
_pgfault_upcall:
// Call the C page fault handler.
// function argument: pointer to UTF

movq  %rsp,%rdi                // passing the function argument in rdi
  8058e7:	48 89 e7             	mov    %rsp,%rdi
movabs _pgfault_handler, %rax
  8058ea:	48 a1 00 b0 b5 00 00 	movabs 0xb5b000,%rax
  8058f1:	00 00 00 
call *%rax
  8058f4:	ff d0                	callq  *%rax
    // LAB 4: Your code here.

    // Return to re-execute the instruction that faulted.
    // LAB 4: Your code here.

	movq 136(%rsp), %rbx  //Load RIP 
  8058f6:	48 8b 9c 24 88 00 00 	mov    0x88(%rsp),%rbx
  8058fd:	00 
	movq 152(%rsp), %rcx  //Load RSP
  8058fe:	48 8b 8c 24 98 00 00 	mov    0x98(%rsp),%rcx
  805905:	00 
	//Move pointer on the stack and save the RIP on trap time stack 
	subq $8, %rcx          
  805906:	48 83 e9 08          	sub    $0x8,%rcx
	movq %rbx, (%rcx) 
  80590a:	48 89 19             	mov    %rbx,(%rcx)
	//Now update value of trap time stack rsp after pushing rip in UXSTACKTOP
	movq %rcx, 152(%rsp)
  80590d:	48 89 8c 24 98 00 00 	mov    %rcx,0x98(%rsp)
  805914:	00 
	
	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addq $16,%rsp
  805915:	48 83 c4 10          	add    $0x10,%rsp
	POPA_ 
  805919:	4c 8b 3c 24          	mov    (%rsp),%r15
  80591d:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  805922:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  805927:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  80592c:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  805931:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  805936:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  80593b:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  805940:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  805945:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  80594a:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  80594f:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  805954:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  805959:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  80595e:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  805963:	48 83 c4 78          	add    $0x78,%rsp
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addq $8, %rsp
  805967:	48 83 c4 08          	add    $0x8,%rsp
	popfq
  80596b:	9d                   	popfq  
	
	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popq %rsp
  80596c:	5c                   	pop    %rsp
	
	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	ret
  80596d:	c3                   	retq   

000000000080596e <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  80596e:	55                   	push   %rbp
  80596f:	48 89 e5             	mov    %rsp,%rbp
  805972:	48 83 ec 18          	sub    $0x18,%rsp
  805976:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	pte_t pte;

	if (!(uvpd[VPD(v)] & PTE_P))
  80597a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80597e:	48 c1 e8 15          	shr    $0x15,%rax
  805982:	48 89 c2             	mov    %rax,%rdx
  805985:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  80598c:	01 00 00 
  80598f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  805993:	83 e0 01             	and    $0x1,%eax
  805996:	48 85 c0             	test   %rax,%rax
  805999:	75 07                	jne    8059a2 <pageref+0x34>
		return 0;
  80599b:	b8 00 00 00 00       	mov    $0x0,%eax
  8059a0:	eb 53                	jmp    8059f5 <pageref+0x87>
	pte = uvpt[PGNUM(v)];
  8059a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8059a6:	48 c1 e8 0c          	shr    $0xc,%rax
  8059aa:	48 89 c2             	mov    %rax,%rdx
  8059ad:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8059b4:	01 00 00 
  8059b7:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8059bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(pte & PTE_P))
  8059bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8059c3:	83 e0 01             	and    $0x1,%eax
  8059c6:	48 85 c0             	test   %rax,%rax
  8059c9:	75 07                	jne    8059d2 <pageref+0x64>
		return 0;
  8059cb:	b8 00 00 00 00       	mov    $0x0,%eax
  8059d0:	eb 23                	jmp    8059f5 <pageref+0x87>
	return pages[PPN(pte)].pp_ref;
  8059d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8059d6:	48 c1 e8 0c          	shr    $0xc,%rax
  8059da:	48 89 c2             	mov    %rax,%rdx
  8059dd:	48 b8 00 00 a0 00 80 	movabs $0x8000a00000,%rax
  8059e4:	00 00 00 
  8059e7:	48 c1 e2 04          	shl    $0x4,%rdx
  8059eb:	48 01 d0             	add    %rdx,%rax
  8059ee:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8059f2:	0f b7 c0             	movzwl %ax,%eax
}
  8059f5:	c9                   	leaveq 
  8059f6:	c3                   	retq   

00000000008059f7 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  8059f7:	55                   	push   %rbp
  8059f8:	48 89 e5             	mov    %rsp,%rbp
  socksem   = sys_sem_new(1);
  8059fb:	bf 01 00 00 00       	mov    $0x1,%edi
  805a00:	48 b8 9b 7a 81 00 00 	movabs $0x817a9b,%rax
  805a07:	00 00 00 
  805a0a:	ff d0                	callq  *%rax
  805a0c:	48 ba a8 94 82 00 00 	movabs $0x8294a8,%rdx
  805a13:	00 00 00 
  805a16:	89 02                	mov    %eax,(%rdx)
  selectsem = sys_sem_new(1);
  805a18:	bf 01 00 00 00       	mov    $0x1,%edi
  805a1d:	48 b8 9b 7a 81 00 00 	movabs $0x817a9b,%rax
  805a24:	00 00 00 
  805a27:	ff d0                	callq  *%rax
  805a29:	48 ba ac 94 82 00 00 	movabs $0x8294ac,%rdx
  805a30:	00 00 00 
  805a33:	89 02                	mov    %eax,(%rdx)
}
  805a35:	5d                   	pop    %rbp
  805a36:	c3                   	retq   

0000000000805a37 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  805a37:	55                   	push   %rbp
  805a38:	48 89 e5             	mov    %rsp,%rbp
  805a3b:	48 83 ec 14          	sub    $0x14,%rsp
  805a3f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  805a42:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805a46:	78 06                	js     805a4e <get_socket+0x17>
  805a48:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  805a4c:	7e 17                	jle    805a65 <get_socket+0x2e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  805a4e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805a55:	00 00 00 
  805a58:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  805a5e:	b8 00 00 00 00       	mov    $0x0,%eax
  805a63:	eb 44                	jmp    805aa9 <get_socket+0x72>
  }

  sock = &sockets[s];
  805a65:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805a68:	48 98                	cltq   
  805a6a:	48 c1 e0 05          	shl    $0x5,%rax
  805a6e:	48 89 c2             	mov    %rax,%rdx
  805a71:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805a78:	00 00 00 
  805a7b:	48 01 d0             	add    %rdx,%rax
  805a7e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (!sock->conn) {
  805a82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805a86:	48 8b 00             	mov    (%rax),%rax
  805a89:	48 85 c0             	test   %rax,%rax
  805a8c:	75 17                	jne    805aa5 <get_socket+0x6e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  805a8e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805a95:	00 00 00 
  805a98:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  805a9e:	b8 00 00 00 00       	mov    $0x0,%eax
  805aa3:	eb 04                	jmp    805aa9 <get_socket+0x72>
  }

  return sock;
  805aa5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  805aa9:	c9                   	leaveq 
  805aaa:	c3                   	retq   

0000000000805aab <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  805aab:	55                   	push   %rbp
  805aac:	48 89 e5             	mov    %rsp,%rbp
  805aaf:	48 83 ec 20          	sub    $0x20,%rsp
  805ab3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  805ab7:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805abe:	00 00 00 
  805ac1:	8b 00                	mov    (%rax),%eax
  805ac3:	89 c7                	mov    %eax,%edi
  805ac5:	48 b8 bb e3 80 00 00 	movabs $0x80e3bb,%rax
  805acc:	00 00 00 
  805acf:	ff d0                	callq  *%rax

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805ad1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  805ad8:	e9 28 01 00 00       	jmpq   805c05 <alloc_socket+0x15a>
    if (!sockets[i].conn) {
  805add:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805ae4:	00 00 00 
  805ae7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805aea:	48 63 d2             	movslq %edx,%rdx
  805aed:	48 c1 e2 05          	shl    $0x5,%rdx
  805af1:	48 01 d0             	add    %rdx,%rax
  805af4:	48 8b 00             	mov    (%rax),%rax
  805af7:	48 85 c0             	test   %rax,%rax
  805afa:	0f 85 01 01 00 00    	jne    805c01 <alloc_socket+0x156>
      sockets[i].conn       = newconn;
  805b00:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805b07:	00 00 00 
  805b0a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805b0d:	48 63 d2             	movslq %edx,%rdx
  805b10:	48 c1 e2 05          	shl    $0x5,%rdx
  805b14:	48 01 c2             	add    %rax,%rdx
  805b17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805b1b:	48 89 02             	mov    %rax,(%rdx)
      sockets[i].lastdata   = NULL;
  805b1e:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805b25:	00 00 00 
  805b28:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805b2b:	48 63 d2             	movslq %edx,%rdx
  805b2e:	48 c1 e2 05          	shl    $0x5,%rdx
  805b32:	48 01 d0             	add    %rdx,%rax
  805b35:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  805b3c:	00 
      sockets[i].lastoffset = 0;
  805b3d:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805b44:	00 00 00 
  805b47:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805b4a:	48 63 d2             	movslq %edx,%rdx
  805b4d:	48 c1 e2 05          	shl    $0x5,%rdx
  805b51:	48 01 d0             	add    %rdx,%rax
  805b54:	48 83 c0 10          	add    $0x10,%rax
  805b58:	66 c7 00 00 00       	movw   $0x0,(%rax)
      sockets[i].rcvevent   = 0;
  805b5d:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805b64:	00 00 00 
  805b67:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805b6a:	48 63 d2             	movslq %edx,%rdx
  805b6d:	48 c1 e2 05          	shl    $0x5,%rdx
  805b71:	48 01 d0             	add    %rdx,%rax
  805b74:	48 83 c0 10          	add    $0x10,%rax
  805b78:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  805b7e:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805b85:	00 00 00 
  805b88:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805b8b:	48 63 d2             	movslq %edx,%rdx
  805b8e:	48 c1 e2 05          	shl    $0x5,%rdx
  805b92:	48 01 d0             	add    %rdx,%rax
  805b95:	48 83 c0 10          	add    $0x10,%rax
  805b99:	66 c7 40 04 01 00    	movw   $0x1,0x4(%rax)
      sockets[i].flags      = 0;
  805b9f:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805ba6:	00 00 00 
  805ba9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805bac:	48 63 d2             	movslq %edx,%rdx
  805baf:	48 c1 e2 05          	shl    $0x5,%rdx
  805bb3:	48 01 d0             	add    %rdx,%rax
  805bb6:	48 83 c0 10          	add    $0x10,%rax
  805bba:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
      sockets[i].err        = 0;
  805bc0:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805bc7:	00 00 00 
  805bca:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805bcd:	48 63 d2             	movslq %edx,%rdx
  805bd0:	48 c1 e2 05          	shl    $0x5,%rdx
  805bd4:	48 01 d0             	add    %rdx,%rax
  805bd7:	48 83 c0 10          	add    $0x10,%rax
  805bdb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      sys_sem_signal(socksem);
  805be2:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805be9:	00 00 00 
  805bec:	8b 00                	mov    (%rax),%eax
  805bee:	89 c7                	mov    %eax,%edi
  805bf0:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  805bf7:	00 00 00 
  805bfa:	ff d0                	callq  *%rax
      return i;
  805bfc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805bff:	eb 2d                	jmp    805c2e <alloc_socket+0x183>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805c01:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  805c05:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  805c09:	0f 8e ce fe ff ff    	jle    805add <alloc_socket+0x32>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  805c0f:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805c16:	00 00 00 
  805c19:	8b 00                	mov    (%rax),%eax
  805c1b:	89 c7                	mov    %eax,%edi
  805c1d:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  805c24:	00 00 00 
  805c27:	ff d0                	callq  *%rax
  return -1;
  805c29:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  805c2e:	c9                   	leaveq 
  805c2f:	c3                   	retq   

0000000000805c30 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  805c30:	55                   	push   %rbp
  805c31:	48 89 e5             	mov    %rsp,%rbp
  805c34:	53                   	push   %rbx
  805c35:	48 83 ec 78          	sub    $0x78,%rsp
  805c39:	89 7d 9c             	mov    %edi,-0x64(%rbp)
  805c3c:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  805c40:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  805c44:	8b 45 9c             	mov    -0x64(%rbp),%eax
  805c47:	89 c7                	mov    %eax,%edi
  805c49:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  805c50:	00 00 00 
  805c53:	ff d0                	callq  *%rax
  805c55:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (!sock)
  805c59:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  805c5e:	75 0a                	jne    805c6a <lwip_accept+0x3a>
    return -1;
  805c60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805c65:	e9 f2 02 00 00       	jmpq   805f5c <lwip_accept+0x32c>

  newconn = netconn_accept(sock->conn);
  805c6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805c6e:	48 8b 00             	mov    (%rax),%rax
  805c71:	48 89 c7             	mov    %rax,%rdi
  805c74:	48 b8 3b 9c 81 00 00 	movabs $0x819c3b,%rax
  805c7b:	00 00 00 
  805c7e:	ff d0                	callq  *%rax
  805c80:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (!newconn) {
  805c84:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  805c89:	75 62                	jne    805ced <lwip_accept+0xbd>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  805c8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805c8f:	48 8b 00             	mov    (%rax),%rax
  805c92:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805c96:	0f be c0             	movsbl %al,%eax
  805c99:	f7 d8                	neg    %eax
  805c9b:	83 f8 0e             	cmp    $0xe,%eax
  805c9e:	77 24                	ja     805cc4 <lwip_accept+0x94>
  805ca0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805ca4:	48 8b 00             	mov    (%rax),%rax
  805ca7:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805cab:	0f be c0             	movsbl %al,%eax
  805cae:	f7 d8                	neg    %eax
  805cb0:	89 c2                	mov    %eax,%edx
  805cb2:	48 b8 40 12 82 00 00 	movabs $0x821240,%rax
  805cb9:	00 00 00 
  805cbc:	48 63 d2             	movslq %edx,%rdx
  805cbf:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805cc2:	eb 05                	jmp    805cc9 <lwip_accept+0x99>
  805cc4:	b8 05 00 00 00       	mov    $0x5,%eax
  805cc9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  805ccd:	89 42 18             	mov    %eax,0x18(%rdx)
  805cd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805cd4:	8b 50 18             	mov    0x18(%rax),%edx
  805cd7:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805cde:	00 00 00 
  805ce1:	89 10                	mov    %edx,(%rax)
    return -1;
  805ce3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805ce8:	e9 6f 02 00 00       	jmpq   805f5c <lwip_accept+0x32c>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  805ced:	48 8d 55 be          	lea    -0x42(%rbp),%rdx
  805cf1:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  805cf5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805cf9:	b9 00 00 00 00       	mov    $0x0,%ecx
  805cfe:	48 89 c7             	mov    %rax,%rdi
  805d01:	48 b8 4c 99 81 00 00 	movabs $0x81994c,%rax
  805d08:	00 00 00 
  805d0b:	ff d0                	callq  *%rax
  805d0d:	88 45 df             	mov    %al,-0x21(%rbp)
  if (err != ERR_OK) {
  805d10:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  805d14:	74 61                	je     805d77 <lwip_accept+0x147>
    netconn_delete(newconn);
  805d16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805d1a:	48 89 c7             	mov    %rax,%rdi
  805d1d:	48 b8 9e 98 81 00 00 	movabs $0x81989e,%rax
  805d24:	00 00 00 
  805d27:	ff d0                	callq  *%rax
    sock_set_errno(sock, err_to_errno(err));
  805d29:	0f be 45 df          	movsbl -0x21(%rbp),%eax
  805d2d:	f7 d8                	neg    %eax
  805d2f:	83 f8 0e             	cmp    $0xe,%eax
  805d32:	77 1a                	ja     805d4e <lwip_accept+0x11e>
  805d34:	0f be 45 df          	movsbl -0x21(%rbp),%eax
  805d38:	f7 d8                	neg    %eax
  805d3a:	89 c2                	mov    %eax,%edx
  805d3c:	48 b8 40 12 82 00 00 	movabs $0x821240,%rax
  805d43:	00 00 00 
  805d46:	48 63 d2             	movslq %edx,%rdx
  805d49:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805d4c:	eb 05                	jmp    805d53 <lwip_accept+0x123>
  805d4e:	b8 05 00 00 00       	mov    $0x5,%eax
  805d53:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  805d57:	89 42 18             	mov    %eax,0x18(%rdx)
  805d5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805d5e:	8b 50 18             	mov    0x18(%rax),%edx
  805d61:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805d68:	00 00 00 
  805d6b:	89 10                	mov    %edx,(%rax)
    return -1;
  805d6d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805d72:	e9 e5 01 00 00       	jmpq   805f5c <lwip_accept+0x32c>
  }

  memset(&sin, 0, sizeof(sin));
  805d77:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  805d7b:	ba 10 00 00 00       	mov    $0x10,%edx
  805d80:	be 00 00 00 00       	mov    $0x0,%esi
  805d85:	48 89 c7             	mov    %rax,%rdi
  805d88:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  805d8f:	00 00 00 
  805d92:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  805d94:	c6 45 a0 10          	movb   $0x10,-0x60(%rbp)
  sin.sin_family = AF_INET;
  805d98:	c6 45 a1 02          	movb   $0x2,-0x5f(%rbp)
  sin.sin_port = htons(port);
  805d9c:	0f b7 45 be          	movzwl -0x42(%rbp),%eax
  805da0:	0f b7 c0             	movzwl %ax,%eax
  805da3:	89 c7                	mov    %eax,%edi
  805da5:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  805dac:	00 00 00 
  805daf:	ff d0                	callq  *%rax
  805db1:	66 89 45 a2          	mov    %ax,-0x5e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  805db5:	8b 45 c0             	mov    -0x40(%rbp),%eax
  805db8:	89 45 a4             	mov    %eax,-0x5c(%rbp)

  if (*addrlen > sizeof(sin))
  805dbb:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  805dbf:	8b 00                	mov    (%rax),%eax
  805dc1:	83 f8 10             	cmp    $0x10,%eax
  805dc4:	76 0a                	jbe    805dd0 <lwip_accept+0x1a0>
    *addrlen = sizeof(sin);
  805dc6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  805dca:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(addr, &sin, *addrlen);
  805dd0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  805dd4:	8b 00                	mov    (%rax),%eax
  805dd6:	89 c2                	mov    %eax,%edx
  805dd8:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  805ddc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  805de0:	48 89 ce             	mov    %rcx,%rsi
  805de3:	48 89 c7             	mov    %rax,%rdi
  805de6:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  805ded:	00 00 00 
  805df0:	ff d0                	callq  *%rax

  newsock = alloc_socket(newconn);
  805df2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805df6:	48 89 c7             	mov    %rax,%rdi
  805df9:	48 b8 ab 5a 80 00 00 	movabs $0x805aab,%rax
  805e00:	00 00 00 
  805e03:	ff d0                	callq  *%rax
  805e05:	89 45 d8             	mov    %eax,-0x28(%rbp)
  if (newsock == -1) {
  805e08:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%rbp)
  805e0c:	75 3b                	jne    805e49 <lwip_accept+0x219>
    netconn_delete(newconn);
  805e0e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805e12:	48 89 c7             	mov    %rax,%rdi
  805e15:	48 b8 9e 98 81 00 00 	movabs $0x81989e,%rax
  805e1c:	00 00 00 
  805e1f:	ff d0                	callq  *%rax
    sock_set_errno(sock, ENFILE);
  805e21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805e25:	c7 40 18 17 00 00 00 	movl   $0x17,0x18(%rax)
  805e2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805e30:	8b 50 18             	mov    0x18(%rax),%edx
  805e33:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805e3a:	00 00 00 
  805e3d:	89 10                	mov    %edx,(%rax)
    return -1;
  805e3f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805e44:	e9 13 01 00 00       	jmpq   805f5c <lwip_accept+0x32c>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  805e49:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  805e4d:	78 06                	js     805e55 <lwip_accept+0x225>
  805e4f:	83 7d d8 1f          	cmpl   $0x1f,-0x28(%rbp)
  805e53:	7e 2a                	jle    805e7f <lwip_accept+0x24f>
  805e55:	48 ba 7c 12 82 00 00 	movabs $0x82127c,%rdx
  805e5c:	00 00 00 
  805e5f:	be 25 01 00 00       	mov    $0x125,%esi
  805e64:	48 bf 91 12 82 00 00 	movabs $0x821291,%rdi
  805e6b:	00 00 00 
  805e6e:	b8 00 00 00 00       	mov    $0x0,%eax
  805e73:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  805e7a:	00 00 00 
  805e7d:	ff d1                	callq  *%rcx
  newconn->callback = event_callback;
  805e7f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805e83:	48 bb ef 73 80 00 00 	movabs $0x8073ef,%rbx
  805e8a:	00 00 00 
  805e8d:	48 89 58 38          	mov    %rbx,0x38(%rax)
  nsock = &sockets[newsock];
  805e91:	8b 45 d8             	mov    -0x28(%rbp),%eax
  805e94:	48 98                	cltq   
  805e96:	48 c1 e0 05          	shl    $0x5,%rax
  805e9a:	48 89 c2             	mov    %rax,%rdx
  805e9d:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805ea4:	00 00 00 
  805ea7:	48 01 d0             	add    %rdx,%rax
  805eaa:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  805eae:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  805eb3:	75 2a                	jne    805edf <lwip_accept+0x2af>
  805eb5:	48 ba a8 12 82 00 00 	movabs $0x8212a8,%rdx
  805ebc:	00 00 00 
  805ebf:	be 28 01 00 00       	mov    $0x128,%esi
  805ec4:	48 bf 91 12 82 00 00 	movabs $0x821291,%rdi
  805ecb:	00 00 00 
  805ece:	b8 00 00 00 00       	mov    $0x0,%eax
  805ed3:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  805eda:	00 00 00 
  805edd:	ff d1                	callq  *%rcx

  sys_sem_wait(socksem);
  805edf:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805ee6:	00 00 00 
  805ee9:	8b 00                	mov    (%rax),%eax
  805eeb:	89 c7                	mov    %eax,%edi
  805eed:	48 b8 bb e3 80 00 00 	movabs $0x80e3bb,%rax
  805ef4:	00 00 00 
  805ef7:	ff d0                	callq  *%rax
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  805ef9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805efd:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  805f01:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805f05:	8b 40 20             	mov    0x20(%rax),%eax
  805f08:	29 c2                	sub    %eax,%edx
  805f0a:	89 d0                	mov    %edx,%eax
  805f0c:	8d 50 ff             	lea    -0x1(%rax),%edx
  805f0f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805f13:	66 89 50 12          	mov    %dx,0x12(%rax)
  newconn->socket = newsock;
  805f17:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805f1b:	8b 55 d8             	mov    -0x28(%rbp),%edx
  805f1e:	89 50 20             	mov    %edx,0x20(%rax)
  sys_sem_signal(socksem);
  805f21:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805f28:	00 00 00 
  805f2b:	8b 00                	mov    (%rax),%eax
  805f2d:	89 c7                	mov    %eax,%edi
  805f2f:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  805f36:	00 00 00 
  805f39:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  805f3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805f3f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  805f46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805f4a:	8b 50 18             	mov    0x18(%rax),%edx
  805f4d:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805f54:	00 00 00 
  805f57:	89 10                	mov    %edx,(%rax)
  return newsock;
  805f59:	8b 45 d8             	mov    -0x28(%rbp),%eax
}
  805f5c:	48 83 c4 78          	add    $0x78,%rsp
  805f60:	5b                   	pop    %rbx
  805f61:	5d                   	pop    %rbp
  805f62:	c3                   	retq   

0000000000805f63 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  805f63:	55                   	push   %rbp
  805f64:	48 89 e5             	mov    %rsp,%rbp
  805f67:	48 83 ec 20          	sub    $0x20,%rsp
  805f6b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  805f6e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  805f72:	89 55 e8             	mov    %edx,-0x18(%rbp)
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  805f75:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805f78:	89 c7                	mov    %eax,%edi
  805f7a:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  805f81:	00 00 00 
  805f84:	ff d0                	callq  *%rax
  805f86:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  805f8a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805f8f:	75 0a                	jne    805f9b <lwip_bind+0x38>
    return -1;
  805f91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805f96:	e9 fb 00 00 00       	jmpq   806096 <lwip_bind+0x133>

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  805f9b:	83 7d e8 10          	cmpl   $0x10,-0x18(%rbp)
  805f9f:	75 0c                	jne    805fad <lwip_bind+0x4a>
  805fa1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805fa5:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  805fa9:	3c 02                	cmp    $0x2,%al
  805fab:	74 2a                	je     805fd7 <lwip_bind+0x74>
  805fad:	48 ba bf 12 82 00 00 	movabs $0x8212bf,%rdx
  805fb4:	00 00 00 
  805fb7:	be 4a 01 00 00       	mov    $0x14a,%esi
  805fbc:	48 bf 91 12 82 00 00 	movabs $0x821291,%rdi
  805fc3:	00 00 00 
  805fc6:	b8 00 00 00 00       	mov    $0x0,%eax
  805fcb:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  805fd2:	00 00 00 
  805fd5:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  805fd7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805fdb:	8b 40 04             	mov    0x4(%rax),%eax
  805fde:	89 45 f0             	mov    %eax,-0x10(%rbp)
  local_port = ((struct sockaddr_in *)name)->sin_port;
  805fe1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805fe5:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  805fe9:	66 89 45 f6          	mov    %ax,-0xa(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  805fed:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  805ff1:	89 c7                	mov    %eax,%edi
  805ff3:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  805ffa:	00 00 00 
  805ffd:	ff d0                	callq  *%rax
  805fff:	0f b7 d0             	movzwl %ax,%edx
  806002:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806006:	48 8b 00             	mov    (%rax),%rax
  806009:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  80600d:	48 89 ce             	mov    %rcx,%rsi
  806010:	48 89 c7             	mov    %rax,%rdi
  806013:	48 b8 42 9a 81 00 00 	movabs $0x819a42,%rax
  80601a:	00 00 00 
  80601d:	ff d0                	callq  *%rax
  80601f:	88 45 f5             	mov    %al,-0xb(%rbp)

  if (err != ERR_OK) {
  806022:	80 7d f5 00          	cmpb   $0x0,-0xb(%rbp)
  806026:	74 4b                	je     806073 <lwip_bind+0x110>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806028:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  80602c:	f7 d8                	neg    %eax
  80602e:	83 f8 0e             	cmp    $0xe,%eax
  806031:	77 1a                	ja     80604d <lwip_bind+0xea>
  806033:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  806037:	f7 d8                	neg    %eax
  806039:	89 c2                	mov    %eax,%edx
  80603b:	48 b8 40 12 82 00 00 	movabs $0x821240,%rax
  806042:	00 00 00 
  806045:	48 63 d2             	movslq %edx,%rdx
  806048:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  80604b:	eb 05                	jmp    806052 <lwip_bind+0xef>
  80604d:	b8 05 00 00 00       	mov    $0x5,%eax
  806052:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806056:	89 42 18             	mov    %eax,0x18(%rdx)
  806059:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80605d:	8b 50 18             	mov    0x18(%rax),%edx
  806060:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806067:	00 00 00 
  80606a:	89 10                	mov    %edx,(%rax)
    return -1;
  80606c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806071:	eb 23                	jmp    806096 <lwip_bind+0x133>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  806073:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806077:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  80607e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806082:	8b 50 18             	mov    0x18(%rax),%edx
  806085:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80608c:	00 00 00 
  80608f:	89 10                	mov    %edx,(%rax)
  return 0;
  806091:	b8 00 00 00 00       	mov    $0x0,%eax
}
  806096:	c9                   	leaveq 
  806097:	c3                   	retq   

0000000000806098 <lwip_close>:

int
lwip_close(int s)
{
  806098:	55                   	push   %rbp
  806099:	48 89 e5             	mov    %rsp,%rbp
  80609c:	48 83 ec 20          	sub    $0x20,%rsp
  8060a0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  8060a3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8060a6:	89 c7                	mov    %eax,%edi
  8060a8:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  8060af:	00 00 00 
  8060b2:	ff d0                	callq  *%rax
  8060b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock) {
  8060b8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8060bd:	75 0a                	jne    8060c9 <lwip_close+0x31>
    return -1;
  8060bf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8060c4:	e9 b2 00 00 00       	jmpq   80617b <lwip_close+0xe3>
  }

  netconn_delete(sock->conn);
  8060c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8060cd:	48 8b 00             	mov    (%rax),%rax
  8060d0:	48 89 c7             	mov    %rax,%rdi
  8060d3:	48 b8 9e 98 81 00 00 	movabs $0x81989e,%rax
  8060da:	00 00 00 
  8060dd:	ff d0                	callq  *%rax

  sys_sem_wait(socksem);
  8060df:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  8060e6:	00 00 00 
  8060e9:	8b 00                	mov    (%rax),%eax
  8060eb:	89 c7                	mov    %eax,%edi
  8060ed:	48 b8 bb e3 80 00 00 	movabs $0x80e3bb,%rax
  8060f4:	00 00 00 
  8060f7:	ff d0                	callq  *%rax
  if (sock->lastdata) {
  8060f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8060fd:	48 8b 40 08          	mov    0x8(%rax),%rax
  806101:	48 85 c0             	test   %rax,%rax
  806104:	74 17                	je     80611d <lwip_close+0x85>
    netbuf_delete(sock->lastdata);
  806106:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80610a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80610e:	48 89 c7             	mov    %rax,%rdi
  806111:	48 b8 84 8b 80 00 00 	movabs $0x808b84,%rax
  806118:	00 00 00 
  80611b:	ff d0                	callq  *%rax
  }
  sock->lastdata   = NULL;
  80611d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806121:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  806128:	00 
  sock->lastoffset = 0;
  806129:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80612d:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  sock->conn       = NULL;
  806133:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806137:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  sock_set_errno(sock, 0);
  80613e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806142:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806149:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80614d:	8b 50 18             	mov    0x18(%rax),%edx
  806150:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806157:	00 00 00 
  80615a:	89 10                	mov    %edx,(%rax)
  sys_sem_signal(socksem);
  80615c:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  806163:	00 00 00 
  806166:	8b 00                	mov    (%rax),%eax
  806168:	89 c7                	mov    %eax,%edi
  80616a:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  806171:	00 00 00 
  806174:	ff d0                	callq  *%rax
  return 0;
  806176:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80617b:	c9                   	leaveq 
  80617c:	c3                   	retq   

000000000080617d <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80617d:	55                   	push   %rbp
  80617e:	48 89 e5             	mov    %rsp,%rbp
  806181:	48 83 ec 30          	sub    $0x30,%rsp
  806185:	89 7d dc             	mov    %edi,-0x24(%rbp)
  806188:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80618c:	89 55 d8             	mov    %edx,-0x28(%rbp)
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  80618f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  806192:	89 c7                	mov    %eax,%edi
  806194:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  80619b:	00 00 00 
  80619e:	ff d0                	callq  *%rax
  8061a0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  8061a4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8061a9:	75 0a                	jne    8061b5 <lwip_connect+0x38>
    return -1;
  8061ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8061b0:	e9 22 01 00 00       	jmpq   8062d7 <lwip_connect+0x15a>

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8061b5:	83 7d d8 10          	cmpl   $0x10,-0x28(%rbp)
  8061b9:	75 0c                	jne    8061c7 <lwip_connect+0x4a>
  8061bb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8061bf:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8061c3:	3c 02                	cmp    $0x2,%al
  8061c5:	74 2a                	je     8061f1 <lwip_connect+0x74>
  8061c7:	48 ba da 12 82 00 00 	movabs $0x8212da,%rdx
  8061ce:	00 00 00 
  8061d1:	be 86 01 00 00       	mov    $0x186,%esi
  8061d6:	48 bf 91 12 82 00 00 	movabs $0x821291,%rdi
  8061dd:	00 00 00 
  8061e0:	b8 00 00 00 00       	mov    $0x0,%eax
  8061e5:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8061ec:	00 00 00 
  8061ef:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
  8061f1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8061f5:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8061f9:	84 c0                	test   %al,%al
  8061fb:	75 1b                	jne    806218 <lwip_connect+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
  8061fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806201:	48 8b 00             	mov    (%rax),%rax
  806204:	48 89 c7             	mov    %rax,%rdi
  806207:	48 b8 56 9b 81 00 00 	movabs $0x819b56,%rax
  80620e:	00 00 00 
  806211:	ff d0                	callq  *%rax
  806213:	88 45 ff             	mov    %al,-0x1(%rbp)
  806216:	eb 4b                	jmp    806263 <lwip_connect+0xe6>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  806218:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80621c:	8b 40 04             	mov    0x4(%rax),%eax
  80621f:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port = ((struct sockaddr_in *)name)->sin_port;
  806222:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  806226:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80622a:	66 89 45 ee          	mov    %ax,-0x12(%rbp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  80622e:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806232:	89 c7                	mov    %eax,%edi
  806234:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  80623b:	00 00 00 
  80623e:	ff d0                	callq  *%rax
  806240:	0f b7 d0             	movzwl %ax,%edx
  806243:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806247:	48 8b 00             	mov    (%rax),%rax
  80624a:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  80624e:	48 89 ce             	mov    %rcx,%rsi
  806251:	48 89 c7             	mov    %rax,%rdi
  806254:	48 b8 cc 9a 81 00 00 	movabs $0x819acc,%rax
  80625b:	00 00 00 
  80625e:	ff d0                	callq  *%rax
  806260:	88 45 ff             	mov    %al,-0x1(%rbp)
  }

  if (err != ERR_OK) {
  806263:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  806267:	74 4b                	je     8062b4 <lwip_connect+0x137>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806269:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  80626d:	f7 d8                	neg    %eax
  80626f:	83 f8 0e             	cmp    $0xe,%eax
  806272:	77 1a                	ja     80628e <lwip_connect+0x111>
  806274:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  806278:	f7 d8                	neg    %eax
  80627a:	89 c2                	mov    %eax,%edx
  80627c:	48 b8 40 12 82 00 00 	movabs $0x821240,%rax
  806283:	00 00 00 
  806286:	48 63 d2             	movslq %edx,%rdx
  806289:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  80628c:	eb 05                	jmp    806293 <lwip_connect+0x116>
  80628e:	b8 05 00 00 00       	mov    $0x5,%eax
  806293:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  806297:	89 42 18             	mov    %eax,0x18(%rdx)
  80629a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80629e:	8b 50 18             	mov    0x18(%rax),%edx
  8062a1:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8062a8:	00 00 00 
  8062ab:	89 10                	mov    %edx,(%rax)
    return -1;
  8062ad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8062b2:	eb 23                	jmp    8062d7 <lwip_connect+0x15a>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8062b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8062b8:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8062bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8062c3:	8b 50 18             	mov    0x18(%rax),%edx
  8062c6:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8062cd:	00 00 00 
  8062d0:	89 10                	mov    %edx,(%rax)
  return 0;
  8062d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8062d7:	c9                   	leaveq 
  8062d8:	c3                   	retq   

00000000008062d9 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  8062d9:	55                   	push   %rbp
  8062da:	48 89 e5             	mov    %rsp,%rbp
  8062dd:	48 83 ec 20          	sub    $0x20,%rsp
  8062e1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8062e4:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  8062e7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8062ea:	89 c7                	mov    %eax,%edi
  8062ec:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  8062f3:	00 00 00 
  8062f6:	ff d0                	callq  *%rax
  8062f8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  8062fc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806301:	75 0a                	jne    80630d <lwip_listen+0x34>
    return -1;
  806303:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806308:	e9 b2 00 00 00       	jmpq   8063bf <lwip_listen+0xe6>

  /* limit the "backlog" parameter to fit in an u8_t */
  if (backlog < 0) {
  80630d:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  806311:	79 07                	jns    80631a <lwip_listen+0x41>
    backlog = 0;
  806313:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  }
  if (backlog > 0xff) {
  80631a:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%rbp)
  806321:	7e 07                	jle    80632a <lwip_listen+0x51>
    backlog = 0xff;
  806323:	c7 45 e8 ff 00 00 00 	movl   $0xff,-0x18(%rbp)
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  80632a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80632d:	0f b6 d0             	movzbl %al,%edx
  806330:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806334:	48 8b 00             	mov    (%rax),%rax
  806337:	89 d6                	mov    %edx,%esi
  806339:	48 89 c7             	mov    %rax,%rdi
  80633c:	48 b8 c6 9b 81 00 00 	movabs $0x819bc6,%rax
  806343:	00 00 00 
  806346:	ff d0                	callq  *%rax
  806348:	88 45 f7             	mov    %al,-0x9(%rbp)

  if (err != ERR_OK) {
  80634b:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80634f:	74 4b                	je     80639c <lwip_listen+0xc3>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806351:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806355:	f7 d8                	neg    %eax
  806357:	83 f8 0e             	cmp    $0xe,%eax
  80635a:	77 1a                	ja     806376 <lwip_listen+0x9d>
  80635c:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806360:	f7 d8                	neg    %eax
  806362:	89 c2                	mov    %eax,%edx
  806364:	48 b8 40 12 82 00 00 	movabs $0x821240,%rax
  80636b:	00 00 00 
  80636e:	48 63 d2             	movslq %edx,%rdx
  806371:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806374:	eb 05                	jmp    80637b <lwip_listen+0xa2>
  806376:	b8 05 00 00 00       	mov    $0x5,%eax
  80637b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80637f:	89 42 18             	mov    %eax,0x18(%rdx)
  806382:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806386:	8b 50 18             	mov    0x18(%rax),%edx
  806389:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806390:	00 00 00 
  806393:	89 10                	mov    %edx,(%rax)
    return -1;
  806395:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80639a:	eb 23                	jmp    8063bf <lwip_listen+0xe6>
  }

  sock_set_errno(sock, 0);
  80639c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063a0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8063a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063ab:	8b 50 18             	mov    0x18(%rax),%edx
  8063ae:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8063b5:	00 00 00 
  8063b8:	89 10                	mov    %edx,(%rax)
  return 0;
  8063ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8063bf:	c9                   	leaveq 
  8063c0:	c3                   	retq   

00000000008063c1 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8063c1:	55                   	push   %rbp
  8063c2:	48 89 e5             	mov    %rsp,%rbp
  8063c5:	48 83 ec 70          	sub    $0x70,%rsp
  8063c9:	89 7d bc             	mov    %edi,-0x44(%rbp)
  8063cc:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8063d0:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8063d3:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  8063d6:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  8063da:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
  struct lwip_socket *sock;
  struct netbuf      *buf;
  u16_t               buflen, copylen, off = 0;
  8063de:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;
  8063e4:	c6 45 e7 00          	movb   $0x0,-0x19(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8063e8:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8063eb:	89 c7                	mov    %eax,%edi
  8063ed:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  8063f4:	00 00 00 
  8063f7:	ff d0                	callq  *%rax
  8063f9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (!sock)
  8063fd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  806402:	75 0a                	jne    80640e <lwip_recvfrom+0x4d>
    return -1;
  806404:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806409:	e9 8b 03 00 00       	jmpq   806799 <lwip_recvfrom+0x3d8>

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  80640e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806412:	48 8b 40 08          	mov    0x8(%rax),%rax
  806416:	48 85 c0             	test   %rax,%rax
  806419:	74 11                	je     80642c <lwip_recvfrom+0x6b>
      buf = sock->lastdata;
  80641b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80641f:	48 8b 40 08          	mov    0x8(%rax),%rax
  806423:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  806427:	e9 0c 01 00 00       	jmpq   806538 <lwip_recvfrom+0x177>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80642c:	8b 45 ac             	mov    -0x54(%rbp),%eax
  80642f:	83 e0 08             	and    $0x8,%eax
  806432:	85 c0                	test   %eax,%eax
  806434:	75 14                	jne    80644a <lwip_recvfrom+0x89>
  806436:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80643a:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80643e:	0f b7 c0             	movzwl %ax,%eax
  806441:	25 00 08 00 00       	and    $0x800,%eax
  806446:	85 c0                	test   %eax,%eax
  806448:	74 35                	je     80647f <lwip_recvfrom+0xbe>
  80644a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80644e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806452:	66 85 c0             	test   %ax,%ax
  806455:	75 28                	jne    80647f <lwip_recvfrom+0xbe>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  806457:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80645b:	c7 40 18 0b 00 00 00 	movl   $0xb,0x18(%rax)
  806462:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806466:	8b 50 18             	mov    0x18(%rax),%edx
  806469:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806470:	00 00 00 
  806473:	89 10                	mov    %edx,(%rax)
        return -1;
  806475:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80647a:	e9 1a 03 00 00       	jmpq   806799 <lwip_recvfrom+0x3d8>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  80647f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806483:	48 8b 00             	mov    (%rax),%rax
  806486:	48 89 c7             	mov    %rax,%rdi
  806489:	48 b8 fd 9c 81 00 00 	movabs $0x819cfd,%rax
  806490:	00 00 00 
  806493:	ff d0                	callq  *%rax
  806495:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  806499:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80649d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8064a1:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  8064a5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8064aa:	0f 85 88 00 00 00    	jne    806538 <lwip_recvfrom+0x177>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8064b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8064b4:	48 8b 00             	mov    (%rax),%rax
  8064b7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8064bb:	48 85 c0             	test   %rax,%rax
  8064be:	74 0f                	je     8064cf <lwip_recvfrom+0x10e>
  8064c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8064c4:	48 8b 00             	mov    (%rax),%rax
  8064c7:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8064cb:	84 c0                	test   %al,%al
  8064cd:	74 40                	je     80650f <lwip_recvfrom+0x14e>
  8064cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8064d3:	48 8b 00             	mov    (%rax),%rax
  8064d6:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8064da:	0f be c0             	movsbl %al,%eax
  8064dd:	f7 d8                	neg    %eax
  8064df:	83 f8 0e             	cmp    $0xe,%eax
  8064e2:	77 24                	ja     806508 <lwip_recvfrom+0x147>
  8064e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8064e8:	48 8b 00             	mov    (%rax),%rax
  8064eb:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8064ef:	0f be c0             	movsbl %al,%eax
  8064f2:	f7 d8                	neg    %eax
  8064f4:	89 c2                	mov    %eax,%edx
  8064f6:	48 b8 40 12 82 00 00 	movabs $0x821240,%rax
  8064fd:	00 00 00 
  806500:	48 63 d2             	movslq %edx,%rdx
  806503:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806506:	eb 05                	jmp    80650d <lwip_recvfrom+0x14c>
  806508:	b8 05 00 00 00       	mov    $0x5,%eax
  80650d:	eb 05                	jmp    806514 <lwip_recvfrom+0x153>
  80650f:	b8 6e 00 00 00       	mov    $0x6e,%eax
  806514:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  806518:	89 42 18             	mov    %eax,0x18(%rdx)
  80651b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80651f:	8b 50 18             	mov    0x18(%rax),%edx
  806522:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806529:	00 00 00 
  80652c:	89 10                	mov    %edx,(%rax)
        return 0;
  80652e:	b8 00 00 00 00       	mov    $0x0,%eax
  806533:	e9 61 02 00 00       	jmpq   806799 <lwip_recvfrom+0x3d8>
      }
    }

    buflen = netbuf_len(buf);
  806538:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80653c:	48 8b 00             	mov    (%rax),%rax
  80653f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806543:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  806547:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80654b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80654f:	66 29 45 d6          	sub    %ax,-0x2a(%rbp)

    if (len > buflen) {
  806553:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  806557:	3b 45 b8             	cmp    -0x48(%rbp),%eax
  80655a:	7d 0a                	jge    806566 <lwip_recvfrom+0x1a5>
      copylen = buflen;
  80655c:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  806560:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  806564:	eb 07                	jmp    80656d <lwip_recvfrom+0x1ac>
    } else {
      copylen = len;
  806566:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806569:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80656d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806571:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806575:	0f b7 c8             	movzwl %ax,%ecx
  806578:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80657c:	0f b7 75 f4          	movzwl -0xc(%rbp),%esi
  806580:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  806584:	48 01 c6             	add    %rax,%rsi
  806587:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80658b:	48 8b 00             	mov    (%rax),%rax
  80658e:	48 89 c7             	mov    %rax,%rdi
  806591:	48 b8 1d e1 80 00 00 	movabs $0x80e11d,%rax
  806598:	00 00 00 
  80659b:	ff d0                	callq  *%rax

    off += copylen;
  80659d:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8065a1:	66 01 45 f4          	add    %ax,-0xc(%rbp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8065a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8065a9:	48 8b 00             	mov    (%rax),%rax
  8065ac:	48 89 c7             	mov    %rax,%rdi
  8065af:	48 b8 07 99 81 00 00 	movabs $0x819907,%rax
  8065b6:	00 00 00 
  8065b9:	ff d0                	callq  *%rax
  8065bb:	83 f8 10             	cmp    $0x10,%eax
  8065be:	75 35                	jne    8065f5 <lwip_recvfrom+0x234>
      len -= copylen;
  8065c0:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8065c4:	29 45 b8             	sub    %eax,-0x48(%rbp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8065c7:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  8065cb:	7e 22                	jle    8065ef <lwip_recvfrom+0x22e>
  8065cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8065d1:	48 8b 00             	mov    (%rax),%rax
  8065d4:	0f b6 40 15          	movzbl 0x15(%rax),%eax
  8065d8:	0f b6 c0             	movzbl %al,%eax
  8065db:	83 e0 01             	and    $0x1,%eax
  8065de:	85 c0                	test   %eax,%eax
  8065e0:	75 0d                	jne    8065ef <lwip_recvfrom+0x22e>
  8065e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8065e6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8065ea:	66 85 c0             	test   %ax,%ax
  8065ed:	75 0a                	jne    8065f9 <lwip_recvfrom+0x238>
        done = 1;
  8065ef:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
  8065f3:	eb 04                	jmp    8065f9 <lwip_recvfrom+0x238>
      }
    } else {
      done = 1;
  8065f5:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8065f9:	8b 45 ac             	mov    -0x54(%rbp),%eax
  8065fc:	83 e0 01             	and    $0x1,%eax
  8065ff:	85 c0                	test   %eax,%eax
  806601:	75 6e                	jne    806671 <lwip_recvfrom+0x2b0>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  806603:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806607:	48 8b 00             	mov    (%rax),%rax
  80660a:	8b 00                	mov    (%rax),%eax
  80660c:	83 f8 10             	cmp    $0x10,%eax
  80660f:	75 35                	jne    806646 <lwip_recvfrom+0x285>
  806611:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  806615:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  806619:	29 c2                	sub    %eax,%edx
  80661b:	89 d0                	mov    %edx,%eax
  80661d:	85 c0                	test   %eax,%eax
  80661f:	7e 25                	jle    806646 <lwip_recvfrom+0x285>
        sock->lastdata = buf;
  806621:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806625:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806629:	48 89 50 08          	mov    %rdx,0x8(%rax)
        sock->lastoffset += copylen;
  80662d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806631:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  806635:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  806639:	01 c2                	add    %eax,%edx
  80663b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80663f:	66 89 50 10          	mov    %dx,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  806643:	90                   	nop
  806644:	eb 2f                	jmp    806675 <lwip_recvfrom+0x2b4>
      } else {
        sock->lastdata = NULL;
  806646:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80664a:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  806651:	00 
        sock->lastoffset = 0;
  806652:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806656:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  80665c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806660:	48 89 c7             	mov    %rax,%rdi
  806663:	48 b8 84 8b 80 00 00 	movabs $0x808b84,%rax
  80666a:	00 00 00 
  80666d:	ff d0                	callq  *%rax
  80666f:	eb 04                	jmp    806675 <lwip_recvfrom+0x2b4>
      }
    } else {
      done = 1;
  806671:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }
  } while (!done);
  806675:	80 7d e7 00          	cmpb   $0x0,-0x19(%rbp)
  806679:	0f 84 8f fd ff ff    	je     80640e <lwip_recvfrom+0x4d>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  80667f:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806684:	0f 84 ed 00 00 00    	je     806777 <lwip_recvfrom+0x3b6>
  80668a:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  80668f:	0f 84 e2 00 00 00    	je     806777 <lwip_recvfrom+0x3b6>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  806695:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806699:	48 8b 00             	mov    (%rax),%rax
  80669c:	48 89 c7             	mov    %rax,%rdi
  80669f:	48 b8 07 99 81 00 00 	movabs $0x819907,%rax
  8066a6:	00 00 00 
  8066a9:	ff d0                	callq  *%rax
  8066ab:	83 f8 10             	cmp    $0x10,%eax
  8066ae:	75 31                	jne    8066e1 <lwip_recvfrom+0x320>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8066b0:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8066b4:	48 83 c0 04          	add    $0x4,%rax
  8066b8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      netconn_getaddr(sock->conn, addr, &port, 0);
  8066bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8066c0:	48 8b 00             	mov    (%rax),%rax
  8066c3:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
  8066c7:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8066cb:	b9 00 00 00 00       	mov    $0x0,%ecx
  8066d0:	48 89 c7             	mov    %rax,%rdi
  8066d3:	48 b8 4c 99 81 00 00 	movabs $0x81994c,%rax
  8066da:	00 00 00 
  8066dd:	ff d0                	callq  *%rax
  8066df:	eb 18                	jmp    8066f9 <lwip_recvfrom+0x338>
    } else {
      addr = netbuf_fromaddr(buf);
  8066e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8066e5:	48 8b 40 10          	mov    0x10(%rax),%rax
  8066e9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      port = netbuf_fromport(buf);
  8066ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8066f1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8066f5:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
    }

    memset(&sin, 0, sizeof(sin));
  8066f9:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8066fd:	ba 10 00 00 00       	mov    $0x10,%edx
  806702:	be 00 00 00 00       	mov    $0x0,%esi
  806707:	48 89 c7             	mov    %rax,%rdi
  80670a:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  806711:	00 00 00 
  806714:	ff d0                	callq  *%rax
    sin.sin_len = sizeof(sin);
  806716:	c6 45 c0 10          	movb   $0x10,-0x40(%rbp)
    sin.sin_family = AF_INET;
  80671a:	c6 45 c1 02          	movb   $0x2,-0x3f(%rbp)
    sin.sin_port = htons(port);
  80671e:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  806722:	0f b7 c0             	movzwl %ax,%eax
  806725:	89 c7                	mov    %eax,%edi
  806727:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  80672e:	00 00 00 
  806731:	ff d0                	callq  *%rax
  806733:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
    sin.sin_addr.s_addr = addr->addr;
  806737:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80673b:	8b 00                	mov    (%rax),%eax
  80673d:	89 45 c4             	mov    %eax,-0x3c(%rbp)

    if (*fromlen > sizeof(sin))
  806740:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806744:	8b 00                	mov    (%rax),%eax
  806746:	83 f8 10             	cmp    $0x10,%eax
  806749:	76 0a                	jbe    806755 <lwip_recvfrom+0x394>
      *fromlen = sizeof(sin);
  80674b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80674f:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

    SMEMCPY(from, &sin, *fromlen);
  806755:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806759:	8b 00                	mov    (%rax),%eax
  80675b:	89 c2                	mov    %eax,%edx
  80675d:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  806761:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806765:	48 89 ce             	mov    %rcx,%rsi
  806768:	48 89 c7             	mov    %rax,%rdi
  80676b:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  806772:	00 00 00 
  806775:	ff d0                	callq  *%rax
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  806777:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80677b:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806782:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806786:	8b 50 18             	mov    0x18(%rax),%edx
  806789:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806790:	00 00 00 
  806793:	89 10                	mov    %edx,(%rax)
  return off;
  806795:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
}
  806799:	c9                   	leaveq 
  80679a:	c3                   	retq   

000000000080679b <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  80679b:	55                   	push   %rbp
  80679c:	48 89 e5             	mov    %rsp,%rbp
  80679f:	48 83 ec 10          	sub    $0x10,%rsp
  8067a3:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8067a6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8067aa:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  8067ad:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8067b0:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8067b4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8067b7:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8067bd:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8067c3:	b9 00 00 00 00       	mov    $0x0,%ecx
  8067c8:	89 c7                	mov    %eax,%edi
  8067ca:	48 b8 c1 63 80 00 00 	movabs $0x8063c1,%rax
  8067d1:	00 00 00 
  8067d4:	ff d0                	callq  *%rax
}
  8067d6:	c9                   	leaveq 
  8067d7:	c3                   	retq   

00000000008067d8 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  8067d8:	55                   	push   %rbp
  8067d9:	48 89 e5             	mov    %rsp,%rbp
  8067dc:	48 83 ec 20          	sub    $0x20,%rsp
  8067e0:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8067e3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8067e7:	89 55 f8             	mov    %edx,-0x8(%rbp)
  8067ea:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8067ed:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  8067f0:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8067f3:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8067f7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8067fa:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806800:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806806:	89 c7                	mov    %eax,%edi
  806808:	48 b8 c1 63 80 00 00 	movabs $0x8063c1,%rax
  80680f:	00 00 00 
  806812:	ff d0                	callq  *%rax
}
  806814:	c9                   	leaveq 
  806815:	c3                   	retq   

0000000000806816 <lwip_send>:

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  806816:	55                   	push   %rbp
  806817:	48 89 e5             	mov    %rsp,%rbp
  80681a:	48 83 ec 30          	sub    $0x30,%rsp
  80681e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806821:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  806825:	89 55 e8             	mov    %edx,-0x18(%rbp)
  806828:	89 4d dc             	mov    %ecx,-0x24(%rbp)
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  80682b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80682e:	89 c7                	mov    %eax,%edi
  806830:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  806837:	00 00 00 
  80683a:	ff d0                	callq  *%rax
  80683c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  806840:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806845:	75 0a                	jne    806851 <lwip_send+0x3b>
    return -1;
  806847:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80684c:	e9 c3 00 00 00       	jmpq   806914 <lwip_send+0xfe>

  if (sock->conn->type!=NETCONN_TCP) {
  806851:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806855:	48 8b 00             	mov    (%rax),%rax
  806858:	8b 00                	mov    (%rax),%eax
  80685a:	83 f8 10             	cmp    $0x10,%eax
  80685d:	74 2c                	je     80688b <lwip_send+0x75>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  80685f:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  806862:	8b 55 e8             	mov    -0x18(%rbp),%edx
  806865:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  806869:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80686c:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806872:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806878:	89 c7                	mov    %eax,%edi
  80687a:	48 b8 16 69 80 00 00 	movabs $0x806916,%rax
  806881:	00 00 00 
  806884:	ff d0                	callq  *%rax
  806886:	e9 89 00 00 00       	jmpq   806914 <lwip_send+0xfe>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  80688b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80688e:	83 e0 10             	and    $0x10,%eax
  806891:	85 c0                	test   %eax,%eax
  806893:	74 07                	je     80689c <lwip_send+0x86>
  806895:	b8 03 00 00 00       	mov    $0x3,%eax
  80689a:	eb 05                	jmp    8068a1 <lwip_send+0x8b>
  80689c:	b8 01 00 00 00       	mov    $0x1,%eax
  8068a1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8068a5:	48 8b 3a             	mov    (%rdx),%rdi
  8068a8:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8068ab:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8068af:	89 c1                	mov    %eax,%ecx
  8068b1:	48 b8 5b a0 81 00 00 	movabs $0x81a05b,%rax
  8068b8:	00 00 00 
  8068bb:	ff d0                	callq  *%rax
  8068bd:	88 45 f7             	mov    %al,-0x9(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  8068c0:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  8068c4:	f7 d8                	neg    %eax
  8068c6:	83 f8 0e             	cmp    $0xe,%eax
  8068c9:	77 1a                	ja     8068e5 <lwip_send+0xcf>
  8068cb:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  8068cf:	f7 d8                	neg    %eax
  8068d1:	89 c2                	mov    %eax,%edx
  8068d3:	48 b8 40 12 82 00 00 	movabs $0x821240,%rax
  8068da:	00 00 00 
  8068dd:	48 63 d2             	movslq %edx,%rdx
  8068e0:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  8068e3:	eb 05                	jmp    8068ea <lwip_send+0xd4>
  8068e5:	b8 05 00 00 00       	mov    $0x5,%eax
  8068ea:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8068ee:	89 42 18             	mov    %eax,0x18(%rdx)
  8068f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8068f5:	8b 50 18             	mov    0x18(%rax),%edx
  8068f8:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8068ff:	00 00 00 
  806902:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806904:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  806908:	75 05                	jne    80690f <lwip_send+0xf9>
  80690a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80690d:	eb 05                	jmp    806914 <lwip_send+0xfe>
  80690f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  806914:	c9                   	leaveq 
  806915:	c3                   	retq   

0000000000806916 <lwip_sendto>:

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  806916:	55                   	push   %rbp
  806917:	48 89 e5             	mov    %rsp,%rbp
  80691a:	48 83 ec 60          	sub    $0x60,%rsp
  80691e:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806921:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806925:	89 55 b8             	mov    %edx,-0x48(%rbp)
  806928:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  80692b:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  80692f:	44 89 4d a8          	mov    %r9d,-0x58(%rbp)
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  806933:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806936:	89 c7                	mov    %eax,%edi
  806938:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  80693f:	00 00 00 
  806942:	ff d0                	callq  *%rax
  806944:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  806948:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80694d:	75 0a                	jne    806959 <lwip_sendto+0x43>
    return -1;
  80694f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806954:	e9 d8 01 00 00       	jmpq   806b31 <lwip_sendto+0x21b>

  if (sock->conn->type==NETCONN_TCP) {
  806959:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80695d:	48 8b 00             	mov    (%rax),%rax
  806960:	8b 00                	mov    (%rax),%eax
  806962:	83 f8 10             	cmp    $0x10,%eax
  806965:	75 20                	jne    806987 <lwip_sendto+0x71>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  806967:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  80696a:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80696d:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  806971:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806974:	89 c7                	mov    %eax,%edi
  806976:	48 b8 16 68 80 00 00 	movabs $0x806816,%rax
  80697d:	00 00 00 
  806980:	ff d0                	callq  *%rax
  806982:	e9 aa 01 00 00       	jmpq   806b31 <lwip_sendto+0x21b>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  806987:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  80698b:	78 09                	js     806996 <lwip_sendto+0x80>
  80698d:	81 7d b8 ff ff 00 00 	cmpl   $0xffff,-0x48(%rbp)
  806994:	7e 2a                	jle    8069c0 <lwip_sendto+0xaa>
  806996:	48 ba f8 12 82 00 00 	movabs $0x8212f8,%rdx
  80699d:	00 00 00 
  8069a0:	be 97 02 00 00       	mov    $0x297,%esi
  8069a5:	48 bf 91 12 82 00 00 	movabs $0x821291,%rdi
  8069ac:	00 00 00 
  8069af:	b8 00 00 00 00       	mov    $0x0,%eax
  8069b4:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8069bb:	00 00 00 
  8069be:	ff d1                	callq  *%rcx
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8069c0:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8069c5:	75 06                	jne    8069cd <lwip_sendto+0xb7>
  8069c7:	83 7d a8 00          	cmpl   $0x0,-0x58(%rbp)
  8069cb:	74 3c                	je     806a09 <lwip_sendto+0xf3>
  8069cd:	83 7d a8 10          	cmpl   $0x10,-0x58(%rbp)
  8069d1:	75 0c                	jne    8069df <lwip_sendto+0xc9>
  8069d3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8069d7:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8069db:	3c 02                	cmp    $0x2,%al
  8069dd:	74 2a                	je     806a09 <lwip_sendto+0xf3>
  8069df:	48 ba 1c 13 82 00 00 	movabs $0x82131c,%rdx
  8069e6:	00 00 00 
  8069e9:	be 9b 02 00 00       	mov    $0x29b,%esi
  8069ee:	48 bf 91 12 82 00 00 	movabs $0x821291,%rdi
  8069f5:	00 00 00 
  8069f8:	b8 00 00 00 00       	mov    $0x0,%eax
  8069fd:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  806a04:	00 00 00 
  806a07:	ff d1                	callq  *%rcx
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  806a09:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  806a10:	00 
  806a11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  806a15:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  if (to) {
  806a19:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806a1e:	74 39                	je     806a59 <lwip_sendto+0x143>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  806a20:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806a24:	8b 40 04             	mov    0x4(%rax),%eax
  806a27:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  806a2a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806a2e:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  806a32:	0f b7 c0             	movzwl %ax,%eax
  806a35:	89 c7                	mov    %eax,%edi
  806a37:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  806a3e:	00 00 00 
  806a41:	ff d0                	callq  *%rax
  806a43:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    buf.addr         = &remote_addr;
  806a47:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806a4b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    buf.port         = remote_port;
  806a4f:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806a53:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  806a57:	eb 1b                	jmp    806a74 <lwip_sendto+0x15e>
  } else {
    remote_addr.addr = 0;
  806a59:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    remote_port      = 0;
  806a60:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    buf.addr         = NULL;
  806a66:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  806a6d:	00 
    buf.port         = 0;
  806a6e:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  806a74:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806a77:	0f b7 d0             	movzwl %ax,%edx
  806a7a:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  806a7e:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806a82:	48 89 ce             	mov    %rcx,%rsi
  806a85:	48 89 c7             	mov    %rax,%rdi
  806a88:	48 b8 5c 8d 80 00 00 	movabs $0x808d5c,%rax
  806a8f:	00 00 00 
  806a92:	ff d0                	callq  *%rax
  806a94:	0f be c0             	movsbl %al,%eax
  806a97:	89 45 fc             	mov    %eax,-0x4(%rbp)
  806a9a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806a9e:	75 23                	jne    806ac3 <lwip_sendto+0x1ad>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  806aa0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806aa4:	48 8b 00             	mov    (%rax),%rax
  806aa7:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  806aab:	48 89 d6             	mov    %rdx,%rsi
  806aae:	48 89 c7             	mov    %rax,%rdi
  806ab1:	48 b8 df 9f 81 00 00 	movabs $0x819fdf,%rax
  806ab8:	00 00 00 
  806abb:	ff d0                	callq  *%rax
  806abd:	0f be c0             	movsbl %al,%eax
  806ac0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  806ac3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  806ac7:	48 85 c0             	test   %rax,%rax
  806aca:	74 13                	je     806adf <lwip_sendto+0x1c9>
    pbuf_free(buf.p);
  806acc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  806ad0:	48 89 c7             	mov    %rax,%rdi
  806ad3:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  806ada:	00 00 00 
  806add:	ff d0                	callq  *%rax
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  806adf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806ae2:	f7 d8                	neg    %eax
  806ae4:	83 f8 0e             	cmp    $0xe,%eax
  806ae7:	77 19                	ja     806b02 <lwip_sendto+0x1ec>
  806ae9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806aec:	f7 d8                	neg    %eax
  806aee:	89 c2                	mov    %eax,%edx
  806af0:	48 b8 40 12 82 00 00 	movabs $0x821240,%rax
  806af7:	00 00 00 
  806afa:	48 63 d2             	movslq %edx,%rdx
  806afd:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806b00:	eb 05                	jmp    806b07 <lwip_sendto+0x1f1>
  806b02:	b8 05 00 00 00       	mov    $0x5,%eax
  806b07:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  806b0b:	89 42 18             	mov    %eax,0x18(%rdx)
  806b0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806b12:	8b 50 18             	mov    0x18(%rax),%edx
  806b15:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806b1c:	00 00 00 
  806b1f:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806b21:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806b25:	75 05                	jne    806b2c <lwip_sendto+0x216>
  806b27:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806b2a:	eb 05                	jmp    806b31 <lwip_sendto+0x21b>
  806b2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  806b31:	c9                   	leaveq 
  806b32:	c3                   	retq   

0000000000806b33 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
  806b33:	55                   	push   %rbp
  806b34:	48 89 e5             	mov    %rsp,%rbp
  806b37:	48 83 ec 20          	sub    $0x20,%rsp
  806b3b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806b3e:	89 75 e8             	mov    %esi,-0x18(%rbp)
  806b41:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  806b44:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806b47:	83 f8 02             	cmp    $0x2,%eax
  806b4a:	74 38                	je     806b84 <lwip_socket+0x51>
  806b4c:	83 f8 03             	cmp    $0x3,%eax
  806b4f:	74 0a                	je     806b5b <lwip_socket+0x28>
  806b51:	83 f8 01             	cmp    $0x1,%eax
  806b54:	74 66                	je     806bbc <lwip_socket+0x89>
  806b56:	e9 87 00 00 00       	jmpq   806be2 <lwip_socket+0xaf>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  806b5b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  806b5e:	0f b6 c0             	movzbl %al,%eax
  806b61:	48 ba ef 73 80 00 00 	movabs $0x8073ef,%rdx
  806b68:	00 00 00 
  806b6b:	89 c6                	mov    %eax,%esi
  806b6d:	bf 40 00 00 00       	mov    $0x40,%edi
  806b72:	48 b8 fb 96 81 00 00 	movabs $0x8196fb,%rax
  806b79:	00 00 00 
  806b7c:	ff d0                	callq  *%rax
  806b7e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806b82:	eb 78                	jmp    806bfc <lwip_socket+0xc9>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  806b84:	81 7d e4 88 00 00 00 	cmpl   $0x88,-0x1c(%rbp)
  806b8b:	75 07                	jne    806b94 <lwip_socket+0x61>
  806b8d:	b8 21 00 00 00       	mov    $0x21,%eax
  806b92:	eb 05                	jmp    806b99 <lwip_socket+0x66>
  806b94:	b8 20 00 00 00       	mov    $0x20,%eax
  806b99:	48 ba ef 73 80 00 00 	movabs $0x8073ef,%rdx
  806ba0:	00 00 00 
  806ba3:	be 00 00 00 00       	mov    $0x0,%esi
  806ba8:	89 c7                	mov    %eax,%edi
  806baa:	48 b8 fb 96 81 00 00 	movabs $0x8196fb,%rax
  806bb1:	00 00 00 
  806bb4:	ff d0                	callq  *%rax
  806bb6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806bba:	eb 40                	jmp    806bfc <lwip_socket+0xc9>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  806bbc:	48 ba ef 73 80 00 00 	movabs $0x8073ef,%rdx
  806bc3:	00 00 00 
  806bc6:	be 00 00 00 00       	mov    $0x0,%esi
  806bcb:	bf 10 00 00 00       	mov    $0x10,%edi
  806bd0:	48 b8 fb 96 81 00 00 	movabs $0x8196fb,%rax
  806bd7:	00 00 00 
  806bda:	ff d0                	callq  *%rax
  806bdc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806be0:	eb 1a                	jmp    806bfc <lwip_socket+0xc9>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  806be2:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806be9:	00 00 00 
  806bec:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
    return -1;
  806bf2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806bf7:	e9 81 00 00 00       	jmpq   806c7d <lwip_socket+0x14a>
  }

  if (!conn) {
  806bfc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806c01:	75 17                	jne    806c1a <lwip_socket+0xe7>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  806c03:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806c0a:	00 00 00 
  806c0d:	c7 00 69 00 00 00    	movl   $0x69,(%rax)
    return -1;
  806c13:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806c18:	eb 63                	jmp    806c7d <lwip_socket+0x14a>
  }

  i = alloc_socket(conn);
  806c1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806c1e:	48 89 c7             	mov    %rax,%rdi
  806c21:	48 b8 ab 5a 80 00 00 	movabs $0x805aab,%rax
  806c28:	00 00 00 
  806c2b:	ff d0                	callq  *%rax
  806c2d:	89 45 f4             	mov    %eax,-0xc(%rbp)

  if (i == -1) {
  806c30:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%rbp)
  806c34:	75 2a                	jne    806c60 <lwip_socket+0x12d>
    netconn_delete(conn);
  806c36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806c3a:	48 89 c7             	mov    %rax,%rdi
  806c3d:	48 b8 9e 98 81 00 00 	movabs $0x81989e,%rax
  806c44:	00 00 00 
  806c47:	ff d0                	callq  *%rax
    set_errno(ENFILE);
  806c49:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806c50:	00 00 00 
  806c53:	c7 00 17 00 00 00    	movl   $0x17,(%rax)
    return -1;
  806c59:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806c5e:	eb 1d                	jmp    806c7d <lwip_socket+0x14a>
  }
  conn->socket = i;
  806c60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806c64:	8b 55 f4             	mov    -0xc(%rbp),%edx
  806c67:	89 50 20             	mov    %edx,0x20(%rax)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  806c6a:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806c71:	00 00 00 
  806c74:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  return i;
  806c7a:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  806c7d:	c9                   	leaveq 
  806c7e:	c3                   	retq   

0000000000806c7f <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  806c7f:	55                   	push   %rbp
  806c80:	48 89 e5             	mov    %rsp,%rbp
  806c83:	48 83 ec 10          	sub    $0x10,%rsp
  806c87:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806c8a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806c8e:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_send(s, data, size, 0);
  806c91:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806c94:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806c98:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806c9b:	b9 00 00 00 00       	mov    $0x0,%ecx
  806ca0:	89 c7                	mov    %eax,%edi
  806ca2:	48 b8 16 68 80 00 00 	movabs $0x806816,%rax
  806ca9:	00 00 00 
  806cac:	ff d0                	callq  *%rax
}
  806cae:	c9                   	leaveq 
  806caf:	c3                   	retq   

0000000000806cb0 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  806cb0:	55                   	push   %rbp
  806cb1:	48 89 e5             	mov    %rsp,%rbp
  806cb4:	48 83 ec 60          	sub    $0x60,%rsp
  806cb8:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806cbb:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806cbf:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  806cc3:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
  int i, nready = 0;
  806cc7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  806cce:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806cd2:	ba 04 00 00 00       	mov    $0x4,%edx
  806cd7:	be 00 00 00 00       	mov    $0x0,%esi
  806cdc:	48 89 c7             	mov    %rax,%rdi
  806cdf:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  806ce6:	00 00 00 
  806ce9:	ff d0                	callq  *%rax
  FD_ZERO(&lwriteset);
  806ceb:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  806cef:	ba 04 00 00 00       	mov    $0x4,%edx
  806cf4:	be 00 00 00 00       	mov    $0x0,%esi
  806cf9:	48 89 c7             	mov    %rax,%rdi
  806cfc:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  806d03:	00 00 00 
  806d06:	ff d0                	callq  *%rax
  FD_ZERO(&lexceptset);
  806d08:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806d0c:	ba 04 00 00 00       	mov    $0x4,%edx
  806d11:	be 00 00 00 00       	mov    $0x0,%esi
  806d16:	48 89 c7             	mov    %rax,%rdi
  806d19:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  806d20:	00 00 00 
  806d23:	ff d0                	callq  *%rax
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  806d25:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  806d2c:	e9 29 01 00 00       	jmpq   806e5a <lwip_selscan+0x1aa>
    if (FD_ISSET(i, readset)) {
  806d31:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806d34:	8d 50 07             	lea    0x7(%rax),%edx
  806d37:	85 c0                	test   %eax,%eax
  806d39:	0f 48 c2             	cmovs  %edx,%eax
  806d3c:	c1 f8 03             	sar    $0x3,%eax
  806d3f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  806d43:	48 98                	cltq   
  806d45:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  806d49:	0f b6 d0             	movzbl %al,%edx
  806d4c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806d4f:	83 e0 07             	and    $0x7,%eax
  806d52:	89 c1                	mov    %eax,%ecx
  806d54:	d3 fa                	sar    %cl,%edx
  806d56:	89 d0                	mov    %edx,%eax
  806d58:	83 e0 01             	and    $0x1,%eax
  806d5b:	85 c0                	test   %eax,%eax
  806d5d:	74 6b                	je     806dca <lwip_selscan+0x11a>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  806d5f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806d62:	89 c7                	mov    %eax,%edi
  806d64:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  806d6b:	00 00 00 
  806d6e:	ff d0                	callq  *%rax
  806d70:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  806d74:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806d79:	74 4f                	je     806dca <lwip_selscan+0x11a>
  806d7b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806d7f:	48 8b 40 08          	mov    0x8(%rax),%rax
  806d83:	48 85 c0             	test   %rax,%rax
  806d86:	75 0d                	jne    806d95 <lwip_selscan+0xe5>
  806d88:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806d8c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806d90:	66 85 c0             	test   %ax,%ax
  806d93:	74 35                	je     806dca <lwip_selscan+0x11a>
        FD_SET(i, &lreadset);
  806d95:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806d98:	8d 50 07             	lea    0x7(%rax),%edx
  806d9b:	85 c0                	test   %eax,%eax
  806d9d:	0f 48 c2             	cmovs  %edx,%eax
  806da0:	c1 f8 03             	sar    $0x3,%eax
  806da3:	48 63 d0             	movslq %eax,%rdx
  806da6:	0f b6 54 15 e0       	movzbl -0x20(%rbp,%rdx,1),%edx
  806dab:	89 d6                	mov    %edx,%esi
  806dad:	8b 55 fc             	mov    -0x4(%rbp),%edx
  806db0:	83 e2 07             	and    $0x7,%edx
  806db3:	bf 01 00 00 00       	mov    $0x1,%edi
  806db8:	89 d1                	mov    %edx,%ecx
  806dba:	d3 e7                	shl    %cl,%edi
  806dbc:	89 fa                	mov    %edi,%edx
  806dbe:	09 f2                	or     %esi,%edx
  806dc0:	48 98                	cltq   
  806dc2:	88 54 05 e0          	mov    %dl,-0x20(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  806dc6:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  806dca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806dcd:	8d 50 07             	lea    0x7(%rax),%edx
  806dd0:	85 c0                	test   %eax,%eax
  806dd2:	0f 48 c2             	cmovs  %edx,%eax
  806dd5:	c1 f8 03             	sar    $0x3,%eax
  806dd8:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  806ddc:	48 98                	cltq   
  806dde:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  806de2:	0f b6 d0             	movzbl %al,%edx
  806de5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806de8:	83 e0 07             	and    $0x7,%eax
  806deb:	89 c1                	mov    %eax,%ecx
  806ded:	d3 fa                	sar    %cl,%edx
  806def:	89 d0                	mov    %edx,%eax
  806df1:	83 e0 01             	and    $0x1,%eax
  806df4:	85 c0                	test   %eax,%eax
  806df6:	74 5e                	je     806e56 <lwip_selscan+0x1a6>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  806df8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806dfb:	89 c7                	mov    %eax,%edi
  806dfd:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  806e04:	00 00 00 
  806e07:	ff d0                	callq  *%rax
  806e09:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      if (p_sock && p_sock->sendevent) {
  806e0d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806e12:	74 42                	je     806e56 <lwip_selscan+0x1a6>
  806e14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806e18:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  806e1c:	66 85 c0             	test   %ax,%ax
  806e1f:	74 35                	je     806e56 <lwip_selscan+0x1a6>
        FD_SET(i, &lwriteset);
  806e21:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806e24:	8d 50 07             	lea    0x7(%rax),%edx
  806e27:	85 c0                	test   %eax,%eax
  806e29:	0f 48 c2             	cmovs  %edx,%eax
  806e2c:	c1 f8 03             	sar    $0x3,%eax
  806e2f:	48 63 d0             	movslq %eax,%rdx
  806e32:	0f b6 54 15 d0       	movzbl -0x30(%rbp,%rdx,1),%edx
  806e37:	89 d6                	mov    %edx,%esi
  806e39:	8b 55 fc             	mov    -0x4(%rbp),%edx
  806e3c:	83 e2 07             	and    $0x7,%edx
  806e3f:	bf 01 00 00 00       	mov    $0x1,%edi
  806e44:	89 d1                	mov    %edx,%ecx
  806e46:	d3 e7                	shl    %cl,%edi
  806e48:	89 fa                	mov    %edi,%edx
  806e4a:	09 f2                	or     %esi,%edx
  806e4c:	48 98                	cltq   
  806e4e:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  806e52:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  806e56:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  806e5a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806e5d:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  806e60:	0f 8c cb fe ff ff    	jl     806d31 <lwip_selscan+0x81>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  806e66:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  806e6a:	8b 55 e0             	mov    -0x20(%rbp),%edx
  806e6d:	89 10                	mov    %edx,(%rax)
  *writeset = lwriteset;
  806e6f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  806e73:	8b 55 d0             	mov    -0x30(%rbp),%edx
  806e76:	89 10                	mov    %edx,(%rax)
  FD_ZERO(exceptset);
  806e78:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806e7c:	ba 04 00 00 00       	mov    $0x4,%edx
  806e81:	be 00 00 00 00       	mov    $0x0,%esi
  806e86:	48 89 c7             	mov    %rax,%rdi
  806e89:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  806e90:	00 00 00 
  806e93:	ff d0                	callq  *%rax
  
  return nready;
  806e95:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  806e98:	c9                   	leaveq 
  806e99:	c3                   	retq   

0000000000806e9a <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  806e9a:	55                   	push   %rbp
  806e9b:	48 89 e5             	mov    %rsp,%rbp
  806e9e:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  806ea5:	89 7d 8c             	mov    %edi,-0x74(%rbp)
  806ea8:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  806eac:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  806eb3:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  806eba:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  806ec1:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  806ec8:	00 
  select_cb.readset = readset;
  806ec9:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  806ecd:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  select_cb.writeset = writeset;
  806ed1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806ed8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  select_cb.exceptset = exceptset;
  806edc:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  806ee3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  select_cb.sem_signalled = 0;
  806ee7:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  806eee:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  806ef5:	00 00 00 
  806ef8:	8b 00                	mov    (%rax),%eax
  806efa:	89 c7                	mov    %eax,%edi
  806efc:	48 b8 bb e3 80 00 00 	movabs $0x80e3bb,%rax
  806f03:	00 00 00 
  806f06:	ff d0                	callq  *%rax

  if (readset)
  806f08:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  806f0d:	74 0b                	je     806f1a <lwip_select+0x80>
    lreadset = *readset;
  806f0f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  806f13:	8b 00                	mov    (%rax),%eax
  806f15:	89 45 e0             	mov    %eax,-0x20(%rbp)
  806f18:	eb 1d                	jmp    806f37 <lwip_select+0x9d>
  else
    FD_ZERO(&lreadset);
  806f1a:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806f1e:	ba 04 00 00 00       	mov    $0x4,%edx
  806f23:	be 00 00 00 00       	mov    $0x0,%esi
  806f28:	48 89 c7             	mov    %rax,%rdi
  806f2b:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  806f32:	00 00 00 
  806f35:	ff d0                	callq  *%rax
  if (writeset)
  806f37:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  806f3e:	00 
  806f3f:	74 0e                	je     806f4f <lwip_select+0xb5>
    lwriteset = *writeset;
  806f41:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806f48:	8b 00                	mov    (%rax),%eax
  806f4a:	89 45 d0             	mov    %eax,-0x30(%rbp)
  806f4d:	eb 1d                	jmp    806f6c <lwip_select+0xd2>
  else
    FD_ZERO(&lwriteset);
  806f4f:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  806f53:	ba 04 00 00 00       	mov    $0x4,%edx
  806f58:	be 00 00 00 00       	mov    $0x0,%esi
  806f5d:	48 89 c7             	mov    %rax,%rdi
  806f60:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  806f67:	00 00 00 
  806f6a:	ff d0                	callq  *%rax
  if (exceptset)
  806f6c:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  806f73:	00 
  806f74:	74 0e                	je     806f84 <lwip_select+0xea>
    lexceptset = *exceptset;
  806f76:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  806f7d:	8b 00                	mov    (%rax),%eax
  806f7f:	89 45 c0             	mov    %eax,-0x40(%rbp)
  806f82:	eb 1d                	jmp    806fa1 <lwip_select+0x107>
  else
    FD_ZERO(&lexceptset);
  806f84:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806f88:	ba 04 00 00 00       	mov    $0x4,%edx
  806f8d:	be 00 00 00 00       	mov    $0x0,%esi
  806f92:	48 89 c7             	mov    %rax,%rdi
  806f95:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  806f9c:	00 00 00 
  806f9f:	ff d0                	callq  *%rax

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  806fa1:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  806fa5:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  806fa9:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  806fad:	8b 45 8c             	mov    -0x74(%rbp),%eax
  806fb0:	89 c7                	mov    %eax,%edi
  806fb2:	48 b8 b0 6c 80 00 00 	movabs $0x806cb0,%rax
  806fb9:	00 00 00 
  806fbc:	ff d0                	callq  *%rax
  806fbe:	89 45 fc             	mov    %eax,-0x4(%rbp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  806fc1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806fc5:	0f 85 b9 03 00 00    	jne    807384 <lwip_select+0x4ea>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  806fcb:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  806fd2:	00 
  806fd3:	0f 84 d3 00 00 00    	je     8070ac <lwip_select+0x212>
  806fd9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  806fe0:	48 8b 00             	mov    (%rax),%rax
  806fe3:	48 85 c0             	test   %rax,%rax
  806fe6:	0f 85 c0 00 00 00    	jne    8070ac <lwip_select+0x212>
  806fec:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  806ff3:	48 8b 40 08          	mov    0x8(%rax),%rax
  806ff7:	48 85 c0             	test   %rax,%rax
  806ffa:	0f 85 ac 00 00 00    	jne    8070ac <lwip_select+0x212>
      sys_sem_signal(selectsem);
  807000:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807007:	00 00 00 
  80700a:	8b 00                	mov    (%rax),%eax
  80700c:	89 c7                	mov    %eax,%edi
  80700e:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  807015:	00 00 00 
  807018:	ff d0                	callq  *%rax
      if (readset)
  80701a:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  80701f:	74 1d                	je     80703e <lwip_select+0x1a4>
        FD_ZERO(readset);
  807021:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807025:	ba 04 00 00 00       	mov    $0x4,%edx
  80702a:	be 00 00 00 00       	mov    $0x0,%esi
  80702f:	48 89 c7             	mov    %rax,%rdi
  807032:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  807039:	00 00 00 
  80703c:	ff d0                	callq  *%rax
      if (writeset)
  80703e:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807045:	00 
  807046:	74 20                	je     807068 <lwip_select+0x1ce>
        FD_ZERO(writeset);
  807048:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80704f:	ba 04 00 00 00       	mov    $0x4,%edx
  807054:	be 00 00 00 00       	mov    $0x0,%esi
  807059:	48 89 c7             	mov    %rax,%rdi
  80705c:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  807063:	00 00 00 
  807066:	ff d0                	callq  *%rax
      if (exceptset)
  807068:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  80706f:	00 
  807070:	74 20                	je     807092 <lwip_select+0x1f8>
        FD_ZERO(exceptset);
  807072:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807079:	ba 04 00 00 00       	mov    $0x4,%edx
  80707e:	be 00 00 00 00       	mov    $0x0,%esi
  807083:	48 89 c7             	mov    %rax,%rdi
  807086:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  80708d:	00 00 00 
  807090:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  807092:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807099:	00 00 00 
  80709c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  8070a2:	b8 00 00 00 00       	mov    $0x0,%eax
  8070a7:	e9 41 03 00 00       	jmpq   8073ed <lwip_select+0x553>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  8070ac:	bf 00 00 00 00       	mov    $0x0,%edi
  8070b1:	48 b8 9b 7a 81 00 00 	movabs $0x817a9b,%rax
  8070b8:	00 00 00 
  8070bb:	ff d0                	callq  *%rax
  8070bd:	89 45 b4             	mov    %eax,-0x4c(%rbp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  8070c0:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8070c7:	00 00 00 
  8070ca:	48 8b 00             	mov    (%rax),%rax
  8070cd:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    select_cb_list = &select_cb;
  8070d1:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8070d8:	00 00 00 
  8070db:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  8070df:	48 89 10             	mov    %rdx,(%rax)
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  8070e2:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8070e9:	00 00 00 
  8070ec:	8b 00                	mov    (%rax),%eax
  8070ee:	89 c7                	mov    %eax,%edi
  8070f0:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  8070f7:	00 00 00 
  8070fa:	ff d0                	callq  *%rax
    
    /* Now just wait to be woken */
    if (timeout == 0)
  8070fc:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  807103:	00 
  807104:	75 09                	jne    80710f <lwip_select+0x275>
      /* Wait forever */
      msectimeout = 0;
  807106:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80710d:	eb 55                	jmp    807164 <lwip_select+0x2ca>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  80710f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807116:	48 8b 00             	mov    (%rax),%rax
  807119:	69 f0 e8 03 00 00    	imul   $0x3e8,%eax,%esi
  80711f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807126:	48 8b 40 08          	mov    0x8(%rax),%rax
  80712a:	48 8d 88 f4 01 00 00 	lea    0x1f4(%rax),%rcx
  807131:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  807138:	9b c4 20 
  80713b:	48 89 c8             	mov    %rcx,%rax
  80713e:	48 f7 ea             	imul   %rdx
  807141:	48 c1 fa 07          	sar    $0x7,%rdx
  807145:	48 89 c8             	mov    %rcx,%rax
  807148:	48 c1 f8 3f          	sar    $0x3f,%rax
  80714c:	48 29 c2             	sub    %rax,%rdx
  80714f:	48 89 d0             	mov    %rdx,%rax
  807152:	01 f0                	add    %esi,%eax
  807154:	89 45 f8             	mov    %eax,-0x8(%rbp)
      if(msectimeout == 0)
  807157:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80715b:	75 07                	jne    807164 <lwip_select+0x2ca>
        msectimeout = 1;
  80715d:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  807164:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807167:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80716a:	89 d6                	mov    %edx,%esi
  80716c:	89 c7                	mov    %eax,%edi
  80716e:	48 b8 29 e8 80 00 00 	movabs $0x80e829,%rax
  807175:	00 00 00 
  807178:	ff d0                	callq  *%rax
  80717a:	89 45 ec             	mov    %eax,-0x14(%rbp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  80717d:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807184:	00 00 00 
  807187:	8b 00                	mov    (%rax),%eax
  807189:	89 c7                	mov    %eax,%edi
  80718b:	48 b8 bb e3 80 00 00 	movabs $0x80e3bb,%rax
  807192:	00 00 00 
  807195:	ff d0                	callq  *%rax
    if (select_cb_list == &select_cb)
  807197:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  80719e:	00 00 00 
  8071a1:	48 8b 10             	mov    (%rax),%rdx
  8071a4:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8071a8:	48 39 c2             	cmp    %rax,%rdx
  8071ab:	75 13                	jne    8071c0 <lwip_select+0x326>
      select_cb_list = select_cb.next;
  8071ad:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8071b1:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8071b8:	00 00 00 
  8071bb:	48 89 10             	mov    %rdx,(%rax)
  8071be:	eb 42                	jmp    807202 <lwip_select+0x368>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8071c0:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8071c7:	00 00 00 
  8071ca:	48 8b 00             	mov    (%rax),%rax
  8071cd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8071d1:	eb 28                	jmp    8071fb <lwip_select+0x361>
        if (p_selcb->next == &select_cb) {
  8071d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8071d7:	48 8b 10             	mov    (%rax),%rdx
  8071da:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8071de:	48 39 c2             	cmp    %rax,%rdx
  8071e1:	75 0d                	jne    8071f0 <lwip_select+0x356>
          p_selcb->next = select_cb.next;
  8071e3:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8071e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8071eb:	48 89 10             	mov    %rdx,(%rax)
          break;
  8071ee:	eb 12                	jmp    807202 <lwip_select+0x368>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8071f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8071f4:	48 8b 00             	mov    (%rax),%rax
  8071f7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8071fb:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807200:	75 d1                	jne    8071d3 <lwip_select+0x339>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  807202:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807209:	00 00 00 
  80720c:	8b 00                	mov    (%rax),%eax
  80720e:	89 c7                	mov    %eax,%edi
  807210:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  807217:	00 00 00 
  80721a:	ff d0                	callq  *%rax
    
    sys_sem_free(select_cb.sem);
  80721c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80721f:	89 c7                	mov    %eax,%edi
  807221:	48 b8 99 7b 81 00 00 	movabs $0x817b99,%rax
  807228:	00 00 00 
  80722b:	ff d0                	callq  *%rax
    if (i == 0)  {
  80722d:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  807231:	0f 85 92 00 00 00    	jne    8072c9 <lwip_select+0x42f>
      /* Timeout */
      if (readset)
  807237:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  80723c:	74 1d                	je     80725b <lwip_select+0x3c1>
        FD_ZERO(readset);
  80723e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807242:	ba 04 00 00 00       	mov    $0x4,%edx
  807247:	be 00 00 00 00       	mov    $0x0,%esi
  80724c:	48 89 c7             	mov    %rax,%rdi
  80724f:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  807256:	00 00 00 
  807259:	ff d0                	callq  *%rax
      if (writeset)
  80725b:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807262:	00 
  807263:	74 20                	je     807285 <lwip_select+0x3eb>
        FD_ZERO(writeset);
  807265:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80726c:	ba 04 00 00 00       	mov    $0x4,%edx
  807271:	be 00 00 00 00       	mov    $0x0,%esi
  807276:	48 89 c7             	mov    %rax,%rdi
  807279:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  807280:	00 00 00 
  807283:	ff d0                	callq  *%rax
      if (exceptset)
  807285:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  80728c:	00 
  80728d:	74 20                	je     8072af <lwip_select+0x415>
        FD_ZERO(exceptset);
  80728f:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807296:	ba 04 00 00 00       	mov    $0x4,%edx
  80729b:	be 00 00 00 00       	mov    $0x0,%esi
  8072a0:	48 89 c7             	mov    %rax,%rdi
  8072a3:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  8072aa:	00 00 00 
  8072ad:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  8072af:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8072b6:	00 00 00 
  8072b9:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  8072bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8072c4:	e9 24 01 00 00       	jmpq   8073ed <lwip_select+0x553>
    }
    
    if (readset)
  8072c9:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8072ce:	74 0b                	je     8072db <lwip_select+0x441>
      lreadset = *readset;
  8072d0:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8072d4:	8b 00                	mov    (%rax),%eax
  8072d6:	89 45 e0             	mov    %eax,-0x20(%rbp)
  8072d9:	eb 1d                	jmp    8072f8 <lwip_select+0x45e>
    else
      FD_ZERO(&lreadset);
  8072db:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8072df:	ba 04 00 00 00       	mov    $0x4,%edx
  8072e4:	be 00 00 00 00       	mov    $0x0,%esi
  8072e9:	48 89 c7             	mov    %rax,%rdi
  8072ec:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  8072f3:	00 00 00 
  8072f6:	ff d0                	callq  *%rax
    if (writeset)
  8072f8:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  8072ff:	00 
  807300:	74 0e                	je     807310 <lwip_select+0x476>
      lwriteset = *writeset;
  807302:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  807309:	8b 00                	mov    (%rax),%eax
  80730b:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80730e:	eb 1d                	jmp    80732d <lwip_select+0x493>
    else
      FD_ZERO(&lwriteset);
  807310:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  807314:	ba 04 00 00 00       	mov    $0x4,%edx
  807319:	be 00 00 00 00       	mov    $0x0,%esi
  80731e:	48 89 c7             	mov    %rax,%rdi
  807321:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  807328:	00 00 00 
  80732b:	ff d0                	callq  *%rax
    if (exceptset)
  80732d:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  807334:	00 
  807335:	74 0e                	je     807345 <lwip_select+0x4ab>
      lexceptset = *exceptset;
  807337:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80733e:	8b 00                	mov    (%rax),%eax
  807340:	89 45 c0             	mov    %eax,-0x40(%rbp)
  807343:	eb 1d                	jmp    807362 <lwip_select+0x4c8>
    else
      FD_ZERO(&lexceptset);
  807345:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807349:	ba 04 00 00 00       	mov    $0x4,%edx
  80734e:	be 00 00 00 00       	mov    $0x0,%esi
  807353:	48 89 c7             	mov    %rax,%rdi
  807356:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  80735d:	00 00 00 
  807360:	ff d0                	callq  *%rax
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  807362:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  807366:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80736a:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  80736e:	8b 45 8c             	mov    -0x74(%rbp),%eax
  807371:	89 c7                	mov    %eax,%edi
  807373:	48 b8 b0 6c 80 00 00 	movabs $0x806cb0,%rax
  80737a:	00 00 00 
  80737d:	ff d0                	callq  *%rax
  80737f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  807382:	eb 1a                	jmp    80739e <lwip_select+0x504>
  } else
    sys_sem_signal(selectsem);
  807384:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80738b:	00 00 00 
  80738e:	8b 00                	mov    (%rax),%eax
  807390:	89 c7                	mov    %eax,%edi
  807392:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  807399:	00 00 00 
  80739c:	ff d0                	callq  *%rax
  
  if (readset)
  80739e:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8073a3:	74 09                	je     8073ae <lwip_select+0x514>
    *readset = lreadset;
  8073a5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8073a9:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8073ac:	89 10                	mov    %edx,(%rax)
  if (writeset)
  8073ae:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  8073b5:	00 
  8073b6:	74 0c                	je     8073c4 <lwip_select+0x52a>
    *writeset = lwriteset;
  8073b8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8073bf:	8b 55 d0             	mov    -0x30(%rbp),%edx
  8073c2:	89 10                	mov    %edx,(%rax)
  if (exceptset)
  8073c4:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8073cb:	00 
  8073cc:	74 0c                	je     8073da <lwip_select+0x540>
    *exceptset = lexceptset;
  8073ce:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8073d5:	8b 55 c0             	mov    -0x40(%rbp),%edx
  8073d8:	89 10                	mov    %edx,(%rax)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  8073da:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8073e1:	00 00 00 
  8073e4:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
  return nready;
  8073ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8073ed:	c9                   	leaveq 
  8073ee:	c3                   	retq   

00000000008073ef <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  8073ef:	55                   	push   %rbp
  8073f0:	48 89 e5             	mov    %rsp,%rbp
  8073f3:	48 83 ec 30          	sub    $0x30,%rsp
  8073f7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8073fb:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  8073fe:	89 d0                	mov    %edx,%eax
  807400:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  807404:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  807409:	0f 84 a6 00 00 00    	je     8074b5 <event_callback+0xc6>
    s = conn->socket;
  80740f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807413:	8b 40 20             	mov    0x20(%rax),%eax
  807416:	89 45 f4             	mov    %eax,-0xc(%rbp)
    if (s < 0) {
  807419:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80741d:	79 75                	jns    807494 <event_callback+0xa5>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  80741f:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  807426:	00 00 00 
  807429:	8b 00                	mov    (%rax),%eax
  80742b:	89 c7                	mov    %eax,%edi
  80742d:	48 b8 bb e3 80 00 00 	movabs $0x80e3bb,%rax
  807434:	00 00 00 
  807437:	ff d0                	callq  *%rax
      if (conn->socket < 0) {
  807439:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80743d:	8b 40 20             	mov    0x20(%rax),%eax
  807440:	85 c0                	test   %eax,%eax
  807442:	79 36                	jns    80747a <event_callback+0x8b>
        if (evt == NETCONN_EVT_RCVPLUS) {
  807444:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  807448:	75 11                	jne    80745b <event_callback+0x6c>
          conn->socket--;
  80744a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80744e:	8b 40 20             	mov    0x20(%rax),%eax
  807451:	8d 50 ff             	lea    -0x1(%rax),%edx
  807454:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807458:	89 50 20             	mov    %edx,0x20(%rax)
        }
        sys_sem_signal(socksem);
  80745b:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  807462:	00 00 00 
  807465:	8b 00                	mov    (%rax),%eax
  807467:	89 c7                	mov    %eax,%edi
  807469:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  807470:	00 00 00 
  807473:	ff d0                	callq  *%rax
        return;
  807475:	e9 4b 02 00 00       	jmpq   8076c5 <event_callback+0x2d6>
      }
      sys_sem_signal(socksem);
  80747a:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  807481:	00 00 00 
  807484:	8b 00                	mov    (%rax),%eax
  807486:	89 c7                	mov    %eax,%edi
  807488:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  80748f:	00 00 00 
  807492:	ff d0                	callq  *%rax
    }

    sock = get_socket(s);
  807494:	8b 45 f4             	mov    -0xc(%rbp),%eax
  807497:	89 c7                	mov    %eax,%edi
  807499:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  8074a0:	00 00 00 
  8074a3:	ff d0                	callq  *%rax
  8074a5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (!sock) {
  8074a9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8074ae:	75 0a                	jne    8074ba <event_callback+0xcb>
      return;
  8074b0:	e9 10 02 00 00       	jmpq   8076c5 <event_callback+0x2d6>
    }
  } else {
    return;
  8074b5:	e9 0b 02 00 00       	jmpq   8076c5 <event_callback+0x2d6>
  }

  sys_sem_wait(selectsem);
  8074ba:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8074c1:	00 00 00 
  8074c4:	8b 00                	mov    (%rax),%eax
  8074c6:	89 c7                	mov    %eax,%edi
  8074c8:	48 b8 bb e3 80 00 00 	movabs $0x80e3bb,%rax
  8074cf:	00 00 00 
  8074d2:	ff d0                	callq  *%rax
  /* Set event as required */
  switch (evt) {
  8074d4:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8074d7:	83 f8 01             	cmp    $0x1,%eax
  8074da:	74 26                	je     807502 <event_callback+0x113>
  8074dc:	83 f8 01             	cmp    $0x1,%eax
  8074df:	72 0c                	jb     8074ed <event_callback+0xfe>
  8074e1:	83 f8 02             	cmp    $0x2,%eax
  8074e4:	74 31                	je     807517 <event_callback+0x128>
  8074e6:	83 f8 03             	cmp    $0x3,%eax
  8074e9:	74 38                	je     807523 <event_callback+0x134>
  8074eb:	eb 42                	jmp    80752f <event_callback+0x140>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  8074ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8074f1:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8074f5:	8d 50 01             	lea    0x1(%rax),%edx
  8074f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8074fc:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  807500:	eb 57                	jmp    807559 <event_callback+0x16a>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  807502:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807506:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80750a:	8d 50 ff             	lea    -0x1(%rax),%edx
  80750d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807511:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  807515:	eb 42                	jmp    807559 <event_callback+0x16a>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  807517:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80751b:	66 c7 40 14 01 00    	movw   $0x1,0x14(%rax)
      break;
  807521:	eb 36                	jmp    807559 <event_callback+0x16a>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  807523:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807527:	66 c7 40 14 00 00    	movw   $0x0,0x14(%rax)
      break;
  80752d:	eb 2a                	jmp    807559 <event_callback+0x16a>
    default:
      LWIP_ASSERT("unknown event", 0);
  80752f:	48 ba 39 13 82 00 00 	movabs $0x821339,%rdx
  807536:	00 00 00 
  807539:	be 17 04 00 00       	mov    $0x417,%esi
  80753e:	48 bf 91 12 82 00 00 	movabs $0x821291,%rdi
  807545:	00 00 00 
  807548:	b8 00 00 00 00       	mov    $0x0,%eax
  80754d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  807554:	00 00 00 
  807557:	ff d1                	callq  *%rcx
      break;
  }
  sys_sem_signal(selectsem);
  807559:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807560:	00 00 00 
  807563:	8b 00                	mov    (%rax),%eax
  807565:	89 c7                	mov    %eax,%edi
  807567:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  80756e:	00 00 00 
  807571:	ff d0                	callq  *%rax
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  807573:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80757a:	00 00 00 
  80757d:	8b 00                	mov    (%rax),%eax
  80757f:	89 c7                	mov    %eax,%edi
  807581:	48 b8 bb e3 80 00 00 	movabs $0x80e3bb,%rax
  807588:	00 00 00 
  80758b:	ff d0                	callq  *%rax
    for (scb = select_cb_list; scb; scb = scb->next) {
  80758d:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  807594:	00 00 00 
  807597:	48 8b 00             	mov    (%rax),%rax
  80759a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80759e:	e9 b6 00 00 00       	jmpq   807659 <event_callback+0x26a>
      if (scb->sem_signalled == 0) {
  8075a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8075a7:	8b 40 20             	mov    0x20(%rax),%eax
  8075aa:	85 c0                	test   %eax,%eax
  8075ac:	0f 85 9c 00 00 00    	jne    80764e <event_callback+0x25f>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  8075b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8075b6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8075ba:	48 85 c0             	test   %rax,%rax
  8075bd:	74 41                	je     807600 <event_callback+0x211>
  8075bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8075c3:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8075c7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8075ca:	8d 48 07             	lea    0x7(%rax),%ecx
  8075cd:	85 c0                	test   %eax,%eax
  8075cf:	0f 48 c1             	cmovs  %ecx,%eax
  8075d2:	c1 f8 03             	sar    $0x3,%eax
  8075d5:	48 98                	cltq   
  8075d7:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8075db:	0f b6 d0             	movzbl %al,%edx
  8075de:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8075e1:	83 e0 07             	and    $0x7,%eax
  8075e4:	89 c1                	mov    %eax,%ecx
  8075e6:	d3 fa                	sar    %cl,%edx
  8075e8:	89 d0                	mov    %edx,%eax
  8075ea:	83 e0 01             	and    $0x1,%eax
  8075ed:	85 c0                	test   %eax,%eax
  8075ef:	74 0f                	je     807600 <event_callback+0x211>
          if (sock->rcvevent)
  8075f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8075f5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8075f9:	66 85 c0             	test   %ax,%ax
  8075fc:	74 02                	je     807600 <event_callback+0x211>
            break;
  8075fe:	eb 64                	jmp    807664 <event_callback+0x275>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  807600:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807604:	48 8b 40 10          	mov    0x10(%rax),%rax
  807608:	48 85 c0             	test   %rax,%rax
  80760b:	74 41                	je     80764e <event_callback+0x25f>
  80760d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807611:	48 8b 50 10          	mov    0x10(%rax),%rdx
  807615:	8b 45 f4             	mov    -0xc(%rbp),%eax
  807618:	8d 48 07             	lea    0x7(%rax),%ecx
  80761b:	85 c0                	test   %eax,%eax
  80761d:	0f 48 c1             	cmovs  %ecx,%eax
  807620:	c1 f8 03             	sar    $0x3,%eax
  807623:	48 98                	cltq   
  807625:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  807629:	0f b6 d0             	movzbl %al,%edx
  80762c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80762f:	83 e0 07             	and    $0x7,%eax
  807632:	89 c1                	mov    %eax,%ecx
  807634:	d3 fa                	sar    %cl,%edx
  807636:	89 d0                	mov    %edx,%eax
  807638:	83 e0 01             	and    $0x1,%eax
  80763b:	85 c0                	test   %eax,%eax
  80763d:	74 0f                	je     80764e <event_callback+0x25f>
          if (sock->sendevent)
  80763f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807643:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  807647:	66 85 c0             	test   %ax,%ax
  80764a:	74 02                	je     80764e <event_callback+0x25f>
            break;
  80764c:	eb 16                	jmp    807664 <event_callback+0x275>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  80764e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807652:	48 8b 00             	mov    (%rax),%rax
  807655:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  807659:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80765e:	0f 85 3f ff ff ff    	jne    8075a3 <event_callback+0x1b4>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
  807664:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807669:	74 3f                	je     8076aa <event_callback+0x2bb>
      scb->sem_signalled = 1;
  80766b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80766f:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%rax)
      sys_sem_signal(selectsem);
  807676:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80767d:	00 00 00 
  807680:	8b 00                	mov    (%rax),%eax
  807682:	89 c7                	mov    %eax,%edi
  807684:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  80768b:	00 00 00 
  80768e:	ff d0                	callq  *%rax
      sys_sem_signal(scb->sem);
  807690:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807694:	8b 40 24             	mov    0x24(%rax),%eax
  807697:	89 c7                	mov    %eax,%edi
  807699:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  8076a0:	00 00 00 
  8076a3:	ff d0                	callq  *%rax
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  8076a5:	e9 c9 fe ff ff       	jmpq   807573 <event_callback+0x184>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  8076aa:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8076b1:	00 00 00 
  8076b4:	8b 00                	mov    (%rax),%eax
  8076b6:	89 c7                	mov    %eax,%edi
  8076b8:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  8076bf:	00 00 00 
  8076c2:	ff d0                	callq  *%rax
      break;
  8076c4:	90                   	nop
    }
  }
}
  8076c5:	c9                   	leaveq 
  8076c6:	c3                   	retq   

00000000008076c7 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  8076c7:	55                   	push   %rbp
  8076c8:	48 89 e5             	mov    %rsp,%rbp
  8076cb:	48 83 ec 10          	sub    $0x10,%rsp
  8076cf:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8076d2:	89 75 f8             	mov    %esi,-0x8(%rbp)
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  8076d5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8076d8:	89 c7                	mov    %eax,%edi
  8076da:	48 b8 98 60 80 00 00 	movabs $0x806098,%rax
  8076e1:	00 00 00 
  8076e4:	ff d0                	callq  *%rax
}
  8076e6:	c9                   	leaveq 
  8076e7:	c3                   	retq   

00000000008076e8 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  8076e8:	55                   	push   %rbp
  8076e9:	48 89 e5             	mov    %rsp,%rbp
  8076ec:	48 83 ec 50          	sub    $0x50,%rsp
  8076f0:	89 7d cc             	mov    %edi,-0x34(%rbp)
  8076f3:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8076f7:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8076fb:	89 c8                	mov    %ecx,%eax
  8076fd:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  807700:	8b 45 cc             	mov    -0x34(%rbp),%eax
  807703:	89 c7                	mov    %eax,%edi
  807705:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  80770c:	00 00 00 
  80770f:	ff d0                	callq  *%rax
  807711:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  807715:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80771a:	75 0a                	jne    807726 <lwip_getaddrname+0x3e>
    return -1;
  80771c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807721:	e9 c9 00 00 00       	jmpq   8077ef <lwip_getaddrname+0x107>

  memset(&sin, 0, sizeof(sin));
  807726:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80772a:	ba 10 00 00 00       	mov    $0x10,%edx
  80772f:	be 00 00 00 00       	mov    $0x0,%esi
  807734:	48 89 c7             	mov    %rax,%rdi
  807737:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  80773e:	00 00 00 
  807741:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  807743:	c6 45 e0 10          	movb   $0x10,-0x20(%rbp)
  sin.sin_family = AF_INET;
  807747:	c6 45 e1 02          	movb   $0x2,-0x1f(%rbp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  80774b:	0f b6 55 c8          	movzbl -0x38(%rbp),%edx
  80774f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807753:	48 8b 00             	mov    (%rax),%rax
  807756:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  80775a:	48 8d 79 02          	lea    0x2(%rcx),%rdi
  80775e:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  807762:	89 d1                	mov    %edx,%ecx
  807764:	48 89 fa             	mov    %rdi,%rdx
  807767:	48 89 c7             	mov    %rax,%rdi
  80776a:	48 b8 4c 99 81 00 00 	movabs $0x81994c,%rax
  807771:	00 00 00 
  807774:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  807776:	0f b7 45 e2          	movzwl -0x1e(%rbp),%eax
  80777a:	0f b7 c0             	movzwl %ax,%eax
  80777d:	89 c7                	mov    %eax,%edi
  80777f:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  807786:	00 00 00 
  807789:	ff d0                	callq  *%rax
  80778b:	66 89 45 e2          	mov    %ax,-0x1e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  80778f:	8b 45 d0             	mov    -0x30(%rbp),%eax
  807792:	89 45 e4             	mov    %eax,-0x1c(%rbp)

  if (*namelen > sizeof(sin))
  807795:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  807799:	8b 00                	mov    (%rax),%eax
  80779b:	83 f8 10             	cmp    $0x10,%eax
  80779e:	76 0a                	jbe    8077aa <lwip_getaddrname+0xc2>
    *namelen = sizeof(sin);
  8077a0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8077a4:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(name, &sin, *namelen);
  8077aa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8077ae:	8b 00                	mov    (%rax),%eax
  8077b0:	89 c2                	mov    %eax,%edx
  8077b2:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8077b6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8077ba:	48 89 ce             	mov    %rcx,%rsi
  8077bd:	48 89 c7             	mov    %rax,%rdi
  8077c0:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  8077c7:	00 00 00 
  8077ca:	ff d0                	callq  *%rax
  sock_set_errno(sock, 0);
  8077cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8077d0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8077d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8077db:	8b 50 18             	mov    0x18(%rax),%edx
  8077de:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8077e5:	00 00 00 
  8077e8:	89 10                	mov    %edx,(%rax)
  return 0;
  8077ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8077ef:	c9                   	leaveq 
  8077f0:	c3                   	retq   

00000000008077f1 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  8077f1:	55                   	push   %rbp
  8077f2:	48 89 e5             	mov    %rsp,%rbp
  8077f5:	48 83 ec 20          	sub    $0x20,%rsp
  8077f9:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8077fc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  807800:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 0);
  807804:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807808:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80780c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80780f:	b9 00 00 00 00       	mov    $0x0,%ecx
  807814:	89 c7                	mov    %eax,%edi
  807816:	48 b8 e8 76 80 00 00 	movabs $0x8076e8,%rax
  80781d:	00 00 00 
  807820:	ff d0                	callq  *%rax
}
  807822:	c9                   	leaveq 
  807823:	c3                   	retq   

0000000000807824 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  807824:	55                   	push   %rbp
  807825:	48 89 e5             	mov    %rsp,%rbp
  807828:	48 83 ec 20          	sub    $0x20,%rsp
  80782c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80782f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  807833:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 1);
  807837:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80783b:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80783f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807842:	b9 01 00 00 00       	mov    $0x1,%ecx
  807847:	89 c7                	mov    %eax,%edi
  807849:	48 b8 e8 76 80 00 00 	movabs $0x8076e8,%rax
  807850:	00 00 00 
  807853:	ff d0                	callq  *%rax
}
  807855:	c9                   	leaveq 
  807856:	c3                   	retq   

0000000000807857 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  807857:	55                   	push   %rbp
  807858:	48 89 e5             	mov    %rsp,%rbp
  80785b:	48 83 ec 60          	sub    $0x60,%rsp
  80785f:	89 7d bc             	mov    %edi,-0x44(%rbp)
  807862:	89 75 b8             	mov    %esi,-0x48(%rbp)
  807865:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  807868:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  80786c:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  err_t err = ERR_OK;
  807870:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807874:	8b 45 bc             	mov    -0x44(%rbp),%eax
  807877:	89 c7                	mov    %eax,%edi
  807879:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  807880:	00 00 00 
  807883:	ff d0                	callq  *%rax
  807885:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  807889:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80788e:	75 0a                	jne    80789a <lwip_getsockopt+0x43>
    return -1;
  807890:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807895:	e9 15 02 00 00       	jmpq   807aaf <lwip_getsockopt+0x258>

  if ((NULL == optval) || (NULL == optlen)) {
  80789a:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  80789f:	74 07                	je     8078a8 <lwip_getsockopt+0x51>
  8078a1:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8078a6:	75 28                	jne    8078d0 <lwip_getsockopt+0x79>
    sock_set_errno(sock, EFAULT);
  8078a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8078ac:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  8078b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8078b7:	8b 50 18             	mov    0x18(%rax),%edx
  8078ba:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8078c1:	00 00 00 
  8078c4:	89 10                	mov    %edx,(%rax)
    return -1;
  8078c6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8078cb:	e9 df 01 00 00       	jmpq   807aaf <lwip_getsockopt+0x258>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8078d0:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8078d3:	83 f8 06             	cmp    $0x6,%eax
  8078d6:	0f 84 c3 00 00 00    	je     80799f <lwip_getsockopt+0x148>
  8078dc:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  8078e1:	74 0d                	je     8078f0 <lwip_getsockopt+0x99>
  8078e3:	85 c0                	test   %eax,%eax
  8078e5:	0f 84 8e 00 00 00    	je     807979 <lwip_getsockopt+0x122>
  8078eb:	e9 ec 00 00 00       	jmpq   8079dc <lwip_getsockopt+0x185>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8078f0:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8078f3:	83 f8 20             	cmp    $0x20,%eax
  8078f6:	74 28                	je     807920 <lwip_getsockopt+0xc9>
  8078f8:	83 f8 20             	cmp    $0x20,%eax
  8078fb:	7f 0c                	jg     807909 <lwip_getsockopt+0xb2>
  8078fd:	83 f8 02             	cmp    $0x2,%eax
  807900:	74 1e                	je     807920 <lwip_getsockopt+0xc9>
  807902:	83 f8 08             	cmp    $0x8,%eax
  807905:	74 19                	je     807920 <lwip_getsockopt+0xc9>
  807907:	eb 68                	jmp    807971 <lwip_getsockopt+0x11a>
  807909:	3d 07 10 00 00       	cmp    $0x1007,%eax
  80790e:	7c 61                	jl     807971 <lwip_getsockopt+0x11a>
  807910:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807915:	7e 09                	jle    807920 <lwip_getsockopt+0xc9>
  807917:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  80791c:	74 15                	je     807933 <lwip_getsockopt+0xdc>
  80791e:	eb 51                	jmp    807971 <lwip_getsockopt+0x11a>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  807920:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807924:	8b 00                	mov    (%rax),%eax
  807926:	83 f8 03             	cmp    $0x3,%eax
  807929:	77 06                	ja     807931 <lwip_getsockopt+0xda>
        err = EINVAL;
  80792b:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  80792f:	eb 46                	jmp    807977 <lwip_getsockopt+0x120>
  807931:	eb 44                	jmp    807977 <lwip_getsockopt+0x120>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  807933:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807937:	8b 00                	mov    (%rax),%eax
  807939:	83 f8 03             	cmp    $0x3,%eax
  80793c:	77 04                	ja     807942 <lwip_getsockopt+0xeb>
        err = EINVAL;
  80793e:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807942:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807946:	48 8b 00             	mov    (%rax),%rax
  807949:	8b 00                	mov    (%rax),%eax
  80794b:	83 f8 20             	cmp    $0x20,%eax
  80794e:	75 19                	jne    807969 <lwip_getsockopt+0x112>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  807950:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807954:	48 8b 00             	mov    (%rax),%rax
  807957:	48 8b 40 08          	mov    0x8(%rax),%rax
  80795b:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80795f:	0f b6 c0             	movzbl %al,%eax
  807962:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807965:	85 c0                	test   %eax,%eax
  807967:	74 06                	je     80796f <lwip_getsockopt+0x118>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  807969:	c6 45 ff 61          	movb   $0x61,-0x1(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  80796d:	eb 08                	jmp    807977 <lwip_getsockopt+0x120>
  80796f:	eb 06                	jmp    807977 <lwip_getsockopt+0x120>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807971:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807975:	eb 69                	jmp    8079e0 <lwip_getsockopt+0x189>
  807977:	eb 67                	jmp    8079e0 <lwip_getsockopt+0x189>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807979:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80797c:	83 e8 01             	sub    $0x1,%eax
  80797f:	83 f8 01             	cmp    $0x1,%eax
  807982:	77 13                	ja     807997 <lwip_getsockopt+0x140>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  807984:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807988:	8b 00                	mov    (%rax),%eax
  80798a:	83 f8 03             	cmp    $0x3,%eax
  80798d:	77 06                	ja     807995 <lwip_getsockopt+0x13e>
        err = EINVAL;
  80798f:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  807993:	eb 08                	jmp    80799d <lwip_getsockopt+0x146>
  807995:	eb 06                	jmp    80799d <lwip_getsockopt+0x146>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807997:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  80799b:	eb 43                	jmp    8079e0 <lwip_getsockopt+0x189>
  80799d:	eb 41                	jmp    8079e0 <lwip_getsockopt+0x189>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  80799f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8079a3:	8b 00                	mov    (%rax),%eax
  8079a5:	83 f8 03             	cmp    $0x3,%eax
  8079a8:	77 06                	ja     8079b0 <lwip_getsockopt+0x159>
      err = EINVAL;
  8079aa:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      break;
  8079ae:	eb 30                	jmp    8079e0 <lwip_getsockopt+0x189>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  8079b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8079b4:	48 8b 00             	mov    (%rax),%rax
  8079b7:	8b 00                	mov    (%rax),%eax
  8079b9:	83 f8 10             	cmp    $0x10,%eax
  8079bc:	74 0a                	je     8079c8 <lwip_getsockopt+0x171>
      return 0;
  8079be:	b8 00 00 00 00       	mov    $0x0,%eax
  8079c3:	e9 e7 00 00 00       	jmpq   807aaf <lwip_getsockopt+0x258>

    switch (optname) {
  8079c8:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8079cb:	83 e8 01             	sub    $0x1,%eax
  8079ce:	83 f8 01             	cmp    $0x1,%eax
  8079d1:	76 06                	jbe    8079d9 <lwip_getsockopt+0x182>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  8079d3:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  8079d7:	eb 07                	jmp    8079e0 <lwip_getsockopt+0x189>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  8079d9:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  8079da:	eb 04                	jmp    8079e0 <lwip_getsockopt+0x189>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  8079dc:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
  }  /* switch */

   
  if (err != ERR_OK) {
  8079e0:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8079e4:	74 28                	je     807a0e <lwip_getsockopt+0x1b7>
    sock_set_errno(sock, err);
  8079e6:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  8079ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8079ee:	89 50 18             	mov    %edx,0x18(%rax)
  8079f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8079f5:	8b 50 18             	mov    0x18(%rax),%edx
  8079f8:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8079ff:	00 00 00 
  807a02:	89 10                	mov    %edx,(%rax)
    return -1;
  807a04:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807a09:	e9 a1 00 00 00       	jmpq   807aaf <lwip_getsockopt+0x258>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  807a0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807a12:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  807a16:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807a19:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  807a1c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807a1f:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = optval;
  807a22:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807a26:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = optlen;
  807a2a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807a2e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  807a32:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  807a36:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  807a39:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807a3d:	ba 01 00 00 00       	mov    $0x1,%edx
  807a42:	48 89 c6             	mov    %rax,%rsi
  807a45:	48 bf b1 7a 80 00 00 	movabs $0x807ab1,%rdi
  807a4c:	00 00 00 
  807a4f:	48 b8 12 88 80 00 00 	movabs $0x808812,%rax
  807a56:	00 00 00 
  807a59:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  807a5b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807a5f:	48 8b 00             	mov    (%rax),%rax
  807a62:	8b 40 14             	mov    0x14(%rax),%eax
  807a65:	be 00 00 00 00       	mov    $0x0,%esi
  807a6a:	89 c7                	mov    %eax,%edi
  807a6c:	48 b8 1c 7e 81 00 00 	movabs $0x817e1c,%rax
  807a73:	00 00 00 
  807a76:	ff d0                	callq  *%rax
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  807a78:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  807a7c:	88 45 ff             	mov    %al,-0x1(%rbp)

  sock_set_errno(sock, err);
  807a7f:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  807a83:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807a87:	89 50 18             	mov    %edx,0x18(%rax)
  807a8a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807a8e:	8b 50 18             	mov    0x18(%rax),%edx
  807a91:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807a98:	00 00 00 
  807a9b:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  807a9d:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  807aa1:	74 07                	je     807aaa <lwip_getsockopt+0x253>
  807aa3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807aa8:	eb 05                	jmp    807aaf <lwip_getsockopt+0x258>
  807aaa:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807aaf:	c9                   	leaveq 
  807ab0:	c3                   	retq   

0000000000807ab1 <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
  807ab1:	55                   	push   %rbp
  807ab2:	48 89 e5             	mov    %rsp,%rbp
  807ab5:	48 83 ec 40          	sub    $0x40,%rsp
  807ab9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  807abd:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  807ac2:	75 2a                	jne    807aee <lwip_getsockopt_internal+0x3d>
  807ac4:	48 ba 47 13 82 00 00 	movabs $0x821347,%rdx
  807acb:	00 00 00 
  807ace:	be 38 05 00 00       	mov    $0x538,%esi
  807ad3:	48 bf 91 12 82 00 00 	movabs $0x821291,%rdi
  807ada:	00 00 00 
  807add:	b8 00 00 00 00       	mov    $0x0,%eax
  807ae2:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  807ae9:	00 00 00 
  807aec:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  807aee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807af2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  807af6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807afa:	48 8b 00             	mov    (%rax),%rax
  807afd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  807b01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807b05:	8b 40 08             	mov    0x8(%rax),%eax
  807b08:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  807b0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807b0f:	8b 40 0c             	mov    0xc(%rax),%eax
  807b12:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  807b15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807b19:	8b 40 10             	mov    0x10(%rax),%eax
  807b1c:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  807b1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807b23:	48 8b 40 18          	mov    0x18(%rax),%rax
  807b27:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  807b2b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  807b2e:	83 f8 06             	cmp    $0x6,%eax
  807b31:	0f 84 b7 01 00 00    	je     807cee <lwip_getsockopt_internal+0x23d>
  807b37:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807b3c:	74 0d                	je     807b4b <lwip_getsockopt_internal+0x9a>
  807b3e:	85 c0                	test   %eax,%eax
  807b40:	0f 84 64 01 00 00    	je     807caa <lwip_getsockopt_internal+0x1f9>
  807b46:	e9 ec 01 00 00       	jmpq   807d37 <lwip_getsockopt_internal+0x286>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807b4b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807b4e:	83 f8 20             	cmp    $0x20,%eax
  807b51:	74 36                	je     807b89 <lwip_getsockopt_internal+0xd8>
  807b53:	83 f8 20             	cmp    $0x20,%eax
  807b56:	7f 0f                	jg     807b67 <lwip_getsockopt_internal+0xb6>
  807b58:	83 f8 02             	cmp    $0x2,%eax
  807b5b:	74 2c                	je     807b89 <lwip_getsockopt_internal+0xd8>
  807b5d:	83 f8 08             	cmp    $0x8,%eax
  807b60:	74 27                	je     807b89 <lwip_getsockopt_internal+0xd8>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807b62:	e9 d0 01 00 00       	jmpq   807d37 <lwip_getsockopt_internal+0x286>

  switch (level) {
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807b67:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807b6c:	74 3d                	je     807bab <lwip_getsockopt_internal+0xfa>
  807b6e:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807b73:	0f 84 08 01 00 00    	je     807c81 <lwip_getsockopt_internal+0x1d0>
  807b79:	3d 07 10 00 00       	cmp    $0x1007,%eax
  807b7e:	0f 84 80 00 00 00    	je     807c04 <lwip_getsockopt_internal+0x153>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807b84:	e9 ae 01 00 00       	jmpq   807d37 <lwip_getsockopt_internal+0x286>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  807b89:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b8d:	48 8b 00             	mov    (%rax),%rax
  807b90:	48 8b 40 08          	mov    0x8(%rax),%rax
  807b94:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  807b98:	0f b7 c0             	movzwl %ax,%eax
  807b9b:	23 45 e4             	and    -0x1c(%rbp),%eax
  807b9e:	89 c2                	mov    %eax,%edx
  807ba0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807ba4:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  807ba6:	e9 fa 00 00 00       	jmpq   807ca5 <lwip_getsockopt_internal+0x1f4>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  807bab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807baf:	48 8b 00             	mov    (%rax),%rax
  807bb2:	8b 00                	mov    (%rax),%eax
  807bb4:	25 f0 00 00 00       	and    $0xf0,%eax
  807bb9:	83 f8 20             	cmp    $0x20,%eax
  807bbc:	74 24                	je     807be2 <lwip_getsockopt_internal+0x131>
  807bbe:	83 f8 40             	cmp    $0x40,%eax
  807bc1:	74 07                	je     807bca <lwip_getsockopt_internal+0x119>
  807bc3:	83 f8 10             	cmp    $0x10,%eax
  807bc6:	74 0e                	je     807bd6 <lwip_getsockopt_internal+0x125>
  807bc8:	eb 24                	jmp    807bee <lwip_getsockopt_internal+0x13d>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  807bca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807bce:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
        break;
  807bd4:	eb 29                	jmp    807bff <lwip_getsockopt_internal+0x14e>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  807bd6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807bda:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
        break;
  807be0:	eb 1d                	jmp    807bff <lwip_getsockopt_internal+0x14e>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  807be2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807be6:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
        break;
  807bec:	eb 11                	jmp    807bff <lwip_getsockopt_internal+0x14e>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  807bee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807bf2:	48 8b 00             	mov    (%rax),%rax
  807bf5:	8b 00                	mov    (%rax),%eax
  807bf7:	89 c2                	mov    %eax,%edx
  807bf9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807bfd:	89 10                	mov    %edx,(%rax)
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
  807bff:	e9 a1 00 00 00       	jmpq   807ca5 <lwip_getsockopt_internal+0x1f4>

    case SO_ERROR:
      if (sock->err == 0) {
  807c04:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c08:	8b 40 18             	mov    0x18(%rax),%eax
  807c0b:	85 c0                	test   %eax,%eax
  807c0d:	75 58                	jne    807c67 <lwip_getsockopt_internal+0x1b6>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  807c0f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c13:	48 8b 00             	mov    (%rax),%rax
  807c16:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807c1a:	0f be c0             	movsbl %al,%eax
  807c1d:	f7 d8                	neg    %eax
  807c1f:	83 f8 0e             	cmp    $0xe,%eax
  807c22:	77 24                	ja     807c48 <lwip_getsockopt_internal+0x197>
  807c24:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c28:	48 8b 00             	mov    (%rax),%rax
  807c2b:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807c2f:	0f be c0             	movsbl %al,%eax
  807c32:	f7 d8                	neg    %eax
  807c34:	89 c2                	mov    %eax,%edx
  807c36:	48 b8 40 12 82 00 00 	movabs $0x821240,%rax
  807c3d:	00 00 00 
  807c40:	48 63 d2             	movslq %edx,%rdx
  807c43:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  807c46:	eb 05                	jmp    807c4d <lwip_getsockopt_internal+0x19c>
  807c48:	b8 05 00 00 00       	mov    $0x5,%eax
  807c4d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807c51:	89 42 18             	mov    %eax,0x18(%rdx)
  807c54:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c58:	8b 50 18             	mov    0x18(%rax),%edx
  807c5b:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807c62:	00 00 00 
  807c65:	89 10                	mov    %edx,(%rax)
      } 
      *(int *)optval = sock->err;
  807c67:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c6b:	8b 50 18             	mov    0x18(%rax),%edx
  807c6e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807c72:	89 10                	mov    %edx,(%rax)
      sock->err = 0;
  807c74:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c78:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  807c7f:	eb 24                	jmp    807ca5 <lwip_getsockopt_internal+0x1f4>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  807c81:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c85:	48 8b 00             	mov    (%rax),%rax
  807c88:	48 8b 40 08          	mov    0x8(%rax),%rax
  807c8c:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807c90:	0f b6 c0             	movzbl %al,%eax
  807c93:	83 e0 01             	and    $0x1,%eax
  807c96:	85 c0                	test   %eax,%eax
  807c98:	0f 95 c0             	setne  %al
  807c9b:	0f b6 d0             	movzbl %al,%edx
  807c9e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807ca2:	89 10                	mov    %edx,(%rax)
      break;
  807ca4:	90                   	nop
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807ca5:	e9 8d 00 00 00       	jmpq   807d37 <lwip_getsockopt_internal+0x286>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807caa:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807cad:	83 f8 01             	cmp    $0x1,%eax
  807cb0:	74 21                	je     807cd3 <lwip_getsockopt_internal+0x222>
  807cb2:	83 f8 02             	cmp    $0x2,%eax
  807cb5:	74 02                	je     807cb9 <lwip_getsockopt_internal+0x208>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  807cb7:	eb 7e                	jmp    807d37 <lwip_getsockopt_internal+0x286>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  807cb9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807cbd:	48 8b 00             	mov    (%rax),%rax
  807cc0:	48 8b 40 08          	mov    0x8(%rax),%rax
  807cc4:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  807cc8:	0f b6 d0             	movzbl %al,%edx
  807ccb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807ccf:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  807cd1:	eb 19                	jmp    807cec <lwip_getsockopt_internal+0x23b>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  807cd3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807cd7:	48 8b 00             	mov    (%rax),%rax
  807cda:	48 8b 40 08          	mov    0x8(%rax),%rax
  807cde:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  807ce2:	0f b6 d0             	movzbl %al,%edx
  807ce5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807ce9:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  807ceb:	90                   	nop
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  807cec:	eb 49                	jmp    807d37 <lwip_getsockopt_internal+0x286>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  807cee:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807cf1:	83 f8 01             	cmp    $0x1,%eax
  807cf4:	74 07                	je     807cfd <lwip_getsockopt_internal+0x24c>
  807cf6:	83 f8 02             	cmp    $0x2,%eax
  807cf9:	74 21                	je     807d1c <lwip_getsockopt_internal+0x26b>
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  807cfb:	eb 39                	jmp    807d36 <lwip_getsockopt_internal+0x285>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  807cfd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d01:	48 8b 00             	mov    (%rax),%rax
  807d04:	48 8b 40 08          	mov    0x8(%rax),%rax
  807d08:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  807d0c:	0f b6 c0             	movzbl %al,%eax
  807d0f:	83 e0 40             	and    $0x40,%eax
  807d12:	89 c2                	mov    %eax,%edx
  807d14:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807d18:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  807d1a:	eb 1a                	jmp    807d36 <lwip_getsockopt_internal+0x285>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  807d1c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d20:	48 8b 00             	mov    (%rax),%rax
  807d23:	48 8b 40 08          	mov    0x8(%rax),%rax
  807d27:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  807d2d:	89 c2                	mov    %eax,%edx
  807d2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807d33:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
  807d35:	90                   	nop
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  807d36:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  807d37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d3b:	48 8b 00             	mov    (%rax),%rax
  807d3e:	8b 40 14             	mov    0x14(%rax),%eax
  807d41:	89 c7                	mov    %eax,%edi
  807d43:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  807d4a:	00 00 00 
  807d4d:	ff d0                	callq  *%rax
}
  807d4f:	c9                   	leaveq 
  807d50:	c3                   	retq   

0000000000807d51 <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  807d51:	55                   	push   %rbp
  807d52:	48 89 e5             	mov    %rsp,%rbp
  807d55:	48 83 ec 60          	sub    $0x60,%rsp
  807d59:	89 7d bc             	mov    %edi,-0x44(%rbp)
  807d5c:	89 75 b8             	mov    %esi,-0x48(%rbp)
  807d5f:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  807d62:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  807d66:	44 89 45 b0          	mov    %r8d,-0x50(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807d6a:	8b 45 bc             	mov    -0x44(%rbp),%eax
  807d6d:	89 c7                	mov    %eax,%edi
  807d6f:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  807d76:	00 00 00 
  807d79:	ff d0                	callq  *%rax
  807d7b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  int err = ERR_OK;
  807d7f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  807d86:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807d8b:	75 0a                	jne    807d97 <lwip_setsockopt+0x46>
    return -1;
  807d8d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807d92:	e9 fd 01 00 00       	jmpq   807f94 <lwip_setsockopt+0x243>

  if (NULL == optval) {
  807d97:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  807d9c:	75 28                	jne    807dc6 <lwip_setsockopt+0x75>
    sock_set_errno(sock, EFAULT);
  807d9e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807da2:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  807da9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807dad:	8b 50 18             	mov    0x18(%rax),%edx
  807db0:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807db7:	00 00 00 
  807dba:	89 10                	mov    %edx,(%rax)
    return -1;
  807dbc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807dc1:	e9 ce 01 00 00       	jmpq   807f94 <lwip_setsockopt+0x243>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  807dc6:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807dc9:	83 f8 06             	cmp    $0x6,%eax
  807dcc:	0f 84 ac 00 00 00    	je     807e7e <lwip_setsockopt+0x12d>
  807dd2:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807dd7:	74 09                	je     807de2 <lwip_setsockopt+0x91>
  807dd9:	85 c0                	test   %eax,%eax
  807ddb:	74 78                	je     807e55 <lwip_setsockopt+0x104>
  807ddd:	e9 dc 00 00 00       	jmpq   807ebe <lwip_setsockopt+0x16d>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807de2:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807de5:	83 f8 20             	cmp    $0x20,%eax
  807de8:	74 0c                	je     807df6 <lwip_setsockopt+0xa5>
  807dea:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807def:	74 18                	je     807e09 <lwip_setsockopt+0xb8>
  807df1:	83 f8 08             	cmp    $0x8,%eax
  807df4:	75 54                	jne    807e4a <lwip_setsockopt+0xf9>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  807df6:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807df9:	83 f8 03             	cmp    $0x3,%eax
  807dfc:	77 09                	ja     807e07 <lwip_setsockopt+0xb6>
        err = EINVAL;
  807dfe:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  807e05:	eb 4c                	jmp    807e53 <lwip_setsockopt+0x102>
  807e07:	eb 4a                	jmp    807e53 <lwip_setsockopt+0x102>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  807e09:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807e0c:	83 f8 03             	cmp    $0x3,%eax
  807e0f:	77 07                	ja     807e18 <lwip_setsockopt+0xc7>
        err = EINVAL;
  807e11:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807e18:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e1c:	48 8b 00             	mov    (%rax),%rax
  807e1f:	8b 00                	mov    (%rax),%eax
  807e21:	83 f8 20             	cmp    $0x20,%eax
  807e24:	75 19                	jne    807e3f <lwip_setsockopt+0xee>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  807e26:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e2a:	48 8b 00             	mov    (%rax),%rax
  807e2d:	48 8b 40 08          	mov    0x8(%rax),%rax
  807e31:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807e35:	0f b6 c0             	movzbl %al,%eax
  807e38:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807e3b:	85 c0                	test   %eax,%eax
  807e3d:	74 09                	je     807e48 <lwip_setsockopt+0xf7>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  807e3f:	c7 45 fc 61 00 00 00 	movl   $0x61,-0x4(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  807e46:	eb 0b                	jmp    807e53 <lwip_setsockopt+0x102>
  807e48:	eb 09                	jmp    807e53 <lwip_setsockopt+0x102>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  807e4a:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  807e51:	eb 72                	jmp    807ec5 <lwip_setsockopt+0x174>
  807e53:	eb 70                	jmp    807ec5 <lwip_setsockopt+0x174>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807e55:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807e58:	83 e8 01             	sub    $0x1,%eax
  807e5b:	83 f8 01             	cmp    $0x1,%eax
  807e5e:	77 13                	ja     807e73 <lwip_setsockopt+0x122>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  807e60:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807e63:	83 f8 03             	cmp    $0x3,%eax
  807e66:	77 09                	ja     807e71 <lwip_setsockopt+0x120>
        err = EINVAL;
  807e68:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  807e6f:	eb 0b                	jmp    807e7c <lwip_setsockopt+0x12b>
  807e71:	eb 09                	jmp    807e7c <lwip_setsockopt+0x12b>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  807e73:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  807e7a:	eb 49                	jmp    807ec5 <lwip_setsockopt+0x174>
  807e7c:	eb 47                	jmp    807ec5 <lwip_setsockopt+0x174>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  807e7e:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807e81:	83 f8 03             	cmp    $0x3,%eax
  807e84:	77 09                	ja     807e8f <lwip_setsockopt+0x13e>
      err = EINVAL;
  807e86:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      break;
  807e8d:	eb 36                	jmp    807ec5 <lwip_setsockopt+0x174>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  807e8f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e93:	48 8b 00             	mov    (%rax),%rax
  807e96:	8b 00                	mov    (%rax),%eax
  807e98:	83 f8 10             	cmp    $0x10,%eax
  807e9b:	74 0a                	je     807ea7 <lwip_setsockopt+0x156>
      return 0;
  807e9d:	b8 00 00 00 00       	mov    $0x0,%eax
  807ea2:	e9 ed 00 00 00       	jmpq   807f94 <lwip_setsockopt+0x243>

    switch (optname) {
  807ea7:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807eaa:	83 e8 01             	sub    $0x1,%eax
  807ead:	83 f8 01             	cmp    $0x1,%eax
  807eb0:	76 09                	jbe    807ebb <lwip_setsockopt+0x16a>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  807eb2:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  807eb9:	eb 0a                	jmp    807ec5 <lwip_setsockopt+0x174>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  807ebb:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807ebc:	eb 07                	jmp    807ec5 <lwip_setsockopt+0x174>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  807ebe:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
  }  /* switch (level) */


  if (err != ERR_OK) {
  807ec5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  807ec9:	74 27                	je     807ef2 <lwip_setsockopt+0x1a1>
    sock_set_errno(sock, err);
  807ecb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ecf:	8b 55 fc             	mov    -0x4(%rbp),%edx
  807ed2:	89 50 18             	mov    %edx,0x18(%rax)
  807ed5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ed9:	8b 50 18             	mov    0x18(%rax),%edx
  807edc:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807ee3:	00 00 00 
  807ee6:	89 10                	mov    %edx,(%rax)
    return -1;
  807ee8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807eed:	e9 a2 00 00 00       	jmpq   807f94 <lwip_setsockopt+0x243>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  807ef2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ef6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  807efa:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807efd:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  807f00:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807f03:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = (void*)optval;
  807f06:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807f0a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = &optlen;
  807f0e:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  807f12:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  807f16:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807f19:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  807f1c:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807f20:	ba 01 00 00 00       	mov    $0x1,%edx
  807f25:	48 89 c6             	mov    %rax,%rsi
  807f28:	48 bf 96 7f 80 00 00 	movabs $0x807f96,%rdi
  807f2f:	00 00 00 
  807f32:	48 b8 12 88 80 00 00 	movabs $0x808812,%rax
  807f39:	00 00 00 
  807f3c:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  807f3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f42:	48 8b 00             	mov    (%rax),%rax
  807f45:	8b 40 14             	mov    0x14(%rax),%eax
  807f48:	be 00 00 00 00       	mov    $0x0,%esi
  807f4d:	89 c7                	mov    %eax,%edi
  807f4f:	48 b8 1c 7e 81 00 00 	movabs $0x817e1c,%rax
  807f56:	00 00 00 
  807f59:	ff d0                	callq  *%rax
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  807f5b:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  807f5f:	0f be c0             	movsbl %al,%eax
  807f62:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sock_set_errno(sock, err);
  807f65:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f69:	8b 55 fc             	mov    -0x4(%rbp),%edx
  807f6c:	89 50 18             	mov    %edx,0x18(%rax)
  807f6f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f73:	8b 50 18             	mov    0x18(%rax),%edx
  807f76:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807f7d:	00 00 00 
  807f80:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  807f82:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  807f86:	74 07                	je     807f8f <lwip_setsockopt+0x23e>
  807f88:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f8d:	eb 05                	jmp    807f94 <lwip_setsockopt+0x243>
  807f8f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807f94:	c9                   	leaveq 
  807f95:	c3                   	retq   

0000000000807f96 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
  807f96:	55                   	push   %rbp
  807f97:	48 89 e5             	mov    %rsp,%rbp
  807f9a:	48 83 ec 40          	sub    $0x40,%rsp
  807f9e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  807fa2:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  807fa7:	75 2a                	jne    807fd3 <lwip_setsockopt_internal+0x3d>
  807fa9:	48 ba 47 13 82 00 00 	movabs $0x821347,%rdx
  807fb0:	00 00 00 
  807fb3:	be ae 06 00 00       	mov    $0x6ae,%esi
  807fb8:	48 bf 91 12 82 00 00 	movabs $0x821291,%rdi
  807fbf:	00 00 00 
  807fc2:	b8 00 00 00 00       	mov    $0x0,%eax
  807fc7:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  807fce:	00 00 00 
  807fd1:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  807fd3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807fd7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  807fdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807fdf:	48 8b 00             	mov    (%rax),%rax
  807fe2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  807fe6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807fea:	8b 40 08             	mov    0x8(%rax),%eax
  807fed:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  807ff0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807ff4:	8b 40 0c             	mov    0xc(%rax),%eax
  807ff7:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  807ffa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807ffe:	8b 40 10             	mov    0x10(%rax),%eax
  808001:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  808004:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808008:	48 8b 40 18          	mov    0x18(%rax),%rax
  80800c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  808010:	8b 45 e8             	mov    -0x18(%rbp),%eax
  808013:	83 f8 06             	cmp    $0x6,%eax
  808016:	0f 84 16 01 00 00    	je     808132 <lwip_setsockopt_internal+0x19c>
  80801c:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  808021:	74 0d                	je     808030 <lwip_setsockopt_internal+0x9a>
  808023:	85 c0                	test   %eax,%eax
  808025:	0f 84 c8 00 00 00    	je     8080f3 <lwip_setsockopt_internal+0x15d>
  80802b:	e9 78 01 00 00       	jmpq   8081a8 <lwip_setsockopt_internal+0x212>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  808030:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808033:	83 f8 20             	cmp    $0x20,%eax
  808036:	74 11                	je     808049 <lwip_setsockopt_internal+0xb3>
  808038:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  80803d:	74 62                	je     8080a1 <lwip_setsockopt_internal+0x10b>
  80803f:	83 f8 08             	cmp    $0x8,%eax
  808042:	74 05                	je     808049 <lwip_setsockopt_internal+0xb3>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  808044:	e9 5f 01 00 00       	jmpq   8081a8 <lwip_setsockopt_internal+0x212>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  808049:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80804d:	8b 00                	mov    (%rax),%eax
  80804f:	85 c0                	test   %eax,%eax
  808051:	74 27                	je     80807a <lwip_setsockopt_internal+0xe4>
        sock->conn->pcb.ip->so_options |= optname;
  808053:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808057:	48 8b 00             	mov    (%rax),%rax
  80805a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80805e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808062:	48 8b 12             	mov    (%rdx),%rdx
  808065:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808069:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  80806d:	89 d1                	mov    %edx,%ecx
  80806f:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  808072:	09 ca                	or     %ecx,%edx
  808074:	66 89 50 08          	mov    %dx,0x8(%rax)
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  808078:	eb 74                	jmp    8080ee <lwip_setsockopt_internal+0x158>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
        sock->conn->pcb.ip->so_options |= optname;
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  80807a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80807e:	48 8b 00             	mov    (%rax),%rax
  808081:	48 8b 40 08          	mov    0x8(%rax),%rax
  808085:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808089:	48 8b 12             	mov    (%rdx),%rdx
  80808c:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808090:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  808094:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  808097:	f7 d1                	not    %ecx
  808099:	21 ca                	and    %ecx,%edx
  80809b:	66 89 50 08          	mov    %dx,0x8(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  80809f:	eb 4d                	jmp    8080ee <lwip_setsockopt_internal+0x158>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  8080a1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8080a5:	8b 00                	mov    (%rax),%eax
  8080a7:	85 c0                	test   %eax,%eax
  8080a9:	74 22                	je     8080cd <lwip_setsockopt_internal+0x137>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  8080ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080af:	48 8b 00             	mov    (%rax),%rax
  8080b2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8080b6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8080ba:	48 8b 12             	mov    (%rdx),%rdx
  8080bd:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8080c1:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  8080c5:	83 ca 01             	or     $0x1,%edx
  8080c8:	88 50 18             	mov    %dl,0x18(%rax)
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
  8080cb:	eb 20                	jmp    8080ed <lwip_setsockopt_internal+0x157>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  8080cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080d1:	48 8b 00             	mov    (%rax),%rax
  8080d4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8080d8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8080dc:	48 8b 12             	mov    (%rdx),%rdx
  8080df:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8080e3:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  8080e7:	83 e2 fe             	and    $0xfffffffe,%edx
  8080ea:	88 50 18             	mov    %dl,0x18(%rax)
      }
      break;
  8080ed:	90                   	nop
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  8080ee:	e9 b5 00 00 00       	jmpq   8081a8 <lwip_setsockopt_internal+0x212>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8080f3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8080f6:	83 f8 01             	cmp    $0x1,%eax
  8080f9:	74 20                	je     80811b <lwip_setsockopt_internal+0x185>
  8080fb:	83 f8 02             	cmp    $0x2,%eax
  8080fe:	74 05                	je     808105 <lwip_setsockopt_internal+0x16f>
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  808100:	e9 a3 00 00 00       	jmpq   8081a8 <lwip_setsockopt_internal+0x212>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  808105:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808109:	48 8b 00             	mov    (%rax),%rax
  80810c:	48 8b 40 08          	mov    0x8(%rax),%rax
  808110:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  808114:	8b 12                	mov    (%rdx),%edx
  808116:	88 50 0b             	mov    %dl,0xb(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  808119:	eb 15                	jmp    808130 <lwip_setsockopt_internal+0x19a>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  80811b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80811f:	48 8b 00             	mov    (%rax),%rax
  808122:	48 8b 40 08          	mov    0x8(%rax),%rax
  808126:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80812a:	8b 12                	mov    (%rdx),%edx
  80812c:	88 50 0a             	mov    %dl,0xa(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  80812f:	90                   	nop
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  808130:	eb 76                	jmp    8081a8 <lwip_setsockopt_internal+0x212>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  808132:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808135:	83 f8 01             	cmp    $0x1,%eax
  808138:	74 07                	je     808141 <lwip_setsockopt_internal+0x1ab>
  80813a:	83 f8 02             	cmp    $0x2,%eax
  80813d:	74 50                	je     80818f <lwip_setsockopt_internal+0x1f9>
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  80813f:	eb 66                	jmp    8081a7 <lwip_setsockopt_internal+0x211>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
  808141:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808145:	8b 00                	mov    (%rax),%eax
  808147:	85 c0                	test   %eax,%eax
  808149:	74 22                	je     80816d <lwip_setsockopt_internal+0x1d7>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  80814b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80814f:	48 8b 00             	mov    (%rax),%rax
  808152:	48 8b 40 08          	mov    0x8(%rax),%rax
  808156:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80815a:	48 8b 12             	mov    (%rdx),%rdx
  80815d:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808161:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  808165:	83 ca 40             	or     $0x40,%edx
  808168:	88 50 2c             	mov    %dl,0x2c(%rax)
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  80816b:	eb 3a                	jmp    8081a7 <lwip_setsockopt_internal+0x211>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  80816d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808171:	48 8b 00             	mov    (%rax),%rax
  808174:	48 8b 40 08          	mov    0x8(%rax),%rax
  808178:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80817c:	48 8b 12             	mov    (%rdx),%rdx
  80817f:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808183:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  808187:	83 e2 bf             	and    $0xffffffbf,%edx
  80818a:	88 50 2c             	mov    %dl,0x2c(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  80818d:	eb 18                	jmp    8081a7 <lwip_setsockopt_internal+0x211>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  80818f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808193:	48 8b 00             	mov    (%rax),%rax
  808196:	48 8b 40 08          	mov    0x8(%rax),%rax
  80819a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80819e:	8b 12                	mov    (%rdx),%edx
  8081a0:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %lu\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
  8081a6:	90                   	nop
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  8081a7:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  8081a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8081ac:	48 8b 00             	mov    (%rax),%rax
  8081af:	8b 40 14             	mov    0x14(%rax),%eax
  8081b2:	89 c7                	mov    %eax,%edi
  8081b4:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  8081bb:	00 00 00 
  8081be:	ff d0                	callq  *%rax
}
  8081c0:	c9                   	leaveq 
  8081c1:	c3                   	retq   

00000000008081c2 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  8081c2:	55                   	push   %rbp
  8081c3:	48 89 e5             	mov    %rsp,%rbp
  8081c6:	48 83 ec 28          	sub    $0x28,%rsp
  8081ca:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8081cd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8081d1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct lwip_socket *sock = get_socket(s);
  8081d5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8081d8:	89 c7                	mov    %eax,%edi
  8081da:	48 b8 37 5a 80 00 00 	movabs $0x805a37,%rax
  8081e1:	00 00 00 
  8081e4:	ff d0                	callq  *%rax
  8081e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t buflen = 0;
  8081ea:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if (!sock)
  8081f0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8081f5:	75 0a                	jne    808201 <lwip_ioctl+0x3f>
    return -1;
  8081f7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8081fc:	e9 4d 01 00 00       	jmpq   80834e <lwip_ioctl+0x18c>

  switch (cmd) {
  808201:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  808205:	48 3d 7f 66 08 40    	cmp    $0x4008667f,%rax
  80820b:	74 13                	je     808220 <lwip_ioctl+0x5e>
  80820d:	ba 7e 66 08 80       	mov    $0x8008667e,%edx
  808212:	48 39 d0             	cmp    %rdx,%rax
  808215:	0f 84 ae 00 00 00    	je     8082c9 <lwip_ioctl+0x107>
  80821b:	e9 0b 01 00 00       	jmpq   80832b <lwip_ioctl+0x169>
  case FIONREAD:
    if (!argp) {
  808220:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  808225:	75 28                	jne    80824f <lwip_ioctl+0x8d>
      sock_set_errno(sock, EINVAL);
  808227:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80822b:	c7 40 18 16 00 00 00 	movl   $0x16,0x18(%rax)
  808232:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808236:	8b 50 18             	mov    0x18(%rax),%edx
  808239:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808240:	00 00 00 
  808243:	89 10                	mov    %edx,(%rax)
      return -1;
  808245:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80824a:	e9 ff 00 00 00       	jmpq   80834e <lwip_ioctl+0x18c>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  80824f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808253:	48 8b 00             	mov    (%rax),%rax
  808256:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  80825a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80825e:	66 89 10             	mov    %dx,(%rax)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  808261:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808265:	48 8b 40 08          	mov    0x8(%rax),%rax
  808269:	48 85 c0             	test   %rax,%rax
  80826c:	74 33                	je     8082a1 <lwip_ioctl+0xdf>
      buflen = netbuf_len(sock->lastdata);
  80826e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808272:	48 8b 40 08          	mov    0x8(%rax),%rax
  808276:	48 8b 00             	mov    (%rax),%rax
  808279:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80827d:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
      buflen -= sock->lastoffset;
  808281:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808285:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  808289:	66 29 45 f6          	sub    %ax,-0xa(%rbp)

      *((u16_t*)argp) += buflen;
  80828d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808291:	0f b7 10             	movzwl (%rax),%edx
  808294:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  808298:	01 c2                	add    %eax,%edx
  80829a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80829e:	66 89 10             	mov    %dx,(%rax)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  8082a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082a5:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8082ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082b0:	8b 50 18             	mov    0x18(%rax),%edx
  8082b3:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8082ba:	00 00 00 
  8082bd:	89 10                	mov    %edx,(%rax)
    return 0;
  8082bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8082c4:	e9 85 00 00 00       	jmpq   80834e <lwip_ioctl+0x18c>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8082c9:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8082ce:	74 21                	je     8082f1 <lwip_ioctl+0x12f>
  8082d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8082d4:	8b 00                	mov    (%rax),%eax
  8082d6:	85 c0                	test   %eax,%eax
  8082d8:	74 17                	je     8082f1 <lwip_ioctl+0x12f>
      sock->flags |= O_NONBLOCK;
  8082da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082de:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  8082e2:	80 cc 08             	or     $0x8,%ah
  8082e5:	89 c2                	mov    %eax,%edx
  8082e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082eb:	66 89 50 16          	mov    %dx,0x16(%rax)
  8082ef:	eb 15                	jmp    808306 <lwip_ioctl+0x144>
    else
      sock->flags &= ~O_NONBLOCK;
  8082f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082f5:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  8082f9:	80 e4 f7             	and    $0xf7,%ah
  8082fc:	89 c2                	mov    %eax,%edx
  8082fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808302:	66 89 50 16          	mov    %dx,0x16(%rax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  808306:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80830a:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  808311:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808315:	8b 50 18             	mov    0x18(%rax),%edx
  808318:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80831f:	00 00 00 
  808322:	89 10                	mov    %edx,(%rax)
    return 0;
  808324:	b8 00 00 00 00       	mov    $0x0,%eax
  808329:	eb 23                	jmp    80834e <lwip_ioctl+0x18c>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  80832b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80832f:	c7 40 18 26 00 00 00 	movl   $0x26,0x18(%rax)
  808336:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80833a:	8b 50 18             	mov    0x18(%rax),%edx
  80833d:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808344:	00 00 00 
  808347:	89 10                	mov    %edx,(%rax)
    return -1;
  808349:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  } /* switch (cmd) */
}
  80834e:	c9                   	leaveq 
  80834f:	c3                   	retq   

0000000000808350 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  808350:	55                   	push   %rbp
  808351:	48 89 e5             	mov    %rsp,%rbp
  808354:	48 83 ec 10          	sub    $0x10,%rsp
  808358:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  80835c:	48 b8 f7 e8 80 00 00 	movabs $0x80e8f7,%rax
  808363:	00 00 00 
  808366:	ff d0                	callq  *%rax
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  808368:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80836f:	00 00 00 
  808372:	48 8b 00             	mov    (%rax),%rax
  808375:	48 85 c0             	test   %rax,%rax
  808378:	75 12                	jne    80838c <tcpip_tcp_timer+0x3c>
  80837a:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  808381:	00 00 00 
  808384:	48 8b 00             	mov    (%rax),%rax
  808387:	48 85 c0             	test   %rax,%rax
  80838a:	74 22                	je     8083ae <tcpip_tcp_timer+0x5e>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80838c:	ba 00 00 00 00       	mov    $0x0,%edx
  808391:	48 be 50 83 80 00 00 	movabs $0x808350,%rsi
  808398:	00 00 00 
  80839b:	bf fa 00 00 00       	mov    $0xfa,%edi
  8083a0:	48 b8 e2 e4 80 00 00 	movabs $0x80e4e2,%rax
  8083a7:	00 00 00 
  8083aa:	ff d0                	callq  *%rax
  8083ac:	eb 10                	jmp    8083be <tcpip_tcp_timer+0x6e>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  8083ae:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  8083b5:	00 00 00 
  8083b8:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  }
}
  8083be:	c9                   	leaveq 
  8083bf:	c3                   	retq   

00000000008083c0 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  8083c0:	55                   	push   %rbp
  8083c1:	48 89 e5             	mov    %rsp,%rbp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8083c4:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  8083cb:	00 00 00 
  8083ce:	8b 00                	mov    (%rax),%eax
  8083d0:	85 c0                	test   %eax,%eax
  8083d2:	75 54                	jne    808428 <tcp_timer_needed+0x68>
  8083d4:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8083db:	00 00 00 
  8083de:	48 8b 00             	mov    (%rax),%rax
  8083e1:	48 85 c0             	test   %rax,%rax
  8083e4:	75 12                	jne    8083f8 <tcp_timer_needed+0x38>
  8083e6:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8083ed:	00 00 00 
  8083f0:	48 8b 00             	mov    (%rax),%rax
  8083f3:	48 85 c0             	test   %rax,%rax
  8083f6:	74 30                	je     808428 <tcp_timer_needed+0x68>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  8083f8:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  8083ff:	00 00 00 
  808402:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  808408:	ba 00 00 00 00       	mov    $0x0,%edx
  80840d:	48 be 50 83 80 00 00 	movabs $0x808350,%rsi
  808414:	00 00 00 
  808417:	bf fa 00 00 00       	mov    $0xfa,%edi
  80841c:	48 b8 e2 e4 80 00 00 	movabs $0x80e4e2,%rax
  808423:	00 00 00 
  808426:	ff d0                	callq  *%rax
  }
}
  808428:	5d                   	pop    %rbp
  808429:	c3                   	retq   

000000000080842a <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  80842a:	55                   	push   %rbp
  80842b:	48 89 e5             	mov    %rsp,%rbp
  80842e:	48 83 ec 10          	sub    $0x10,%rsp
  808432:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  808436:	48 b8 15 13 81 00 00 	movabs $0x811315,%rax
  80843d:	00 00 00 
  808440:	ff d0                	callq  *%rax
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  808442:	ba 00 00 00 00       	mov    $0x0,%edx
  808447:	48 be 2a 84 80 00 00 	movabs $0x80842a,%rsi
  80844e:	00 00 00 
  808451:	bf e8 03 00 00       	mov    $0x3e8,%edi
  808456:	48 b8 e2 e4 80 00 00 	movabs $0x80e4e2,%rax
  80845d:	00 00 00 
  808460:	ff d0                	callq  *%rax
}
  808462:	c9                   	leaveq 
  808463:	c3                   	retq   

0000000000808464 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  808464:	55                   	push   %rbp
  808465:	48 89 e5             	mov    %rsp,%rbp
  808468:	48 83 ec 10          	sub    $0x10,%rsp
  80846c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  808470:	48 b8 5c 57 81 00 00 	movabs $0x81575c,%rax
  808477:	00 00 00 
  80847a:	ff d0                	callq  *%rax
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80847c:	ba 00 00 00 00       	mov    $0x0,%edx
  808481:	48 be 64 84 80 00 00 	movabs $0x808464,%rsi
  808488:	00 00 00 
  80848b:	bf 88 13 00 00       	mov    $0x1388,%edi
  808490:	48 b8 e2 e4 80 00 00 	movabs $0x80e4e2,%rax
  808497:	00 00 00 
  80849a:	ff d0                	callq  *%rax
}
  80849c:	c9                   	leaveq 
  80849d:	c3                   	retq   

000000000080849e <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  80849e:	55                   	push   %rbp
  80849f:	48 89 e5             	mov    %rsp,%rbp
  8084a2:	48 83 ec 10          	sub    $0x10,%rsp
  8084a6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8084aa:	48 b8 cf 95 80 00 00 	movabs $0x8095cf,%rax
  8084b1:	00 00 00 
  8084b4:	ff d0                	callq  *%rax
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8084b6:	ba 00 00 00 00       	mov    $0x0,%edx
  8084bb:	48 be 9e 84 80 00 00 	movabs $0x80849e,%rsi
  8084c2:	00 00 00 
  8084c5:	bf 60 ea 00 00       	mov    $0xea60,%edi
  8084ca:	48 b8 e2 e4 80 00 00 	movabs $0x80e4e2,%rax
  8084d1:	00 00 00 
  8084d4:	ff d0                	callq  *%rax
}
  8084d6:	c9                   	leaveq 
  8084d7:	c3                   	retq   

00000000008084d8 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  8084d8:	55                   	push   %rbp
  8084d9:	48 89 e5             	mov    %rsp,%rbp
  8084dc:	48 83 ec 10          	sub    $0x10,%rsp
  8084e0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  8084e4:	48 b8 65 96 80 00 00 	movabs $0x809665,%rax
  8084eb:	00 00 00 
  8084ee:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8084f0:	ba 00 00 00 00       	mov    $0x0,%edx
  8084f5:	48 be d8 84 80 00 00 	movabs $0x8084d8,%rsi
  8084fc:	00 00 00 
  8084ff:	bf f4 01 00 00       	mov    $0x1f4,%edi
  808504:	48 b8 e2 e4 80 00 00 	movabs $0x80e4e2,%rax
  80850b:	00 00 00 
  80850e:	ff d0                	callq  *%rax
}
  808510:	c9                   	leaveq 
  808511:	c3                   	retq   

0000000000808512 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  808512:	55                   	push   %rbp
  808513:	48 89 e5             	mov    %rsp,%rbp
  808516:	48 83 ec 20          	sub    $0x20,%rsp
  80851a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80851e:	ba 00 00 00 00       	mov    $0x0,%edx
  808523:	48 be 2a 84 80 00 00 	movabs $0x80842a,%rsi
  80852a:	00 00 00 
  80852d:	bf e8 03 00 00       	mov    $0x3e8,%edi
  808532:	48 b8 e2 e4 80 00 00 	movabs $0x80e4e2,%rax
  808539:	00 00 00 
  80853c:	ff d0                	callq  *%rax
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80853e:	ba 00 00 00 00       	mov    $0x0,%edx
  808543:	48 be 64 84 80 00 00 	movabs $0x808464,%rsi
  80854a:	00 00 00 
  80854d:	bf 88 13 00 00       	mov    $0x1388,%edi
  808552:	48 b8 e2 e4 80 00 00 	movabs $0x80e4e2,%rax
  808559:	00 00 00 
  80855c:	ff d0                	callq  *%rax
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  80855e:	ba 00 00 00 00       	mov    $0x0,%edx
  808563:	48 be 9e 84 80 00 00 	movabs $0x80849e,%rsi
  80856a:	00 00 00 
  80856d:	bf 60 ea 00 00       	mov    $0xea60,%edi
  808572:	48 b8 e2 e4 80 00 00 	movabs $0x80e4e2,%rax
  808579:	00 00 00 
  80857c:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80857e:	ba 00 00 00 00       	mov    $0x0,%edx
  808583:	48 be d8 84 80 00 00 	movabs $0x8084d8,%rsi
  80858a:	00 00 00 
  80858d:	bf f4 01 00 00       	mov    $0x1f4,%edi
  808592:	48 b8 e2 e4 80 00 00 	movabs $0x80e4e2,%rax
  808599:	00 00 00 
  80859c:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  80859e:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  8085a5:	00 00 00 
  8085a8:	48 8b 00             	mov    (%rax),%rax
  8085ab:	48 85 c0             	test   %rax,%rax
  8085ae:	74 1f                	je     8085cf <tcpip_thread+0xbd>
    tcpip_init_done(tcpip_init_done_arg);
  8085b0:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  8085b7:	00 00 00 
  8085ba:	48 8b 00             	mov    (%rax),%rax
  8085bd:	48 ba b8 94 82 00 00 	movabs $0x8294b8,%rdx
  8085c4:	00 00 00 
  8085c7:	48 8b 12             	mov    (%rdx),%rdx
  8085ca:	48 89 d7             	mov    %rdx,%rdi
  8085cd:	ff d0                	callq  *%rax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8085cf:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8085d6:	00 00 00 
  8085d9:	8b 00                	mov    (%rax),%eax
  8085db:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  8085df:	48 89 d6             	mov    %rdx,%rsi
  8085e2:	89 c7                	mov    %eax,%edi
  8085e4:	48 b8 81 e2 80 00 00 	movabs $0x80e281,%rax
  8085eb:	00 00 00 
  8085ee:	ff d0                	callq  *%rax
    switch (msg->type) {
  8085f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085f4:	8b 00                	mov    (%rax),%eax
  8085f6:	83 f8 01             	cmp    $0x1,%eax
  8085f9:	74 3d                	je     808638 <tcpip_thread+0x126>
  8085fb:	83 f8 01             	cmp    $0x1,%eax
  8085fe:	72 17                	jb     808617 <tcpip_thread+0x105>
  808600:	83 f8 02             	cmp    $0x2,%eax
  808603:	0f 84 a8 00 00 00    	je     8086b1 <tcpip_thread+0x19f>
  808609:	83 f8 03             	cmp    $0x3,%eax
  80860c:	0f 84 ce 00 00 00    	je     8086e0 <tcpip_thread+0x1ce>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;

    default:
      break;
  808612:	e9 3a 01 00 00       	jmpq   808751 <tcpip_thread+0x23f>
    sys_mbox_fetch(mbox, (void *)&msg);
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  808617:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80861b:	48 8b 40 10          	mov    0x10(%rax),%rax
  80861f:	48 8b 00             	mov    (%rax),%rax
  808622:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808626:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80862a:	48 83 c2 08          	add    $0x8,%rdx
  80862e:	48 89 d7             	mov    %rdx,%rdi
  808631:	ff d0                	callq  *%rax
      break;
  808633:	e9 19 01 00 00       	jmpq   808751 <tcpip_thread+0x23f>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  808638:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80863c:	48 8b 40 18          	mov    0x18(%rax),%rax
  808640:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  808644:	0f b6 c0             	movzbl %al,%eax
  808647:	83 e0 20             	and    $0x20,%eax
  80864a:	85 c0                	test   %eax,%eax
  80864c:	74 24                	je     808672 <tcpip_thread+0x160>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  80864e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808652:	48 8b 50 18          	mov    0x18(%rax),%rdx
  808656:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80865a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80865e:	48 89 d6             	mov    %rdx,%rsi
  808661:	48 89 c7             	mov    %rax,%rdi
  808664:	48 b8 02 70 81 00 00 	movabs $0x817002,%rax
  80866b:	00 00 00 
  80866e:	ff d0                	callq  *%rax
  808670:	eb 22                	jmp    808694 <tcpip_thread+0x182>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  808672:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808676:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80867a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80867e:	48 8b 40 10          	mov    0x10(%rax),%rax
  808682:	48 89 d6             	mov    %rdx,%rsi
  808685:	48 89 c7             	mov    %rax,%rdi
  808688:	48 b8 5f 0b 81 00 00 	movabs $0x810b5f,%rax
  80868f:	00 00 00 
  808692:	ff d0                	callq  *%rax
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  808694:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808698:	48 89 c6             	mov    %rax,%rsi
  80869b:	bf 09 00 00 00       	mov    $0x9,%edi
  8086a0:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  8086a7:	00 00 00 
  8086aa:	ff d0                	callq  *%rax
      break;
  8086ac:	e9 a0 00 00 00       	jmpq   808751 <tcpip_thread+0x23f>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  8086b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8086b5:	48 8b 40 10          	mov    0x10(%rax),%rax
  8086b9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8086bd:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  8086c1:	48 89 d7             	mov    %rdx,%rdi
  8086c4:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8086c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8086ca:	48 89 c6             	mov    %rax,%rsi
  8086cd:	bf 08 00 00 00       	mov    $0x8,%edi
  8086d2:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  8086d9:	00 00 00 
  8086dc:	ff d0                	callq  *%rax
      break;
  8086de:	eb 71                	jmp    808751 <tcpip_thread+0x23f>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8086e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8086e4:	8b 40 10             	mov    0x10(%rax),%eax
  8086e7:	83 f8 ff             	cmp    $0xffffffff,%eax
  8086ea:	74 2a                	je     808716 <tcpip_thread+0x204>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8086ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8086f0:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8086f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8086f8:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8086fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808700:	8b 40 10             	mov    0x10(%rax),%eax
  808703:	48 89 ce             	mov    %rcx,%rsi
  808706:	89 c7                	mov    %eax,%edi
  808708:	48 b8 e2 e4 80 00 00 	movabs $0x80e4e2,%rax
  80870f:	00 00 00 
  808712:	ff d0                	callq  *%rax
  808714:	eb 22                	jmp    808738 <tcpip_thread+0x226>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  808716:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80871a:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80871e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808722:	48 8b 40 18          	mov    0x18(%rax),%rax
  808726:	48 89 d6             	mov    %rdx,%rsi
  808729:	48 89 c7             	mov    %rax,%rdi
  80872c:	48 b8 c7 e6 80 00 00 	movabs $0x80e6c7,%rax
  808733:	00 00 00 
  808736:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  808738:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80873c:	48 89 c6             	mov    %rax,%rsi
  80873f:	bf 08 00 00 00       	mov    $0x8,%edi
  808744:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80874b:	00 00 00 
  80874e:	ff d0                	callq  *%rax
      break;
  808750:	90                   	nop

    default:
      break;
    }
  }
  808751:	e9 79 fe ff ff       	jmpq   8085cf <tcpip_thread+0xbd>

0000000000808756 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  808756:	55                   	push   %rbp
  808757:	48 89 e5             	mov    %rsp,%rbp
  80875a:	48 83 ec 20          	sub    $0x20,%rsp
  80875e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808762:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808766:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  80876d:	00 00 00 
  808770:	8b 00                	mov    (%rax),%eax
  808772:	83 f8 ff             	cmp    $0xffffffff,%eax
  808775:	0f 84 90 00 00 00    	je     80880b <tcpip_input+0xb5>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  80877b:	bf 09 00 00 00       	mov    $0x9,%edi
  808780:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  808787:	00 00 00 
  80878a:	ff d0                	callq  *%rax
  80878c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808790:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808795:	75 07                	jne    80879e <tcpip_input+0x48>
      return ERR_MEM;
  808797:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80879c:	eb 72                	jmp    808810 <tcpip_input+0xba>
    }

    msg->type = TCPIP_MSG_INPKT;
  80879e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8087a2:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    msg->msg.inp.p = p;
  8087a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8087ac:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8087b0:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.inp.netif = inp;
  8087b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8087b8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8087bc:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8087c0:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8087c7:	00 00 00 
  8087ca:	8b 00                	mov    (%rax),%eax
  8087cc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8087d0:	48 89 d6             	mov    %rdx,%rsi
  8087d3:	89 c7                	mov    %eax,%edi
  8087d5:	48 b8 35 78 81 00 00 	movabs $0x817835,%rax
  8087dc:	00 00 00 
  8087df:	ff d0                	callq  *%rax
  8087e1:	84 c0                	test   %al,%al
  8087e3:	74 1f                	je     808804 <tcpip_input+0xae>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8087e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8087e9:	48 89 c6             	mov    %rax,%rsi
  8087ec:	bf 09 00 00 00       	mov    $0x9,%edi
  8087f1:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  8087f8:	00 00 00 
  8087fb:	ff d0                	callq  *%rax
      return ERR_MEM;
  8087fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808802:	eb 0c                	jmp    808810 <tcpip_input+0xba>
    }
    return ERR_OK;
  808804:	b8 00 00 00 00       	mov    $0x0,%eax
  808809:	eb 05                	jmp    808810 <tcpip_input+0xba>
  }
  return ERR_VAL;
  80880b:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808810:	c9                   	leaveq 
  808811:	c3                   	retq   

0000000000808812 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  808812:	55                   	push   %rbp
  808813:	48 89 e5             	mov    %rsp,%rbp
  808816:	48 83 ec 30          	sub    $0x30,%rsp
  80881a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80881e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808822:	89 d0                	mov    %edx,%eax
  808824:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808827:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  80882e:	00 00 00 
  808831:	8b 00                	mov    (%rax),%eax
  808833:	83 f8 ff             	cmp    $0xffffffff,%eax
  808836:	0f 84 bc 00 00 00    	je     8088f8 <tcpip_callback_with_block+0xe6>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80883c:	bf 08 00 00 00       	mov    $0x8,%edi
  808841:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  808848:	00 00 00 
  80884b:	ff d0                	callq  *%rax
  80884d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808851:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808856:	75 0a                	jne    808862 <tcpip_callback_with_block+0x50>
      return ERR_MEM;
  808858:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80885d:	e9 9b 00 00 00       	jmpq   8088fd <tcpip_callback_with_block+0xeb>
    }

    msg->type = TCPIP_MSG_CALLBACK;
  808862:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808866:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
    msg->msg.cb.f = f;
  80886c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808870:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  808874:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.cb.ctx = ctx;
  808878:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80887c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808880:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (block) {
  808884:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  808888:	74 23                	je     8088ad <tcpip_callback_with_block+0x9b>
      sys_mbox_post(mbox, msg);
  80888a:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808891:	00 00 00 
  808894:	8b 00                	mov    (%rax),%eax
  808896:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80889a:	48 89 d6             	mov    %rdx,%rsi
  80889d:	89 c7                	mov    %eax,%edi
  80889f:	48 b8 d3 77 81 00 00 	movabs $0x8177d3,%rax
  8088a6:	00 00 00 
  8088a9:	ff d0                	callq  *%rax
  8088ab:	eb 44                	jmp    8088f1 <tcpip_callback_with_block+0xdf>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8088ad:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8088b4:	00 00 00 
  8088b7:	8b 00                	mov    (%rax),%eax
  8088b9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8088bd:	48 89 d6             	mov    %rdx,%rsi
  8088c0:	89 c7                	mov    %eax,%edi
  8088c2:	48 b8 35 78 81 00 00 	movabs $0x817835,%rax
  8088c9:	00 00 00 
  8088cc:	ff d0                	callq  *%rax
  8088ce:	84 c0                	test   %al,%al
  8088d0:	74 1f                	je     8088f1 <tcpip_callback_with_block+0xdf>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  8088d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088d6:	48 89 c6             	mov    %rax,%rsi
  8088d9:	bf 08 00 00 00       	mov    $0x8,%edi
  8088de:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  8088e5:	00 00 00 
  8088e8:	ff d0                	callq  *%rax
        return ERR_MEM;
  8088ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8088ef:	eb 0c                	jmp    8088fd <tcpip_callback_with_block+0xeb>
      }
    }
    return ERR_OK;
  8088f1:	b8 00 00 00 00       	mov    $0x0,%eax
  8088f6:	eb 05                	jmp    8088fd <tcpip_callback_with_block+0xeb>
  }
  return ERR_VAL;
  8088f8:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8088fd:	c9                   	leaveq 
  8088fe:	c3                   	retq   

00000000008088ff <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8088ff:	55                   	push   %rbp
  808900:	48 89 e5             	mov    %rsp,%rbp
  808903:	48 83 ec 30          	sub    $0x30,%rsp
  808907:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80890a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80890e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808912:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808919:	00 00 00 
  80891c:	8b 00                	mov    (%rax),%eax
  80891e:	83 f8 ff             	cmp    $0xffffffff,%eax
  808921:	74 77                	je     80899a <tcpip_timeout+0x9b>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808923:	bf 08 00 00 00       	mov    $0x8,%edi
  808928:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  80892f:	00 00 00 
  808932:	ff d0                	callq  *%rax
  808934:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808938:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80893d:	75 07                	jne    808946 <tcpip_timeout+0x47>
      return ERR_MEM;
  80893f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808944:	eb 59                	jmp    80899f <tcpip_timeout+0xa0>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  808946:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80894a:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
    msg->msg.tmo.msecs = msecs;
  808950:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808954:	8b 55 ec             	mov    -0x14(%rbp),%edx
  808957:	89 50 10             	mov    %edx,0x10(%rax)
    msg->msg.tmo.h = h;
  80895a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80895e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808962:	48 89 50 18          	mov    %rdx,0x18(%rax)
    msg->msg.tmo.arg = arg;
  808966:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80896a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80896e:	48 89 50 20          	mov    %rdx,0x20(%rax)
    sys_mbox_post(mbox, msg);
  808972:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808979:	00 00 00 
  80897c:	8b 00                	mov    (%rax),%eax
  80897e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808982:	48 89 d6             	mov    %rdx,%rsi
  808985:	89 c7                	mov    %eax,%edi
  808987:	48 b8 d3 77 81 00 00 	movabs $0x8177d3,%rax
  80898e:	00 00 00 
  808991:	ff d0                	callq  *%rax
    return ERR_OK;
  808993:	b8 00 00 00 00       	mov    $0x0,%eax
  808998:	eb 05                	jmp    80899f <tcpip_timeout+0xa0>
  }
  return ERR_VAL;
  80899a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80899f:	c9                   	leaveq 
  8089a0:	c3                   	retq   

00000000008089a1 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  8089a1:	55                   	push   %rbp
  8089a2:	48 89 e5             	mov    %rsp,%rbp
  8089a5:	48 83 ec 40          	sub    $0x40,%rsp
  8089a9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  8089ad:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8089b4:	00 00 00 
  8089b7:	8b 00                	mov    (%rax),%eax
  8089b9:	83 f8 ff             	cmp    $0xffffffff,%eax
  8089bc:	74 55                	je     808a13 <tcpip_apimsg+0x72>
    msg.type = TCPIP_MSG_API;
  8089be:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
    msg.msg.apimsg = apimsg;
  8089c5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8089c9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    sys_mbox_post(mbox, &msg);
  8089cd:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8089d4:	00 00 00 
  8089d7:	8b 00                	mov    (%rax),%eax
  8089d9:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8089dd:	48 89 d6             	mov    %rdx,%rsi
  8089e0:	89 c7                	mov    %eax,%edi
  8089e2:	48 b8 d3 77 81 00 00 	movabs $0x8177d3,%rax
  8089e9:	00 00 00 
  8089ec:	ff d0                	callq  *%rax
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  8089ee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8089f2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8089f6:	8b 40 14             	mov    0x14(%rax),%eax
  8089f9:	be 00 00 00 00       	mov    $0x0,%esi
  8089fe:	89 c7                	mov    %eax,%edi
  808a00:	48 b8 1c 7e 81 00 00 	movabs $0x817e1c,%rax
  808a07:	00 00 00 
  808a0a:	ff d0                	callq  *%rax
    return ERR_OK;
  808a0c:	b8 00 00 00 00       	mov    $0x0,%eax
  808a11:	eb 05                	jmp    808a18 <tcpip_apimsg+0x77>
  }
  return ERR_VAL;
  808a13:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808a18:	c9                   	leaveq 
  808a19:	c3                   	retq   

0000000000808a1a <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  808a1a:	55                   	push   %rbp
  808a1b:	48 89 e5             	mov    %rsp,%rbp
  808a1e:	48 83 ec 10          	sub    $0x10,%rsp
  808a22:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808a26:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  lwip_init();
  808a2a:	48 b8 c5 90 80 00 00 	movabs $0x8090c5,%rax
  808a31:	00 00 00 
  808a34:	ff d0                	callq  *%rax

  tcpip_init_done = initfunc;
  808a36:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  808a3d:	00 00 00 
  808a40:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808a44:	48 89 10             	mov    %rdx,(%rax)
  tcpip_init_done_arg = arg;
  808a47:	48 b8 b8 94 82 00 00 	movabs $0x8294b8,%rax
  808a4e:	00 00 00 
  808a51:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808a55:	48 89 10             	mov    %rdx,(%rax)
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  808a58:	bf 00 00 00 00       	mov    $0x0,%edi
  808a5d:	48 b8 a4 73 81 00 00 	movabs $0x8173a4,%rax
  808a64:	00 00 00 
  808a67:	ff d0                	callq  *%rax
  808a69:	48 ba 78 81 82 00 00 	movabs $0x828178,%rdx
  808a70:	00 00 00 
  808a73:	89 02                	mov    %eax,(%rdx)
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  808a75:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  808a7b:	b9 00 00 00 00       	mov    $0x0,%ecx
  808a80:	ba 00 00 00 00       	mov    $0x0,%edx
  808a85:	48 be 12 85 80 00 00 	movabs $0x808512,%rsi
  808a8c:	00 00 00 
  808a8f:	48 bf 53 13 82 00 00 	movabs $0x821353,%rdi
  808a96:	00 00 00 
  808a99:	48 b8 3d 83 81 00 00 	movabs $0x81833d,%rax
  808aa0:	00 00 00 
  808aa3:	ff d0                	callq  *%rax
}
  808aa5:	c9                   	leaveq 
  808aa6:	c3                   	retq   

0000000000808aa7 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  808aa7:	55                   	push   %rbp
  808aa8:	48 89 e5             	mov    %rsp,%rbp
  808aab:	48 83 ec 20          	sub    $0x20,%rsp
  808aaf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q = p;
  808ab3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808ab7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pbuf_free(q);
  808abb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808abf:	48 89 c7             	mov    %rax,%rdi
  808ac2:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  808ac9:	00 00 00 
  808acc:	ff d0                	callq  *%rax
}
  808ace:	c9                   	leaveq 
  808acf:	c3                   	retq   

0000000000808ad0 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  808ad0:	55                   	push   %rbp
  808ad1:	48 89 e5             	mov    %rsp,%rbp
  808ad4:	48 83 ec 10          	sub    $0x10,%rsp
  808ad8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  808adc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ae0:	ba 00 00 00 00       	mov    $0x0,%edx
  808ae5:	48 89 c6             	mov    %rax,%rsi
  808ae8:	48 bf a7 8a 80 00 00 	movabs $0x808aa7,%rdi
  808aef:	00 00 00 
  808af2:	48 b8 12 88 80 00 00 	movabs $0x808812,%rax
  808af9:	00 00 00 
  808afc:	ff d0                	callq  *%rax
}
  808afe:	c9                   	leaveq 
  808aff:	c3                   	retq   

0000000000808b00 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  808b00:	55                   	push   %rbp
  808b01:	48 89 e5             	mov    %rsp,%rbp
  808b04:	48 83 ec 10          	sub    $0x10,%rsp
  808b08:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(mem_free, m, 0);
  808b0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b10:	ba 00 00 00 00       	mov    $0x0,%edx
  808b15:	48 89 c6             	mov    %rax,%rsi
  808b18:	48 bf c9 c1 80 00 00 	movabs $0x80c1c9,%rdi
  808b1f:	00 00 00 
  808b22:	48 b8 12 88 80 00 00 	movabs $0x808812,%rax
  808b29:	00 00 00 
  808b2c:	ff d0                	callq  *%rax
}
  808b2e:	c9                   	leaveq 
  808b2f:	c3                   	retq   

0000000000808b30 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  808b30:	55                   	push   %rbp
  808b31:	48 89 e5             	mov    %rsp,%rbp
  808b34:	48 83 ec 10          	sub    $0x10,%rsp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  808b38:	bf 06 00 00 00       	mov    $0x6,%edi
  808b3d:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  808b44:	00 00 00 
  808b47:	ff d0                	callq  *%rax
  808b49:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (buf != NULL) {
  808b4d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808b52:	74 29                	je     808b7d <netbuf_new+0x4d>
    buf->p = NULL;
  808b54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b58:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    buf->ptr = NULL;
  808b5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b63:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808b6a:	00 
    buf->addr = NULL;
  808b6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b6f:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  808b76:	00 
    return buf;
  808b77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b7b:	eb 05                	jmp    808b82 <netbuf_new+0x52>
  } else {
    return NULL;
  808b7d:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
  808b82:	c9                   	leaveq 
  808b83:	c3                   	retq   

0000000000808b84 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  808b84:	55                   	push   %rbp
  808b85:	48 89 e5             	mov    %rsp,%rbp
  808b88:	48 83 ec 10          	sub    $0x10,%rsp
  808b8c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (buf != NULL) {
  808b90:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808b95:	74 55                	je     808bec <netbuf_delete+0x68>
    if (buf->p != NULL) {
  808b97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b9b:	48 8b 00             	mov    (%rax),%rax
  808b9e:	48 85 c0             	test   %rax,%rax
  808ba1:	74 31                	je     808bd4 <netbuf_delete+0x50>
      pbuf_free(buf->p);
  808ba3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ba7:	48 8b 00             	mov    (%rax),%rax
  808baa:	48 89 c7             	mov    %rax,%rdi
  808bad:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  808bb4:	00 00 00 
  808bb7:	ff d0                	callq  *%rax
      buf->p = buf->ptr = NULL;
  808bb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bbd:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808bc4:	00 
  808bc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bc9:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808bcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bd1:	48 89 10             	mov    %rdx,(%rax)
    }
    memp_free(MEMP_NETBUF, buf);
  808bd4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bd8:	48 89 c6             	mov    %rax,%rsi
  808bdb:	bf 06 00 00 00       	mov    $0x6,%edi
  808be0:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  808be7:	00 00 00 
  808bea:	ff d0                	callq  *%rax
  }
}
  808bec:	c9                   	leaveq 
  808bed:	c3                   	retq   

0000000000808bee <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  808bee:	55                   	push   %rbp
  808bef:	48 89 e5             	mov    %rsp,%rbp
  808bf2:	48 83 ec 10          	sub    $0x10,%rsp
  808bf6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808bfa:	89 f0                	mov    %esi,%eax
  808bfc:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  808c00:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808c05:	75 2a                	jne    808c31 <netbuf_alloc+0x43>
  808c07:	48 ba 60 13 82 00 00 	movabs $0x821360,%rdx
  808c0e:	00 00 00 
  808c11:	be 63 00 00 00       	mov    $0x63,%esi
  808c16:	48 bf 7a 13 82 00 00 	movabs $0x82137a,%rdi
  808c1d:	00 00 00 
  808c20:	b8 00 00 00 00       	mov    $0x0,%eax
  808c25:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  808c2c:	00 00 00 
  808c2f:	ff d1                	callq  *%rcx

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  808c31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c35:	48 8b 00             	mov    (%rax),%rax
  808c38:	48 85 c0             	test   %rax,%rax
  808c3b:	74 16                	je     808c53 <netbuf_alloc+0x65>
    pbuf_free(buf->p);
  808c3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c41:	48 8b 00             	mov    (%rax),%rax
  808c44:	48 89 c7             	mov    %rax,%rdi
  808c47:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  808c4e:	00 00 00 
  808c51:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  808c53:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  808c57:	ba 00 00 00 00       	mov    $0x0,%edx
  808c5c:	89 c6                	mov    %eax,%esi
  808c5e:	bf 00 00 00 00       	mov    $0x0,%edi
  808c63:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  808c6a:	00 00 00 
  808c6d:	ff d0                	callq  *%rax
  808c6f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808c73:	48 89 02             	mov    %rax,(%rdx)
  if (buf->p == NULL) {
  808c76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c7a:	48 8b 00             	mov    (%rax),%rax
  808c7d:	48 85 c0             	test   %rax,%rax
  808c80:	75 07                	jne    808c89 <netbuf_alloc+0x9b>
     return NULL;
  808c82:	b8 00 00 00 00       	mov    $0x0,%eax
  808c87:	eb 55                	jmp    808cde <netbuf_alloc+0xf0>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  808c89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c8d:	48 8b 00             	mov    (%rax),%rax
  808c90:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  808c94:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  808c98:	73 2a                	jae    808cc4 <netbuf_alloc+0xd6>
  808c9a:	48 ba 90 13 82 00 00 	movabs $0x821390,%rdx
  808ca1:	00 00 00 
  808ca4:	be 6e 00 00 00       	mov    $0x6e,%esi
  808ca9:	48 bf 7a 13 82 00 00 	movabs $0x82137a,%rdi
  808cb0:	00 00 00 
  808cb3:	b8 00 00 00 00       	mov    $0x0,%eax
  808cb8:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  808cbf:	00 00 00 
  808cc2:	ff d1                	callq  *%rcx
             (buf->p->len >= size));
  buf->ptr = buf->p;
  808cc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808cc8:	48 8b 10             	mov    (%rax),%rdx
  808ccb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ccf:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return buf->p->payload;
  808cd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808cd7:	48 8b 00             	mov    (%rax),%rax
  808cda:	48 8b 40 08          	mov    0x8(%rax),%rax
}
  808cde:	c9                   	leaveq 
  808cdf:	c3                   	retq   

0000000000808ce0 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  808ce0:	55                   	push   %rbp
  808ce1:	48 89 e5             	mov    %rsp,%rbp
  808ce4:	48 83 ec 10          	sub    $0x10,%rsp
  808ce8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  808cec:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808cf1:	75 2a                	jne    808d1d <netbuf_free+0x3d>
  808cf3:	48 ba b4 13 82 00 00 	movabs $0x8213b4,%rdx
  808cfa:	00 00 00 
  808cfd:	be 7b 00 00 00       	mov    $0x7b,%esi
  808d02:	48 bf 7a 13 82 00 00 	movabs $0x82137a,%rdi
  808d09:	00 00 00 
  808d0c:	b8 00 00 00 00       	mov    $0x0,%eax
  808d11:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  808d18:	00 00 00 
  808d1b:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  808d1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d21:	48 8b 00             	mov    (%rax),%rax
  808d24:	48 85 c0             	test   %rax,%rax
  808d27:	74 16                	je     808d3f <netbuf_free+0x5f>
    pbuf_free(buf->p);
  808d29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d2d:	48 8b 00             	mov    (%rax),%rax
  808d30:	48 89 c7             	mov    %rax,%rdi
  808d33:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  808d3a:	00 00 00 
  808d3d:	ff d0                	callq  *%rax
  }
  buf->p = buf->ptr = NULL;
  808d3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d43:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808d4a:	00 
  808d4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d4f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808d53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d57:	48 89 10             	mov    %rdx,(%rax)
}
  808d5a:	c9                   	leaveq 
  808d5b:	c3                   	retq   

0000000000808d5c <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  808d5c:	55                   	push   %rbp
  808d5d:	48 89 e5             	mov    %rsp,%rbp
  808d60:	48 83 ec 20          	sub    $0x20,%rsp
  808d64:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808d68:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  808d6c:	89 d0                	mov    %edx,%eax
  808d6e:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  808d72:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808d77:	75 2a                	jne    808da3 <netbuf_ref+0x47>
  808d79:	48 ba cd 13 82 00 00 	movabs $0x8213cd,%rdx
  808d80:	00 00 00 
  808d83:	be 8e 00 00 00       	mov    $0x8e,%esi
  808d88:	48 bf 7a 13 82 00 00 	movabs $0x82137a,%rdi
  808d8f:	00 00 00 
  808d92:	b8 00 00 00 00       	mov    $0x0,%eax
  808d97:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  808d9e:	00 00 00 
  808da1:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  808da3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808da7:	48 8b 00             	mov    (%rax),%rax
  808daa:	48 85 c0             	test   %rax,%rax
  808dad:	74 16                	je     808dc5 <netbuf_ref+0x69>
    pbuf_free(buf->p);
  808daf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808db3:	48 8b 00             	mov    (%rax),%rax
  808db6:	48 89 c7             	mov    %rax,%rdi
  808db9:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  808dc0:	00 00 00 
  808dc3:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  808dc5:	ba 02 00 00 00       	mov    $0x2,%edx
  808dca:	be 00 00 00 00       	mov    $0x0,%esi
  808dcf:	bf 00 00 00 00       	mov    $0x0,%edi
  808dd4:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  808ddb:	00 00 00 
  808dde:	ff d0                	callq  *%rax
  808de0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808de4:	48 89 02             	mov    %rax,(%rdx)
  if (buf->p == NULL) {
  808de7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808deb:	48 8b 00             	mov    (%rax),%rax
  808dee:	48 85 c0             	test   %rax,%rax
  808df1:	75 13                	jne    808e06 <netbuf_ref+0xaa>
    buf->ptr = NULL;
  808df3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808df7:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808dfe:	00 
    return ERR_MEM;
  808dff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808e04:	eb 41                	jmp    808e47 <netbuf_ref+0xeb>
  }
  buf->p->payload = (void*)dataptr;
  808e06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e0a:	48 8b 00             	mov    (%rax),%rax
  808e0d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808e11:	48 89 50 08          	mov    %rdx,0x8(%rax)
  buf->p->len = buf->p->tot_len = size;
  808e15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e19:	48 8b 10             	mov    (%rax),%rdx
  808e1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e20:	48 8b 00             	mov    (%rax),%rax
  808e23:	0f b7 4d ec          	movzwl -0x14(%rbp),%ecx
  808e27:	66 89 48 10          	mov    %cx,0x10(%rax)
  808e2b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  808e2f:	66 89 42 12          	mov    %ax,0x12(%rdx)
  buf->ptr = buf->p;
  808e33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e37:	48 8b 10             	mov    (%rax),%rdx
  808e3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e3e:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return ERR_OK;
  808e42:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808e47:	c9                   	leaveq 
  808e48:	c3                   	retq   

0000000000808e49 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  808e49:	55                   	push   %rbp
  808e4a:	48 89 e5             	mov    %rsp,%rbp
  808e4d:	48 83 ec 10          	sub    $0x10,%rsp
  808e51:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808e55:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  808e59:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808e5e:	75 2a                	jne    808e8a <netbuf_chain+0x41>
  808e60:	48 ba e5 13 82 00 00 	movabs $0x8213e5,%rdx
  808e67:	00 00 00 
  808e6a:	be a6 00 00 00       	mov    $0xa6,%esi
  808e6f:	48 bf 7a 13 82 00 00 	movabs $0x82137a,%rdi
  808e76:	00 00 00 
  808e79:	b8 00 00 00 00       	mov    $0x0,%eax
  808e7e:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  808e85:	00 00 00 
  808e88:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  808e8a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  808e8f:	75 2a                	jne    808ebb <netbuf_chain+0x72>
  808e91:	48 ba fe 13 82 00 00 	movabs $0x8213fe,%rdx
  808e98:	00 00 00 
  808e9b:	be a7 00 00 00       	mov    $0xa7,%esi
  808ea0:	48 bf 7a 13 82 00 00 	movabs $0x82137a,%rdi
  808ea7:	00 00 00 
  808eaa:	b8 00 00 00 00       	mov    $0x0,%eax
  808eaf:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  808eb6:	00 00 00 
  808eb9:	ff d1                	callq  *%rcx
  pbuf_chain(head->p, tail->p);
  808ebb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808ebf:	48 8b 10             	mov    (%rax),%rdx
  808ec2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ec6:	48 8b 00             	mov    (%rax),%rax
  808ec9:	48 89 d6             	mov    %rdx,%rsi
  808ecc:	48 89 c7             	mov    %rax,%rdi
  808ecf:	48 b8 39 dd 80 00 00 	movabs $0x80dd39,%rax
  808ed6:	00 00 00 
  808ed9:	ff d0                	callq  *%rax
  head->ptr = head->p;
  808edb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808edf:	48 8b 10             	mov    (%rax),%rdx
  808ee2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ee6:	48 89 50 08          	mov    %rdx,0x8(%rax)
  memp_free(MEMP_NETBUF, tail);
  808eea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808eee:	48 89 c6             	mov    %rax,%rsi
  808ef1:	bf 06 00 00 00       	mov    $0x6,%edi
  808ef6:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  808efd:	00 00 00 
  808f00:	ff d0                	callq  *%rax
}
  808f02:	c9                   	leaveq 
  808f03:	c3                   	retq   

0000000000808f04 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  808f04:	55                   	push   %rbp
  808f05:	48 89 e5             	mov    %rsp,%rbp
  808f08:	48 83 ec 20          	sub    $0x20,%rsp
  808f0c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808f10:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  808f14:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  808f18:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808f1d:	75 2a                	jne    808f49 <netbuf_data+0x45>
  808f1f:	48 ba 19 14 82 00 00 	movabs $0x821419,%rdx
  808f26:	00 00 00 
  808f29:	be b9 00 00 00       	mov    $0xb9,%esi
  808f2e:	48 bf 7a 13 82 00 00 	movabs $0x82137a,%rdi
  808f35:	00 00 00 
  808f38:	b8 00 00 00 00       	mov    $0x0,%eax
  808f3d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  808f44:	00 00 00 
  808f47:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  808f49:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  808f4e:	75 2a                	jne    808f7a <netbuf_data+0x76>
  808f50:	48 ba 32 14 82 00 00 	movabs $0x821432,%rdx
  808f57:	00 00 00 
  808f5a:	be ba 00 00 00       	mov    $0xba,%esi
  808f5f:	48 bf 7a 13 82 00 00 	movabs $0x82137a,%rdi
  808f66:	00 00 00 
  808f69:	b8 00 00 00 00       	mov    $0x0,%eax
  808f6e:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  808f75:	00 00 00 
  808f78:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  808f7a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  808f7f:	75 2a                	jne    808fab <netbuf_data+0xa7>
  808f81:	48 ba 4f 14 82 00 00 	movabs $0x82144f,%rdx
  808f88:	00 00 00 
  808f8b:	be bb 00 00 00       	mov    $0xbb,%esi
  808f90:	48 bf 7a 13 82 00 00 	movabs $0x82137a,%rdi
  808f97:	00 00 00 
  808f9a:	b8 00 00 00 00       	mov    $0x0,%eax
  808f9f:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  808fa6:	00 00 00 
  808fa9:	ff d1                	callq  *%rcx

  if (buf->ptr == NULL) {
  808fab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808faf:	48 8b 40 08          	mov    0x8(%rax),%rax
  808fb3:	48 85 c0             	test   %rax,%rax
  808fb6:	75 07                	jne    808fbf <netbuf_data+0xbb>
    return ERR_BUF;
  808fb8:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808fbd:	eb 2b                	jmp    808fea <netbuf_data+0xe6>
  }
  *dataptr = buf->ptr->payload;
  808fbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fc3:	48 8b 40 08          	mov    0x8(%rax),%rax
  808fc7:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808fcb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808fcf:	48 89 10             	mov    %rdx,(%rax)
  *len = buf->ptr->len;
  808fd2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fd6:	48 8b 40 08          	mov    0x8(%rax),%rax
  808fda:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  808fde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808fe2:	66 89 10             	mov    %dx,(%rax)
  return ERR_OK;
  808fe5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808fea:	c9                   	leaveq 
  808feb:	c3                   	retq   

0000000000808fec <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  808fec:	55                   	push   %rbp
  808fed:	48 89 e5             	mov    %rsp,%rbp
  808ff0:	48 83 ec 10          	sub    $0x10,%rsp
  808ff4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  808ff8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808ffd:	75 2a                	jne    809029 <netbuf_next+0x3d>
  808fff:	48 ba b4 13 82 00 00 	movabs $0x8213b4,%rdx
  809006:	00 00 00 
  809009:	be d2 00 00 00       	mov    $0xd2,%esi
  80900e:	48 bf 7a 13 82 00 00 	movabs $0x82137a,%rdi
  809015:	00 00 00 
  809018:	b8 00 00 00 00       	mov    $0x0,%eax
  80901d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  809024:	00 00 00 
  809027:	ff d1                	callq  *%rcx
  if (buf->ptr->next == NULL) {
  809029:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80902d:	48 8b 40 08          	mov    0x8(%rax),%rax
  809031:	48 8b 00             	mov    (%rax),%rax
  809034:	48 85 c0             	test   %rax,%rax
  809037:	75 07                	jne    809040 <netbuf_next+0x54>
    return -1;
  809039:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80903e:	eb 2f                	jmp    80906f <netbuf_next+0x83>
  }
  buf->ptr = buf->ptr->next;
  809040:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809044:	48 8b 40 08          	mov    0x8(%rax),%rax
  809048:	48 8b 10             	mov    (%rax),%rdx
  80904b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80904f:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (buf->ptr->next == NULL) {
  809053:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809057:	48 8b 40 08          	mov    0x8(%rax),%rax
  80905b:	48 8b 00             	mov    (%rax),%rax
  80905e:	48 85 c0             	test   %rax,%rax
  809061:	75 07                	jne    80906a <netbuf_next+0x7e>
    return 1;
  809063:	b8 01 00 00 00       	mov    $0x1,%eax
  809068:	eb 05                	jmp    80906f <netbuf_next+0x83>
  }
  return 0;
  80906a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80906f:	c9                   	leaveq 
  809070:	c3                   	retq   

0000000000809071 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  809071:	55                   	push   %rbp
  809072:	48 89 e5             	mov    %rsp,%rbp
  809075:	48 83 ec 10          	sub    $0x10,%rsp
  809079:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80907d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809082:	75 2a                	jne    8090ae <netbuf_first+0x3d>
  809084:	48 ba b4 13 82 00 00 	movabs $0x8213b4,%rdx
  80908b:	00 00 00 
  80908e:	be e7 00 00 00       	mov    $0xe7,%esi
  809093:	48 bf 7a 13 82 00 00 	movabs $0x82137a,%rdi
  80909a:	00 00 00 
  80909d:	b8 00 00 00 00       	mov    $0x0,%eax
  8090a2:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8090a9:	00 00 00 
  8090ac:	ff d1                	callq  *%rcx
  buf->ptr = buf->p;
  8090ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090b2:	48 8b 10             	mov    (%rax),%rdx
  8090b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090b9:	48 89 50 08          	mov    %rdx,0x8(%rax)
}
  8090bd:	c9                   	leaveq 
  8090be:	c3                   	retq   

00000000008090bf <lwip_sanity_check>:
#endif

#ifdef LWIP_DEBUG
static void
lwip_sanity_check(void)
{
  8090bf:	55                   	push   %rbp
  8090c0:	48 89 e5             	mov    %rsp,%rbp
  if (TCP_WND > (PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is larger than space provided by PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE\n"));
  if (TCP_WND < TCP_MSS)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is smaller than MSS\n"));
#endif /* LWIP_TCP */
}
  8090c3:	5d                   	pop    %rbp
  8090c4:	c3                   	retq   

00000000008090c5 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8090c5:	55                   	push   %rbp
  8090c6:	48 89 e5             	mov    %rsp,%rbp
  /* Sanity check user-configurable values */
  lwip_sanity_check();
  8090c9:	48 b8 bf 90 80 00 00 	movabs $0x8090bf,%rax
  8090d0:	00 00 00 
  8090d3:	ff d0                	callq  *%rax

  /* Modules initialization */
  stats_init();
  sys_init();
  8090d5:	48 b8 14 71 81 00 00 	movabs $0x817114,%rax
  8090dc:	00 00 00 
  8090df:	ff d0                	callq  *%rax
  mem_init();
  8090e1:	48 b8 df c0 80 00 00 	movabs $0x80c0df,%rax
  8090e8:	00 00 00 
  8090eb:	ff d0                	callq  *%rax
  memp_init();
  8090ed:	48 b8 42 ca 80 00 00 	movabs $0x80ca42,%rax
  8090f4:	00 00 00 
  8090f7:	ff d0                	callq  *%rax
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  8090f9:	48 b8 f7 59 80 00 00 	movabs $0x8059f7,%rax
  809100:	00 00 00 
  809103:	ff d0                	callq  *%rax
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  809105:	5d                   	pop    %rbp
  809106:	c3                   	retq   

0000000000809107 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  809107:	55                   	push   %rbp
  809108:	48 89 e5             	mov    %rsp,%rbp
  80910b:	48 83 ec 20          	sub    $0x20,%rsp
  80910f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809113:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809117:	48 8b 40 38          	mov    0x38(%rax),%rax
  80911b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  80911f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809123:	48 89 c7             	mov    %rax,%rdi
  809126:	48 b8 db d0 80 00 00 	movabs $0x80d0db,%rax
  80912d:	00 00 00 
  809130:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  809132:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809136:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  80913d:	00 00 00 
  809140:	48 89 c7             	mov    %rax,%rdi
  809143:	48 b8 f3 ce 80 00 00 	movabs $0x80cef3,%rax
  80914a:	00 00 00 
  80914d:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  80914f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809153:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  80915a:	00 00 00 
  80915d:	48 89 c7             	mov    %rax,%rdi
  809160:	48 b8 f9 cf 80 00 00 	movabs $0x80cff9,%rax
  809167:	00 00 00 
  80916a:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY); 
  80916c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809170:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  809177:	00 00 00 
  80917a:	48 89 c7             	mov    %rax,%rdi
  80917d:	48 b8 26 d0 80 00 00 	movabs $0x80d026,%rax
  809184:	00 00 00 
  809187:	ff d0                	callq  *%rax
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  809189:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80918d:	be 0c 00 00 00       	mov    $0xc,%esi
  809192:	48 89 c7             	mov    %rax,%rdi
  809195:	48 b8 9e ae 80 00 00 	movabs $0x80ae9e,%rax
  80919c:	00 00 00 
  80919f:	ff d0                	callq  *%rax
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  8091a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8091a5:	48 89 c7             	mov    %rax,%rdi
  8091a8:	48 b8 b5 a2 80 00 00 	movabs $0x80a2b5,%rax
  8091af:	00 00 00 
  8091b2:	ff d0                	callq  *%rax
}
  8091b4:	c9                   	leaveq 
  8091b5:	c3                   	retq   

00000000008091b6 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8091b6:	55                   	push   %rbp
  8091b7:	48 89 e5             	mov    %rsp,%rbp
  8091ba:	48 83 ec 20          	sub    $0x20,%rsp
  8091be:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8091c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8091c6:	48 8b 40 38          	mov    0x38(%rax),%rax
  8091ca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8091ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091d2:	48 8d 48 4c          	lea    0x4c(%rax),%rcx
  8091d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8091da:	ba 00 00 00 00       	mov    $0x0,%edx
  8091df:	48 89 ce             	mov    %rcx,%rsi
  8091e2:	48 89 c7             	mov    %rax,%rdi
  8091e5:	48 b8 b6 68 81 00 00 	movabs $0x8168b6,%rax
  8091ec:	00 00 00 
  8091ef:	ff d0                	callq  *%rax
  8091f1:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  8091f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091f8:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8091fc:	8d 50 01             	lea    0x1(%rax),%edx
  8091ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809203:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 500;
  809206:	66 c7 45 f4 f4 01    	movw   $0x1f4,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80920c:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  809210:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  809216:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80921b:	89 c8                	mov    %ecx,%eax
  80921d:	f7 ea                	imul   %edx
  80921f:	c1 fa 05             	sar    $0x5,%edx
  809222:	89 c8                	mov    %ecx,%eax
  809224:	c1 f8 1f             	sar    $0x1f,%eax
  809227:	29 c2                	sub    %eax,%edx
  809229:	89 d0                	mov    %edx,%eax
  80922b:	89 c2                	mov    %eax,%edx
  80922d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809231:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  809235:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809239:	be 08 00 00 00       	mov    $0x8,%esi
  80923e:	48 89 c7             	mov    %rax,%rdi
  809241:	48 b8 9e ae 80 00 00 	movabs $0x80ae9e,%rax
  809248:	00 00 00 
  80924b:	ff d0                	callq  *%rax
}
  80924d:	c9                   	leaveq 
  80924e:	c3                   	retq   

000000000080924f <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  80924f:	55                   	push   %rbp
  809250:	48 89 e5             	mov    %rsp,%rbp
  809253:	48 83 ec 20          	sub    $0x20,%rsp
  809257:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80925b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80925f:	48 8b 40 38          	mov    0x38(%rax),%rax
  809263:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  809267:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80926b:	be 36 00 00 00       	mov    $0x36,%esi
  809270:	48 89 c7             	mov    %rax,%rdi
  809273:	48 b8 65 bc 80 00 00 	movabs $0x80bc65,%rax
  80927a:	00 00 00 
  80927d:	ff d0                	callq  *%rax
  80927f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  809283:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  809288:	74 69                	je     8092f3 <dhcp_handle_offer+0xa4>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80928a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80928e:	48 83 c0 02          	add    $0x2,%rax
  809292:	48 89 c7             	mov    %rax,%rdi
  809295:	48 b8 3c be 80 00 00 	movabs $0x80be3c,%rax
  80929c:	00 00 00 
  80929f:	ff d0                	callq  *%rax
  8092a1:	89 c7                	mov    %eax,%edi
  8092a3:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  8092aa:	00 00 00 
  8092ad:	ff d0                	callq  *%rax
  8092af:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8092b3:	89 42 48             	mov    %eax,0x48(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8092b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092ba:	48 8b 40 18          	mov    0x18(%rax),%rax
  8092be:	48 83 c0 10          	add    $0x10,%rax
  8092c2:	48 85 c0             	test   %rax,%rax
  8092c5:	74 0d                	je     8092d4 <dhcp_handle_offer+0x85>
  8092c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092cb:	48 8b 40 18          	mov    0x18(%rax),%rax
  8092cf:	8b 40 10             	mov    0x10(%rax),%eax
  8092d2:	eb 05                	jmp    8092d9 <dhcp_handle_offer+0x8a>
  8092d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8092d9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8092dd:	89 42 4c             	mov    %eax,0x4c(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  8092e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8092e4:	48 89 c7             	mov    %rax,%rdi
  8092e7:	48 b8 f5 92 80 00 00 	movabs $0x8092f5,%rax
  8092ee:	00 00 00 
  8092f1:	ff d0                	callq  *%rax
  }
}
  8092f3:	c9                   	leaveq 
  8092f4:	c3                   	retq   

00000000008092f5 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  8092f5:	55                   	push   %rbp
  8092f6:	48 89 e5             	mov    %rsp,%rbp
  8092f9:	48 83 ec 20          	sub    $0x20,%rsp
  8092fd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809301:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809305:	48 8b 40 38          	mov    0x38(%rax),%rax
  809309:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80930d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809311:	48 89 c7             	mov    %rax,%rdi
  809314:	48 b8 92 b6 80 00 00 	movabs $0x80b692,%rax
  80931b:	00 00 00 
  80931e:	ff d0                	callq  *%rax
  809320:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  809323:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809327:	0f 85 3a 02 00 00    	jne    809567 <dhcp_select+0x272>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80932d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809331:	ba 01 00 00 00       	mov    $0x1,%edx
  809336:	be 35 00 00 00       	mov    $0x35,%esi
  80933b:	48 89 c7             	mov    %rax,%rdi
  80933e:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  809345:	00 00 00 
  809348:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80934a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80934e:	be 03 00 00 00       	mov    $0x3,%esi
  809353:	48 89 c7             	mov    %rax,%rdi
  809356:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  80935d:	00 00 00 
  809360:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  809362:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809366:	ba 02 00 00 00       	mov    $0x2,%edx
  80936b:	be 39 00 00 00       	mov    $0x39,%esi
  809370:	48 89 c7             	mov    %rax,%rdi
  809373:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  80937a:	00 00 00 
  80937d:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80937f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809383:	be 40 02 00 00       	mov    $0x240,%esi
  809388:	48 89 c7             	mov    %rax,%rdi
  80938b:	48 b8 f6 af 80 00 00 	movabs $0x80aff6,%rax
  809392:	00 00 00 
  809395:	ff d0                	callq  *%rax

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  809397:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80939b:	ba 04 00 00 00       	mov    $0x4,%edx
  8093a0:	be 32 00 00 00       	mov    $0x32,%esi
  8093a5:	48 89 c7             	mov    %rax,%rdi
  8093a8:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  8093af:	00 00 00 
  8093b2:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8093b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093b8:	8b 40 4c             	mov    0x4c(%rax),%eax
  8093bb:	89 c7                	mov    %eax,%edi
  8093bd:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  8093c4:	00 00 00 
  8093c7:	ff d0                	callq  *%rax
  8093c9:	89 c2                	mov    %eax,%edx
  8093cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093cf:	89 d6                	mov    %edx,%esi
  8093d1:	48 89 c7             	mov    %rax,%rdi
  8093d4:	48 b8 a1 b0 80 00 00 	movabs $0x80b0a1,%rax
  8093db:	00 00 00 
  8093de:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8093e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093e4:	ba 04 00 00 00       	mov    $0x4,%edx
  8093e9:	be 36 00 00 00       	mov    $0x36,%esi
  8093ee:	48 89 c7             	mov    %rax,%rdi
  8093f1:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  8093f8:	00 00 00 
  8093fb:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8093fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809401:	8b 40 48             	mov    0x48(%rax),%eax
  809404:	89 c7                	mov    %eax,%edi
  809406:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  80940d:	00 00 00 
  809410:	ff d0                	callq  *%rax
  809412:	89 c2                	mov    %eax,%edx
  809414:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809418:	89 d6                	mov    %edx,%esi
  80941a:	48 89 c7             	mov    %rax,%rdi
  80941d:	48 b8 a1 b0 80 00 00 	movabs $0x80b0a1,%rax
  809424:	00 00 00 
  809427:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  809429:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80942d:	ba 04 00 00 00       	mov    $0x4,%edx
  809432:	be 37 00 00 00       	mov    $0x37,%esi
  809437:	48 89 c7             	mov    %rax,%rdi
  80943a:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  809441:	00 00 00 
  809444:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  809446:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80944a:	be 01 00 00 00       	mov    $0x1,%esi
  80944f:	48 89 c7             	mov    %rax,%rdi
  809452:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  809459:	00 00 00 
  80945c:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80945e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809462:	be 03 00 00 00       	mov    $0x3,%esi
  809467:	48 89 c7             	mov    %rax,%rdi
  80946a:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  809471:	00 00 00 
  809474:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  809476:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80947a:	be 1c 00 00 00       	mov    $0x1c,%esi
  80947f:	48 89 c7             	mov    %rax,%rdi
  809482:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  809489:	00 00 00 
  80948c:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80948e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809492:	be 06 00 00 00       	mov    $0x6,%esi
  809497:	48 89 c7             	mov    %rax,%rdi
  80949a:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  8094a1:	00 00 00 
  8094a4:	ff d0                	callq  *%rax
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  8094a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094aa:	48 89 c7             	mov    %rax,%rdi
  8094ad:	48 b8 0d bb 80 00 00 	movabs $0x80bb0d,%rax
  8094b4:	00 00 00 
  8094b7:	ff d0                	callq  *%rax
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8094b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094bd:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  8094c1:	66 05 f0 00          	add    $0xf0,%ax
  8094c5:	0f b7 d0             	movzwl %ax,%edx
  8094c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094cc:	48 8b 40 30          	mov    0x30(%rax),%rax
  8094d0:	89 d6                	mov    %edx,%esi
  8094d2:	48 89 c7             	mov    %rax,%rdi
  8094d5:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  8094dc:	00 00 00 
  8094df:	ff d0                	callq  *%rax

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8094e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094e5:	48 8b 70 30          	mov    0x30(%rax),%rsi
  8094e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094ed:	48 8b 40 08          	mov    0x8(%rax),%rax
  8094f1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8094f5:	49 89 d0             	mov    %rdx,%r8
  8094f8:	b9 43 00 00 00       	mov    $0x43,%ecx
  8094fd:	48 ba 6c 22 82 00 00 	movabs $0x82226c,%rdx
  809504:	00 00 00 
  809507:	48 89 c7             	mov    %rax,%rdi
  80950a:	48 b8 08 50 81 00 00 	movabs $0x815008,%rax
  809511:	00 00 00 
  809514:	ff d0                	callq  *%rax
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809516:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80951a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80951e:	ba 43 00 00 00       	mov    $0x43,%edx
  809523:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  80952a:	00 00 00 
  80952d:	48 89 c7             	mov    %rax,%rdi
  809530:	48 b8 05 54 81 00 00 	movabs $0x815405,%rax
  809537:	00 00 00 
  80953a:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80953c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809540:	48 89 c7             	mov    %rax,%rdi
  809543:	48 b8 e7 b9 80 00 00 	movabs $0x80b9e7,%rax
  80954a:	00 00 00 
  80954d:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  80954f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809553:	be 01 00 00 00       	mov    $0x1,%esi
  809558:	48 89 c7             	mov    %rax,%rdi
  80955b:	48 b8 9e ae 80 00 00 	movabs $0x80ae9e,%rax
  809562:	00 00 00 
  809565:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  809567:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80956b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80956f:	8d 50 01             	lea    0x1(%rax),%edx
  809572:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809576:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  809579:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80957d:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809581:	3c 03                	cmp    $0x3,%al
  809583:	77 12                	ja     809597 <dhcp_select+0x2a2>
  809585:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809589:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80958d:	0f b6 c0             	movzbl %al,%eax
  809590:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  809595:	eb 05                	jmp    80959c <dhcp_select+0x2a7>
  809597:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  80959c:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8095a0:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  8095a4:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  8095aa:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8095af:	89 c8                	mov    %ecx,%eax
  8095b1:	f7 ea                	imul   %edx
  8095b3:	c1 fa 05             	sar    $0x5,%edx
  8095b6:	89 c8                	mov    %ecx,%eax
  8095b8:	c1 f8 1f             	sar    $0x1f,%eax
  8095bb:	29 c2                	sub    %eax,%edx
  8095bd:	89 d0                	mov    %edx,%eax
  8095bf:	89 c2                	mov    %eax,%edx
  8095c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095c5:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  8095c9:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  8095cd:	c9                   	leaveq 
  8095ce:	c3                   	retq   

00000000008095cf <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  8095cf:	55                   	push   %rbp
  8095d0:	48 89 e5             	mov    %rsp,%rbp
  8095d3:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  8095d7:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  8095de:	00 00 00 
  8095e1:	48 8b 00             	mov    (%rax),%rax
  8095e4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  8095e8:	eb 72                	jmp    80965c <dhcp_coarse_tmr+0x8d>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8095ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095ee:	48 8b 40 38          	mov    0x38(%rax),%rax
  8095f2:	48 85 c0             	test   %rax,%rax
  8095f5:	74 5a                	je     809651 <dhcp_coarse_tmr+0x82>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  8095f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095fb:	48 8b 40 38          	mov    0x38(%rax),%rax
  8095ff:	0f b7 50 46          	movzwl 0x46(%rax),%edx
  809603:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  809606:	66 89 48 46          	mov    %cx,0x46(%rax)
  80960a:	66 83 fa 01          	cmp    $0x1,%dx
  80960e:	75 15                	jne    809625 <dhcp_coarse_tmr+0x56>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
  809610:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809614:	48 89 c7             	mov    %rax,%rdi
  809617:	48 b8 a6 98 80 00 00 	movabs $0x8098a6,%rax
  80961e:	00 00 00 
  809621:	ff d0                	callq  *%rax
  809623:	eb 2c                	jmp    809651 <dhcp_coarse_tmr+0x82>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  809625:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809629:	48 8b 40 38          	mov    0x38(%rax),%rax
  80962d:	0f b7 50 44          	movzwl 0x44(%rax),%edx
  809631:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  809634:	66 89 48 44          	mov    %cx,0x44(%rax)
  809638:	66 83 fa 01          	cmp    $0x1,%dx
  80963c:	75 13                	jne    809651 <dhcp_coarse_tmr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
  80963e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809642:	48 89 c7             	mov    %rax,%rdi
  809645:	48 b8 58 98 80 00 00 	movabs $0x809858,%rax
  80964c:	00 00 00 
  80964f:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  809651:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809655:	48 8b 00             	mov    (%rax),%rax
  809658:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  80965c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809661:	75 87                	jne    8095ea <dhcp_coarse_tmr+0x1b>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  809663:	c9                   	leaveq 
  809664:	c3                   	retq   

0000000000809665 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  809665:	55                   	push   %rbp
  809666:	48 89 e5             	mov    %rsp,%rbp
  809669:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  80966d:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  809674:	00 00 00 
  809677:	48 8b 00             	mov    (%rax),%rax
  80967a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through netif's */
  while (netif != NULL) {
  80967e:	eb 77                	jmp    8096f7 <dhcp_fine_tmr+0x92>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  809680:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809684:	48 8b 40 38          	mov    0x38(%rax),%rax
  809688:	48 85 c0             	test   %rax,%rax
  80968b:	74 5f                	je     8096ec <dhcp_fine_tmr+0x87>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  80968d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809691:	48 8b 40 38          	mov    0x38(%rax),%rax
  809695:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  809699:	66 83 f8 01          	cmp    $0x1,%ax
  80969d:	76 15                	jbe    8096b4 <dhcp_fine_tmr+0x4f>
        netif->dhcp->request_timeout--;
  80969f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096a3:	48 8b 40 38          	mov    0x38(%rax),%rax
  8096a7:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  8096ab:	83 ea 01             	sub    $0x1,%edx
  8096ae:	66 89 50 42          	mov    %dx,0x42(%rax)
  8096b2:	eb 38                	jmp    8096ec <dhcp_fine_tmr+0x87>
      }
      else if (netif->dhcp->request_timeout == 1) {
  8096b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096b8:	48 8b 40 38          	mov    0x38(%rax),%rax
  8096bc:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  8096c0:	66 83 f8 01          	cmp    $0x1,%ax
  8096c4:	75 26                	jne    8096ec <dhcp_fine_tmr+0x87>
        netif->dhcp->request_timeout--;
  8096c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096ca:	48 8b 40 38          	mov    0x38(%rax),%rax
  8096ce:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  8096d2:	83 ea 01             	sub    $0x1,%edx
  8096d5:	66 89 50 42          	mov    %dx,0x42(%rax)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
  8096d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096dd:	48 89 c7             	mov    %rax,%rdi
  8096e0:	48 b8 00 97 80 00 00 	movabs $0x809700,%rax
  8096e7:	00 00 00 
  8096ea:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  8096ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096f0:	48 8b 00             	mov    (%rax),%rax
  8096f3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  8096f7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8096fc:	75 82                	jne    809680 <dhcp_fine_tmr+0x1b>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  8096fe:	c9                   	leaveq 
  8096ff:	c3                   	retq   

0000000000809700 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  809700:	55                   	push   %rbp
  809701:	48 89 e5             	mov    %rsp,%rbp
  809704:	48 83 ec 20          	sub    $0x20,%rsp
  809708:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80970c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809710:	48 8b 40 38          	mov    0x38(%rax),%rax
  809714:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  809718:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80971c:	0f b6 00             	movzbl (%rax),%eax
  80971f:	3c 0c                	cmp    $0xc,%al
  809721:	74 0b                	je     80972e <dhcp_timeout+0x2e>
  809723:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809727:	0f b6 00             	movzbl (%rax),%eax
  80972a:	3c 06                	cmp    $0x6,%al
  80972c:	75 18                	jne    809746 <dhcp_timeout+0x46>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  80972e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809732:	48 89 c7             	mov    %rax,%rdi
  809735:	48 b8 b5 a2 80 00 00 	movabs $0x80a2b5,%rax
  80973c:	00 00 00 
  80973f:	ff d0                	callq  *%rax
  809741:	e9 10 01 00 00       	jmpq   809856 <dhcp_timeout+0x156>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  809746:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80974a:	0f b6 00             	movzbl (%rax),%eax
  80974d:	3c 01                	cmp    $0x1,%al
  80974f:	75 4f                	jne    8097a0 <dhcp_timeout+0xa0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  809751:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809755:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809759:	3c 05                	cmp    $0x5,%al
  80975b:	77 18                	ja     809775 <dhcp_timeout+0x75>
      dhcp_select(netif);
  80975d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809761:	48 89 c7             	mov    %rax,%rdi
  809764:	48 b8 f5 92 80 00 00 	movabs $0x8092f5,%rax
  80976b:	00 00 00 
  80976e:	ff d0                	callq  *%rax
  809770:	e9 e1 00 00 00       	jmpq   809856 <dhcp_timeout+0x156>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  809775:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809779:	48 89 c7             	mov    %rax,%rdi
  80977c:	48 b8 34 ab 80 00 00 	movabs $0x80ab34,%rax
  809783:	00 00 00 
  809786:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  809788:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80978c:	48 89 c7             	mov    %rax,%rdi
  80978f:	48 b8 b5 a2 80 00 00 	movabs $0x80a2b5,%rax
  809796:	00 00 00 
  809799:	ff d0                	callq  *%rax
  80979b:	e9 b6 00 00 00       	jmpq   809856 <dhcp_timeout+0x156>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  8097a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097a4:	0f b6 00             	movzbl (%rax),%eax
  8097a7:	3c 08                	cmp    $0x8,%al
  8097a9:	75 39                	jne    8097e4 <dhcp_timeout+0xe4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  8097ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097af:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8097b3:	3c 01                	cmp    $0x1,%al
  8097b5:	77 18                	ja     8097cf <dhcp_timeout+0xcf>
      dhcp_check(netif);
  8097b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8097bb:	48 89 c7             	mov    %rax,%rdi
  8097be:	48 b8 b6 91 80 00 00 	movabs $0x8091b6,%rax
  8097c5:	00 00 00 
  8097c8:	ff d0                	callq  *%rax
  8097ca:	e9 87 00 00 00       	jmpq   809856 <dhcp_timeout+0x156>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  8097cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8097d3:	48 89 c7             	mov    %rax,%rdi
  8097d6:	48 b8 17 a5 80 00 00 	movabs $0x80a517,%rax
  8097dd:	00 00 00 
  8097e0:	ff d0                	callq  *%rax
  8097e2:	eb 72                	jmp    809856 <dhcp_timeout+0x156>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  8097e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097e8:	0f b6 00             	movzbl (%rax),%eax
  8097eb:	3c 05                	cmp    $0x5,%al
  8097ed:	75 15                	jne    809804 <dhcp_timeout+0x104>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  8097ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8097f3:	48 89 c7             	mov    %rax,%rdi
  8097f6:	48 b8 9f a7 80 00 00 	movabs $0x80a79f,%rax
  8097fd:	00 00 00 
  809800:	ff d0                	callq  *%rax
  809802:	eb 52                	jmp    809856 <dhcp_timeout+0x156>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  809804:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809808:	0f b6 00             	movzbl (%rax),%eax
  80980b:	3c 04                	cmp    $0x4,%al
  80980d:	75 47                	jne    809856 <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  80980f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809813:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809817:	3c 08                	cmp    $0x8,%al
  809819:	77 15                	ja     809830 <dhcp_timeout+0x130>
      dhcp_rebind(netif);
  80981b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80981f:	48 89 c7             	mov    %rax,%rdi
  809822:	48 b8 69 a9 80 00 00 	movabs $0x80a969,%rax
  809829:	00 00 00 
  80982c:	ff d0                	callq  *%rax
  80982e:	eb 26                	jmp    809856 <dhcp_timeout+0x156>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  809830:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809834:	48 89 c7             	mov    %rax,%rdi
  809837:	48 b8 34 ab 80 00 00 	movabs $0x80ab34,%rax
  80983e:	00 00 00 
  809841:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  809843:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809847:	48 89 c7             	mov    %rax,%rdi
  80984a:	48 b8 b5 a2 80 00 00 	movabs $0x80a2b5,%rax
  809851:	00 00 00 
  809854:	ff d0                	callq  *%rax
    }
  }
}
  809856:	c9                   	leaveq 
  809857:	c3                   	retq   

0000000000809858 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
  809858:	55                   	push   %rbp
  809859:	48 89 e5             	mov    %rsp,%rbp
  80985c:	48 83 ec 20          	sub    $0x20,%rsp
  809860:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809864:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809868:	48 8b 40 38          	mov    0x38(%rax),%rax
  80986c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  809870:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809874:	0f b6 00             	movzbl (%rax),%eax
  809877:	3c 01                	cmp    $0x1,%al
  809879:	74 16                	je     809891 <dhcp_t1_timeout+0x39>
  80987b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80987f:	0f b6 00             	movzbl (%rax),%eax
  809882:	3c 0a                	cmp    $0xa,%al
  809884:	74 0b                	je     809891 <dhcp_t1_timeout+0x39>
  809886:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80988a:	0f b6 00             	movzbl (%rax),%eax
  80988d:	3c 05                	cmp    $0x5,%al
  80988f:	75 13                	jne    8098a4 <dhcp_t1_timeout+0x4c>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  809891:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809895:	48 89 c7             	mov    %rax,%rdi
  809898:	48 b8 9f a7 80 00 00 	movabs $0x80a79f,%rax
  80989f:	00 00 00 
  8098a2:	ff d0                	callq  *%rax
  }
}
  8098a4:	c9                   	leaveq 
  8098a5:	c3                   	retq   

00000000008098a6 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
  8098a6:	55                   	push   %rbp
  8098a7:	48 89 e5             	mov    %rsp,%rbp
  8098aa:	48 83 ec 20          	sub    $0x20,%rsp
  8098ae:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8098b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8098b6:	48 8b 40 38          	mov    0x38(%rax),%rax
  8098ba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  8098be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098c2:	0f b6 00             	movzbl (%rax),%eax
  8098c5:	3c 01                	cmp    $0x1,%al
  8098c7:	74 16                	je     8098df <dhcp_t2_timeout+0x39>
  8098c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098cd:	0f b6 00             	movzbl (%rax),%eax
  8098d0:	3c 0a                	cmp    $0xa,%al
  8098d2:	74 0b                	je     8098df <dhcp_t2_timeout+0x39>
  8098d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098d8:	0f b6 00             	movzbl (%rax),%eax
  8098db:	3c 05                	cmp    $0x5,%al
  8098dd:	75 13                	jne    8098f2 <dhcp_t2_timeout+0x4c>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  8098df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8098e3:	48 89 c7             	mov    %rax,%rdi
  8098e6:	48 b8 69 a9 80 00 00 	movabs $0x80a969,%rax
  8098ed:	00 00 00 
  8098f0:	ff d0                	callq  *%rax
  }
}
  8098f2:	c9                   	leaveq 
  8098f3:	c3                   	retq   

00000000008098f4 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  8098f4:	55                   	push   %rbp
  8098f5:	48 89 e5             	mov    %rsp,%rbp
  8098f8:	53                   	push   %rbx
  8098f9:	48 83 ec 38          	sub    $0x38,%rsp
  8098fd:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809901:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  809905:	48 8b 40 38          	mov    0x38(%rax),%rax
  809909:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  80990d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809911:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  dhcp->offered_gw_addr.addr = 0;
  809918:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80991c:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%rax)
  dhcp->offered_bc_addr.addr = 0;
  809923:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809927:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  80992e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809932:	be 33 00 00 00       	mov    $0x33,%esi
  809937:	48 89 c7             	mov    %rax,%rdi
  80993a:	48 b8 65 bc 80 00 00 	movabs $0x80bc65,%rax
  809941:	00 00 00 
  809944:	ff d0                	callq  *%rax
  809946:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  80994a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80994f:	74 1e                	je     80996f <dhcp_handle_ack+0x7b>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  809951:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809955:	48 83 c0 02          	add    $0x2,%rax
  809959:	48 89 c7             	mov    %rax,%rdi
  80995c:	48 b8 3c be 80 00 00 	movabs $0x80be3c,%rax
  809963:	00 00 00 
  809966:	ff d0                	callq  *%rax
  809968:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80996c:	89 42 68             	mov    %eax,0x68(%rdx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  80996f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809973:	be 3a 00 00 00       	mov    $0x3a,%esi
  809978:	48 89 c7             	mov    %rax,%rdi
  80997b:	48 b8 65 bc 80 00 00 	movabs $0x80bc65,%rax
  809982:	00 00 00 
  809985:	ff d0                	callq  *%rax
  809987:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  80998b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809990:	74 20                	je     8099b2 <dhcp_handle_ack+0xbe>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  809992:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809996:	48 83 c0 02          	add    $0x2,%rax
  80999a:	48 89 c7             	mov    %rax,%rdi
  80999d:	48 b8 3c be 80 00 00 	movabs $0x80be3c,%rax
  8099a4:	00 00 00 
  8099a7:	ff d0                	callq  *%rax
  8099a9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8099ad:	89 42 6c             	mov    %eax,0x6c(%rdx)
  8099b0:	eb 12                	jmp    8099c4 <dhcp_handle_ack+0xd0>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  8099b2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8099b6:	8b 40 68             	mov    0x68(%rax),%eax
  8099b9:	d1 e8                	shr    %eax
  8099bb:	89 c2                	mov    %eax,%edx
  8099bd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8099c1:	89 50 6c             	mov    %edx,0x6c(%rax)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  8099c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8099c8:	be 3b 00 00 00       	mov    $0x3b,%esi
  8099cd:	48 89 c7             	mov    %rax,%rdi
  8099d0:	48 b8 65 bc 80 00 00 	movabs $0x80bc65,%rax
  8099d7:	00 00 00 
  8099da:	ff d0                	callq  *%rax
  8099dc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  8099e0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8099e5:	74 20                	je     809a07 <dhcp_handle_ack+0x113>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8099e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8099eb:	48 83 c0 02          	add    $0x2,%rax
  8099ef:	48 89 c7             	mov    %rax,%rdi
  8099f2:	48 b8 3c be 80 00 00 	movabs $0x80be3c,%rax
  8099f9:	00 00 00 
  8099fc:	ff d0                	callq  *%rax
  8099fe:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809a02:	89 42 70             	mov    %eax,0x70(%rdx)
  809a05:	eb 0e                	jmp    809a15 <dhcp_handle_ack+0x121>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  809a07:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809a0b:	8b 50 68             	mov    0x68(%rax),%edx
  809a0e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809a12:	89 50 70             	mov    %edx,0x70(%rax)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  809a15:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809a19:	48 8b 40 18          	mov    0x18(%rax),%rax
  809a1d:	48 83 c0 10          	add    $0x10,%rax
  809a21:	48 85 c0             	test   %rax,%rax
  809a24:	74 0d                	je     809a33 <dhcp_handle_ack+0x13f>
  809a26:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809a2a:	48 8b 40 18          	mov    0x18(%rax),%rax
  809a2e:	8b 40 10             	mov    0x10(%rax),%eax
  809a31:	eb 05                	jmp    809a38 <dhcp_handle_ack+0x144>
  809a33:	b8 00 00 00 00       	mov    $0x0,%eax
  809a38:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809a3c:	89 42 4c             	mov    %eax,0x4c(%rdx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  809a3f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809a43:	be 01 00 00 00       	mov    $0x1,%esi
  809a48:	48 89 c7             	mov    %rax,%rdi
  809a4b:	48 b8 65 bc 80 00 00 	movabs $0x80bc65,%rax
  809a52:	00 00 00 
  809a55:	ff d0                	callq  *%rax
  809a57:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  /* subnet mask given? */
  if (option_ptr != NULL) {
  809a5b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809a60:	74 2c                	je     809a8e <dhcp_handle_ack+0x19a>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809a62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809a66:	48 83 c0 02          	add    $0x2,%rax
  809a6a:	48 89 c7             	mov    %rax,%rdi
  809a6d:	48 b8 3c be 80 00 00 	movabs $0x80be3c,%rax
  809a74:	00 00 00 
  809a77:	ff d0                	callq  *%rax
  809a79:	89 c7                	mov    %eax,%edi
  809a7b:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  809a82:	00 00 00 
  809a85:	ff d0                	callq  *%rax
  809a87:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809a8b:	89 42 50             	mov    %eax,0x50(%rdx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  809a8e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809a92:	be 03 00 00 00       	mov    $0x3,%esi
  809a97:	48 89 c7             	mov    %rax,%rdi
  809a9a:	48 b8 65 bc 80 00 00 	movabs $0x80bc65,%rax
  809aa1:	00 00 00 
  809aa4:	ff d0                	callq  *%rax
  809aa6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809aaa:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809aaf:	74 2c                	je     809add <dhcp_handle_ack+0x1e9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809ab1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809ab5:	48 83 c0 02          	add    $0x2,%rax
  809ab9:	48 89 c7             	mov    %rax,%rdi
  809abc:	48 b8 3c be 80 00 00 	movabs $0x80be3c,%rax
  809ac3:	00 00 00 
  809ac6:	ff d0                	callq  *%rax
  809ac8:	89 c7                	mov    %eax,%edi
  809aca:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  809ad1:	00 00 00 
  809ad4:	ff d0                	callq  *%rax
  809ad6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809ada:	89 42 54             	mov    %eax,0x54(%rdx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  809add:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809ae1:	be 1c 00 00 00       	mov    $0x1c,%esi
  809ae6:	48 89 c7             	mov    %rax,%rdi
  809ae9:	48 b8 65 bc 80 00 00 	movabs $0x80bc65,%rax
  809af0:	00 00 00 
  809af3:	ff d0                	callq  *%rax
  809af5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809af9:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809afe:	74 2c                	je     809b2c <dhcp_handle_ack+0x238>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809b00:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809b04:	48 83 c0 02          	add    $0x2,%rax
  809b08:	48 89 c7             	mov    %rax,%rdi
  809b0b:	48 b8 3c be 80 00 00 	movabs $0x80be3c,%rax
  809b12:	00 00 00 
  809b15:	ff d0                	callq  *%rax
  809b17:	89 c7                	mov    %eax,%edi
  809b19:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  809b20:	00 00 00 
  809b23:	ff d0                	callq  *%rax
  809b25:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809b29:	89 42 58             	mov    %eax,0x58(%rdx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  809b2c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809b30:	be 06 00 00 00       	mov    $0x6,%esi
  809b35:	48 89 c7             	mov    %rax,%rdi
  809b38:	48 b8 65 bc 80 00 00 	movabs $0x80bc65,%rax
  809b3f:	00 00 00 
  809b42:	ff d0                	callq  *%rax
  809b44:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809b48:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809b4d:	0f 84 9d 00 00 00    	je     809bf0 <dhcp_handle_ack+0x2fc>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  809b53:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809b57:	48 83 c0 01          	add    $0x1,%rax
  809b5b:	48 89 c7             	mov    %rax,%rdi
  809b5e:	48 b8 27 be 80 00 00 	movabs $0x80be27,%rax
  809b65:	00 00 00 
  809b68:	ff d0                	callq  *%rax
  809b6a:	c0 e8 02             	shr    $0x2,%al
  809b6d:	0f b6 d0             	movzbl %al,%edx
  809b70:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809b74:	89 50 5c             	mov    %edx,0x5c(%rax)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  809b77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809b7b:	8b 40 5c             	mov    0x5c(%rax),%eax
  809b7e:	83 f8 02             	cmp    $0x2,%eax
  809b81:	76 0b                	jbe    809b8e <dhcp_handle_ack+0x29a>
      dhcp->dns_count = DHCP_MAX_DNS;
  809b83:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809b87:	c7 40 5c 02 00 00 00 	movl   $0x2,0x5c(%rax)
    for (n = 0; n < dhcp->dns_count; n++) {
  809b8e:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  809b92:	eb 4d                	jmp    809be1 <dhcp_handle_ack+0x2ed>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  809b94:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  809b98:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809b9c:	c1 e0 02             	shl    $0x2,%eax
  809b9f:	83 c0 02             	add    $0x2,%eax
  809ba2:	48 63 d0             	movslq %eax,%rdx
  809ba5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809ba9:	48 01 d0             	add    %rdx,%rax
  809bac:	48 89 c7             	mov    %rax,%rdi
  809baf:	48 b8 3c be 80 00 00 	movabs $0x80be3c,%rax
  809bb6:	00 00 00 
  809bb9:	ff d0                	callq  *%rax
  809bbb:	89 c7                	mov    %eax,%edi
  809bbd:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  809bc4:	00 00 00 
  809bc7:	ff d0                	callq  *%rax
  809bc9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809bcd:	48 63 cb             	movslq %ebx,%rcx
  809bd0:	48 83 c1 18          	add    $0x18,%rcx
  809bd4:	89 04 8a             	mov    %eax,(%rdx,%rcx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  809bd7:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809bdb:	83 c0 01             	add    $0x1,%eax
  809bde:	88 45 ef             	mov    %al,-0x11(%rbp)
  809be1:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  809be5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809be9:	8b 40 5c             	mov    0x5c(%rax),%eax
  809bec:	39 c2                	cmp    %eax,%edx
  809bee:	72 a4                	jb     809b94 <dhcp_handle_ack+0x2a0>
    }
#if LWIP_DNS
    dns_setserver( n, (struct ip_addr *)(&ip_addr_any));
#endif /* LWIP_DNS */
  }
}
  809bf0:	48 83 c4 38          	add    $0x38,%rsp
  809bf4:	5b                   	pop    %rbx
  809bf5:	5d                   	pop    %rbp
  809bf6:	c3                   	retq   

0000000000809bf7 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  809bf7:	55                   	push   %rbp
  809bf8:	48 89 e5             	mov    %rsp,%rbp
  809bfb:	48 83 ec 20          	sub    $0x20,%rsp
  809bff:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
  809c03:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  809c07:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809c0c:	75 2a                	jne    809c38 <dhcp_start+0x41>
  809c0e:	48 ba 68 14 82 00 00 	movabs $0x821468,%rdx
  809c15:	00 00 00 
  809c18:	be 38 02 00 00       	mov    $0x238,%esi
  809c1d:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  809c24:	00 00 00 
  809c27:	b8 00 00 00 00       	mov    $0x0,%eax
  809c2c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  809c33:	00 00 00 
  809c36:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  809c38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c3c:	48 8b 40 38          	mov    0x38(%rax),%rax
  809c40:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  809c44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c48:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  809c4c:	83 e0 f7             	and    $0xfffffff7,%eax
  809c4f:	89 c2                	mov    %eax,%edx
  809c51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c55:	88 50 4a             	mov    %dl,0x4a(%rax)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  809c58:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809c5d:	75 32                	jne    809c91 <dhcp_start+0x9a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  809c5f:	bf 78 00 00 00       	mov    $0x78,%edi
  809c64:	48 b8 65 c6 80 00 00 	movabs $0x80c665,%rax
  809c6b:	00 00 00 
  809c6e:	ff d0                	callq  *%rax
  809c70:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (dhcp == NULL) {
  809c74:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809c79:	75 0a                	jne    809c85 <dhcp_start+0x8e>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  809c7b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809c80:	e9 3a 01 00 00       	jmpq   809dbf <dhcp_start+0x1c8>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  809c85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c89:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809c8d:	48 89 50 38          	mov    %rdx,0x38(%rax)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  809c91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809c95:	ba 78 00 00 00       	mov    $0x78,%edx
  809c9a:	be 00 00 00 00       	mov    $0x0,%esi
  809c9f:	48 89 c7             	mov    %rax,%rdi
  809ca2:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  809ca9:	00 00 00 
  809cac:	ff d0                	callq  *%rax
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  809cae:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  809cb5:	00 00 00 
  809cb8:	ff d0                	callq  *%rax
  809cba:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809cbe:	48 89 42 08          	mov    %rax,0x8(%rdx)
  if (dhcp->pcb == NULL) {
  809cc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809cc6:	48 8b 40 08          	mov    0x8(%rax),%rax
  809cca:	48 85 c0             	test   %rax,%rax
  809ccd:	75 31                	jne    809d00 <dhcp_start+0x109>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  809ccf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809cd3:	48 89 c7             	mov    %rax,%rdi
  809cd6:	48 b8 c9 c1 80 00 00 	movabs $0x80c1c9,%rax
  809cdd:	00 00 00 
  809ce0:	ff d0                	callq  *%rax
    netif->dhcp = dhcp = NULL;
  809ce2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  809ce9:	00 
  809cea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809cee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809cf2:	48 89 50 38          	mov    %rdx,0x38(%rax)
    return ERR_MEM;
  809cf6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809cfb:	e9 bf 00 00 00       	jmpq   809dbf <dhcp_start+0x1c8>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  809d00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809d04:	48 8b 40 08          	mov    0x8(%rax),%rax
  809d08:	ba 44 00 00 00       	mov    $0x44,%edx
  809d0d:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  809d14:	00 00 00 
  809d17:	48 89 c7             	mov    %rax,%rdi
  809d1a:	48 b8 b9 52 81 00 00 	movabs $0x8152b9,%rax
  809d21:	00 00 00 
  809d24:	ff d0                	callq  *%rax
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809d26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809d2a:	48 8b 40 08          	mov    0x8(%rax),%rax
  809d2e:	ba 43 00 00 00       	mov    $0x43,%edx
  809d33:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  809d3a:	00 00 00 
  809d3d:	48 89 c7             	mov    %rax,%rdi
  809d40:	48 b8 05 54 81 00 00 	movabs $0x815405,%rax
  809d47:	00 00 00 
  809d4a:	ff d0                	callq  *%rax
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  809d4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809d50:	48 8b 40 08          	mov    0x8(%rax),%rax
  809d54:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809d58:	48 be 42 b4 80 00 00 	movabs $0x80b442,%rsi
  809d5f:	00 00 00 
  809d62:	48 89 c7             	mov    %rax,%rdi
  809d65:	48 b8 3d 55 81 00 00 	movabs $0x81553d,%rax
  809d6c:	00 00 00 
  809d6f:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  809d71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809d75:	48 89 c7             	mov    %rax,%rdi
  809d78:	48 b8 b5 a2 80 00 00 	movabs $0x80a2b5,%rax
  809d7f:	00 00 00 
  809d82:	ff d0                	callq  *%rax
  809d84:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
  809d87:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809d8b:	74 1a                	je     809da7 <dhcp_start+0x1b0>
    /* free resources allocated above */
    dhcp_stop(netif);
  809d8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809d91:	48 89 c7             	mov    %rax,%rdi
  809d94:	48 b8 a2 ad 80 00 00 	movabs $0x80ada2,%rax
  809d9b:	00 00 00 
  809d9e:	ff d0                	callq  *%rax
    return ERR_MEM;
  809da0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809da5:	eb 18                	jmp    809dbf <dhcp_start+0x1c8>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  809da7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809dab:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  809daf:	83 c8 08             	or     $0x8,%eax
  809db2:	89 c2                	mov    %eax,%edx
  809db4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809db8:	88 50 4a             	mov    %dl,0x4a(%rax)
  return result;
  809dbb:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  809dbf:	c9                   	leaveq 
  809dc0:	c3                   	retq   

0000000000809dc1 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  809dc1:	55                   	push   %rbp
  809dc2:	48 89 e5             	mov    %rsp,%rbp
  809dc5:	48 83 ec 30          	sub    $0x30,%rsp
  809dc9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  809dcd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809dd1:	48 8b 40 38          	mov    0x38(%rax),%rax
  809dd5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  809dd9:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  dhcp = mem_malloc(sizeof(struct dhcp));
  809ddd:	bf 78 00 00 00       	mov    $0x78,%edi
  809de2:	48 b8 65 c6 80 00 00 	movabs $0x80c665,%rax
  809de9:	00 00 00 
  809dec:	ff d0                	callq  *%rax
  809dee:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (dhcp == NULL) {
  809df2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809df7:	75 05                	jne    809dfe <dhcp_inform+0x3d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  809df9:	e9 37 02 00 00       	jmpq   80a035 <dhcp_inform+0x274>
  }
  netif->dhcp = dhcp;
  809dfe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809e02:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809e06:	48 89 50 38          	mov    %rdx,0x38(%rax)
  memset(dhcp, 0, sizeof(struct dhcp));
  809e0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e0e:	ba 78 00 00 00       	mov    $0x78,%edx
  809e13:	be 00 00 00 00       	mov    $0x0,%esi
  809e18:	48 89 c7             	mov    %rax,%rdi
  809e1b:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  809e22:	00 00 00 
  809e25:	ff d0                	callq  *%rax

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  809e27:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  809e2e:	00 00 00 
  809e31:	ff d0                	callq  *%rax
  809e33:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809e37:	48 89 42 08          	mov    %rax,0x8(%rdx)
  if (dhcp->pcb == NULL) {
  809e3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e3f:	48 8b 40 08          	mov    0x8(%rax),%rax
  809e43:	48 85 c0             	test   %rax,%rax
  809e46:	75 18                	jne    809e60 <dhcp_inform+0x9f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  809e48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e4c:	48 89 c7             	mov    %rax,%rdi
  809e4f:	48 b8 c9 c1 80 00 00 	movabs $0x80c1c9,%rax
  809e56:	00 00 00 
  809e59:	ff d0                	callq  *%rax
    return;
  809e5b:	e9 d5 01 00 00       	jmpq   80a035 <dhcp_inform+0x274>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  809e60:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809e64:	48 89 c7             	mov    %rax,%rdi
  809e67:	48 b8 92 b6 80 00 00 	movabs $0x80b692,%rax
  809e6e:	00 00 00 
  809e71:	ff d0                	callq  *%rax
  809e73:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  809e76:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809e7a:	0f 85 5f 01 00 00    	jne    809fdf <dhcp_inform+0x21e>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  809e80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e84:	ba 01 00 00 00       	mov    $0x1,%edx
  809e89:	be 35 00 00 00       	mov    $0x35,%esi
  809e8e:	48 89 c7             	mov    %rax,%rdi
  809e91:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  809e98:	00 00 00 
  809e9b:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_INFORM);
  809e9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809ea1:	be 08 00 00 00       	mov    $0x8,%esi
  809ea6:	48 89 c7             	mov    %rax,%rdi
  809ea9:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  809eb0:	00 00 00 
  809eb3:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  809eb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809eb9:	ba 02 00 00 00       	mov    $0x2,%edx
  809ebe:	be 39 00 00 00       	mov    $0x39,%esi
  809ec3:	48 89 c7             	mov    %rax,%rdi
  809ec6:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  809ecd:	00 00 00 
  809ed0:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  809ed2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809ed6:	be 40 02 00 00       	mov    $0x240,%esi
  809edb:	48 89 c7             	mov    %rax,%rdi
  809ede:	48 b8 f6 af 80 00 00 	movabs $0x80aff6,%rax
  809ee5:	00 00 00 
  809ee8:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  809eea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809eee:	48 89 c7             	mov    %rax,%rdi
  809ef1:	48 b8 0d bb 80 00 00 	movabs $0x80bb0d,%rax
  809ef8:	00 00 00 
  809efb:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  809efd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f01:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  809f05:	66 05 f0 00          	add    $0xf0,%ax
  809f09:	0f b7 d0             	movzwl %ax,%edx
  809f0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f10:	48 8b 40 30          	mov    0x30(%rax),%rax
  809f14:	89 d6                	mov    %edx,%esi
  809f16:	48 89 c7             	mov    %rax,%rdi
  809f19:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  809f20:	00 00 00 
  809f23:	ff d0                	callq  *%rax

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  809f25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f29:	48 8b 40 08          	mov    0x8(%rax),%rax
  809f2d:	ba 44 00 00 00       	mov    $0x44,%edx
  809f32:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  809f39:	00 00 00 
  809f3c:	48 89 c7             	mov    %rax,%rdi
  809f3f:	48 b8 b9 52 81 00 00 	movabs $0x8152b9,%rax
  809f46:	00 00 00 
  809f49:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  809f4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f4f:	48 8b 40 08          	mov    0x8(%rax),%rax
  809f53:	ba 43 00 00 00       	mov    $0x43,%edx
  809f58:	48 be 6c 22 82 00 00 	movabs $0x82226c,%rsi
  809f5f:	00 00 00 
  809f62:	48 89 c7             	mov    %rax,%rdi
  809f65:	48 b8 05 54 81 00 00 	movabs $0x815405,%rax
  809f6c:	00 00 00 
  809f6f:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  809f71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f75:	48 8b 70 30          	mov    0x30(%rax),%rsi
  809f79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f7d:	48 8b 40 08          	mov    0x8(%rax),%rax
  809f81:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  809f85:	49 89 d0             	mov    %rdx,%r8
  809f88:	b9 43 00 00 00       	mov    $0x43,%ecx
  809f8d:	48 ba 6c 22 82 00 00 	movabs $0x82226c,%rdx
  809f94:	00 00 00 
  809f97:	48 89 c7             	mov    %rax,%rdi
  809f9a:	48 b8 08 50 81 00 00 	movabs $0x815008,%rax
  809fa1:	00 00 00 
  809fa4:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809fa6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809faa:	48 8b 40 08          	mov    0x8(%rax),%rax
  809fae:	ba 43 00 00 00       	mov    $0x43,%edx
  809fb3:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  809fba:	00 00 00 
  809fbd:	48 89 c7             	mov    %rax,%rdi
  809fc0:	48 b8 05 54 81 00 00 	movabs $0x815405,%rax
  809fc7:	00 00 00 
  809fca:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  809fcc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809fd0:	48 89 c7             	mov    %rax,%rdi
  809fd3:	48 b8 e7 b9 80 00 00 	movabs $0x80b9e7,%rax
  809fda:	00 00 00 
  809fdd:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
  809fdf:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809fe4:	74 4f                	je     80a035 <dhcp_inform+0x274>
    if (dhcp->pcb != NULL) {
  809fe6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809fea:	48 8b 40 08          	mov    0x8(%rax),%rax
  809fee:	48 85 c0             	test   %rax,%rax
  809ff1:	74 17                	je     80a00a <dhcp_inform+0x249>
      udp_remove(dhcp->pcb);
  809ff3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809ff7:	48 8b 40 08          	mov    0x8(%rax),%rax
  809ffb:	48 89 c7             	mov    %rax,%rdi
  809ffe:	48 b8 6b 55 81 00 00 	movabs $0x81556b,%rax
  80a005:	00 00 00 
  80a008:	ff d0                	callq  *%rax
    }
    dhcp->pcb = NULL;
  80a00a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a00e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80a015:	00 
    mem_free((void *)dhcp);
  80a016:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a01a:	48 89 c7             	mov    %rax,%rdi
  80a01d:	48 b8 c9 c1 80 00 00 	movabs $0x80c1c9,%rax
  80a024:	00 00 00 
  80a027:	ff d0                	callq  *%rax
    netif->dhcp = old_dhcp;
  80a029:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a02d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80a031:	48 89 50 38          	mov    %rdx,0x38(%rax)
  }
}
  80a035:	c9                   	leaveq 
  80a036:	c3                   	retq   

000000000080a037 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  80a037:	55                   	push   %rbp
  80a038:	48 89 e5             	mov    %rsp,%rbp
  80a03b:	48 83 ec 10          	sub    $0x10,%rsp
  80a03f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80a043:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80a047:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80a04c:	75 2a                	jne    80a078 <dhcp_arp_reply+0x41>
  80a04e:	48 ba 68 14 82 00 00 	movabs $0x821468,%rdx
  80a055:	00 00 00 
  80a058:	be b5 02 00 00       	mov    $0x2b5,%esi
  80a05d:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80a064:	00 00 00 
  80a067:	b8 00 00 00 00       	mov    $0x0,%eax
  80a06c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80a073:	00 00 00 
  80a076:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  80a078:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a07c:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a080:	48 85 c0             	test   %rax,%rax
  80a083:	74 37                	je     80a0bc <dhcp_arp_reply+0x85>
  80a085:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a089:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a08d:	0f b6 00             	movzbl (%rax),%eax
  80a090:	3c 08                	cmp    $0x8,%al
  80a092:	75 28                	jne    80a0bc <dhcp_arp_reply+0x85>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  80a094:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a098:	8b 10                	mov    (%rax),%edx
  80a09a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a09e:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a0a2:	8b 40 4c             	mov    0x4c(%rax),%eax
  80a0a5:	39 c2                	cmp    %eax,%edx
  80a0a7:	75 13                	jne    80a0bc <dhcp_arp_reply+0x85>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
  80a0a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0ad:	48 89 c7             	mov    %rax,%rdi
  80a0b0:	48 b8 be a0 80 00 00 	movabs $0x80a0be,%rax
  80a0b7:	00 00 00 
  80a0ba:	ff d0                	callq  *%rax
    }
  }
}
  80a0bc:	c9                   	leaveq 
  80a0bd:	c3                   	retq   

000000000080a0be <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
  80a0be:	55                   	push   %rbp
  80a0bf:	48 89 e5             	mov    %rsp,%rbp
  80a0c2:	48 83 ec 20          	sub    $0x20,%rsp
  80a0c6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a0ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0ce:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a0d2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a0d6:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  80a0da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0de:	be 0c 00 00 00       	mov    $0xc,%esi
  80a0e3:	48 89 c7             	mov    %rax,%rdi
  80a0e6:	48 b8 9e ae 80 00 00 	movabs $0x80ae9e,%rax
  80a0ed:	00 00 00 
  80a0f0:	ff d0                	callq  *%rax
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a0f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0f6:	48 89 c7             	mov    %rax,%rdi
  80a0f9:	48 b8 92 b6 80 00 00 	movabs $0x80b692,%rax
  80a100:	00 00 00 
  80a103:	ff d0                	callq  *%rax
  80a105:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a108:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a10c:	0f 85 5c 01 00 00    	jne    80a26e <dhcp_decline+0x1b0>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a112:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a116:	ba 01 00 00 00       	mov    $0x1,%edx
  80a11b:	be 35 00 00 00       	mov    $0x35,%esi
  80a120:	48 89 c7             	mov    %rax,%rdi
  80a123:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  80a12a:	00 00 00 
  80a12d:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  80a12f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a133:	be 04 00 00 00       	mov    $0x4,%esi
  80a138:	48 89 c7             	mov    %rax,%rdi
  80a13b:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  80a142:	00 00 00 
  80a145:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a147:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a14b:	ba 02 00 00 00       	mov    $0x2,%edx
  80a150:	be 39 00 00 00       	mov    $0x39,%esi
  80a155:	48 89 c7             	mov    %rax,%rdi
  80a158:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  80a15f:	00 00 00 
  80a162:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a164:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a168:	be 40 02 00 00       	mov    $0x240,%esi
  80a16d:	48 89 c7             	mov    %rax,%rdi
  80a170:	48 b8 f6 af 80 00 00 	movabs $0x80aff6,%rax
  80a177:	00 00 00 
  80a17a:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  80a17c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a180:	ba 04 00 00 00       	mov    $0x4,%edx
  80a185:	be 32 00 00 00       	mov    $0x32,%esi
  80a18a:	48 89 c7             	mov    %rax,%rdi
  80a18d:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  80a194:	00 00 00 
  80a197:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80a199:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a19d:	8b 40 4c             	mov    0x4c(%rax),%eax
  80a1a0:	89 c7                	mov    %eax,%edi
  80a1a2:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  80a1a9:	00 00 00 
  80a1ac:	ff d0                	callq  *%rax
  80a1ae:	89 c2                	mov    %eax,%edx
  80a1b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a1b4:	89 d6                	mov    %edx,%esi
  80a1b6:	48 89 c7             	mov    %rax,%rdi
  80a1b9:	48 b8 a1 b0 80 00 00 	movabs $0x80b0a1,%rax
  80a1c0:	00 00 00 
  80a1c3:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a1c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a1c9:	48 89 c7             	mov    %rax,%rdi
  80a1cc:	48 b8 0d bb 80 00 00 	movabs $0x80bb0d,%rax
  80a1d3:	00 00 00 
  80a1d6:	ff d0                	callq  *%rax
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a1d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a1dc:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a1e0:	66 05 f0 00          	add    $0xf0,%ax
  80a1e4:	0f b7 d0             	movzwl %ax,%edx
  80a1e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a1eb:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a1ef:	89 d6                	mov    %edx,%esi
  80a1f1:	48 89 c7             	mov    %rax,%rdi
  80a1f4:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  80a1fb:	00 00 00 
  80a1fe:	ff d0                	callq  *%rax

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a200:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a204:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a208:	ba 43 00 00 00       	mov    $0x43,%edx
  80a20d:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  80a214:	00 00 00 
  80a217:	48 89 c7             	mov    %rax,%rdi
  80a21a:	48 b8 05 54 81 00 00 	movabs $0x815405,%rax
  80a221:	00 00 00 
  80a224:	ff d0                	callq  *%rax
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a226:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a22a:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a22e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a232:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a236:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a23a:	49 89 d0             	mov    %rdx,%r8
  80a23d:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a242:	48 ba 6c 22 82 00 00 	movabs $0x82226c,%rdx
  80a249:	00 00 00 
  80a24c:	48 89 c7             	mov    %rax,%rdi
  80a24f:	48 b8 08 50 81 00 00 	movabs $0x815008,%rax
  80a256:	00 00 00 
  80a259:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a25b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a25f:	48 89 c7             	mov    %rax,%rdi
  80a262:	48 b8 e7 b9 80 00 00 	movabs $0x80b9e7,%rax
  80a269:	00 00 00 
  80a26c:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a26e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a272:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a276:	8d 50 01             	lea    0x1(%rax),%edx
  80a279:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a27d:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 10*1000;
  80a280:	66 c7 45 f4 10 27    	movw   $0x2710,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a286:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a28a:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a290:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a295:	89 c8                	mov    %ecx,%eax
  80a297:	f7 ea                	imul   %edx
  80a299:	c1 fa 05             	sar    $0x5,%edx
  80a29c:	89 c8                	mov    %ecx,%eax
  80a29e:	c1 f8 1f             	sar    $0x1f,%eax
  80a2a1:	29 c2                	sub    %eax,%edx
  80a2a3:	89 d0                	mov    %edx,%eax
  80a2a5:	89 c2                	mov    %eax,%edx
  80a2a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2ab:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a2af:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a2b3:	c9                   	leaveq 
  80a2b4:	c3                   	retq   

000000000080a2b5 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  80a2b5:	55                   	push   %rbp
  80a2b6:	48 89 e5             	mov    %rsp,%rbp
  80a2b9:	48 83 ec 20          	sub    $0x20,%rsp
  80a2bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a2c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2c5:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a2c9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a2cd:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  80a2d1:	48 b8 68 22 82 00 00 	movabs $0x822268,%rax
  80a2d8:	00 00 00 
  80a2db:	8b 10                	mov    (%rax),%edx
  80a2dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2e1:	89 50 4c             	mov    %edx,0x4c(%rax)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a2e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2e8:	48 89 c7             	mov    %rax,%rdi
  80a2eb:	48 b8 92 b6 80 00 00 	movabs $0x80b692,%rax
  80a2f2:	00 00 00 
  80a2f5:	ff d0                	callq  *%rax
  80a2f7:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a2fa:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a2fe:	0f 85 a8 01 00 00    	jne    80a4ac <dhcp_discover+0x1f7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a304:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a308:	ba 01 00 00 00       	mov    $0x1,%edx
  80a30d:	be 35 00 00 00       	mov    $0x35,%esi
  80a312:	48 89 c7             	mov    %rax,%rdi
  80a315:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  80a31c:	00 00 00 
  80a31f:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  80a321:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a325:	be 01 00 00 00       	mov    $0x1,%esi
  80a32a:	48 89 c7             	mov    %rax,%rdi
  80a32d:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  80a334:	00 00 00 
  80a337:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a339:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a33d:	ba 02 00 00 00       	mov    $0x2,%edx
  80a342:	be 39 00 00 00       	mov    $0x39,%esi
  80a347:	48 89 c7             	mov    %rax,%rdi
  80a34a:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  80a351:	00 00 00 
  80a354:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a356:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a35a:	be 40 02 00 00       	mov    $0x240,%esi
  80a35f:	48 89 c7             	mov    %rax,%rdi
  80a362:	48 b8 f6 af 80 00 00 	movabs $0x80aff6,%rax
  80a369:	00 00 00 
  80a36c:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80a36e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a372:	ba 04 00 00 00       	mov    $0x4,%edx
  80a377:	be 37 00 00 00       	mov    $0x37,%esi
  80a37c:	48 89 c7             	mov    %rax,%rdi
  80a37f:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  80a386:	00 00 00 
  80a389:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80a38b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a38f:	be 01 00 00 00       	mov    $0x1,%esi
  80a394:	48 89 c7             	mov    %rax,%rdi
  80a397:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  80a39e:	00 00 00 
  80a3a1:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80a3a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3a7:	be 03 00 00 00       	mov    $0x3,%esi
  80a3ac:	48 89 c7             	mov    %rax,%rdi
  80a3af:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  80a3b6:	00 00 00 
  80a3b9:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80a3bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3bf:	be 1c 00 00 00       	mov    $0x1c,%esi
  80a3c4:	48 89 c7             	mov    %rax,%rdi
  80a3c7:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  80a3ce:	00 00 00 
  80a3d1:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80a3d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3d7:	be 06 00 00 00       	mov    $0x6,%esi
  80a3dc:	48 89 c7             	mov    %rax,%rdi
  80a3df:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  80a3e6:	00 00 00 
  80a3e9:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a3eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3ef:	48 89 c7             	mov    %rax,%rdi
  80a3f2:	48 b8 0d bb 80 00 00 	movabs $0x80bb0d,%rax
  80a3f9:	00 00 00 
  80a3fc:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a3fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a402:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a406:	66 05 f0 00          	add    $0xf0,%ax
  80a40a:	0f b7 d0             	movzwl %ax,%edx
  80a40d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a411:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a415:	89 d6                	mov    %edx,%esi
  80a417:	48 89 c7             	mov    %rax,%rdi
  80a41a:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  80a421:	00 00 00 
  80a424:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a426:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a42a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a42e:	ba 43 00 00 00       	mov    $0x43,%edx
  80a433:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  80a43a:	00 00 00 
  80a43d:	48 89 c7             	mov    %rax,%rdi
  80a440:	48 b8 05 54 81 00 00 	movabs $0x815405,%rax
  80a447:	00 00 00 
  80a44a:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a44c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a450:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a454:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a458:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a45c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a460:	49 89 d0             	mov    %rdx,%r8
  80a463:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a468:	48 ba 6c 22 82 00 00 	movabs $0x82226c,%rdx
  80a46f:	00 00 00 
  80a472:	48 89 c7             	mov    %rax,%rdi
  80a475:	48 b8 08 50 81 00 00 	movabs $0x815008,%rax
  80a47c:	00 00 00 
  80a47f:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  80a481:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a485:	48 89 c7             	mov    %rax,%rdi
  80a488:	48 b8 e7 b9 80 00 00 	movabs $0x80b9e7,%rax
  80a48f:	00 00 00 
  80a492:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80a494:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a498:	be 06 00 00 00       	mov    $0x6,%esi
  80a49d:	48 89 c7             	mov    %rax,%rdi
  80a4a0:	48 b8 9e ae 80 00 00 	movabs $0x80ae9e,%rax
  80a4a7:	00 00 00 
  80a4aa:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a4ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4b0:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a4b4:	8d 50 01             	lea    0x1(%rax),%edx
  80a4b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4bb:	88 50 01             	mov    %dl,0x1(%rax)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  80a4be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4c2:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a4c6:	3c 03                	cmp    $0x3,%al
  80a4c8:	77 15                	ja     80a4df <dhcp_discover+0x22a>
  80a4ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4ce:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a4d2:	0f b6 c0             	movzbl %al,%eax
  80a4d5:	83 c0 01             	add    $0x1,%eax
  80a4d8:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80a4dd:	eb 05                	jmp    80a4e4 <dhcp_discover+0x22f>
  80a4df:	b8 10 27 00 00       	mov    $0x2710,%eax
  80a4e4:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a4e8:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a4ec:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a4f2:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a4f7:	89 c8                	mov    %ecx,%eax
  80a4f9:	f7 ea                	imul   %edx
  80a4fb:	c1 fa 05             	sar    $0x5,%edx
  80a4fe:	89 c8                	mov    %ecx,%eax
  80a500:	c1 f8 1f             	sar    $0x1f,%eax
  80a503:	29 c2                	sub    %eax,%edx
  80a505:	89 d0                	mov    %edx,%eax
  80a507:	89 c2                	mov    %eax,%edx
  80a509:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a50d:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a511:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a515:	c9                   	leaveq 
  80a516:	c3                   	retq   

000000000080a517 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  80a517:	55                   	push   %rbp
  80a518:	48 89 e5             	mov    %rsp,%rbp
  80a51b:	53                   	push   %rbx
  80a51c:	48 83 ec 48          	sub    $0x48,%rsp
  80a520:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80a524:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80a529:	75 2a                	jne    80a555 <dhcp_bind+0x3e>
  80a52b:	48 ba 8b 14 82 00 00 	movabs $0x82148b,%rdx
  80a532:	00 00 00 
  80a535:	be 3d 03 00 00       	mov    $0x33d,%esi
  80a53a:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80a541:	00 00 00 
  80a544:	b8 00 00 00 00       	mov    $0x0,%eax
  80a549:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80a550:	00 00 00 
  80a553:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80a555:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a559:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a55d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80a561:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80a566:	75 2a                	jne    80a592 <dhcp_bind+0x7b>
  80a568:	48 ba a4 14 82 00 00 	movabs $0x8214a4,%rdx
  80a56f:	00 00 00 
  80a572:	be 3f 03 00 00       	mov    $0x33f,%esi
  80a577:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80a57e:	00 00 00 
  80a581:	b8 00 00 00 00       	mov    $0x0,%eax
  80a586:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80a58d:	00 00 00 
  80a590:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80a592:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a596:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a599:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a59c:	74 4d                	je     80a5eb <dhcp_bind+0xd4>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a59e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a5a2:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a5a5:	83 c0 1e             	add    $0x1e,%eax
  80a5a8:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a5ad:	f7 e2                	mul    %edx
  80a5af:	89 d0                	mov    %edx,%eax
  80a5b1:	c1 e8 05             	shr    $0x5,%eax
  80a5b4:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if(timeout > 0xffff) {
  80a5b7:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%rbp)
  80a5be:	76 07                	jbe    80a5c7 <dhcp_bind+0xb0>
      timeout = 0xffff;
  80a5c0:	c7 45 ec ff ff 00 00 	movl   $0xffff,-0x14(%rbp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80a5c7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80a5ca:	89 c2                	mov    %eax,%edx
  80a5cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a5d0:	66 89 50 44          	mov    %dx,0x44(%rax)
    if (dhcp->t1_timeout == 0) {
  80a5d4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a5d8:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  80a5dc:	66 85 c0             	test   %ax,%ax
  80a5df:	75 0a                	jne    80a5eb <dhcp_bind+0xd4>
      dhcp->t1_timeout = 1;
  80a5e1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a5e5:	66 c7 40 44 01 00    	movw   $0x1,0x44(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80a5eb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a5ef:	8b 40 70             	mov    0x70(%rax),%eax
  80a5f2:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a5f5:	74 4d                	je     80a644 <dhcp_bind+0x12d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a5f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a5fb:	8b 40 70             	mov    0x70(%rax),%eax
  80a5fe:	83 c0 1e             	add    $0x1e,%eax
  80a601:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a606:	f7 e2                	mul    %edx
  80a608:	89 d0                	mov    %edx,%eax
  80a60a:	c1 e8 05             	shr    $0x5,%eax
  80a60d:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if(timeout > 0xffff) {
  80a610:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%rbp)
  80a617:	76 07                	jbe    80a620 <dhcp_bind+0x109>
      timeout = 0xffff;
  80a619:	c7 45 ec ff ff 00 00 	movl   $0xffff,-0x14(%rbp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
  80a620:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80a623:	89 c2                	mov    %eax,%edx
  80a625:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a629:	66 89 50 46          	mov    %dx,0x46(%rax)
    if (dhcp->t2_timeout == 0) {
  80a62d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a631:	0f b7 40 46          	movzwl 0x46(%rax),%eax
  80a635:	66 85 c0             	test   %ax,%ax
  80a638:	75 0a                	jne    80a644 <dhcp_bind+0x12d>
      dhcp->t2_timeout = 1;
  80a63a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a63e:	66 c7 40 46 01 00    	movw   $0x1,0x46(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80a644:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a648:	48 83 c0 50          	add    $0x50,%rax
  80a64c:	48 85 c0             	test   %rax,%rax
  80a64f:	74 09                	je     80a65a <dhcp_bind+0x143>
  80a651:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a655:	8b 40 50             	mov    0x50(%rax),%eax
  80a658:	eb 05                	jmp    80a65f <dhcp_bind+0x148>
  80a65a:	b8 00 00 00 00       	mov    $0x0,%eax
  80a65f:	89 45 d0             	mov    %eax,-0x30(%rbp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  80a662:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a665:	85 c0                	test   %eax,%eax
  80a667:	75 65                	jne    80a6ce <dhcp_bind+0x1b7>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  80a669:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a66c:	89 c7                	mov    %eax,%edi
  80a66e:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  80a675:	00 00 00 
  80a678:	ff d0                	callq  *%rax
  80a67a:	c1 e8 18             	shr    $0x18,%eax
  80a67d:	88 45 df             	mov    %al,-0x21(%rbp)
    if (first_octet <= 127) {
  80a680:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80a684:	84 c0                	test   %al,%al
  80a686:	78 16                	js     80a69e <dhcp_bind+0x187>
      sn_mask.addr = htonl(0xff000000);
  80a688:	bf 00 00 00 ff       	mov    $0xff000000,%edi
  80a68d:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  80a694:	00 00 00 
  80a697:	ff d0                	callq  *%rax
  80a699:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80a69c:	eb 30                	jmp    80a6ce <dhcp_bind+0x1b7>
    } else if (first_octet >= 192) {
  80a69e:	80 7d df bf          	cmpb   $0xbf,-0x21(%rbp)
  80a6a2:	76 16                	jbe    80a6ba <dhcp_bind+0x1a3>
      sn_mask.addr = htonl(0xffffff00);
  80a6a4:	bf 00 ff ff ff       	mov    $0xffffff00,%edi
  80a6a9:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  80a6b0:	00 00 00 
  80a6b3:	ff d0                	callq  *%rax
  80a6b5:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80a6b8:	eb 14                	jmp    80a6ce <dhcp_bind+0x1b7>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  80a6ba:	bf 00 00 ff ff       	mov    $0xffff0000,%edi
  80a6bf:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  80a6c6:	00 00 00 
  80a6c9:	ff d0                	callq  *%rax
  80a6cb:	89 45 d0             	mov    %eax,-0x30(%rbp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80a6ce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a6d2:	48 83 c0 54          	add    $0x54,%rax
  80a6d6:	48 85 c0             	test   %rax,%rax
  80a6d9:	74 09                	je     80a6e4 <dhcp_bind+0x1cd>
  80a6db:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a6df:	8b 40 54             	mov    0x54(%rax),%eax
  80a6e2:	eb 05                	jmp    80a6e9 <dhcp_bind+0x1d2>
  80a6e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80a6e9:	89 45 c0             	mov    %eax,-0x40(%rbp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  80a6ec:	8b 45 c0             	mov    -0x40(%rbp),%eax
  80a6ef:	85 c0                	test   %eax,%eax
  80a6f1:	75 28                	jne    80a71b <dhcp_bind+0x204>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80a6f3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a6f7:	8b 50 4c             	mov    0x4c(%rax),%edx
  80a6fa:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a6fd:	21 d0                	and    %edx,%eax
  80a6ff:	89 45 c0             	mov    %eax,-0x40(%rbp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  80a702:	8b 5d c0             	mov    -0x40(%rbp),%ebx
  80a705:	bf 01 00 00 00       	mov    $0x1,%edi
  80a70a:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  80a711:	00 00 00 
  80a714:	ff d0                	callq  *%rax
  80a716:	09 d8                	or     %ebx,%eax
  80a718:	89 45 c0             	mov    %eax,-0x40(%rbp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  80a71b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a71f:	48 8d 50 4c          	lea    0x4c(%rax),%rdx
  80a723:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a727:	48 89 d6             	mov    %rdx,%rsi
  80a72a:	48 89 c7             	mov    %rax,%rdi
  80a72d:	48 b8 f3 ce 80 00 00 	movabs $0x80cef3,%rax
  80a734:	00 00 00 
  80a737:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  80a739:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80a73d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a741:	48 89 d6             	mov    %rdx,%rsi
  80a744:	48 89 c7             	mov    %rax,%rdi
  80a747:	48 b8 26 d0 80 00 00 	movabs $0x80d026,%rax
  80a74e:	00 00 00 
  80a751:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  80a753:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80a757:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a75b:	48 89 d6             	mov    %rdx,%rsi
  80a75e:	48 89 c7             	mov    %rax,%rdi
  80a761:	48 b8 f9 cf 80 00 00 	movabs $0x80cff9,%rax
  80a768:	00 00 00 
  80a76b:	ff d0                	callq  *%rax
  /* bring the interface up */
  netif_set_up(netif);
  80a76d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a771:	48 89 c7             	mov    %rax,%rdi
  80a774:	48 b8 72 d0 80 00 00 	movabs $0x80d072,%rax
  80a77b:	00 00 00 
  80a77e:	ff d0                	callq  *%rax
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  80a780:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a784:	be 0a 00 00 00       	mov    $0xa,%esi
  80a789:	48 89 c7             	mov    %rax,%rdi
  80a78c:	48 b8 9e ae 80 00 00 	movabs $0x80ae9e,%rax
  80a793:	00 00 00 
  80a796:	ff d0                	callq  *%rax
}
  80a798:	48 83 c4 48          	add    $0x48,%rsp
  80a79c:	5b                   	pop    %rbx
  80a79d:	5d                   	pop    %rbp
  80a79e:	c3                   	retq   

000000000080a79f <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  80a79f:	55                   	push   %rbp
  80a7a0:	48 89 e5             	mov    %rsp,%rbp
  80a7a3:	48 83 ec 20          	sub    $0x20,%rsp
  80a7a7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a7ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a7af:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a7b3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  80a7b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7bb:	be 05 00 00 00       	mov    $0x5,%esi
  80a7c0:	48 89 c7             	mov    %rax,%rdi
  80a7c3:	48 b8 9e ae 80 00 00 	movabs $0x80ae9e,%rax
  80a7ca:	00 00 00 
  80a7cd:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a7cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a7d3:	48 89 c7             	mov    %rax,%rdi
  80a7d6:	48 b8 92 b6 80 00 00 	movabs $0x80b692,%rax
  80a7dd:	00 00 00 
  80a7e0:	ff d0                	callq  *%rax
  80a7e2:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a7e5:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a7e9:	0f 85 12 01 00 00    	jne    80a901 <dhcp_renew+0x162>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a7ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7f3:	ba 01 00 00 00       	mov    $0x1,%edx
  80a7f8:	be 35 00 00 00       	mov    $0x35,%esi
  80a7fd:	48 89 c7             	mov    %rax,%rdi
  80a800:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  80a807:	00 00 00 
  80a80a:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80a80c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a810:	be 03 00 00 00       	mov    $0x3,%esi
  80a815:	48 89 c7             	mov    %rax,%rdi
  80a818:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  80a81f:	00 00 00 
  80a822:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a824:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a828:	ba 02 00 00 00       	mov    $0x2,%edx
  80a82d:	be 39 00 00 00       	mov    $0x39,%esi
  80a832:	48 89 c7             	mov    %rax,%rdi
  80a835:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  80a83c:	00 00 00 
  80a83f:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  80a841:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a845:	be 40 02 00 00       	mov    $0x240,%esi
  80a84a:	48 89 c7             	mov    %rax,%rdi
  80a84d:	48 b8 f6 af 80 00 00 	movabs $0x80aff6,%rax
  80a854:	00 00 00 
  80a857:	ff d0                	callq  *%rax
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  80a859:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a85d:	48 89 c7             	mov    %rax,%rdi
  80a860:	48 b8 0d bb 80 00 00 	movabs $0x80bb0d,%rax
  80a867:	00 00 00 
  80a86a:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a86c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a870:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a874:	66 05 f0 00          	add    $0xf0,%ax
  80a878:	0f b7 d0             	movzwl %ax,%edx
  80a87b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a87f:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a883:	89 d6                	mov    %edx,%esi
  80a885:	48 89 c7             	mov    %rax,%rdi
  80a888:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  80a88f:	00 00 00 
  80a892:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80a894:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a898:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80a89c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a8a4:	ba 43 00 00 00       	mov    $0x43,%edx
  80a8a9:	48 89 ce             	mov    %rcx,%rsi
  80a8ac:	48 89 c7             	mov    %rax,%rdi
  80a8af:	48 b8 05 54 81 00 00 	movabs $0x815405,%rax
  80a8b6:	00 00 00 
  80a8b9:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80a8bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8bf:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80a8c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8c7:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a8cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8cf:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a8d3:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80a8d7:	49 89 c8             	mov    %rcx,%r8
  80a8da:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a8df:	48 89 c7             	mov    %rax,%rdi
  80a8e2:	48 b8 08 50 81 00 00 	movabs $0x815008,%rax
  80a8e9:	00 00 00 
  80a8ec:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a8ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a8f2:	48 89 c7             	mov    %rax,%rdi
  80a8f5:	48 b8 e7 b9 80 00 00 	movabs $0x80b9e7,%rax
  80a8fc:	00 00 00 
  80a8ff:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a901:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a905:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a909:	8d 50 01             	lea    0x1(%rax),%edx
  80a90c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a910:	88 50 01             	mov    %dl,0x1(%rax)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  80a913:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a917:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a91b:	3c 09                	cmp    $0x9,%al
  80a91d:	77 12                	ja     80a931 <dhcp_renew+0x192>
  80a91f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a923:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a927:	0f b6 c0             	movzbl %al,%eax
  80a92a:	66 69 c0 d0 07       	imul   $0x7d0,%ax,%ax
  80a92f:	eb 05                	jmp    80a936 <dhcp_renew+0x197>
  80a931:	b8 20 4e 00 00       	mov    $0x4e20,%eax
  80a936:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a93a:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a93e:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a944:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a949:	89 c8                	mov    %ecx,%eax
  80a94b:	f7 ea                	imul   %edx
  80a94d:	c1 fa 05             	sar    $0x5,%edx
  80a950:	89 c8                	mov    %ecx,%eax
  80a952:	c1 f8 1f             	sar    $0x1f,%eax
  80a955:	29 c2                	sub    %eax,%edx
  80a957:	89 d0                	mov    %edx,%eax
  80a959:	89 c2                	mov    %eax,%edx
  80a95b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a95f:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a963:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a967:	c9                   	leaveq 
  80a968:	c3                   	retq   

000000000080a969 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  80a969:	55                   	push   %rbp
  80a96a:	48 89 e5             	mov    %rsp,%rbp
  80a96d:	48 83 ec 20          	sub    $0x20,%rsp
  80a971:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a975:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a979:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a97d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  80a981:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a985:	be 04 00 00 00       	mov    $0x4,%esi
  80a98a:	48 89 c7             	mov    %rax,%rdi
  80a98d:	48 b8 9e ae 80 00 00 	movabs $0x80ae9e,%rax
  80a994:	00 00 00 
  80a997:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a999:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a99d:	48 89 c7             	mov    %rax,%rdi
  80a9a0:	48 b8 92 b6 80 00 00 	movabs $0x80b692,%rax
  80a9a7:	00 00 00 
  80a9aa:	ff d0                	callq  *%rax
  80a9ac:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a9af:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a9b3:	0f 85 13 01 00 00    	jne    80aacc <dhcp_rebind+0x163>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a9b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a9bd:	ba 01 00 00 00       	mov    $0x1,%edx
  80a9c2:	be 35 00 00 00       	mov    $0x35,%esi
  80a9c7:	48 89 c7             	mov    %rax,%rdi
  80a9ca:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  80a9d1:	00 00 00 
  80a9d4:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80a9d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a9da:	be 03 00 00 00       	mov    $0x3,%esi
  80a9df:	48 89 c7             	mov    %rax,%rdi
  80a9e2:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  80a9e9:	00 00 00 
  80a9ec:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a9ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a9f2:	ba 02 00 00 00       	mov    $0x2,%edx
  80a9f7:	be 39 00 00 00       	mov    $0x39,%esi
  80a9fc:	48 89 c7             	mov    %rax,%rdi
  80a9ff:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  80aa06:	00 00 00 
  80aa09:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80aa0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa0f:	be 40 02 00 00       	mov    $0x240,%esi
  80aa14:	48 89 c7             	mov    %rax,%rdi
  80aa17:	48 b8 f6 af 80 00 00 	movabs $0x80aff6,%rax
  80aa1e:	00 00 00 
  80aa21:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80aa23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa27:	48 89 c7             	mov    %rax,%rdi
  80aa2a:	48 b8 0d bb 80 00 00 	movabs $0x80bb0d,%rax
  80aa31:	00 00 00 
  80aa34:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80aa36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa3a:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80aa3e:	66 05 f0 00          	add    $0xf0,%ax
  80aa42:	0f b7 d0             	movzwl %ax,%edx
  80aa45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa49:	48 8b 40 30          	mov    0x30(%rax),%rax
  80aa4d:	89 d6                	mov    %edx,%esi
  80aa4f:	48 89 c7             	mov    %rax,%rdi
  80aa52:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  80aa59:	00 00 00 
  80aa5c:	ff d0                	callq  *%rax

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80aa5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa62:	48 8b 40 08          	mov    0x8(%rax),%rax
  80aa66:	ba 43 00 00 00       	mov    $0x43,%edx
  80aa6b:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  80aa72:	00 00 00 
  80aa75:	48 89 c7             	mov    %rax,%rdi
  80aa78:	48 b8 05 54 81 00 00 	movabs $0x815405,%rax
  80aa7f:	00 00 00 
  80aa82:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80aa84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa88:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80aa8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa90:	48 8b 40 08          	mov    0x8(%rax),%rax
  80aa94:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80aa98:	49 89 d0             	mov    %rdx,%r8
  80aa9b:	b9 43 00 00 00       	mov    $0x43,%ecx
  80aaa0:	48 ba 6c 22 82 00 00 	movabs $0x82226c,%rdx
  80aaa7:	00 00 00 
  80aaaa:	48 89 c7             	mov    %rax,%rdi
  80aaad:	48 b8 08 50 81 00 00 	movabs $0x815008,%rax
  80aab4:	00 00 00 
  80aab7:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80aab9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aabd:	48 89 c7             	mov    %rax,%rdi
  80aac0:	48 b8 e7 b9 80 00 00 	movabs $0x80b9e7,%rax
  80aac7:	00 00 00 
  80aaca:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80aacc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aad0:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aad4:	8d 50 01             	lea    0x1(%rax),%edx
  80aad7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aadb:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80aade:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aae2:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aae6:	3c 09                	cmp    $0x9,%al
  80aae8:	77 12                	ja     80aafc <dhcp_rebind+0x193>
  80aaea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aaee:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aaf2:	0f b6 c0             	movzbl %al,%eax
  80aaf5:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80aafa:	eb 05                	jmp    80ab01 <dhcp_rebind+0x198>
  80aafc:	b8 10 27 00 00       	mov    $0x2710,%eax
  80ab01:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80ab05:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80ab09:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80ab0f:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80ab14:	89 c8                	mov    %ecx,%eax
  80ab16:	f7 ea                	imul   %edx
  80ab18:	c1 fa 05             	sar    $0x5,%edx
  80ab1b:	89 c8                	mov    %ecx,%eax
  80ab1d:	c1 f8 1f             	sar    $0x1f,%eax
  80ab20:	29 c2                	sub    %eax,%edx
  80ab22:	89 d0                	mov    %edx,%eax
  80ab24:	89 c2                	mov    %eax,%edx
  80ab26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab2a:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80ab2e:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80ab32:	c9                   	leaveq 
  80ab33:	c3                   	retq   

000000000080ab34 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  80ab34:	55                   	push   %rbp
  80ab35:	48 89 e5             	mov    %rsp,%rbp
  80ab38:	48 83 ec 20          	sub    $0x20,%rsp
  80ab3c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80ab40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ab44:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ab48:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  80ab4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab50:	be 0d 00 00 00       	mov    $0xd,%esi
  80ab55:	48 89 c7             	mov    %rax,%rdi
  80ab58:	48 b8 9e ae 80 00 00 	movabs $0x80ae9e,%rax
  80ab5f:	00 00 00 
  80ab62:	ff d0                	callq  *%rax
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  80ab64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab68:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%rax)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  80ab6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab73:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  80ab7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab7e:	8b 50 50             	mov    0x50(%rax),%edx
  80ab81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab85:	89 50 4c             	mov    %edx,0x4c(%rax)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  80ab88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab8c:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)
  80ab93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab97:	8b 50 58             	mov    0x58(%rax),%edx
  80ab9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab9e:	89 50 54             	mov    %edx,0x54(%rax)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  80aba1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aba5:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%rax)
  80abac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abb0:	8b 50 70             	mov    0x70(%rax),%edx
  80abb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abb7:	89 50 6c             	mov    %edx,0x6c(%rax)
  80abba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abbe:	8b 50 6c             	mov    0x6c(%rax),%edx
  80abc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abc5:	89 50 68             	mov    %edx,0x68(%rax)
  dhcp->dns_count = 0;
  80abc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abcc:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80abd3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80abd7:	48 89 c7             	mov    %rax,%rdi
  80abda:	48 b8 92 b6 80 00 00 	movabs $0x80b692,%rax
  80abe1:	00 00 00 
  80abe4:	ff d0                	callq  *%rax
  80abe6:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80abe9:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80abed:	0f 85 dd 00 00 00    	jne    80acd0 <dhcp_release+0x19c>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80abf3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abf7:	ba 01 00 00 00       	mov    $0x1,%edx
  80abfc:	be 35 00 00 00       	mov    $0x35,%esi
  80ac01:	48 89 c7             	mov    %rax,%rdi
  80ac04:	48 b8 cf ae 80 00 00 	movabs $0x80aecf,%rax
  80ac0b:	00 00 00 
  80ac0e:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80ac10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac14:	be 07 00 00 00       	mov    $0x7,%esi
  80ac19:	48 89 c7             	mov    %rax,%rdi
  80ac1c:	48 b8 80 af 80 00 00 	movabs $0x80af80,%rax
  80ac23:	00 00 00 
  80ac26:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80ac28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac2c:	48 89 c7             	mov    %rax,%rdi
  80ac2f:	48 b8 0d bb 80 00 00 	movabs $0x80bb0d,%rax
  80ac36:	00 00 00 
  80ac39:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80ac3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac3f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ac43:	66 05 f0 00          	add    $0xf0,%ax
  80ac47:	0f b7 d0             	movzwl %ax,%edx
  80ac4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac4e:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ac52:	89 d6                	mov    %edx,%esi
  80ac54:	48 89 c7             	mov    %rax,%rdi
  80ac57:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  80ac5e:	00 00 00 
  80ac61:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80ac63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac67:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80ac6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac6f:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ac73:	ba 43 00 00 00       	mov    $0x43,%edx
  80ac78:	48 89 ce             	mov    %rcx,%rsi
  80ac7b:	48 89 c7             	mov    %rax,%rdi
  80ac7e:	48 b8 05 54 81 00 00 	movabs $0x815405,%rax
  80ac85:	00 00 00 
  80ac88:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80ac8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac8e:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80ac92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac96:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80ac9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac9e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80aca2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80aca6:	49 89 c8             	mov    %rcx,%r8
  80aca9:	b9 43 00 00 00       	mov    $0x43,%ecx
  80acae:	48 89 c7             	mov    %rax,%rdi
  80acb1:	48 b8 08 50 81 00 00 	movabs $0x815008,%rax
  80acb8:	00 00 00 
  80acbb:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80acbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80acc1:	48 89 c7             	mov    %rax,%rdi
  80acc4:	48 b8 e7 b9 80 00 00 	movabs $0x80b9e7,%rax
  80accb:	00 00 00 
  80acce:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80acd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acd4:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80acd8:	8d 50 01             	lea    0x1(%rax),%edx
  80acdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acdf:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80ace2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ace6:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80acea:	3c 09                	cmp    $0x9,%al
  80acec:	77 12                	ja     80ad00 <dhcp_release+0x1cc>
  80acee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acf2:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80acf6:	0f b6 c0             	movzbl %al,%eax
  80acf9:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80acfe:	eb 05                	jmp    80ad05 <dhcp_release+0x1d1>
  80ad00:	b8 10 27 00 00       	mov    $0x2710,%eax
  80ad05:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80ad09:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80ad0d:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80ad13:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80ad18:	89 c8                	mov    %ecx,%eax
  80ad1a:	f7 ea                	imul   %edx
  80ad1c:	c1 fa 05             	sar    $0x5,%edx
  80ad1f:	89 c8                	mov    %ecx,%eax
  80ad21:	c1 f8 1f             	sar    $0x1f,%eax
  80ad24:	29 c2                	sub    %eax,%edx
  80ad26:	89 d0                	mov    %edx,%eax
  80ad28:	89 c2                	mov    %eax,%edx
  80ad2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad2e:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  80ad32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad36:	48 89 c7             	mov    %rax,%rdi
  80ad39:	48 b8 db d0 80 00 00 	movabs $0x80d0db,%rax
  80ad40:	00 00 00 
  80ad43:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80ad45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad49:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  80ad50:	00 00 00 
  80ad53:	48 89 c7             	mov    %rax,%rdi
  80ad56:	48 b8 f3 ce 80 00 00 	movabs $0x80cef3,%rax
  80ad5d:	00 00 00 
  80ad60:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  80ad62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad66:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  80ad6d:	00 00 00 
  80ad70:	48 89 c7             	mov    %rax,%rdi
  80ad73:	48 b8 f9 cf 80 00 00 	movabs $0x80cff9,%rax
  80ad7a:	00 00 00 
  80ad7d:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY);
  80ad7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad83:	48 be 68 22 82 00 00 	movabs $0x822268,%rsi
  80ad8a:	00 00 00 
  80ad8d:	48 89 c7             	mov    %rax,%rdi
  80ad90:	48 b8 26 d0 80 00 00 	movabs $0x80d026,%rax
  80ad97:	00 00 00 
  80ad9a:	ff d0                	callq  *%rax
  
  /* TODO: netif_down(netif); */
  return result;
  80ad9c:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80ada0:	c9                   	leaveq 
  80ada1:	c3                   	retq   

000000000080ada2 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  80ada2:	55                   	push   %rbp
  80ada3:	48 89 e5             	mov    %rsp,%rbp
  80ada6:	48 83 ec 20          	sub    $0x20,%rsp
  80adaa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80adae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80adb2:	48 8b 40 38          	mov    0x38(%rax),%rax
  80adb6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  80adba:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80adbf:	75 2a                	jne    80adeb <dhcp_stop+0x49>
  80adc1:	48 ba bc 14 82 00 00 	movabs $0x8214bc,%rdx
  80adc8:	00 00 00 
  80adcb:	be 2c 04 00 00       	mov    $0x42c,%esi
  80add0:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80add7:	00 00 00 
  80adda:	b8 00 00 00 00       	mov    $0x0,%eax
  80addf:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80ade6:	00 00 00 
  80ade9:	ff d1                	callq  *%rcx
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80adeb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80adef:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80adf3:	83 e0 f7             	and    $0xfffffff7,%eax
  80adf6:	89 c2                	mov    %eax,%edx
  80adf8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80adfc:	88 50 4a             	mov    %dl,0x4a(%rax)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  80adff:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ae04:	0f 84 92 00 00 00    	je     80ae9c <dhcp_stop+0xfa>
    if (dhcp->pcb != NULL) {
  80ae0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae0e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ae12:	48 85 c0             	test   %rax,%rax
  80ae15:	74 23                	je     80ae3a <dhcp_stop+0x98>
      udp_remove(dhcp->pcb);
  80ae17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae1b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ae1f:	48 89 c7             	mov    %rax,%rdi
  80ae22:	48 b8 6b 55 81 00 00 	movabs $0x81556b,%rax
  80ae29:	00 00 00 
  80ae2c:	ff d0                	callq  *%rax
      dhcp->pcb = NULL;
  80ae2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae32:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80ae39:	00 
    }
    if (dhcp->p != NULL) {
  80ae3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae3e:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ae42:	48 85 c0             	test   %rax,%rax
  80ae45:	74 23                	je     80ae6a <dhcp_stop+0xc8>
      pbuf_free(dhcp->p);
  80ae47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae4b:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ae4f:	48 89 c7             	mov    %rax,%rdi
  80ae52:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  80ae59:	00 00 00 
  80ae5c:	ff d0                	callq  *%rax
      dhcp->p = NULL;
  80ae5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae62:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80ae69:	00 
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  80ae6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae6e:	48 89 c7             	mov    %rax,%rdi
  80ae71:	48 b8 ca b3 80 00 00 	movabs $0x80b3ca,%rax
  80ae78:	00 00 00 
  80ae7b:	ff d0                	callq  *%rax
    mem_free((void *)dhcp);
  80ae7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae81:	48 89 c7             	mov    %rax,%rdi
  80ae84:	48 b8 c9 c1 80 00 00 	movabs $0x80c1c9,%rax
  80ae8b:	00 00 00 
  80ae8e:	ff d0                	callq  *%rax
    netif->dhcp = NULL;
  80ae90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ae94:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80ae9b:	00 
  }
}
  80ae9c:	c9                   	leaveq 
  80ae9d:	c3                   	retq   

000000000080ae9e <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  80ae9e:	55                   	push   %rbp
  80ae9f:	48 89 e5             	mov    %rsp,%rbp
  80aea2:	48 83 ec 0c          	sub    $0xc,%rsp
  80aea6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80aeaa:	89 f0                	mov    %esi,%eax
  80aeac:	88 45 f4             	mov    %al,-0xc(%rbp)
  if (new_state != dhcp->state) {
  80aeaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aeb3:	0f b6 00             	movzbl (%rax),%eax
  80aeb6:	3a 45 f4             	cmp    -0xc(%rbp),%al
  80aeb9:	74 12                	je     80aecd <dhcp_set_state+0x2f>
    dhcp->state = new_state;
  80aebb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aebf:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  80aec3:	88 10                	mov    %dl,(%rax)
    dhcp->tries = 0;
  80aec5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aec9:	c6 40 01 00          	movb   $0x0,0x1(%rax)
  }
}
  80aecd:	c9                   	leaveq 
  80aece:	c3                   	retq   

000000000080aecf <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  80aecf:	55                   	push   %rbp
  80aed0:	48 89 e5             	mov    %rsp,%rbp
  80aed3:	48 83 ec 10          	sub    $0x10,%rsp
  80aed7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80aedb:	89 f1                	mov    %esi,%ecx
  80aedd:	89 d0                	mov    %edx,%eax
  80aedf:	88 4d f4             	mov    %cl,-0xc(%rbp)
  80aee2:	88 45 f0             	mov    %al,-0x10(%rbp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  80aee5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aee9:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80aeed:	0f b7 d0             	movzwl %ax,%edx
  80aef0:	0f b6 45 f0          	movzbl -0x10(%rbp),%eax
  80aef4:	01 d0                	add    %edx,%eax
  80aef6:	83 c0 02             	add    $0x2,%eax
  80aef9:	83 f8 44             	cmp    $0x44,%eax
  80aefc:	76 2a                	jbe    80af28 <dhcp_option+0x59>
  80aefe:	48 ba d8 14 82 00 00 	movabs $0x8214d8,%rdx
  80af05:	00 00 00 
  80af08:	be 5a 04 00 00       	mov    $0x45a,%esi
  80af0d:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80af14:	00 00 00 
  80af17:	b8 00 00 00 00       	mov    $0x0,%eax
  80af1c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80af23:	00 00 00 
  80af26:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  80af28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af2c:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80af30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af34:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80af38:	8d 70 01             	lea    0x1(%rax),%esi
  80af3b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80af3f:	66 89 71 40          	mov    %si,0x40(%rcx)
  80af43:	0f b7 c0             	movzwl %ax,%eax
  80af46:	48 98                	cltq   
  80af48:	0f b6 4d f4          	movzbl -0xc(%rbp),%ecx
  80af4c:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  80af53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af57:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80af5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af5f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80af63:	8d 70 01             	lea    0x1(%rax),%esi
  80af66:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80af6a:	66 89 71 40          	mov    %si,0x40(%rcx)
  80af6e:	0f b7 c0             	movzwl %ax,%eax
  80af71:	48 98                	cltq   
  80af73:	0f b6 4d f0          	movzbl -0x10(%rbp),%ecx
  80af77:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80af7e:	c9                   	leaveq 
  80af7f:	c3                   	retq   

000000000080af80 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80af80:	55                   	push   %rbp
  80af81:	48 89 e5             	mov    %rsp,%rbp
  80af84:	48 83 ec 10          	sub    $0x10,%rsp
  80af88:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80af8c:	89 f0                	mov    %esi,%eax
  80af8e:	88 45 f4             	mov    %al,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80af91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af95:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80af99:	66 83 f8 43          	cmp    $0x43,%ax
  80af9d:	76 2a                	jbe    80afc9 <dhcp_option_byte+0x49>
  80af9f:	48 ba 20 15 82 00 00 	movabs $0x821520,%rdx
  80afa6:	00 00 00 
  80afa9:	be 65 04 00 00       	mov    $0x465,%esi
  80afae:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80afb5:	00 00 00 
  80afb8:	b8 00 00 00 00       	mov    $0x0,%eax
  80afbd:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80afc4:	00 00 00 
  80afc7:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80afc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afcd:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80afd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afd5:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80afd9:	8d 70 01             	lea    0x1(%rax),%esi
  80afdc:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80afe0:	66 89 71 40          	mov    %si,0x40(%rcx)
  80afe4:	0f b7 c0             	movzwl %ax,%eax
  80afe7:	48 98                	cltq   
  80afe9:	0f b6 4d f4          	movzbl -0xc(%rbp),%ecx
  80afed:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80aff4:	c9                   	leaveq 
  80aff5:	c3                   	retq   

000000000080aff6 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  80aff6:	55                   	push   %rbp
  80aff7:	48 89 e5             	mov    %rsp,%rbp
  80affa:	48 83 ec 10          	sub    $0x10,%rsp
  80affe:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b002:	89 f0                	mov    %esi,%eax
  80b004:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80b008:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b00c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b010:	0f b7 c0             	movzwl %ax,%eax
  80b013:	83 c0 02             	add    $0x2,%eax
  80b016:	83 f8 44             	cmp    $0x44,%eax
  80b019:	76 2a                	jbe    80b045 <dhcp_option_short+0x4f>
  80b01b:	48 ba 60 15 82 00 00 	movabs $0x821560,%rdx
  80b022:	00 00 00 
  80b025:	be 6c 04 00 00       	mov    $0x46c,%esi
  80b02a:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80b031:	00 00 00 
  80b034:	b8 00 00 00 00       	mov    $0x0,%eax
  80b039:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80b040:	00 00 00 
  80b043:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80b045:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b049:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b04d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b051:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b055:	8d 70 01             	lea    0x1(%rax),%esi
  80b058:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b05c:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b060:	0f b7 c0             	movzwl %ax,%eax
  80b063:	0f b7 4d f4          	movzwl -0xc(%rbp),%ecx
  80b067:	66 c1 e9 08          	shr    $0x8,%cx
  80b06b:	48 98                	cltq   
  80b06d:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  80b074:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b078:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b07c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b080:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b084:	8d 70 01             	lea    0x1(%rax),%esi
  80b087:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b08b:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b08f:	0f b7 c0             	movzwl %ax,%eax
  80b092:	0f b7 4d f4          	movzwl -0xc(%rbp),%ecx
  80b096:	48 98                	cltq   
  80b098:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b09f:	c9                   	leaveq 
  80b0a0:	c3                   	retq   

000000000080b0a1 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  80b0a1:	55                   	push   %rbp
  80b0a2:	48 89 e5             	mov    %rsp,%rbp
  80b0a5:	48 83 ec 10          	sub    $0x10,%rsp
  80b0a9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b0ad:	89 75 f4             	mov    %esi,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  80b0b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0b4:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b0b8:	0f b7 c0             	movzwl %ax,%eax
  80b0bb:	83 c0 04             	add    $0x4,%eax
  80b0be:	83 f8 44             	cmp    $0x44,%eax
  80b0c1:	76 2a                	jbe    80b0ed <dhcp_option_long+0x4c>
  80b0c3:	48 ba a8 15 82 00 00 	movabs $0x8215a8,%rdx
  80b0ca:	00 00 00 
  80b0cd:	be 74 04 00 00       	mov    $0x474,%esi
  80b0d2:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80b0d9:	00 00 00 
  80b0dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80b0e1:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80b0e8:	00 00 00 
  80b0eb:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  80b0ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0f1:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b0f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0f9:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b0fd:	8d 70 01             	lea    0x1(%rax),%esi
  80b100:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b104:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b108:	0f b7 c0             	movzwl %ax,%eax
  80b10b:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b10e:	c1 e9 18             	shr    $0x18,%ecx
  80b111:	48 98                	cltq   
  80b113:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  80b11a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b11e:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b122:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b126:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b12a:	8d 70 01             	lea    0x1(%rax),%esi
  80b12d:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b131:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b135:	0f b7 c0             	movzwl %ax,%eax
  80b138:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b13b:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
  80b141:	48 c1 e9 10          	shr    $0x10,%rcx
  80b145:	48 98                	cltq   
  80b147:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  80b14e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b152:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b156:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b15a:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b15e:	8d 70 01             	lea    0x1(%rax),%esi
  80b161:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b165:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b169:	0f b7 c0             	movzwl %ax,%eax
  80b16c:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b16f:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80b175:	48 c1 e9 08          	shr    $0x8,%rcx
  80b179:	48 98                	cltq   
  80b17b:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  80b182:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b186:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b18a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b18e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b192:	8d 70 01             	lea    0x1(%rax),%esi
  80b195:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b199:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b19d:	0f b7 c0             	movzwl %ax,%eax
  80b1a0:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b1a3:	48 98                	cltq   
  80b1a5:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b1ac:	c9                   	leaveq 
  80b1ad:	c3                   	retq   

000000000080b1ae <dhcp_unfold_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  80b1ae:	55                   	push   %rbp
  80b1af:	48 89 e5             	mov    %rsp,%rbp
  80b1b2:	48 83 ec 20          	sub    $0x20,%rsp
  80b1b6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  80b1ba:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b1bf:	75 2a                	jne    80b1eb <dhcp_unfold_reply+0x3d>
  80b1c1:	48 ba e8 15 82 00 00 	movabs $0x8215e8,%rdx
  80b1c8:	00 00 00 
  80b1cb:	be 89 04 00 00       	mov    $0x489,%esi
  80b1d0:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80b1d7:	00 00 00 
  80b1da:	b8 00 00 00 00       	mov    $0x0,%eax
  80b1df:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80b1e6:	00 00 00 
  80b1e9:	ff d1                	callq  *%rcx
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80b1eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b1ef:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b1f3:	48 85 c0             	test   %rax,%rax
  80b1f6:	75 2a                	jne    80b222 <dhcp_unfold_reply+0x74>
  80b1f8:	48 ba f5 15 82 00 00 	movabs $0x8215f5,%rdx
  80b1ff:	00 00 00 
  80b202:	be 8a 04 00 00       	mov    $0x48a,%esi
  80b207:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80b20e:	00 00 00 
  80b211:	b8 00 00 00 00       	mov    $0x0,%eax
  80b216:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80b21d:	00 00 00 
  80b220:	ff d1                	callq  *%rcx
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80b222:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b226:	48 89 c7             	mov    %rax,%rdi
  80b229:	48 b8 ca b3 80 00 00 	movabs $0x80b3ca,%rax
  80b230:	00 00 00 
  80b233:	ff d0                	callq  *%rax
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80b235:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b239:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b23d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80b241:	66 3d f0 00          	cmp    $0xf0,%ax
  80b245:	76 52                	jbe    80b299 <dhcp_unfold_reply+0xeb>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b247:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b24b:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b24f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80b253:	8d 90 10 ff ff ff    	lea    -0xf0(%rax),%edx
  80b259:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b25d:	66 89 50 28          	mov    %dx,0x28(%rax)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80b261:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b265:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b269:	0f b7 c0             	movzwl %ax,%eax
  80b26c:	89 c7                	mov    %eax,%edi
  80b26e:	48 b8 65 c6 80 00 00 	movabs $0x80c665,%rax
  80b275:	00 00 00 
  80b278:	ff d0                	callq  *%rax
  80b27a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b27e:	48 89 42 20          	mov    %rax,0x20(%rdx)
    if (dhcp->options_in == NULL) {
  80b282:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b286:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b28a:	48 85 c0             	test   %rax,%rax
  80b28d:	75 0a                	jne    80b299 <dhcp_unfold_reply+0xeb>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
  80b28f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b294:	e9 2f 01 00 00       	jmpq   80b3c8 <dhcp_unfold_reply+0x21a>
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b299:	bf f0 00 00 00       	mov    $0xf0,%edi
  80b29e:	48 b8 65 c6 80 00 00 	movabs $0x80c665,%rax
  80b2a5:	00 00 00 
  80b2a8:	ff d0                	callq  *%rax
  80b2aa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b2ae:	48 89 42 18          	mov    %rax,0x18(%rdx)
  if (dhcp->msg_in == NULL) {
  80b2b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b2b6:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b2ba:	48 85 c0             	test   %rax,%rax
  80b2bd:	75 2d                	jne    80b2ec <dhcp_unfold_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  80b2bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b2c3:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b2c7:	48 89 c7             	mov    %rax,%rdi
  80b2ca:	48 b8 c9 c1 80 00 00 	movabs $0x80c1c9,%rax
  80b2d1:	00 00 00 
  80b2d4:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b2d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b2da:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b2e1:	00 
    return ERR_MEM;
  80b2e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b2e7:	e9 dc 00 00 00       	jmpq   80b3c8 <dhcp_unfold_reply+0x21a>
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80b2ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b2f0:	48 8b 70 18          	mov    0x18(%rax),%rsi
  80b2f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b2f8:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b2fc:	b9 00 00 00 00       	mov    $0x0,%ecx
  80b301:	ba f0 00 00 00       	mov    $0xf0,%edx
  80b306:	48 89 c7             	mov    %rax,%rdi
  80b309:	48 b8 1d e1 80 00 00 	movabs $0x80e11d,%rax
  80b310:	00 00 00 
  80b313:	ff d0                	callq  *%rax
  80b315:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b319:	66 81 7d fe f0 00    	cmpw   $0xf0,-0x2(%rbp)
  80b31f:	74 2a                	je     80b34b <dhcp_unfold_reply+0x19d>
  80b321:	48 ba 08 16 82 00 00 	movabs $0x821608,%rdx
  80b328:	00 00 00 
  80b32b:	be a0 04 00 00       	mov    $0x4a0,%esi
  80b330:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80b337:	00 00 00 
  80b33a:	b8 00 00 00 00       	mov    $0x0,%eax
  80b33f:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80b346:	00 00 00 
  80b349:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  80b34b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b34f:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b353:	48 85 c0             	test   %rax,%rax
  80b356:	74 6b                	je     80b3c3 <dhcp_unfold_reply+0x215>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b358:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b35c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b360:	0f b7 d0             	movzwl %ax,%edx
  80b363:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b367:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80b36b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b36f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b373:	b9 f0 00 00 00       	mov    $0xf0,%ecx
  80b378:	48 89 c7             	mov    %rax,%rdi
  80b37b:	48 b8 1d e1 80 00 00 	movabs $0x80e11d,%rax
  80b382:	00 00 00 
  80b385:	ff d0                	callq  *%rax
  80b387:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80b38b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b38f:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b393:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80b397:	74 2a                	je     80b3c3 <dhcp_unfold_reply+0x215>
  80b399:	48 ba 3a 16 82 00 00 	movabs $0x82163a,%rdx
  80b3a0:	00 00 00 
  80b3a3:	be a7 04 00 00       	mov    $0x4a7,%esi
  80b3a8:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80b3af:	00 00 00 
  80b3b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3b7:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80b3be:	00 00 00 
  80b3c1:	ff d1                	callq  *%rcx
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes to dhcp->options_in[]\n",
      dhcp->options_in_len));
  }
  LWIP_UNUSED_ARG(ret);
  return ERR_OK;
  80b3c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b3c8:	c9                   	leaveq 
  80b3c9:	c3                   	retq   

000000000080b3ca <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  80b3ca:	55                   	push   %rbp
  80b3cb:	48 89 e5             	mov    %rsp,%rbp
  80b3ce:	48 83 ec 10          	sub    $0x10,%rsp
  80b3d2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (dhcp->msg_in != NULL) {
  80b3d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b3da:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b3de:	48 85 c0             	test   %rax,%rax
  80b3e1:	74 23                	je     80b406 <dhcp_free_reply+0x3c>
    mem_free((void *)dhcp->msg_in);
  80b3e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b3e7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b3eb:	48 89 c7             	mov    %rax,%rdi
  80b3ee:	48 b8 c9 c1 80 00 00 	movabs $0x80c1c9,%rax
  80b3f5:	00 00 00 
  80b3f8:	ff d0                	callq  *%rax
    dhcp->msg_in = NULL;
  80b3fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b3fe:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  80b405:	00 
  }
  if (dhcp->options_in) {
  80b406:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b40a:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b40e:	48 85 c0             	test   %rax,%rax
  80b411:	74 2d                	je     80b440 <dhcp_free_reply+0x76>
    mem_free((void *)dhcp->options_in);
  80b413:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b417:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b41b:	48 89 c7             	mov    %rax,%rdi
  80b41e:	48 b8 c9 c1 80 00 00 	movabs $0x80c1c9,%rax
  80b425:	00 00 00 
  80b428:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b42a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b42e:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b435:	00 
    dhcp->options_in_len = 0;
  80b436:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b43a:	66 c7 40 28 00 00    	movw   $0x0,0x28(%rax)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  80b440:	c9                   	leaveq 
  80b441:	c3                   	retq   

000000000080b442 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  80b442:	55                   	push   %rbp
  80b443:	48 89 e5             	mov    %rsp,%rbp
  80b446:	48 83 ec 60          	sub    $0x60,%rsp
  80b44a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80b44e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80b452:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80b456:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80b45a:	44 89 c0             	mov    %r8d,%eax
  80b45d:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct netif *netif = (struct netif *)arg;
  80b461:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80b465:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80b469:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b46d:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b471:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  80b475:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b479:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b47d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  80b481:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b485:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80b489:	48 89 50 10          	mov    %rdx,0x10(%rax)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80b48d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b491:	0f b6 00             	movzbl (%rax),%eax
  80b494:	3c 02                	cmp    $0x2,%al
  80b496:	74 05                	je     80b49d <dhcp_recv+0x5b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  80b498:	e9 d4 01 00 00       	jmpq   80b671 <dhcp_recv+0x22f>
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b49d:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  80b4a1:	eb 31                	jmp    80b4d4 <dhcp_recv+0x92>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  80b4a3:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b4a7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80b4ab:	48 98                	cltq   
  80b4ad:	0f b6 4c 02 41       	movzbl 0x41(%rdx,%rax,1),%ecx
  80b4b2:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b4b6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b4ba:	48 98                	cltq   
  80b4bc:	0f b6 44 02 1c       	movzbl 0x1c(%rdx,%rax,1),%eax
  80b4c1:	38 c1                	cmp    %al,%cl
  80b4c3:	74 05                	je     80b4ca <dhcp_recv+0x88>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
  80b4c5:	e9 a7 01 00 00       	jmpq   80b671 <dhcp_recv+0x22f>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b4ca:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b4ce:	83 c0 01             	add    $0x1,%eax
  80b4d1:	88 45 ff             	mov    %al,-0x1(%rbp)
  80b4d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b4d8:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80b4dc:	3a 45 ff             	cmp    -0x1(%rbp),%al
  80b4df:	77 c2                	ja     80b4a3 <dhcp_recv+0x61>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80b4e1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b4e5:	8b 40 04             	mov    0x4(%rax),%eax
  80b4e8:	89 c7                	mov    %eax,%edi
  80b4ea:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  80b4f1:	00 00 00 
  80b4f4:	ff d0                	callq  *%rax
  80b4f6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b4fa:	8b 52 04             	mov    0x4(%rdx),%edx
  80b4fd:	39 d0                	cmp    %edx,%eax
  80b4ff:	74 05                	je     80b506 <dhcp_recv+0xc4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  80b501:	e9 6b 01 00 00       	jmpq   80b671 <dhcp_recv+0x22f>
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
  80b506:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b50a:	48 89 c7             	mov    %rax,%rdi
  80b50d:	48 b8 ae b1 80 00 00 	movabs $0x80b1ae,%rax
  80b514:	00 00 00 
  80b517:	ff d0                	callq  *%rax
  80b519:	84 c0                	test   %al,%al
  80b51b:	74 05                	je     80b522 <dhcp_recv+0xe0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
  80b51d:	e9 4f 01 00 00       	jmpq   80b671 <dhcp_recv+0x22f>
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80b522:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b526:	be 35 00 00 00       	mov    $0x35,%esi
  80b52b:	48 89 c7             	mov    %rax,%rdi
  80b52e:	48 b8 65 bc 80 00 00 	movabs $0x80bc65,%rax
  80b535:	00 00 00 
  80b538:	ff d0                	callq  *%rax
  80b53a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (options_ptr == NULL) {
  80b53e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b543:	75 05                	jne    80b54a <dhcp_recv+0x108>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  80b545:	e9 27 01 00 00       	jmpq   80b671 <dhcp_recv+0x22f>
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  80b54a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b54e:	48 83 c0 02          	add    $0x2,%rax
  80b552:	48 89 c7             	mov    %rax,%rdi
  80b555:	48 b8 27 be 80 00 00 	movabs $0x80be27,%rax
  80b55c:	00 00 00 
  80b55f:	ff d0                	callq  *%rax
  80b561:	88 45 d7             	mov    %al,-0x29(%rbp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80b564:	80 7d d7 05          	cmpb   $0x5,-0x29(%rbp)
  80b568:	0f 85 84 00 00 00    	jne    80b5f2 <dhcp_recv+0x1b0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80b56e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b572:	0f b6 00             	movzbl (%rax),%eax
  80b575:	3c 01                	cmp    $0x1,%al
  80b577:	75 35                	jne    80b5ae <dhcp_recv+0x16c>
      dhcp_handle_ack(netif);
  80b579:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b57d:	48 89 c7             	mov    %rax,%rdi
  80b580:	48 b8 f4 98 80 00 00 	movabs $0x8098f4,%rax
  80b587:	00 00 00 
  80b58a:	ff d0                	callq  *%rax
      dhcp->request_timeout = 0;
  80b58c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b590:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  80b596:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b59a:	48 89 c7             	mov    %rax,%rdi
  80b59d:	48 b8 b6 91 80 00 00 	movabs $0x8091b6,%rax
  80b5a4:	00 00 00 
  80b5a7:	ff d0                	callq  *%rax
  80b5a9:	e9 c3 00 00 00       	jmpq   80b671 <dhcp_recv+0x22f>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  80b5ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5b2:	0f b6 00             	movzbl (%rax),%eax
  80b5b5:	3c 03                	cmp    $0x3,%al
  80b5b7:	74 1a                	je     80b5d3 <dhcp_recv+0x191>
  80b5b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5bd:	0f b6 00             	movzbl (%rax),%eax
  80b5c0:	3c 04                	cmp    $0x4,%al
  80b5c2:	74 0f                	je     80b5d3 <dhcp_recv+0x191>
  80b5c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5c8:	0f b6 00             	movzbl (%rax),%eax
  80b5cb:	3c 05                	cmp    $0x5,%al
  80b5cd:	0f 85 9e 00 00 00    	jne    80b671 <dhcp_recv+0x22f>
      dhcp->request_timeout = 0;
  80b5d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5d7:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
      dhcp_bind(netif);
  80b5dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b5e1:	48 89 c7             	mov    %rax,%rdi
  80b5e4:	48 b8 17 a5 80 00 00 	movabs $0x80a517,%rax
  80b5eb:	00 00 00 
  80b5ee:	ff d0                	callq  *%rax
  80b5f0:	eb 7f                	jmp    80b671 <dhcp_recv+0x22f>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b5f2:	80 7d d7 06          	cmpb   $0x6,-0x29(%rbp)
  80b5f6:	75 4b                	jne    80b643 <dhcp_recv+0x201>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b5f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5fc:	0f b6 00             	movzbl (%rax),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b5ff:	3c 03                	cmp    $0x3,%al
  80b601:	74 21                	je     80b624 <dhcp_recv+0x1e2>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b603:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b607:	0f b6 00             	movzbl (%rax),%eax
  80b60a:	3c 01                	cmp    $0x1,%al
  80b60c:	74 16                	je     80b624 <dhcp_recv+0x1e2>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b60e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b612:	0f b6 00             	movzbl (%rax),%eax
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b615:	3c 04                	cmp    $0x4,%al
  80b617:	74 0b                	je     80b624 <dhcp_recv+0x1e2>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b619:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b61d:	0f b6 00             	movzbl (%rax),%eax
  80b620:	3c 05                	cmp    $0x5,%al
  80b622:	75 1f                	jne    80b643 <dhcp_recv+0x201>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  80b624:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b628:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    dhcp_handle_nak(netif);
  80b62e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b632:	48 89 c7             	mov    %rax,%rdi
  80b635:	48 b8 07 91 80 00 00 	movabs $0x809107,%rax
  80b63c:	00 00 00 
  80b63f:	ff d0                	callq  *%rax
  80b641:	eb 2e                	jmp    80b671 <dhcp_recv+0x22f>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80b643:	80 7d d7 02          	cmpb   $0x2,-0x29(%rbp)
  80b647:	75 28                	jne    80b671 <dhcp_recv+0x22f>
  80b649:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b64d:	0f b6 00             	movzbl (%rax),%eax
  80b650:	3c 06                	cmp    $0x6,%al
  80b652:	75 1d                	jne    80b671 <dhcp_recv+0x22f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  80b654:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b658:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    /* remember offered lease */
    dhcp_handle_offer(netif);
  80b65e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b662:	48 89 c7             	mov    %rax,%rdi
  80b665:	48 b8 4f 92 80 00 00 	movabs $0x80924f,%rax
  80b66c:	00 00 00 
  80b66f:	ff d0                	callq  *%rax
  }
free_pbuf_and_return:
  pbuf_free(p);
  80b671:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b675:	48 89 c7             	mov    %rax,%rdi
  80b678:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  80b67f:	00 00 00 
  80b682:	ff d0                	callq  *%rax
  dhcp->p = NULL;
  80b684:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b688:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80b68f:	00 
}
  80b690:	c9                   	leaveq 
  80b691:	c3                   	retq   

000000000080b692 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  80b692:	55                   	push   %rbp
  80b693:	48 89 e5             	mov    %rsp,%rbp
  80b696:	53                   	push   %rbx
  80b697:	48 83 ec 28          	sub    $0x28,%rsp
  80b69b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  80b69f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b6a4:	75 2a                	jne    80b6d0 <dhcp_create_request+0x3e>
  80b6a6:	48 ba 58 16 82 00 00 	movabs $0x821658,%rdx
  80b6ad:	00 00 00 
  80b6b0:	be 2d 05 00 00       	mov    $0x52d,%esi
  80b6b5:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80b6bc:	00 00 00 
  80b6bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80b6c4:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80b6cb:	00 00 00 
  80b6ce:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80b6d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b6d4:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b6d8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  80b6dc:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80b6e1:	75 2a                	jne    80b70d <dhcp_create_request+0x7b>
  80b6e3:	48 ba 80 16 82 00 00 	movabs $0x821680,%rdx
  80b6ea:	00 00 00 
  80b6ed:	be 2f 05 00 00       	mov    $0x52f,%esi
  80b6f2:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80b6f9:	00 00 00 
  80b6fc:	b8 00 00 00 00       	mov    $0x0,%eax
  80b701:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80b708:	00 00 00 
  80b70b:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  80b70d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b711:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b715:	48 85 c0             	test   %rax,%rax
  80b718:	74 2a                	je     80b744 <dhcp_create_request+0xb2>
  80b71a:	48 ba a8 16 82 00 00 	movabs $0x8216a8,%rdx
  80b721:	00 00 00 
  80b724:	be 30 05 00 00       	mov    $0x530,%esi
  80b729:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80b730:	00 00 00 
  80b733:	b8 00 00 00 00       	mov    $0x0,%eax
  80b738:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80b73f:	00 00 00 
  80b742:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  80b744:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b748:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b74c:	48 85 c0             	test   %rax,%rax
  80b74f:	74 2a                	je     80b77b <dhcp_create_request+0xe9>
  80b751:	48 ba d8 16 82 00 00 	movabs $0x8216d8,%rdx
  80b758:	00 00 00 
  80b75b:	be 31 05 00 00       	mov    $0x531,%esi
  80b760:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80b767:	00 00 00 
  80b76a:	b8 00 00 00 00       	mov    $0x0,%eax
  80b76f:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80b776:	00 00 00 
  80b779:	ff d1                	callq  *%rcx
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  80b77b:	ba 00 00 00 00       	mov    $0x0,%edx
  80b780:	be 34 01 00 00       	mov    $0x134,%esi
  80b785:	bf 00 00 00 00       	mov    $0x0,%edi
  80b78a:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  80b791:	00 00 00 
  80b794:	ff d0                	callq  *%rax
  80b796:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b79a:	48 89 42 30          	mov    %rax,0x30(%rdx)
  if (dhcp->p_out == NULL) {
  80b79e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b7a2:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b7a6:	48 85 c0             	test   %rax,%rax
  80b7a9:	75 0a                	jne    80b7b5 <dhcp_create_request+0x123>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  80b7ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b7b0:	e9 2b 02 00 00       	jmpq   80b9e0 <dhcp_create_request+0x34e>
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80b7b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b7b9:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b7bd:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80b7c1:	66 3d 33 01          	cmp    $0x133,%ax
  80b7c5:	77 2a                	ja     80b7f1 <dhcp_create_request+0x15f>
  80b7c7:	48 ba 08 17 82 00 00 	movabs $0x821708,%rdx
  80b7ce:	00 00 00 
  80b7d1:	be 38 05 00 00       	mov    $0x538,%esi
  80b7d6:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80b7dd:	00 00 00 
  80b7e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b7e5:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80b7ec:	00 00 00 
  80b7ef:	ff d1                	callq  *%rcx
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  80b7f1:	48 b8 7c 81 82 00 00 	movabs $0x82817c,%rax
  80b7f8:	00 00 00 
  80b7fb:	8b 00                	mov    (%rax),%eax
  80b7fd:	8d 48 01             	lea    0x1(%rax),%ecx
  80b800:	48 ba 7c 81 82 00 00 	movabs $0x82817c,%rdx
  80b807:	00 00 00 
  80b80a:	89 0a                	mov    %ecx,(%rdx)
  80b80c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b810:	89 42 04             	mov    %eax,0x4(%rdx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  80b813:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b817:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b81b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80b81f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b823:	48 89 50 38          	mov    %rdx,0x38(%rax)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  80b827:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b82b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b82f:	c6 00 01             	movb   $0x1,(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  80b832:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b836:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b83a:	c6 40 01 01          	movb   $0x1,0x1(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  80b83e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b842:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b846:	c6 40 02 06          	movb   $0x6,0x2(%rax)
  dhcp->msg_out->hops = 0;
  80b84a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b84e:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b852:	c6 40 03 00          	movb   $0x0,0x3(%rax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  80b856:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b85a:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80b85e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b862:	8b 40 04             	mov    0x4(%rax),%eax
  80b865:	89 c7                	mov    %eax,%edi
  80b867:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  80b86e:	00 00 00 
  80b871:	ff d0                	callq  *%rax
  80b873:	89 43 04             	mov    %eax,0x4(%rbx)
  dhcp->msg_out->secs = 0;
  80b876:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b87a:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b87e:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
  dhcp->msg_out->flags = 0;
  80b884:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b888:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b88c:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  80b892:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b896:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b89a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80b89e:	8b 52 08             	mov    0x8(%rdx),%edx
  80b8a1:	89 50 0c             	mov    %edx,0xc(%rax)
  dhcp->msg_out->yiaddr.addr = 0;
  80b8a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b8a8:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b8ac:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  dhcp->msg_out->siaddr.addr = 0;
  80b8b3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b8b7:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b8bb:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
  dhcp->msg_out->giaddr.addr = 0;
  80b8c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b8c6:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b8ca:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80b8d1:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b8d7:	eb 45                	jmp    80b91e <dhcp_create_request+0x28c>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  80b8d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b8dd:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80b8e1:	0f b7 75 ee          	movzwl -0x12(%rbp),%esi
  80b8e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b8e9:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80b8ed:	0f b6 c0             	movzbl %al,%eax
  80b8f0:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80b8f4:	76 11                	jbe    80b907 <dhcp_create_request+0x275>
  80b8f6:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b8fa:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80b8fe:	48 98                	cltq   
  80b900:	0f b6 44 02 41       	movzbl 0x41(%rdx,%rax,1),%eax
  80b905:	eb 05                	jmp    80b90c <dhcp_create_request+0x27a>
  80b907:	b8 00 00 00 00       	mov    $0x0,%eax
  80b90c:	48 63 d6             	movslq %esi,%rdx
  80b90f:	88 44 11 1c          	mov    %al,0x1c(%rcx,%rdx,1)
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80b913:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b917:	83 c0 01             	add    $0x1,%eax
  80b91a:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80b91e:	66 83 7d ee 0f       	cmpw   $0xf,-0x12(%rbp)
  80b923:	76 b4                	jbe    80b8d9 <dhcp_create_request+0x247>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80b925:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b92b:	eb 1e                	jmp    80b94b <dhcp_create_request+0x2b9>
    dhcp->msg_out->sname[i] = 0;
  80b92d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b931:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b935:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b939:	48 98                	cltq   
  80b93b:	c6 44 02 2c 00       	movb   $0x0,0x2c(%rdx,%rax,1)
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80b940:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b944:	83 c0 01             	add    $0x1,%eax
  80b947:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80b94b:	66 83 7d ee 3f       	cmpw   $0x3f,-0x12(%rbp)
  80b950:	76 db                	jbe    80b92d <dhcp_create_request+0x29b>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80b952:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b958:	eb 1e                	jmp    80b978 <dhcp_create_request+0x2e6>
    dhcp->msg_out->file[i] = 0;
  80b95a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b95e:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b962:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b966:	48 98                	cltq   
  80b968:	c6 44 02 6c 00       	movb   $0x0,0x6c(%rdx,%rax,1)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80b96d:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b971:	83 c0 01             	add    $0x1,%eax
  80b974:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80b978:	66 83 7d ee 7f       	cmpw   $0x7f,-0x12(%rbp)
  80b97d:	76 db                	jbe    80b95a <dhcp_create_request+0x2c8>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  80b97f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b983:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80b987:	bf 63 53 82 63       	mov    $0x63825363,%edi
  80b98c:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  80b993:	00 00 00 
  80b996:	ff d0                	callq  *%rax
  80b998:	89 83 ec 00 00 00    	mov    %eax,0xec(%rbx)
  dhcp->options_out_len = 0;
  80b99e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b9a2:	66 c7 40 40 00 00    	movw   $0x0,0x40(%rax)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80b9a8:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b9ae:	eb 24                	jmp    80b9d4 <dhcp_create_request+0x342>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  80b9b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b9b4:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b9b8:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b9bc:	0f b7 4d ee          	movzwl -0x12(%rbp),%ecx
  80b9c0:	48 98                	cltq   
  80b9c2:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80b9c9:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b9cd:	83 c0 01             	add    $0x1,%eax
  80b9d0:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80b9d4:	66 83 7d ee 43       	cmpw   $0x43,-0x12(%rbp)
  80b9d9:	76 d5                	jbe    80b9b0 <dhcp_create_request+0x31e>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  80b9db:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b9e0:	48 83 c4 28          	add    $0x28,%rsp
  80b9e4:	5b                   	pop    %rbx
  80b9e5:	5d                   	pop    %rbp
  80b9e6:	c3                   	retq   

000000000080b9e7 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  80b9e7:	55                   	push   %rbp
  80b9e8:	48 89 e5             	mov    %rsp,%rbp
  80b9eb:	48 83 ec 20          	sub    $0x20,%rsp
  80b9ef:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  80b9f3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b9f8:	75 2a                	jne    80ba24 <dhcp_delete_request+0x3d>
  80b9fa:	48 ba 50 17 82 00 00 	movabs $0x821750,%rdx
  80ba01:	00 00 00 
  80ba04:	be 69 05 00 00       	mov    $0x569,%esi
  80ba09:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80ba10:	00 00 00 
  80ba13:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba18:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80ba1f:	00 00 00 
  80ba22:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80ba24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ba28:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ba2c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  80ba30:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ba35:	75 2a                	jne    80ba61 <dhcp_delete_request+0x7a>
  80ba37:	48 ba 78 17 82 00 00 	movabs $0x821778,%rdx
  80ba3e:	00 00 00 
  80ba41:	be 6b 05 00 00       	mov    $0x56b,%esi
  80ba46:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80ba4d:	00 00 00 
  80ba50:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba55:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80ba5c:	00 00 00 
  80ba5f:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  80ba61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ba65:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ba69:	48 85 c0             	test   %rax,%rax
  80ba6c:	75 2a                	jne    80ba98 <dhcp_delete_request+0xb1>
  80ba6e:	48 ba a0 17 82 00 00 	movabs $0x8217a0,%rdx
  80ba75:	00 00 00 
  80ba78:	be 6c 05 00 00       	mov    $0x56c,%esi
  80ba7d:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80ba84:	00 00 00 
  80ba87:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba8c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80ba93:	00 00 00 
  80ba96:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  80ba98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ba9c:	48 8b 40 38          	mov    0x38(%rax),%rax
  80baa0:	48 85 c0             	test   %rax,%rax
  80baa3:	75 2a                	jne    80bacf <dhcp_delete_request+0xe8>
  80baa5:	48 ba d0 17 82 00 00 	movabs $0x8217d0,%rdx
  80baac:	00 00 00 
  80baaf:	be 6d 05 00 00       	mov    $0x56d,%esi
  80bab4:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80babb:	00 00 00 
  80babe:	b8 00 00 00 00       	mov    $0x0,%eax
  80bac3:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80baca:	00 00 00 
  80bacd:	ff d1                	callq  *%rcx
  if (dhcp->p_out != NULL) {
  80bacf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bad3:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bad7:	48 85 c0             	test   %rax,%rax
  80bada:	74 17                	je     80baf3 <dhcp_delete_request+0x10c>
    pbuf_free(dhcp->p_out);
  80badc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bae0:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bae4:	48 89 c7             	mov    %rax,%rdi
  80bae7:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  80baee:	00 00 00 
  80baf1:	ff d0                	callq  *%rax
  }
  dhcp->p_out = NULL;
  80baf3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80baf7:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80bafe:	00 
  dhcp->msg_out = NULL;
  80baff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bb03:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80bb0a:	00 
}
  80bb0b:	c9                   	leaveq 
  80bb0c:	c3                   	retq   

000000000080bb0d <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  80bb0d:	55                   	push   %rbp
  80bb0e:	48 89 e5             	mov    %rsp,%rbp
  80bb11:	48 83 ec 10          	sub    $0x10,%rsp
  80bb15:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  80bb19:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80bb1e:	75 2a                	jne    80bb4a <dhcp_option_trailer+0x3d>
  80bb20:	48 ba 00 18 82 00 00 	movabs $0x821800,%rdx
  80bb27:	00 00 00 
  80bb2a:	be 80 05 00 00       	mov    $0x580,%esi
  80bb2f:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80bb36:	00 00 00 
  80bb39:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb3e:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80bb45:	00 00 00 
  80bb48:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  80bb4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bb4e:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bb52:	48 85 c0             	test   %rax,%rax
  80bb55:	75 2a                	jne    80bb81 <dhcp_option_trailer+0x74>
  80bb57:	48 ba 28 18 82 00 00 	movabs $0x821828,%rdx
  80bb5e:	00 00 00 
  80bb61:	be 81 05 00 00       	mov    $0x581,%esi
  80bb66:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80bb6d:	00 00 00 
  80bb70:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb75:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80bb7c:	00 00 00 
  80bb7f:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80bb81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bb85:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bb89:	66 83 f8 43          	cmp    $0x43,%ax
  80bb8d:	76 2a                	jbe    80bbb9 <dhcp_option_trailer+0xac>
  80bb8f:	48 ba 58 18 82 00 00 	movabs $0x821858,%rdx
  80bb96:	00 00 00 
  80bb99:	be 82 05 00 00       	mov    $0x582,%esi
  80bb9e:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80bba5:	00 00 00 
  80bba8:	b8 00 00 00 00       	mov    $0x0,%eax
  80bbad:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80bbb4:	00 00 00 
  80bbb7:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  80bbb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bbbd:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bbc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bbc5:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bbc9:	8d 70 01             	lea    0x1(%rax),%esi
  80bbcc:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80bbd0:	66 89 71 40          	mov    %si,0x40(%rcx)
  80bbd4:	0f b7 c0             	movzwl %ax,%eax
  80bbd7:	48 98                	cltq   
  80bbd9:	c6 84 02 f0 00 00 00 	movb   $0xff,0xf0(%rdx,%rax,1)
  80bbe0:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80bbe1:	eb 60                	jmp    80bc43 <dhcp_option_trailer+0x136>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80bbe3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bbe7:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bbeb:	66 83 f8 43          	cmp    $0x43,%ax
  80bbef:	76 2a                	jbe    80bc1b <dhcp_option_trailer+0x10e>
  80bbf1:	48 ba 58 18 82 00 00 	movabs $0x821858,%rdx
  80bbf8:	00 00 00 
  80bbfb:	be 87 05 00 00       	mov    $0x587,%esi
  80bc00:	48 bf 76 14 82 00 00 	movabs $0x821476,%rdi
  80bc07:	00 00 00 
  80bc0a:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc0f:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80bc16:	00 00 00 
  80bc19:	ff d1                	callq  *%rcx
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  80bc1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bc1f:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bc23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bc27:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bc2b:	8d 70 01             	lea    0x1(%rax),%esi
  80bc2e:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80bc32:	66 89 71 40          	mov    %si,0x40(%rcx)
  80bc36:	0f b7 c0             	movzwl %ax,%eax
  80bc39:	48 98                	cltq   
  80bc3b:	c6 84 02 f0 00 00 00 	movb   $0x0,0xf0(%rdx,%rax,1)
  80bc42:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80bc43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bc47:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bc4b:	66 83 f8 43          	cmp    $0x43,%ax
  80bc4f:	76 92                	jbe    80bbe3 <dhcp_option_trailer+0xd6>
  80bc51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bc55:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bc59:	0f b7 c0             	movzwl %ax,%eax
  80bc5c:	83 e0 03             	and    $0x3,%eax
  80bc5f:	85 c0                	test   %eax,%eax
  80bc61:	75 80                	jne    80bbe3 <dhcp_option_trailer+0xd6>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  80bc63:	c9                   	leaveq 
  80bc64:	c3                   	retq   

000000000080bc65 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80bc65:	55                   	push   %rbp
  80bc66:	48 89 e5             	mov    %rsp,%rbp
  80bc69:	48 83 ec 2c          	sub    $0x2c,%rsp
  80bc6d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80bc71:	89 f0                	mov    %esi,%eax
  80bc73:	88 45 d4             	mov    %al,-0x2c(%rbp)
  u8_t overload = DHCP_OVERLOAD_NONE;
  80bc76:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80bc7a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bc7e:	48 8b 40 20          	mov    0x20(%rax),%rax
  80bc82:	48 85 c0             	test   %rax,%rax
  80bc85:	0f 84 95 01 00 00    	je     80be20 <dhcp_get_option_ptr+0x1bb>
  80bc8b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bc8f:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80bc93:	66 85 c0             	test   %ax,%ax
  80bc96:	0f 84 84 01 00 00    	je     80be20 <dhcp_get_option_ptr+0x1bb>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
  80bc9c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bca0:	48 8b 40 20          	mov    0x20(%rax),%rax
  80bca4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    u16_t offset = 0;
  80bca8:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80bcae:	e9 80 00 00 00       	jmpq   80bd33 <dhcp_get_option_ptr+0xce>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80bcb3:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bcb7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bcbb:	48 01 d0             	add    %rdx,%rax
  80bcbe:	0f b6 00             	movzbl (%rax),%eax
  80bcc1:	3c 34                	cmp    $0x34,%al
  80bcc3:	75 22                	jne    80bce7 <dhcp_get_option_ptr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  80bcc5:	66 83 45 ee 02       	addw   $0x2,-0x12(%rbp)
        overload = options[offset++];
  80bcca:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bcce:	8d 50 01             	lea    0x1(%rax),%edx
  80bcd1:	66 89 55 ee          	mov    %dx,-0x12(%rbp)
  80bcd5:	0f b7 d0             	movzwl %ax,%edx
  80bcd8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bcdc:	48 01 d0             	add    %rdx,%rax
  80bcdf:	0f b6 00             	movzbl (%rax),%eax
  80bce2:	88 45 ff             	mov    %al,-0x1(%rbp)
  80bce5:	eb 4c                	jmp    80bd33 <dhcp_get_option_ptr+0xce>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  80bce7:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bceb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bcef:	48 01 d0             	add    %rdx,%rax
  80bcf2:	0f b6 00             	movzbl (%rax),%eax
  80bcf5:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80bcf8:	75 10                	jne    80bd0a <dhcp_get_option_ptr+0xa5>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset %"U16_F" in options\n", offset));
        return &options[offset];
  80bcfa:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bcfe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bd02:	48 01 d0             	add    %rdx,%rax
  80bd05:	e9 1b 01 00 00       	jmpq   80be25 <dhcp_get_option_ptr+0x1c0>
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  80bd0a:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bd0e:	83 c0 01             	add    $0x1,%eax
  80bd11:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80bd15:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bd19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bd1d:	48 01 d0             	add    %rdx,%rax
  80bd20:	0f b6 00             	movzbl (%rax),%eax
  80bd23:	0f b6 d0             	movzbl %al,%edx
  80bd26:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bd2a:	01 d0                	add    %edx,%eax
  80bd2c:	83 c0 01             	add    $0x1,%eax
  80bd2f:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80bd33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bd37:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80bd3b:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80bd3f:	76 16                	jbe    80bd57 <dhcp_get_option_ptr+0xf2>
  80bd41:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bd45:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bd49:	48 01 d0             	add    %rdx,%rax
  80bd4c:	0f b6 00             	movzbl (%rax),%eax
  80bd4f:	3c ff                	cmp    $0xff,%al
  80bd51:	0f 85 5c ff ff ff    	jne    80bcb3 <dhcp_get_option_ptr+0x4e>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80bd57:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80bd5b:	0f 84 bf 00 00 00    	je     80be20 <dhcp_get_option_ptr+0x1bb>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  80bd61:	80 7d ff 01          	cmpb   $0x1,-0x1(%rbp)
  80bd65:	75 18                	jne    80bd7f <dhcp_get_option_ptr+0x11a>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  80bd67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bd6b:	48 8b 40 18          	mov    0x18(%rax),%rax
  80bd6f:	48 83 c0 6c          	add    $0x6c,%rax
  80bd73:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN;
  80bd77:	66 c7 45 ec 80 00    	movw   $0x80,-0x14(%rbp)
  80bd7d:	eb 34                	jmp    80bdb3 <dhcp_get_option_ptr+0x14e>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  80bd7f:	80 7d ff 02          	cmpb   $0x2,-0x1(%rbp)
  80bd83:	75 18                	jne    80bd9d <dhcp_get_option_ptr+0x138>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80bd85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bd89:	48 8b 40 18          	mov    0x18(%rax),%rax
  80bd8d:	48 83 c0 2c          	add    $0x2c,%rax
  80bd91:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_SNAME_LEN;
  80bd95:	66 c7 45 ec 40 00    	movw   $0x40,-0x14(%rbp)
  80bd9b:	eb 16                	jmp    80bdb3 <dhcp_get_option_ptr+0x14e>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80bd9d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bda1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80bda5:	48 83 c0 2c          	add    $0x2c,%rax
  80bda9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  80bdad:	66 c7 45 ec c0 00    	movw   $0xc0,-0x14(%rbp)
      }
      offset = 0;
  80bdb3:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80bdb9:	eb 49                	jmp    80be04 <dhcp_get_option_ptr+0x19f>
        if (options[offset] == option_type) {
  80bdbb:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bdbf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bdc3:	48 01 d0             	add    %rdx,%rax
  80bdc6:	0f b6 00             	movzbl (%rax),%eax
  80bdc9:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80bdcc:	75 0d                	jne    80bddb <dhcp_get_option_ptr+0x176>
           LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset=%"U16_F"\n", offset));
          return &options[offset];
  80bdce:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bdd2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bdd6:	48 01 d0             	add    %rdx,%rax
  80bdd9:	eb 4a                	jmp    80be25 <dhcp_get_option_ptr+0x1c0>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80bddb:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bddf:	83 c0 01             	add    $0x1,%eax
  80bde2:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
          offset += 1 + options[offset];
  80bde6:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bdea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bdee:	48 01 d0             	add    %rdx,%rax
  80bdf1:	0f b6 00             	movzbl (%rax),%eax
  80bdf4:	0f b6 d0             	movzbl %al,%edx
  80bdf7:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bdfb:	01 d0                	add    %edx,%eax
  80bdfd:	83 c0 01             	add    $0x1,%eax
  80be00:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80be04:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80be08:	66 3b 45 ec          	cmp    -0x14(%rbp),%ax
  80be0c:	73 12                	jae    80be20 <dhcp_get_option_ptr+0x1bb>
  80be0e:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80be12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80be16:	48 01 d0             	add    %rdx,%rax
  80be19:	0f b6 00             	movzbl (%rax),%eax
  80be1c:	3c ff                	cmp    $0xff,%al
  80be1e:	75 9b                	jne    80bdbb <dhcp_get_option_ptr+0x156>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80be20:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80be25:	c9                   	leaveq 
  80be26:	c3                   	retq   

000000000080be27 <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  80be27:	55                   	push   %rbp
  80be28:	48 89 e5             	mov    %rsp,%rbp
  80be2b:	48 83 ec 08          	sub    $0x8,%rsp
  80be2f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  80be33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be37:	0f b6 00             	movzbl (%rax),%eax
}
  80be3a:	c9                   	leaveq 
  80be3b:	c3                   	retq   

000000000080be3c <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  80be3c:	55                   	push   %rbp
  80be3d:	48 89 e5             	mov    %rsp,%rbp
  80be40:	48 83 ec 18          	sub    $0x18,%rsp
  80be44:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  80be48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80be4c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80be50:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80be54:	0f b6 00             	movzbl (%rax),%eax
  80be57:	0f b6 c0             	movzbl %al,%eax
  80be5a:	c1 e0 18             	shl    $0x18,%eax
  80be5d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++) << 16;
  80be60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80be64:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80be68:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80be6c:	0f b6 00             	movzbl (%rax),%eax
  80be6f:	0f b6 c0             	movzbl %al,%eax
  80be72:	c1 e0 10             	shl    $0x10,%eax
  80be75:	09 45 fc             	or     %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++) << 8;
  80be78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80be7c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80be80:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80be84:	0f b6 00             	movzbl (%rax),%eax
  80be87:	0f b6 c0             	movzbl %al,%eax
  80be8a:	c1 e0 08             	shl    $0x8,%eax
  80be8d:	09 45 fc             	or     %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++);
  80be90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80be94:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80be98:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80be9c:	0f b6 00             	movzbl (%rax),%eax
  80be9f:	0f b6 c0             	movzbl %al,%eax
  80bea2:	09 45 fc             	or     %eax,-0x4(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
  80bea5:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80bea8:	c9                   	leaveq 
  80bea9:	c3                   	retq   

000000000080beaa <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
  80beaa:	55                   	push   %rbp
  80beab:	48 89 e5             	mov    %rsp,%rbp
  80beae:	48 83 ec 20          	sub    $0x20,%rsp
  80beb2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80beb6:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80bebd:	00 00 00 
  80bec0:	48 8b 00             	mov    (%rax),%rax
  80bec3:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80bec7:	73 2a                	jae    80bef3 <plug_holes+0x49>
  80bec9:	48 ba 98 18 82 00 00 	movabs $0x821898,%rdx
  80bed0:	00 00 00 
  80bed3:	be e3 00 00 00       	mov    $0xe3,%esi
  80bed8:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80bedf:	00 00 00 
  80bee2:	b8 00 00 00 00       	mov    $0x0,%eax
  80bee7:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80beee:	00 00 00 
  80bef1:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80bef3:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80befa:	00 00 00 
  80befd:	48 8b 00             	mov    (%rax),%rax
  80bf00:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80bf04:	72 2a                	jb     80bf30 <plug_holes+0x86>
  80bf06:	48 ba c3 18 82 00 00 	movabs $0x8218c3,%rdx
  80bf0d:	00 00 00 
  80bf10:	be e4 00 00 00       	mov    $0xe4,%esi
  80bf15:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80bf1c:	00 00 00 
  80bf1f:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf24:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80bf2b:	00 00 00 
  80bf2e:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
  80bf30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bf34:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80bf38:	84 c0                	test   %al,%al
  80bf3a:	74 2a                	je     80bf66 <plug_holes+0xbc>
  80bf3c:	48 ba dd 18 82 00 00 	movabs $0x8218dd,%rdx
  80bf43:	00 00 00 
  80bf46:	be e5 00 00 00       	mov    $0xe5,%esi
  80bf4b:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80bf52:	00 00 00 
  80bf55:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf5a:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80bf61:	00 00 00 
  80bf64:	ff d1                	callq  *%rcx

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80bf66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bf6a:	8b 00                	mov    (%rax),%eax
  80bf6c:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80bf71:	76 2a                	jbe    80bf9d <plug_holes+0xf3>
  80bf73:	48 ba f8 18 82 00 00 	movabs $0x8218f8,%rdx
  80bf7a:	00 00 00 
  80bf7d:	be e8 00 00 00       	mov    $0xe8,%esi
  80bf82:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80bf89:	00 00 00 
  80bf8c:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf91:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80bf98:	00 00 00 
  80bf9b:	ff d1                	callq  *%rcx

  nmem = (struct mem *)&ram[mem->next];
  80bf9d:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80bfa4:	00 00 00 
  80bfa7:	48 8b 10             	mov    (%rax),%rdx
  80bfaa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bfae:	8b 00                	mov    (%rax),%eax
  80bfb0:	89 c0                	mov    %eax,%eax
  80bfb2:	48 01 d0             	add    %rdx,%rax
  80bfb5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80bfb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bfbd:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80bfc1:	0f 84 81 00 00 00    	je     80c048 <plug_holes+0x19e>
  80bfc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bfcb:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80bfcf:	84 c0                	test   %al,%al
  80bfd1:	75 75                	jne    80c048 <plug_holes+0x19e>
  80bfd3:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80bfda:	00 00 00 
  80bfdd:	48 8b 00             	mov    (%rax),%rax
  80bfe0:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80bfe4:	74 62                	je     80c048 <plug_holes+0x19e>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  80bfe6:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80bfed:	00 00 00 
  80bff0:	48 8b 00             	mov    (%rax),%rax
  80bff3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80bff7:	75 11                	jne    80c00a <plug_holes+0x160>
      lfree = mem;
  80bff9:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c000:	00 00 00 
  80c003:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c007:	48 89 10             	mov    %rdx,(%rax)
    }
    mem->next = nmem->next;
  80c00a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c00e:	8b 10                	mov    (%rax),%edx
  80c010:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c014:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  80c016:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c01d:	00 00 00 
  80c020:	48 8b 10             	mov    (%rax),%rdx
  80c023:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c027:	8b 00                	mov    (%rax),%eax
  80c029:	89 c0                	mov    %eax,%eax
  80c02b:	48 01 c2             	add    %rax,%rdx
  80c02e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80c032:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c039:	00 00 00 
  80c03c:	48 8b 00             	mov    (%rax),%rax
  80c03f:	48 29 c1             	sub    %rax,%rcx
  80c042:	48 89 c8             	mov    %rcx,%rax
  80c045:	89 42 04             	mov    %eax,0x4(%rdx)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80c048:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c04f:	00 00 00 
  80c052:	48 8b 10             	mov    (%rax),%rdx
  80c055:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c059:	8b 40 04             	mov    0x4(%rax),%eax
  80c05c:	89 c0                	mov    %eax,%eax
  80c05e:	48 01 d0             	add    %rdx,%rax
  80c061:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (pmem != mem && pmem->used == 0) {
  80c065:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c069:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c06d:	74 6e                	je     80c0dd <plug_holes+0x233>
  80c06f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c073:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c077:	84 c0                	test   %al,%al
  80c079:	75 62                	jne    80c0dd <plug_holes+0x233>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  80c07b:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c082:	00 00 00 
  80c085:	48 8b 00             	mov    (%rax),%rax
  80c088:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c08c:	75 11                	jne    80c09f <plug_holes+0x1f5>
      lfree = pmem;
  80c08e:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c095:	00 00 00 
  80c098:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80c09c:	48 89 10             	mov    %rdx,(%rax)
    }
    pmem->next = mem->next;
  80c09f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c0a3:	8b 10                	mov    (%rax),%edx
  80c0a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c0a9:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  80c0ab:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c0b2:	00 00 00 
  80c0b5:	48 8b 10             	mov    (%rax),%rdx
  80c0b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c0bc:	8b 00                	mov    (%rax),%eax
  80c0be:	89 c0                	mov    %eax,%eax
  80c0c0:	48 01 c2             	add    %rax,%rdx
  80c0c3:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80c0c7:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c0ce:	00 00 00 
  80c0d1:	48 8b 00             	mov    (%rax),%rax
  80c0d4:	48 29 c1             	sub    %rax,%rcx
  80c0d7:	48 89 c8             	mov    %rcx,%rax
  80c0da:	89 42 04             	mov    %eax,0x4(%rdx)
  }
}
  80c0dd:	c9                   	leaveq 
  80c0de:	c3                   	retq   

000000000080c0df <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  80c0df:	55                   	push   %rbp
  80c0e0:	48 89 e5             	mov    %rsp,%rbp
  80c0e3:	48 83 ec 10          	sub    $0x10,%rsp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  80c0e7:	48 b8 e0 94 82 00 00 	movabs $0x8294e0,%rax
  80c0ee:	00 00 00 
  80c0f1:	48 83 c0 03          	add    $0x3,%rax
  80c0f5:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80c0f9:	48 89 c2             	mov    %rax,%rdx
  80c0fc:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c103:	00 00 00 
  80c106:	48 89 10             	mov    %rdx,(%rax)
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  80c109:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c110:	00 00 00 
  80c113:	48 8b 00             	mov    (%rax),%rax
  80c116:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  mem->next = MEM_SIZE_ALIGNED;
  80c11a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c11e:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  mem->prev = 0;
  80c124:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c128:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  mem->used = 0;
  80c12f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c133:	c6 40 08 00          	movb   $0x0,0x8(%rax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  80c137:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c13e:	00 00 00 
  80c141:	48 8b 00             	mov    (%rax),%rax
  80c144:	48 8d 90 00 00 22 00 	lea    0x220000(%rax),%rdx
  80c14b:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c152:	00 00 00 
  80c155:	48 89 10             	mov    %rdx,(%rax)
  ram_end->used = 1;
  80c158:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c15f:	00 00 00 
  80c162:	48 8b 00             	mov    (%rax),%rax
  80c165:	c6 40 08 01          	movb   $0x1,0x8(%rax)
  ram_end->next = MEM_SIZE_ALIGNED;
  80c169:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c170:	00 00 00 
  80c173:	48 8b 00             	mov    (%rax),%rax
  80c176:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  80c17c:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c183:	00 00 00 
  80c186:	48 8b 00             	mov    (%rax),%rax
  80c189:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%rax)

  mem_sem = sys_sem_new(1);
  80c190:	bf 01 00 00 00       	mov    $0x1,%edi
  80c195:	48 b8 9b 7a 81 00 00 	movabs $0x817a9b,%rax
  80c19c:	00 00 00 
  80c19f:	ff d0                	callq  *%rax
  80c1a1:	48 ba 18 95 a4 00 00 	movabs $0xa49518,%rdx
  80c1a8:	00 00 00 
  80c1ab:	89 02                	mov    %eax,(%rdx)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80c1ad:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c1b4:	00 00 00 
  80c1b7:	48 8b 10             	mov    (%rax),%rdx
  80c1ba:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c1c1:	00 00 00 
  80c1c4:	48 89 10             	mov    %rdx,(%rax)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  80c1c7:	c9                   	leaveq 
  80c1c8:	c3                   	retq   

000000000080c1c9 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  80c1c9:	55                   	push   %rbp
  80c1ca:	48 89 e5             	mov    %rsp,%rbp
  80c1cd:	48 83 ec 20          	sub    $0x20,%rsp
  80c1d1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  80c1d5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80c1da:	75 05                	jne    80c1e1 <mem_free+0x18>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  80c1dc:	e9 6b 01 00 00       	jmpq   80c34c <mem_free+0x183>
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80c1e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c1e5:	83 e0 03             	and    $0x3,%eax
  80c1e8:	48 85 c0             	test   %rax,%rax
  80c1eb:	74 2a                	je     80c217 <mem_free+0x4e>
  80c1ed:	48 ba 28 19 82 00 00 	movabs $0x821928,%rdx
  80c1f4:	00 00 00 
  80c1f7:	be 30 01 00 00       	mov    $0x130,%esi
  80c1fc:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80c203:	00 00 00 
  80c206:	b8 00 00 00 00       	mov    $0x0,%eax
  80c20b:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80c212:	00 00 00 
  80c215:	ff d1                	callq  *%rcx

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c217:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c21e:	00 00 00 
  80c221:	48 8b 00             	mov    (%rax),%rax
  80c224:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c228:	72 13                	jb     80c23d <mem_free+0x74>
  80c22a:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c231:	00 00 00 
  80c234:	48 8b 00             	mov    (%rax),%rax
  80c237:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c23b:	72 2a                	jb     80c267 <mem_free+0x9e>
  80c23d:	48 ba 49 19 82 00 00 	movabs $0x821949,%rdx
  80c244:	00 00 00 
  80c247:	be 33 01 00 00       	mov    $0x133,%esi
  80c24c:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80c253:	00 00 00 
  80c256:	b8 00 00 00 00       	mov    $0x0,%eax
  80c25b:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80c262:	00 00 00 
  80c265:	ff d1                	callq  *%rcx
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c267:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c26e:	00 00 00 
  80c271:	48 8b 00             	mov    (%rax),%rax
  80c274:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c278:	72 13                	jb     80c28d <mem_free+0xc4>
  80c27a:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c281:	00 00 00 
  80c284:	48 8b 00             	mov    (%rax),%rax
  80c287:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c28b:	72 05                	jb     80c292 <mem_free+0xc9>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  80c28d:	e9 ba 00 00 00       	jmpq   80c34c <mem_free+0x183>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c292:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c299:	00 00 00 
  80c29c:	8b 00                	mov    (%rax),%eax
  80c29e:	be 00 00 00 00       	mov    $0x0,%esi
  80c2a3:	89 c7                	mov    %eax,%edi
  80c2a5:	48 b8 1c 7e 81 00 00 	movabs $0x817e1c,%rax
  80c2ac:	00 00 00 
  80c2af:	ff d0                	callq  *%rax
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c2b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c2b5:	48 83 e8 0c          	sub    $0xc,%rax
  80c2b9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80c2bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c2c1:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c2c5:	84 c0                	test   %al,%al
  80c2c7:	75 2a                	jne    80c2f3 <mem_free+0x12a>
  80c2c9:	48 ba 60 19 82 00 00 	movabs $0x821960,%rdx
  80c2d0:	00 00 00 
  80c2d3:	be 43 01 00 00       	mov    $0x143,%esi
  80c2d8:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80c2df:	00 00 00 
  80c2e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80c2e7:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80c2ee:	00 00 00 
  80c2f1:	ff d1                	callq  *%rcx
  /* ... and is now unused. */
  mem->used = 0;
  80c2f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c2f7:	c6 40 08 00          	movb   $0x0,0x8(%rax)

  if (mem < lfree) {
  80c2fb:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c302:	00 00 00 
  80c305:	48 8b 00             	mov    (%rax),%rax
  80c308:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80c30c:	73 11                	jae    80c31f <mem_free+0x156>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80c30e:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c315:	00 00 00 
  80c318:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c31c:	48 89 10             	mov    %rdx,(%rax)
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
  80c31f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c323:	48 89 c7             	mov    %rax,%rdi
  80c326:	48 b8 aa be 80 00 00 	movabs $0x80beaa,%rax
  80c32d:	00 00 00 
  80c330:	ff d0                	callq  *%rax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c332:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c339:	00 00 00 
  80c33c:	8b 00                	mov    (%rax),%eax
  80c33e:	89 c7                	mov    %eax,%edi
  80c340:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  80c347:	00 00 00 
  80c34a:	ff d0                	callq  *%rax
}
  80c34c:	c9                   	leaveq 
  80c34d:	c3                   	retq   

000000000080c34e <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80c34e:	55                   	push   %rbp
  80c34f:	48 89 e5             	mov    %rsp,%rbp
  80c352:	48 83 ec 30          	sub    $0x30,%rsp
  80c356:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80c35a:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80c35d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c360:	83 c0 03             	add    $0x3,%eax
  80c363:	83 e0 fc             	and    $0xfffffffc,%eax
  80c366:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  if(newsize < MIN_SIZE_ALIGNED) {
  80c369:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%rbp)
  80c36d:	77 07                	ja     80c376 <mem_realloc+0x28>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  80c36f:	c7 45 d4 0c 00 00 00 	movl   $0xc,-0x2c(%rbp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  80c376:	81 7d d4 00 00 22 00 	cmpl   $0x220000,-0x2c(%rbp)
  80c37d:	76 0a                	jbe    80c389 <mem_realloc+0x3b>
    return NULL;
  80c37f:	b8 00 00 00 00       	mov    $0x0,%eax
  80c384:	e9 da 02 00 00       	jmpq   80c663 <mem_realloc+0x315>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c389:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c390:	00 00 00 
  80c393:	48 8b 00             	mov    (%rax),%rax
  80c396:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c39a:	72 13                	jb     80c3af <mem_realloc+0x61>
  80c39c:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c3a3:	00 00 00 
  80c3a6:	48 8b 00             	mov    (%rax),%rax
  80c3a9:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c3ad:	72 2a                	jb     80c3d9 <mem_realloc+0x8b>
  80c3af:	48 ba 74 19 82 00 00 	movabs $0x821974,%rdx
  80c3b6:	00 00 00 
  80c3b9:	be 79 01 00 00       	mov    $0x179,%esi
  80c3be:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80c3c5:	00 00 00 
  80c3c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80c3cd:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80c3d4:	00 00 00 
  80c3d7:	ff d1                	callq  *%rcx
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c3d9:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c3e0:	00 00 00 
  80c3e3:	48 8b 00             	mov    (%rax),%rax
  80c3e6:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c3ea:	72 13                	jb     80c3ff <mem_realloc+0xb1>
  80c3ec:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c3f3:	00 00 00 
  80c3f6:	48 8b 00             	mov    (%rax),%rax
  80c3f9:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c3fd:	72 09                	jb     80c408 <mem_realloc+0xba>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  80c3ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c403:	e9 5b 02 00 00       	jmpq   80c663 <mem_realloc+0x315>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c408:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c40c:	48 83 e8 0c          	sub    $0xc,%rax
  80c410:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  80c414:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c418:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c41f:	00 00 00 
  80c422:	48 8b 00             	mov    (%rax),%rax
  80c425:	48 29 c2             	sub    %rax,%rdx
  80c428:	48 89 d0             	mov    %rdx,%rax
  80c42b:	89 45 f4             	mov    %eax,-0xc(%rbp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80c42e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c432:	8b 00                	mov    (%rax),%eax
  80c434:	2b 45 f4             	sub    -0xc(%rbp),%eax
  80c437:	83 e8 0c             	sub    $0xc,%eax
  80c43a:	89 45 f0             	mov    %eax,-0x10(%rbp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80c43d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c440:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c443:	76 2a                	jbe    80c46f <mem_realloc+0x121>
  80c445:	48 ba 90 19 82 00 00 	movabs $0x821990,%rdx
  80c44c:	00 00 00 
  80c44f:	be 8a 01 00 00       	mov    $0x18a,%esi
  80c454:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80c45b:	00 00 00 
  80c45e:	b8 00 00 00 00       	mov    $0x0,%eax
  80c463:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80c46a:	00 00 00 
  80c46d:	ff d1                	callq  *%rcx
  if (newsize > size) {
  80c46f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c472:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c475:	76 0a                	jbe    80c481 <mem_realloc+0x133>
    /* not supported */
    return NULL;
  80c477:	b8 00 00 00 00       	mov    $0x0,%eax
  80c47c:	e9 e2 01 00 00       	jmpq   80c663 <mem_realloc+0x315>
  }
  if (newsize == size) {
  80c481:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c484:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c487:	75 09                	jne    80c492 <mem_realloc+0x144>
    /* No change in size, simply return */
    return rmem;
  80c489:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c48d:	e9 d1 01 00 00       	jmpq   80c663 <mem_realloc+0x315>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c492:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c499:	00 00 00 
  80c49c:	8b 00                	mov    (%rax),%eax
  80c49e:	be 00 00 00 00       	mov    $0x0,%esi
  80c4a3:	89 c7                	mov    %eax,%edi
  80c4a5:	48 b8 1c 7e 81 00 00 	movabs $0x817e1c,%rax
  80c4ac:	00 00 00 
  80c4af:	ff d0                	callq  *%rax

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80c4b1:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c4b8:	00 00 00 
  80c4bb:	48 8b 10             	mov    (%rax),%rdx
  80c4be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c4c2:	8b 00                	mov    (%rax),%eax
  80c4c4:	89 c0                	mov    %eax,%eax
  80c4c6:	48 01 d0             	add    %rdx,%rax
  80c4c9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if(mem2->used == 0) {
  80c4cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c4d1:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c4d5:	84 c0                	test   %al,%al
  80c4d7:	0f 85 ba 00 00 00    	jne    80c597 <mem_realloc+0x249>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80c4dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c4e1:	8b 00                	mov    (%rax),%eax
  80c4e3:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c4e6:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c4e9:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c4ec:	01 d0                	add    %edx,%eax
  80c4ee:	83 c0 0c             	add    $0xc,%eax
  80c4f1:	89 45 e0             	mov    %eax,-0x20(%rbp)
    if (lfree == mem2) {
  80c4f4:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c4fb:	00 00 00 
  80c4fe:	48 8b 00             	mov    (%rax),%rax
  80c501:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c505:	75 20                	jne    80c527 <mem_realloc+0x1d9>
      lfree = (struct mem *)&ram[ptr2];
  80c507:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c50e:	00 00 00 
  80c511:	48 8b 10             	mov    (%rax),%rdx
  80c514:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c517:	48 01 c2             	add    %rax,%rdx
  80c51a:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c521:	00 00 00 
  80c524:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2 = (struct mem *)&ram[ptr2];
  80c527:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c52e:	00 00 00 
  80c531:	48 8b 10             	mov    (%rax),%rdx
  80c534:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c537:	48 01 d0             	add    %rdx,%rax
  80c53a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    mem2->used = 0;
  80c53e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c542:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    /* restore the next pointer */
    mem2->next = next;
  80c546:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c54a:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80c54d:	89 10                	mov    %edx,(%rax)
    /* link it back to mem */
    mem2->prev = ptr;
  80c54f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c553:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c556:	89 50 04             	mov    %edx,0x4(%rax)
    /* link mem to it */
    mem->next = ptr2;
  80c559:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c55d:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c560:	89 10                	mov    %edx,(%rax)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c562:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c566:	8b 00                	mov    (%rax),%eax
  80c568:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c56d:	74 23                	je     80c592 <mem_realloc+0x244>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c56f:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c576:	00 00 00 
  80c579:	48 8b 10             	mov    (%rax),%rdx
  80c57c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c580:	8b 00                	mov    (%rax),%eax
  80c582:	89 c0                	mov    %eax,%eax
  80c584:	48 01 c2             	add    %rax,%rdx
  80c587:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c58a:	89 42 04             	mov    %eax,0x4(%rdx)
  80c58d:	e9 b3 00 00 00       	jmpq   80c645 <mem_realloc+0x2f7>
  80c592:	e9 ae 00 00 00       	jmpq   80c645 <mem_realloc+0x2f7>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  80c597:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c59a:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80c59e:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80c5a1:	48 39 c2             	cmp    %rax,%rdx
  80c5a4:	0f 87 9b 00 00 00    	ja     80c645 <mem_realloc+0x2f7>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c5aa:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c5ad:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c5b0:	01 d0                	add    %edx,%eax
  80c5b2:	83 c0 0c             	add    $0xc,%eax
  80c5b5:	89 45 e0             	mov    %eax,-0x20(%rbp)
    mem2 = (struct mem *)&ram[ptr2];
  80c5b8:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c5bf:	00 00 00 
  80c5c2:	48 8b 10             	mov    (%rax),%rdx
  80c5c5:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c5c8:	48 01 d0             	add    %rdx,%rax
  80c5cb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (mem2 < lfree) {
  80c5cf:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c5d6:	00 00 00 
  80c5d9:	48 8b 00             	mov    (%rax),%rax
  80c5dc:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c5e0:	73 11                	jae    80c5f3 <mem_realloc+0x2a5>
      lfree = mem2;
  80c5e2:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c5e9:	00 00 00 
  80c5ec:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c5f0:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2->used = 0;
  80c5f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c5f7:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    mem2->next = mem->next;
  80c5fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c5ff:	8b 10                	mov    (%rax),%edx
  80c601:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c605:	89 10                	mov    %edx,(%rax)
    mem2->prev = ptr;
  80c607:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c60b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c60e:	89 50 04             	mov    %edx,0x4(%rax)
    mem->next = ptr2;
  80c611:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c615:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c618:	89 10                	mov    %edx,(%rax)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c61a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c61e:	8b 00                	mov    (%rax),%eax
  80c620:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c625:	74 1e                	je     80c645 <mem_realloc+0x2f7>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c627:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c62e:	00 00 00 
  80c631:	48 8b 10             	mov    (%rax),%rdx
  80c634:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c638:	8b 00                	mov    (%rax),%eax
  80c63a:	89 c0                	mov    %eax,%eax
  80c63c:	48 01 c2             	add    %rax,%rdx
  80c63f:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c642:	89 42 04             	mov    %eax,0x4(%rdx)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c645:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c64c:	00 00 00 
  80c64f:	8b 00                	mov    (%rax),%eax
  80c651:	89 c7                	mov    %eax,%edi
  80c653:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  80c65a:	00 00 00 
  80c65d:	ff d0                	callq  *%rax
  return rmem;
  80c65f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  80c663:	c9                   	leaveq 
  80c664:	c3                   	retq   

000000000080c665 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80c665:	55                   	push   %rbp
  80c666:	48 89 e5             	mov    %rsp,%rbp
  80c669:	48 83 ec 30          	sub    $0x30,%rsp
  80c66d:	89 7d dc             	mov    %edi,-0x24(%rbp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  80c670:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80c674:	75 0a                	jne    80c680 <mem_malloc+0x1b>
    return NULL;
  80c676:	b8 00 00 00 00       	mov    $0x0,%eax
  80c67b:	e9 6b 03 00 00       	jmpq   80c9eb <mem_malloc+0x386>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  80c680:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c683:	83 c0 03             	add    $0x3,%eax
  80c686:	83 e0 fc             	and    $0xfffffffc,%eax
  80c689:	89 45 dc             	mov    %eax,-0x24(%rbp)

  if(size < MIN_SIZE_ALIGNED) {
  80c68c:	83 7d dc 0b          	cmpl   $0xb,-0x24(%rbp)
  80c690:	77 07                	ja     80c699 <mem_malloc+0x34>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  80c692:	c7 45 dc 0c 00 00 00 	movl   $0xc,-0x24(%rbp)
  }

  if (size > MEM_SIZE_ALIGNED) {
  80c699:	81 7d dc 00 00 22 00 	cmpl   $0x220000,-0x24(%rbp)
  80c6a0:	76 0a                	jbe    80c6ac <mem_malloc+0x47>
    return NULL;
  80c6a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80c6a7:	e9 3f 03 00 00       	jmpq   80c9eb <mem_malloc+0x386>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80c6ac:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c6b3:	00 00 00 
  80c6b6:	8b 00                	mov    (%rax),%eax
  80c6b8:	be 00 00 00 00       	mov    $0x0,%esi
  80c6bd:	89 c7                	mov    %eax,%edi
  80c6bf:	48 b8 1c 7e 81 00 00 	movabs $0x817e1c,%rax
  80c6c6:	00 00 00 
  80c6c9:	ff d0                	callq  *%rax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80c6cb:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c6d2:	00 00 00 
  80c6d5:	48 8b 00             	mov    (%rax),%rax
  80c6d8:	48 89 c2             	mov    %rax,%rdx
  80c6db:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c6e2:	00 00 00 
  80c6e5:	48 8b 00             	mov    (%rax),%rax
  80c6e8:	48 29 c2             	sub    %rax,%rdx
  80c6eb:	48 89 d0             	mov    %rdx,%rax
  80c6ee:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80c6f1:	e9 c5 02 00 00       	jmpq   80c9bb <mem_malloc+0x356>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80c6f6:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c6fd:	00 00 00 
  80c700:	48 8b 10             	mov    (%rax),%rdx
  80c703:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c706:	48 01 d0             	add    %rdx,%rax
  80c709:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80c70d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c711:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c715:	84 c0                	test   %al,%al
  80c717:	0f 85 86 02 00 00    	jne    80c9a3 <mem_malloc+0x33e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80c71d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c721:	8b 00                	mov    (%rax),%eax
  80c723:	89 c2                	mov    %eax,%edx
  80c725:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c728:	48 29 c2             	sub    %rax,%rdx
  80c72b:	48 89 d0             	mov    %rdx,%rax
  80c72e:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80c732:	8b 45 dc             	mov    -0x24(%rbp),%eax
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80c735:	48 39 c2             	cmp    %rax,%rdx
  80c738:	0f 82 65 02 00 00    	jb     80c9a3 <mem_malloc+0x33e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80c73e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c742:	8b 00                	mov    (%rax),%eax
  80c744:	89 c2                	mov    %eax,%edx
  80c746:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c749:	48 29 c2             	sub    %rax,%rdx
  80c74c:	48 89 d0             	mov    %rdx,%rax
  80c74f:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80c753:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c756:	48 83 c0 18          	add    $0x18,%rax
  80c75a:	48 39 c2             	cmp    %rax,%rdx
  80c75d:	0f 82 81 00 00 00    	jb     80c7e4 <mem_malloc+0x17f>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80c763:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c766:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80c769:	01 d0                	add    %edx,%eax
  80c76b:	83 c0 0c             	add    $0xc,%eax
  80c76e:	89 45 ec             	mov    %eax,-0x14(%rbp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  80c771:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c778:	00 00 00 
  80c77b:	48 8b 10             	mov    (%rax),%rdx
  80c77e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c781:	48 01 d0             	add    %rdx,%rax
  80c784:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          mem2->used = 0;
  80c788:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c78c:	c6 40 08 00          	movb   $0x0,0x8(%rax)
          mem2->next = mem->next;
  80c790:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c794:	8b 10                	mov    (%rax),%edx
  80c796:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c79a:	89 10                	mov    %edx,(%rax)
          mem2->prev = ptr;
  80c79c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c7a0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80c7a3:	89 50 04             	mov    %edx,0x4(%rax)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  80c7a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c7aa:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80c7ad:	89 10                	mov    %edx,(%rax)
          mem->used = 1;
  80c7af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c7b3:	c6 40 08 01          	movb   $0x1,0x8(%rax)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80c7b7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c7bb:	8b 00                	mov    (%rax),%eax
  80c7bd:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c7c2:	74 28                	je     80c7ec <mem_malloc+0x187>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c7c4:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c7cb:	00 00 00 
  80c7ce:	48 8b 10             	mov    (%rax),%rdx
  80c7d1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c7d5:	8b 00                	mov    (%rax),%eax
  80c7d7:	89 c0                	mov    %eax,%eax
  80c7d9:	48 01 c2             	add    %rax,%rdx
  80c7dc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c7df:	89 42 04             	mov    %eax,0x4(%rdx)
  80c7e2:	eb 08                	jmp    80c7ec <mem_malloc+0x187>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80c7e4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c7e8:	c6 40 08 01          	movb   $0x1,0x8(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  80c7ec:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c7f3:	00 00 00 
  80c7f6:	48 8b 00             	mov    (%rax),%rax
  80c7f9:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80c7fd:	0f 85 c2 00 00 00    	jne    80c8c5 <mem_malloc+0x260>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80c803:	eb 2e                	jmp    80c833 <mem_malloc+0x1ce>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  80c805:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c80c:	00 00 00 
  80c80f:	48 8b 10             	mov    (%rax),%rdx
  80c812:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c819:	00 00 00 
  80c81c:	48 8b 00             	mov    (%rax),%rax
  80c81f:	8b 00                	mov    (%rax),%eax
  80c821:	89 c0                	mov    %eax,%eax
  80c823:	48 01 c2             	add    %rax,%rdx
  80c826:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c82d:	00 00 00 
  80c830:	48 89 10             	mov    %rdx,(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80c833:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c83a:	00 00 00 
  80c83d:	48 8b 00             	mov    (%rax),%rax
  80c840:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c844:	84 c0                	test   %al,%al
  80c846:	74 1f                	je     80c867 <mem_malloc+0x202>
  80c848:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c84f:	00 00 00 
  80c852:	48 8b 10             	mov    (%rax),%rdx
  80c855:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c85c:	00 00 00 
  80c85f:	48 8b 00             	mov    (%rax),%rax
  80c862:	48 39 c2             	cmp    %rax,%rdx
  80c865:	75 9e                	jne    80c805 <mem_malloc+0x1a0>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  80c867:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c86e:	00 00 00 
  80c871:	48 8b 10             	mov    (%rax),%rdx
  80c874:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c87b:	00 00 00 
  80c87e:	48 8b 00             	mov    (%rax),%rax
  80c881:	48 39 c2             	cmp    %rax,%rdx
  80c884:	74 3f                	je     80c8c5 <mem_malloc+0x260>
  80c886:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c88d:	00 00 00 
  80c890:	48 8b 00             	mov    (%rax),%rax
  80c893:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c897:	84 c0                	test   %al,%al
  80c899:	74 2a                	je     80c8c5 <mem_malloc+0x260>
  80c89b:	48 ba b3 19 82 00 00 	movabs $0x8219b3,%rdx
  80c8a2:	00 00 00 
  80c8a5:	be 46 02 00 00       	mov    $0x246,%esi
  80c8aa:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80c8b1:	00 00 00 
  80c8b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80c8b9:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80c8c0:	00 00 00 
  80c8c3:	ff d1                	callq  *%rcx
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80c8c5:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c8cc:	00 00 00 
  80c8cf:	8b 00                	mov    (%rax),%eax
  80c8d1:	89 c7                	mov    %eax,%edi
  80c8d3:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  80c8da:	00 00 00 
  80c8dd:	ff d0                	callq  *%rax
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80c8df:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80c8e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c8e6:	48 01 d0             	add    %rdx,%rax
  80c8e9:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80c8ed:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c8f4:	00 00 00 
  80c8f7:	48 8b 00             	mov    (%rax),%rax
  80c8fa:	48 39 c2             	cmp    %rax,%rdx
  80c8fd:	76 2a                	jbe    80c929 <mem_malloc+0x2c4>
  80c8ff:	48 ba d0 19 82 00 00 	movabs $0x8219d0,%rdx
  80c906:	00 00 00 
  80c909:	be 4b 02 00 00       	mov    $0x24b,%esi
  80c90e:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80c915:	00 00 00 
  80c918:	b8 00 00 00 00       	mov    $0x0,%eax
  80c91d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80c924:	00 00 00 
  80c927:	ff d1                	callq  *%rcx
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80c929:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c92d:	48 83 c0 0c          	add    $0xc,%rax
  80c931:	83 e0 03             	and    $0x3,%eax
  80c934:	48 85 c0             	test   %rax,%rax
  80c937:	74 2a                	je     80c963 <mem_malloc+0x2fe>
  80c939:	48 ba 00 1a 82 00 00 	movabs $0x821a00,%rdx
  80c940:	00 00 00 
  80c943:	be 4d 02 00 00       	mov    $0x24d,%esi
  80c948:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80c94f:	00 00 00 
  80c952:	b8 00 00 00 00       	mov    $0x0,%eax
  80c957:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80c95e:	00 00 00 
  80c961:	ff d1                	callq  *%rcx
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80c963:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c967:	83 e0 03             	and    $0x3,%eax
  80c96a:	48 85 c0             	test   %rax,%rax
  80c96d:	74 2a                	je     80c999 <mem_malloc+0x334>
  80c96f:	48 ba 30 1a 82 00 00 	movabs $0x821a30,%rdx
  80c976:	00 00 00 
  80c979:	be 4f 02 00 00       	mov    $0x24f,%esi
  80c97e:	48 bf af 18 82 00 00 	movabs $0x8218af,%rdi
  80c985:	00 00 00 
  80c988:	b8 00 00 00 00       	mov    $0x0,%eax
  80c98d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80c994:	00 00 00 
  80c997:	ff d1                	callq  *%rcx
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  80c999:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c99d:	48 83 c0 0c          	add    $0xc,%rax
  80c9a1:	eb 48                	jmp    80c9eb <mem_malloc+0x386>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80c9a3:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c9aa:	00 00 00 
  80c9ad:	48 8b 10             	mov    (%rax),%rdx
  80c9b0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c9b3:	48 01 d0             	add    %rdx,%rax
  80c9b6:	8b 00                	mov    (%rax),%eax
  80c9b8:	89 45 fc             	mov    %eax,-0x4(%rbp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80c9bb:	b8 00 00 22 00       	mov    $0x220000,%eax
  80c9c0:	2b 45 dc             	sub    -0x24(%rbp),%eax
  80c9c3:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80c9c6:	0f 87 2a fd ff ff    	ja     80c6f6 <mem_malloc+0x91>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  80c9cc:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c9d3:	00 00 00 
  80c9d6:	8b 00                	mov    (%rax),%eax
  80c9d8:	89 c7                	mov    %eax,%edi
  80c9da:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  80c9e1:	00 00 00 
  80c9e4:	ff d0                	callq  *%rax
  return NULL;
  80c9e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c9eb:	c9                   	leaveq 
  80c9ec:	c3                   	retq   

000000000080c9ed <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  80c9ed:	55                   	push   %rbp
  80c9ee:	48 89 e5             	mov    %rsp,%rbp
  80c9f1:	48 83 ec 20          	sub    $0x20,%rsp
  80c9f5:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80c9f8:	89 75 e8             	mov    %esi,-0x18(%rbp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  80c9fb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c9fe:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80ca02:	89 c7                	mov    %eax,%edi
  80ca04:	48 b8 65 c6 80 00 00 	movabs $0x80c665,%rax
  80ca0b:	00 00 00 
  80ca0e:	ff d0                	callq  *%rax
  80ca10:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p) {
  80ca14:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ca19:	74 21                	je     80ca3c <mem_calloc+0x4f>
    /* zero the memory */
    memset(p, 0, count * size);
  80ca1b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80ca1e:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80ca22:	89 c2                	mov    %eax,%edx
  80ca24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ca28:	be 00 00 00 00       	mov    $0x0,%esi
  80ca2d:	48 89 c7             	mov    %rax,%rdi
  80ca30:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  80ca37:	00 00 00 
  80ca3a:	ff d0                	callq  *%rax
  }
  return p;
  80ca3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80ca40:	c9                   	leaveq 
  80ca41:	c3                   	retq   

000000000080ca42 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80ca42:	55                   	push   %rbp
  80ca43:	48 89 e5             	mov    %rsp,%rbp
  80ca46:	48 83 ec 10          	sub    $0x10,%rsp
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
  80ca4a:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80ca50:	eb 05                	jmp    80ca57 <memp_init+0x15>
  80ca52:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80ca57:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80ca5c:	76 f4                	jbe    80ca52 <memp_init+0x10>
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80ca5e:	48 b8 a0 95 a4 00 00 	movabs $0xa495a0,%rax
  80ca65:	00 00 00 
  80ca68:	48 83 c0 03          	add    $0x3,%rax
  80ca6c:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80ca70:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80ca74:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80ca7a:	e9 97 00 00 00       	jmpq   80cb16 <memp_init+0xd4>
    memp_tab[i] = NULL;
  80ca7f:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80ca83:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80ca8a:	00 00 00 
  80ca8d:	48 63 d2             	movslq %edx,%rdx
  80ca90:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80ca97:	00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80ca98:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  80ca9e:	eb 56                	jmp    80caf6 <memp_init+0xb4>
      memp->next = memp_tab[i];
  80caa0:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80caa4:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80caab:	00 00 00 
  80caae:	48 63 d2             	movslq %edx,%rdx
  80cab1:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80cab5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cab9:	48 89 10             	mov    %rdx,(%rax)
      memp_tab[i] = memp;
  80cabc:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cac0:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cac7:	00 00 00 
  80caca:	48 63 d2             	movslq %edx,%rdx
  80cacd:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80cad1:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80cad5:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cad9:	48 b8 60 1a 82 00 00 	movabs $0x821a60,%rax
  80cae0:	00 00 00 
  80cae3:	48 63 d2             	movslq %edx,%rdx
  80cae6:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80caea:	0f b7 c0             	movzwl %ax,%eax
  80caed:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80caf1:	66 83 45 f4 01       	addw   $0x1,-0xc(%rbp)
  80caf6:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cafa:	48 b8 80 1a 82 00 00 	movabs $0x821a80,%rax
  80cb01:	00 00 00 
  80cb04:	48 63 d2             	movslq %edx,%rdx
  80cb07:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80cb0b:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  80cb0f:	77 8f                	ja     80caa0 <memp_init+0x5e>
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80cb11:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80cb16:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80cb1b:	0f 86 5e ff ff ff    	jbe    80ca7f <memp_init+0x3d>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80cb21:	c9                   	leaveq 
  80cb22:	c3                   	retq   

000000000080cb23 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80cb23:	55                   	push   %rbp
  80cb24:	48 89 e5             	mov    %rsp,%rbp
  80cb27:	48 83 ec 20          	sub    $0x20,%rsp
  80cb2b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80cb2e:	83 7d ec 0d          	cmpl   $0xd,-0x14(%rbp)
  80cb32:	76 2a                	jbe    80cb5e <memp_malloc+0x3b>
  80cb34:	48 ba 2f 1b 82 00 00 	movabs $0x821b2f,%rdx
  80cb3b:	00 00 00 
  80cb3e:	be 2d 01 00 00       	mov    $0x12d,%esi
  80cb43:	48 bf 4c 1b 82 00 00 	movabs $0x821b4c,%rdi
  80cb4a:	00 00 00 
  80cb4d:	b8 00 00 00 00       	mov    $0x0,%eax
  80cb52:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80cb59:	00 00 00 
  80cb5c:	ff d1                	callq  *%rcx
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80cb5e:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cb65:	00 00 00 
  80cb68:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cb6b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80cb6f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (memp != NULL) {    
  80cb73:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cb78:	74 4e                	je     80cbc8 <memp_malloc+0xa5>
    memp_tab[type] = memp->next;    
  80cb7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cb7e:	48 8b 08             	mov    (%rax),%rcx
  80cb81:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cb88:	00 00 00 
  80cb8b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cb8e:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80cb92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cb96:	83 e0 03             	and    $0x3,%eax
  80cb99:	48 85 c0             	test   %rax,%rax
  80cb9c:	74 2a                	je     80cbc8 <memp_malloc+0xa5>
  80cb9e:	48 ba 68 1b 82 00 00 	movabs $0x821b68,%rdx
  80cba5:	00 00 00 
  80cba8:	be 3f 01 00 00       	mov    $0x13f,%esi
  80cbad:	48 bf 4c 1b 82 00 00 	movabs $0x821b4c,%rdi
  80cbb4:	00 00 00 
  80cbb7:	b8 00 00 00 00       	mov    $0x0,%eax
  80cbbc:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80cbc3:	00 00 00 
  80cbc6:	ff d1                	callq  *%rcx
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
  80cbc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cbcc:	c9                   	leaveq 
  80cbcd:	c3                   	retq   

000000000080cbce <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  80cbce:	55                   	push   %rbp
  80cbcf:	48 89 e5             	mov    %rsp,%rbp
  80cbd2:	48 83 ec 20          	sub    $0x20,%rsp
  80cbd6:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80cbd9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  80cbdd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80cbe2:	75 02                	jne    80cbe6 <memp_free+0x18>
    return;
  80cbe4:	eb 6b                	jmp    80cc51 <memp_free+0x83>
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  80cbe6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cbea:	83 e0 03             	and    $0x3,%eax
  80cbed:	48 85 c0             	test   %rax,%rax
  80cbf0:	74 2a                	je     80cc1c <memp_free+0x4e>
  80cbf2:	48 ba 90 1b 82 00 00 	movabs $0x821b90,%rdx
  80cbf9:	00 00 00 
  80cbfc:	be 5b 01 00 00       	mov    $0x15b,%esi
  80cc01:	48 bf 4c 1b 82 00 00 	movabs $0x821b4c,%rdi
  80cc08:	00 00 00 
  80cc0b:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc10:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80cc17:	00 00 00 
  80cc1a:	ff d1                	callq  *%rcx
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
  80cc1c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cc20:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  80cc24:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cc2b:	00 00 00 
  80cc2e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cc31:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80cc35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc39:	48 89 10             	mov    %rdx,(%rax)
  memp_tab[type] = memp;
  80cc3c:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cc43:	00 00 00 
  80cc46:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cc49:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80cc4d:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80cc51:	c9                   	leaveq 
  80cc52:	c3                   	retq   

000000000080cc53 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  80cc53:	55                   	push   %rbp
  80cc54:	48 89 e5             	mov    %rsp,%rbp
  80cc57:	48 83 ec 30          	sub    $0x30,%rsp
  80cc5b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80cc5f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80cc63:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80cc67:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  80cc6b:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  80cc6f:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  80cc73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc77:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  netif->netmask.addr = 0;
  80cc7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc82:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
  netif->gw.addr = 0;
  80cc89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc8d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  netif->flags = 0;
  80cc94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc98:	c6 40 4a 00          	movb   $0x0,0x4a(%rax)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  80cc9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cca0:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80cca7:	00 
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  80cca8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ccac:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80ccb0:	48 89 50 30          	mov    %rdx,0x30(%rax)
  netif->num = netifnum++;
  80ccb4:	48 b8 4b b0 b4 00 00 	movabs $0xb4b04b,%rax
  80ccbb:	00 00 00 
  80ccbe:	0f b6 00             	movzbl (%rax),%eax
  80ccc1:	8d 48 01             	lea    0x1(%rax),%ecx
  80ccc4:	48 ba 4b b0 b4 00 00 	movabs $0xb4b04b,%rdx
  80cccb:	00 00 00 
  80ccce:	88 0a                	mov    %cl,(%rdx)
  80ccd0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80ccd4:	88 42 4d             	mov    %al,0x4d(%rdx)
  netif->input = input;
  80ccd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ccdb:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80ccdf:	48 89 50 18          	mov    %rdx,0x18(%rax)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  80cce3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80cce7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80cceb:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80ccef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ccf3:	48 89 c7             	mov    %rax,%rdi
  80ccf6:	48 b8 45 cd 80 00 00 	movabs $0x80cd45,%rax
  80ccfd:	00 00 00 
  80cd00:	ff d0                	callq  *%rax

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  80cd02:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cd06:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80cd0a:	48 89 d7             	mov    %rdx,%rdi
  80cd0d:	ff d0                	callq  *%rax
  80cd0f:	84 c0                	test   %al,%al
  80cd11:	74 07                	je     80cd1a <netif_add+0xc7>
    return NULL;
  80cd13:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd18:	eb 29                	jmp    80cd43 <netif_add+0xf0>
  }

  /* add this netif to the list */
  netif->next = netif_list;
  80cd1a:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cd21:	00 00 00 
  80cd24:	48 8b 10             	mov    (%rax),%rdx
  80cd27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd2b:	48 89 10             	mov    %rdx,(%rax)
  netif_list = netif;
  80cd2e:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cd35:	00 00 00 
  80cd38:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cd3c:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  80cd3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cd43:	c9                   	leaveq 
  80cd44:	c3                   	retq   

000000000080cd45 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  80cd45:	55                   	push   %rbp
  80cd46:	48 89 e5             	mov    %rsp,%rbp
  80cd49:	48 83 ec 20          	sub    $0x20,%rsp
  80cd4d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80cd51:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80cd55:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80cd59:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  netif_set_ipaddr(netif, ipaddr);
  80cd5d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80cd61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd65:	48 89 d6             	mov    %rdx,%rsi
  80cd68:	48 89 c7             	mov    %rax,%rdi
  80cd6b:	48 b8 f3 ce 80 00 00 	movabs $0x80cef3,%rax
  80cd72:	00 00 00 
  80cd75:	ff d0                	callq  *%rax
  netif_set_netmask(netif, netmask);
  80cd77:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80cd7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd7f:	48 89 d6             	mov    %rdx,%rsi
  80cd82:	48 89 c7             	mov    %rax,%rdi
  80cd85:	48 b8 26 d0 80 00 00 	movabs $0x80d026,%rax
  80cd8c:	00 00 00 
  80cd8f:	ff d0                	callq  *%rax
  netif_set_gw(netif, gw);
  80cd91:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80cd95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd99:	48 89 d6             	mov    %rdx,%rsi
  80cd9c:	48 89 c7             	mov    %rax,%rdi
  80cd9f:	48 b8 f9 cf 80 00 00 	movabs $0x80cff9,%rax
  80cda6:	00 00 00 
  80cda9:	ff d0                	callq  *%rax
}
  80cdab:	c9                   	leaveq 
  80cdac:	c3                   	retq   

000000000080cdad <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80cdad:	55                   	push   %rbp
  80cdae:	48 89 e5             	mov    %rsp,%rbp
  80cdb1:	48 83 ec 20          	sub    $0x20,%rsp
  80cdb5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if ( netif == NULL ) return;
  80cdb9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80cdbe:	75 05                	jne    80cdc5 <netif_remove+0x18>
  80cdc0:	e9 98 00 00 00       	jmpq   80ce5d <netif_remove+0xb0>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80cdc5:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cdcc:	00 00 00 
  80cdcf:	48 8b 00             	mov    (%rax),%rax
  80cdd2:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80cdd6:	75 16                	jne    80cdee <netif_remove+0x41>
    netif_list = netif->next;
  80cdd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cddc:	48 8b 10             	mov    (%rax),%rdx
  80cddf:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cde6:	00 00 00 
  80cde9:	48 89 10             	mov    %rdx,(%rax)
  80cdec:	eb 4b                	jmp    80ce39 <netif_remove+0x8c>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80cdee:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cdf5:	00 00 00 
  80cdf8:	48 8b 00             	mov    (%rax),%rax
  80cdfb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80cdff:	eb 28                	jmp    80ce29 <netif_remove+0x7c>
      if (tmpNetif->next == netif) {
  80ce01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce05:	48 8b 00             	mov    (%rax),%rax
  80ce08:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ce0c:	75 10                	jne    80ce1e <netif_remove+0x71>
        tmpNetif->next = netif->next;
  80ce0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ce12:	48 8b 10             	mov    (%rax),%rdx
  80ce15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce19:	48 89 10             	mov    %rdx,(%rax)
        snmp_dec_iflist();
        break;
  80ce1c:	eb 12                	jmp    80ce30 <netif_remove+0x83>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80ce1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce22:	48 8b 00             	mov    (%rax),%rax
  80ce25:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ce29:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ce2e:	75 d1                	jne    80ce01 <netif_remove+0x54>
        tmpNetif->next = netif->next;
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
  80ce30:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ce35:	75 02                	jne    80ce39 <netif_remove+0x8c>
      return; /*  we didn't find any netif today */
  80ce37:	eb 24                	jmp    80ce5d <netif_remove+0xb0>
  }
  /* this netif is default? */
  if (netif_default == netif)
  80ce39:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80ce40:	00 00 00 
  80ce43:	48 8b 00             	mov    (%rax),%rax
  80ce46:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ce4a:	75 11                	jne    80ce5d <netif_remove+0xb0>
    /* reset default netif */
    netif_set_default(NULL);
  80ce4c:	bf 00 00 00 00       	mov    $0x0,%edi
  80ce51:	48 b8 53 d0 80 00 00 	movabs $0x80d053,%rax
  80ce58:	00 00 00 
  80ce5b:	ff d0                	callq  *%rax
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  80ce5d:	c9                   	leaveq 
  80ce5e:	c3                   	retq   

000000000080ce5f <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  80ce5f:	55                   	push   %rbp
  80ce60:	48 89 e5             	mov    %rsp,%rbp
  80ce63:	48 83 ec 18          	sub    $0x18,%rsp
  80ce67:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  80ce6b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ce70:	75 07                	jne    80ce79 <netif_find+0x1a>
    return NULL;
  80ce72:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce77:	eb 78                	jmp    80cef1 <netif_find+0x92>
  }

  num = name[2] - '0';
  80ce79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ce7d:	48 83 c0 02          	add    $0x2,%rax
  80ce81:	0f b6 00             	movzbl (%rax),%eax
  80ce84:	83 e8 30             	sub    $0x30,%eax
  80ce87:	88 45 f7             	mov    %al,-0x9(%rbp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80ce8a:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80ce91:	00 00 00 
  80ce94:	48 8b 00             	mov    (%rax),%rax
  80ce97:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ce9b:	eb 48                	jmp    80cee5 <netif_find+0x86>
    if (num == netif->num &&
  80ce9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cea1:	0f b6 40 4d          	movzbl 0x4d(%rax),%eax
  80cea5:	3a 45 f7             	cmp    -0x9(%rbp),%al
  80cea8:	75 30                	jne    80ceda <netif_find+0x7b>
       name[0] == netif->name[0] &&
  80ceaa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ceae:	0f b6 10             	movzbl (%rax),%edx
  80ceb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ceb5:	0f b6 40 4b          	movzbl 0x4b(%rax),%eax
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
  80ceb9:	38 c2                	cmp    %al,%dl
  80cebb:	75 1d                	jne    80ceda <netif_find+0x7b>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
  80cebd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cec1:	48 83 c0 01          	add    $0x1,%rax
  80cec5:	0f b6 10             	movzbl (%rax),%edx
  80cec8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cecc:	0f b6 40 4c          	movzbl 0x4c(%rax),%eax

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
  80ced0:	38 c2                	cmp    %al,%dl
  80ced2:	75 06                	jne    80ceda <netif_find+0x7b>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
  80ced4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ced8:	eb 17                	jmp    80cef1 <netif_find+0x92>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80ceda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cede:	48 8b 00             	mov    (%rax),%rax
  80cee1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80cee5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ceea:	75 b1                	jne    80ce9d <netif_find+0x3e>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
  80ceec:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80cef1:	c9                   	leaveq 
  80cef2:	c3                   	retq   

000000000080cef3 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  80cef3:	55                   	push   %rbp
  80cef4:	48 89 e5             	mov    %rsp,%rbp
  80cef7:	48 83 ec 30          	sub    $0x30,%rsp
  80cefb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80ceff:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  80cf03:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80cf07:	8b 10                	mov    (%rax),%edx
  80cf09:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80cf0d:	8b 40 08             	mov    0x8(%rax),%eax
  80cf10:	39 c2                	cmp    %eax,%edx
  80cf12:	0f 84 c4 00 00 00    	je     80cfdc <netif_set_ipaddr+0xe9>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  80cf18:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80cf1f:	00 00 00 
  80cf22:	48 8b 00             	mov    (%rax),%rax
  80cf25:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (pcb != NULL) {
  80cf29:	eb 46                	jmp    80cf71 <netif_set_ipaddr+0x7e>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80cf2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf2f:	8b 10                	mov    (%rax),%edx
  80cf31:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80cf35:	8b 40 08             	mov    0x8(%rax),%eax
  80cf38:	39 c2                	cmp    %eax,%edx
  80cf3a:	75 29                	jne    80cf65 <netif_set_ipaddr+0x72>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  80cf3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf40:	48 8b 40 10          	mov    0x10(%rax),%rax
  80cf44:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  80cf48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf4c:	48 89 c7             	mov    %rax,%rdi
  80cf4f:	48 b8 ce eb 80 00 00 	movabs $0x80ebce,%rax
  80cf56:	00 00 00 
  80cf59:	ff d0                	callq  *%rax
        pcb = next;
  80cf5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cf5f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80cf63:	eb 0c                	jmp    80cf71 <netif_set_ipaddr+0x7e>
      } else {
        pcb = pcb->next;
  80cf65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf69:	48 8b 40 10          	mov    0x10(%rax),%rax
  80cf6d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  80cf71:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cf76:	75 b3                	jne    80cf2b <netif_set_ipaddr+0x38>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80cf78:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80cf7f:	00 00 00 
  80cf82:	48 8b 00             	mov    (%rax),%rax
  80cf85:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80cf89:	eb 4a                	jmp    80cfd5 <netif_set_ipaddr+0xe2>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80cf8b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cf8f:	48 85 c0             	test   %rax,%rax
  80cf92:	74 35                	je     80cfc9 <netif_set_ipaddr+0xd6>
  80cf94:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cf98:	8b 00                	mov    (%rax),%eax
  80cf9a:	85 c0                	test   %eax,%eax
  80cf9c:	74 2b                	je     80cfc9 <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  80cf9e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cfa2:	8b 10                	mov    (%rax),%edx
  80cfa4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80cfa8:	8b 40 08             	mov    0x8(%rax),%eax
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80cfab:	39 c2                	cmp    %eax,%edx
  80cfad:	75 1a                	jne    80cfc9 <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  80cfaf:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80cfb4:	74 08                	je     80cfbe <netif_set_ipaddr+0xcb>
  80cfb6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80cfba:	8b 00                	mov    (%rax),%eax
  80cfbc:	eb 05                	jmp    80cfc3 <netif_set_ipaddr+0xd0>
  80cfbe:	b8 00 00 00 00       	mov    $0x0,%eax
  80cfc3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80cfc7:	89 02                	mov    %eax,(%rdx)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80cfc9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cfcd:	48 8b 40 10          	mov    0x10(%rax),%rax
  80cfd1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80cfd5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80cfda:	75 af                	jne    80cf8b <netif_set_ipaddr+0x98>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80cfdc:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80cfe1:	74 08                	je     80cfeb <netif_set_ipaddr+0xf8>
  80cfe3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80cfe7:	8b 00                	mov    (%rax),%eax
  80cfe9:	eb 05                	jmp    80cff0 <netif_set_ipaddr+0xfd>
  80cfeb:	b8 00 00 00 00       	mov    $0x0,%eax
  80cff0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80cff4:	89 42 08             	mov    %eax,0x8(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80cff7:	c9                   	leaveq 
  80cff8:	c3                   	retq   

000000000080cff9 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  80cff9:	55                   	push   %rbp
  80cffa:	48 89 e5             	mov    %rsp,%rbp
  80cffd:	48 83 ec 10          	sub    $0x10,%rsp
  80d001:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d005:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&(netif->gw), gw);
  80d009:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d00e:	74 08                	je     80d018 <netif_set_gw+0x1f>
  80d010:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d014:	8b 00                	mov    (%rax),%eax
  80d016:	eb 05                	jmp    80d01d <netif_set_gw+0x24>
  80d018:	b8 00 00 00 00       	mov    $0x0,%eax
  80d01d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d021:	89 42 10             	mov    %eax,0x10(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  80d024:	c9                   	leaveq 
  80d025:	c3                   	retq   

000000000080d026 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  80d026:	55                   	push   %rbp
  80d027:	48 89 e5             	mov    %rsp,%rbp
  80d02a:	48 83 ec 10          	sub    $0x10,%rsp
  80d02e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d032:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80d036:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d03b:	74 08                	je     80d045 <netif_set_netmask+0x1f>
  80d03d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d041:	8b 00                	mov    (%rax),%eax
  80d043:	eb 05                	jmp    80d04a <netif_set_netmask+0x24>
  80d045:	b8 00 00 00 00       	mov    $0x0,%eax
  80d04a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d04e:	89 42 0c             	mov    %eax,0xc(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  80d051:	c9                   	leaveq 
  80d052:	c3                   	retq   

000000000080d053 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  80d053:	55                   	push   %rbp
  80d054:	48 89 e5             	mov    %rsp,%rbp
  80d057:	48 83 ec 08          	sub    $0x8,%rsp
  80d05b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80d05f:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80d066:	00 00 00 
  80d069:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d06d:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80d070:	c9                   	leaveq 
  80d071:	c3                   	retq   

000000000080d072 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  80d072:	55                   	push   %rbp
  80d073:	48 89 e5             	mov    %rsp,%rbp
  80d076:	48 83 ec 10          	sub    $0x10,%rsp
  80d07a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  80d07e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d082:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d086:	0f b6 c0             	movzbl %al,%eax
  80d089:	83 e0 01             	and    $0x1,%eax
  80d08c:	85 c0                	test   %eax,%eax
  80d08e:	75 49                	jne    80d0d9 <netif_set_up+0x67>
    netif->flags |= NETIF_FLAG_UP;
  80d090:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d094:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d098:	83 c8 01             	or     $0x1,%eax
  80d09b:	89 c2                	mov    %eax,%edx
  80d09d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0a1:	88 50 4a             	mov    %dl,0x4a(%rax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80d0a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0a8:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d0ac:	0f b6 c0             	movzbl %al,%eax
  80d0af:	83 e0 20             	and    $0x20,%eax
  80d0b2:	85 c0                	test   %eax,%eax
  80d0b4:	74 23                	je     80d0d9 <netif_set_up+0x67>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80d0b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0ba:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80d0be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0c2:	ba 00 00 00 00       	mov    $0x0,%edx
  80d0c7:	48 89 ce             	mov    %rcx,%rsi
  80d0ca:	48 89 c7             	mov    %rax,%rdi
  80d0cd:	48 b8 b6 68 81 00 00 	movabs $0x8168b6,%rax
  80d0d4:	00 00 00 
  80d0d7:	ff d0                	callq  *%rax
    }
#endif /* LWIP_ARP */
    
  }
}
  80d0d9:	c9                   	leaveq 
  80d0da:	c3                   	retq   

000000000080d0db <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  80d0db:	55                   	push   %rbp
  80d0dc:	48 89 e5             	mov    %rsp,%rbp
  80d0df:	48 83 ec 08          	sub    $0x8,%rsp
  80d0e3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( netif->flags & NETIF_FLAG_UP )
  80d0e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0eb:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d0ef:	0f b6 c0             	movzbl %al,%eax
  80d0f2:	83 e0 01             	and    $0x1,%eax
  80d0f5:	85 c0                	test   %eax,%eax
  80d0f7:	74 14                	je     80d10d <netif_set_down+0x32>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80d0f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0fd:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d101:	83 e0 fe             	and    $0xfffffffe,%eax
  80d104:	89 c2                	mov    %eax,%edx
  80d106:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d10a:	88 50 4a             	mov    %dl,0x4a(%rax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80d10d:	c9                   	leaveq 
  80d10e:	c3                   	retq   

000000000080d10f <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80d10f:	55                   	push   %rbp
  80d110:	48 89 e5             	mov    %rsp,%rbp
  80d113:	48 83 ec 08          	sub    $0x8,%rsp
  80d117:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80d11b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d11f:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d123:	0f b6 c0             	movzbl %al,%eax
  80d126:	83 e0 01             	and    $0x1,%eax
  80d129:	85 c0                	test   %eax,%eax
  80d12b:	0f 95 c0             	setne  %al
}
  80d12e:	c9                   	leaveq 
  80d12f:	c3                   	retq   

000000000080d130 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  80d130:	55                   	push   %rbp
  80d131:	48 89 e5             	mov    %rsp,%rbp
  80d134:	48 83 ec 30          	sub    $0x30,%rsp
  80d138:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80d13b:	89 f0                	mov    %esi,%eax
  80d13d:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  80d140:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  80d144:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  switch (layer) {
  80d14a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80d14d:	83 f8 01             	cmp    $0x1,%eax
  80d150:	74 16                	je     80d168 <pbuf_alloc+0x38>
  80d152:	83 f8 01             	cmp    $0x1,%eax
  80d155:	72 0c                	jb     80d163 <pbuf_alloc+0x33>
  80d157:	83 f8 02             	cmp    $0x2,%eax
  80d15a:	74 11                	je     80d16d <pbuf_alloc+0x3d>
  80d15c:	83 f8 03             	cmp    $0x3,%eax
  80d15f:	74 3d                	je     80d19e <pbuf_alloc+0x6e>
  80d161:	eb 11                	jmp    80d174 <pbuf_alloc+0x44>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  80d163:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80d168:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  80d16d:	66 83 45 ee 0e       	addw   $0xe,-0x12(%rbp)
    break;
  80d172:	eb 2b                	jmp    80d19f <pbuf_alloc+0x6f>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  80d174:	48 ba b0 1b 82 00 00 	movabs $0x821bb0,%rdx
  80d17b:	00 00 00 
  80d17e:	be 8a 00 00 00       	mov    $0x8a,%esi
  80d183:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d18a:	00 00 00 
  80d18d:	b8 00 00 00 00       	mov    $0x0,%eax
  80d192:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d199:	00 00 00 
  80d19c:	ff d1                	callq  *%rcx
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
  80d19e:	90                   	nop
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  80d19f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d1a2:	83 f8 02             	cmp    $0x2,%eax
  80d1a5:	77 0e                	ja     80d1b5 <pbuf_alloc+0x85>
  80d1a7:	83 f8 01             	cmp    $0x1,%eax
  80d1aa:	0f 83 ac 03 00 00    	jae    80d55c <pbuf_alloc+0x42c>
  80d1b0:	e9 d8 02 00 00       	jmpq   80d48d <pbuf_alloc+0x35d>
  80d1b5:	83 f8 03             	cmp    $0x3,%eax
  80d1b8:	0f 85 05 04 00 00    	jne    80d5c3 <pbuf_alloc+0x493>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  80d1be:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d1c3:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  80d1ca:	00 00 00 
  80d1cd:	ff d0                	callq  *%rax
  80d1cf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  80d1d3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d1d8:	75 0a                	jne    80d1e4 <pbuf_alloc+0xb4>
      return NULL;
  80d1da:	b8 00 00 00 00       	mov    $0x0,%eax
  80d1df:	e9 1f 04 00 00       	jmpq   80d603 <pbuf_alloc+0x4d3>
    }
    p->type = type;
  80d1e4:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d1e7:	89 c2                	mov    %eax,%edx
  80d1e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1ed:	88 50 14             	mov    %dl,0x14(%rax)
    p->next = NULL;
  80d1f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1f4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  80d1fb:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d1ff:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d203:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d207:	48 01 d0             	add    %rdx,%rax
  80d20a:	48 83 c0 03          	add    $0x3,%rax
  80d20e:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d212:	48 89 c2             	mov    %rax,%rdx
  80d215:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d219:	48 89 50 08          	mov    %rdx,0x8(%rax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
  80d21d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d221:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d225:	83 e0 03             	and    $0x3,%eax
  80d228:	48 85 c0             	test   %rax,%rax
  80d22b:	74 2a                	je     80d257 <pbuf_alloc+0x127>
  80d22d:	48 ba e0 1b 82 00 00 	movabs $0x821be0,%rdx
  80d234:	00 00 00 
  80d237:	be 9c 00 00 00       	mov    $0x9c,%esi
  80d23c:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d243:	00 00 00 
  80d246:	b8 00 00 00 00       	mov    $0x0,%eax
  80d24b:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d252:	00 00 00 
  80d255:	ff d1                	callq  *%rcx
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  80d257:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d25b:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d25f:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  80d263:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d267:	83 c0 03             	add    $0x3,%eax
  80d26a:	83 e0 fc             	and    $0xfffffffc,%eax
  80d26d:	89 c2                	mov    %eax,%edx
  80d26f:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  80d274:	29 d0                	sub    %edx,%eax
  80d276:	89 c2                	mov    %eax,%edx
  80d278:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d27c:	39 c2                	cmp    %eax,%edx
  80d27e:	0f 4e c2             	cmovle %edx,%eax
  80d281:	89 c2                	mov    %eax,%edx
  80d283:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d287:	66 89 50 12          	mov    %dx,0x12(%rax)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d28b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d28f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d293:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d297:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d29b:	0f b7 c0             	movzwl %ax,%eax
  80d29e:	48 01 c2             	add    %rax,%rdx
  80d2a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2a5:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d2ab:	48 39 c2             	cmp    %rax,%rdx
  80d2ae:	76 2a                	jbe    80d2da <pbuf_alloc+0x1aa>
  80d2b0:	48 ba 10 1c 82 00 00 	movabs $0x821c10,%rdx
  80d2b7:	00 00 00 
  80d2ba:	be a3 00 00 00       	mov    $0xa3,%esi
  80d2bf:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d2c6:	00 00 00 
  80d2c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80d2ce:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d2d5:	00 00 00 
  80d2d8:	ff d1                	callq  *%rcx
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  80d2da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2de:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  80d2e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2e8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
  80d2ec:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d2f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2f4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d2f8:	0f b7 c0             	movzwl %ax,%eax
  80d2fb:	29 c2                	sub    %eax,%edx
  80d2fd:	89 d0                	mov    %edx,%eax
  80d2ff:	89 45 e8             	mov    %eax,-0x18(%rbp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d302:	e9 77 01 00 00       	jmpq   80d47e <pbuf_alloc+0x34e>
      q = memp_malloc(MEMP_PBUF_POOL);
  80d307:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d30c:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  80d313:	00 00 00 
  80d316:	ff d0                	callq  *%rax
  80d318:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      if (q == NULL) {
  80d31c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d321:	75 1d                	jne    80d340 <pbuf_alloc+0x210>
        /* free chain so far allocated */
        pbuf_free(p);
  80d323:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d327:	48 89 c7             	mov    %rax,%rdi
  80d32a:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  80d331:	00 00 00 
  80d334:	ff d0                	callq  *%rax
        /* bail out unsuccesfully */
        return NULL;
  80d336:	b8 00 00 00 00       	mov    $0x0,%eax
  80d33b:	e9 c3 02 00 00       	jmpq   80d603 <pbuf_alloc+0x4d3>
      }
      q->type = type;
  80d340:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d343:	89 c2                	mov    %eax,%edx
  80d345:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d349:	88 50 14             	mov    %dl,0x14(%rax)
      q->flags = 0;
  80d34c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d350:	c6 40 15 00          	movb   $0x0,0x15(%rax)
      q->next = NULL;
  80d354:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d358:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80d35f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d363:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d367:	48 89 10             	mov    %rdx,(%rax)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80d36a:	81 7d e8 fe ff 00 00 	cmpl   $0xfffe,-0x18(%rbp)
  80d371:	7e 2a                	jle    80d39d <pbuf_alloc+0x26d>
  80d373:	48 ba 41 1c 82 00 00 	movabs $0x821c41,%rdx
  80d37a:	00 00 00 
  80d37d:	be bc 00 00 00       	mov    $0xbc,%esi
  80d382:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d389:	00 00 00 
  80d38c:	b8 00 00 00 00       	mov    $0x0,%eax
  80d391:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d398:	00 00 00 
  80d39b:	ff d1                	callq  *%rcx
      q->tot_len = (u16_t)rem_len;
  80d39d:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d3a0:	89 c2                	mov    %eax,%edx
  80d3a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d3a6:	66 89 50 10          	mov    %dx,0x10(%rax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  80d3aa:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d3ad:	66 3d cf 07          	cmp    $0x7cf,%ax
  80d3b1:	77 05                	ja     80d3b8 <pbuf_alloc+0x288>
  80d3b3:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d3b6:	eb 05                	jmp    80d3bd <pbuf_alloc+0x28d>
  80d3b8:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  80d3bd:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d3c1:	66 89 42 12          	mov    %ax,0x12(%rdx)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  80d3c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d3c9:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d3cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d3d1:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80d3d5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d3d9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d3dd:	83 e0 03             	and    $0x3,%eax
  80d3e0:	48 85 c0             	test   %rax,%rax
  80d3e3:	74 2a                	je     80d40f <pbuf_alloc+0x2df>
  80d3e5:	48 ba 58 1c 82 00 00 	movabs $0x821c58,%rdx
  80d3ec:	00 00 00 
  80d3ef:	be c2 00 00 00       	mov    $0xc2,%esi
  80d3f4:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d3fb:	00 00 00 
  80d3fe:	b8 00 00 00 00       	mov    $0x0,%eax
  80d403:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d40a:	00 00 00 
  80d40d:	ff d1                	callq  *%rcx
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d40f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d413:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d417:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d41b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d41f:	0f b7 c0             	movzwl %ax,%eax
  80d422:	48 01 c2             	add    %rax,%rdx
  80d425:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d429:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d42f:	48 39 c2             	cmp    %rax,%rdx
  80d432:	76 2a                	jbe    80d45e <pbuf_alloc+0x32e>
  80d434:	48 ba 10 1c 82 00 00 	movabs $0x821c10,%rdx
  80d43b:	00 00 00 
  80d43e:	be c5 00 00 00       	mov    $0xc5,%esi
  80d443:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d44a:	00 00 00 
  80d44d:	b8 00 00 00 00       	mov    $0x0,%eax
  80d452:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d459:	00 00 00 
  80d45c:	ff d1                	callq  *%rcx
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  80d45e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d462:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  80d468:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d46c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d470:	0f b7 c0             	movzwl %ax,%eax
  80d473:	29 45 e8             	sub    %eax,-0x18(%rbp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
  80d476:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d47a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d47e:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80d482:	0f 8f 7f fe ff ff    	jg     80d307 <pbuf_alloc+0x1d7>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
  80d488:	e9 60 01 00 00       	jmpq   80d5ed <pbuf_alloc+0x4bd>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  80d48d:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d491:	83 c0 1b             	add    $0x1b,%eax
  80d494:	83 e0 fc             	and    $0xfffffffc,%eax
  80d497:	89 c2                	mov    %eax,%edx
  80d499:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d49d:	83 c0 03             	add    $0x3,%eax
  80d4a0:	83 e0 fc             	and    $0xfffffffc,%eax
  80d4a3:	01 d0                	add    %edx,%eax
  80d4a5:	89 c7                	mov    %eax,%edi
  80d4a7:	48 b8 65 c6 80 00 00 	movabs $0x80c665,%rax
  80d4ae:	00 00 00 
  80d4b1:	ff d0                	callq  *%rax
  80d4b3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d4b7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d4bc:	75 0a                	jne    80d4c8 <pbuf_alloc+0x398>
      return NULL;
  80d4be:	b8 00 00 00 00       	mov    $0x0,%eax
  80d4c3:	e9 3b 01 00 00       	jmpq   80d603 <pbuf_alloc+0x4d3>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  80d4c8:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d4cc:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d4d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4d4:	48 01 d0             	add    %rdx,%rax
  80d4d7:	48 83 c0 03          	add    $0x3,%rax
  80d4db:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d4df:	48 89 c2             	mov    %rax,%rdx
  80d4e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4e6:	48 89 50 08          	mov    %rdx,0x8(%rax)
    p->len = p->tot_len = length;
  80d4ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4ee:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d4f2:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d4f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4fa:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d4fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d502:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d506:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d50a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d511:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d514:	89 c2                	mov    %eax,%edx
  80d516:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d51a:	88 50 14             	mov    %dl,0x14(%rax)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
  80d51d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d521:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d525:	83 e0 03             	and    $0x3,%eax
  80d528:	48 85 c0             	test   %rax,%rax
  80d52b:	74 2a                	je     80d557 <pbuf_alloc+0x427>
  80d52d:	48 ba 88 1c 82 00 00 	movabs $0x821c88,%rdx
  80d534:	00 00 00 
  80d537:	be dd 00 00 00       	mov    $0xdd,%esi
  80d53c:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d543:	00 00 00 
  80d546:	b8 00 00 00 00       	mov    $0x0,%eax
  80d54b:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d552:	00 00 00 
  80d555:	ff d1                	callq  *%rcx
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
  80d557:	e9 91 00 00 00       	jmpq   80d5ed <pbuf_alloc+0x4bd>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  80d55c:	bf 0c 00 00 00       	mov    $0xc,%edi
  80d561:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  80d568:	00 00 00 
  80d56b:	ff d0                	callq  *%rax
  80d56d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d571:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d576:	75 0a                	jne    80d582 <pbuf_alloc+0x452>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  80d578:	b8 00 00 00 00       	mov    $0x0,%eax
  80d57d:	e9 81 00 00 00       	jmpq   80d603 <pbuf_alloc+0x4d3>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  80d582:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d586:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80d58d:	00 
    p->len = p->tot_len = length;
  80d58e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d592:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d596:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d59a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d59e:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d5a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5a6:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d5aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5ae:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d5b5:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d5b8:	89 c2                	mov    %eax,%edx
  80d5ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5be:	88 50 14             	mov    %dl,0x14(%rax)
    break;
  80d5c1:	eb 2a                	jmp    80d5ed <pbuf_alloc+0x4bd>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  80d5c3:	48 ba b3 1c 82 00 00 	movabs $0x821cb3,%rdx
  80d5ca:	00 00 00 
  80d5cd:	be f1 00 00 00       	mov    $0xf1,%esi
  80d5d2:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d5d9:	00 00 00 
  80d5dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80d5e1:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d5e8:	00 00 00 
  80d5eb:	ff d1                	callq  *%rcx
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80d5ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5f1:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
  /* set flags */
  p->flags = 0;
  80d5f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5fb:	c6 40 15 00          	movb   $0x0,0x15(%rax)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  80d5ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80d603:	c9                   	leaveq 
  80d604:	c3                   	retq   

000000000080d605 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  80d605:	55                   	push   %rbp
  80d606:	48 89 e5             	mov    %rsp,%rbp
  80d609:	48 83 ec 20          	sub    $0x20,%rsp
  80d60d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d611:	89 f0                	mov    %esi,%eax
  80d613:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  80d617:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d61c:	75 2a                	jne    80d648 <pbuf_realloc+0x43>
  80d61e:	48 ba ce 1c 82 00 00 	movabs $0x821cce,%rdx
  80d625:	00 00 00 
  80d628:	be 13 01 00 00       	mov    $0x113,%esi
  80d62d:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d634:	00 00 00 
  80d637:	b8 00 00 00 00       	mov    $0x0,%eax
  80d63c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d643:	00 00 00 
  80d646:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  80d648:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d64c:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d650:	3c 03                	cmp    $0x3,%al
  80d652:	74 4e                	je     80d6a2 <pbuf_realloc+0x9d>
  80d654:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d658:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d65c:	3c 01                	cmp    $0x1,%al
  80d65e:	74 42                	je     80d6a2 <pbuf_realloc+0x9d>
  80d660:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d664:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d668:	84 c0                	test   %al,%al
  80d66a:	74 36                	je     80d6a2 <pbuf_realloc+0x9d>
  80d66c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d670:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d674:	3c 02                	cmp    $0x2,%al
  80d676:	74 2a                	je     80d6a2 <pbuf_realloc+0x9d>
  80d678:	48 ba e6 1c 82 00 00 	movabs $0x821ce6,%rdx
  80d67f:	00 00 00 
  80d682:	be 17 01 00 00       	mov    $0x117,%esi
  80d687:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d68e:	00 00 00 
  80d691:	b8 00 00 00 00       	mov    $0x0,%eax
  80d696:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d69d:	00 00 00 
  80d6a0:	ff d1                	callq  *%rcx
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  80d6a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d6a6:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d6aa:	66 3b 45 e4          	cmp    -0x1c(%rbp),%ax
  80d6ae:	77 05                	ja     80d6b5 <pbuf_realloc+0xb0>
    /* enlarging not yet supported */
    return;
  80d6b0:	e9 97 01 00 00       	jmpq   80d84c <pbuf_realloc+0x247>
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  80d6b5:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  80d6b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d6bd:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d6c1:	0f b7 c0             	movzwl %ax,%eax
  80d6c4:	29 c2                	sub    %eax,%edx
  80d6c6:	89 d0                	mov    %edx,%eax
  80d6c8:	89 45 f0             	mov    %eax,-0x10(%rbp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  80d6cb:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d6cf:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  q = p;
  80d6d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d6d7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80d6db:	e9 90 00 00 00       	jmpq   80d770 <pbuf_realloc+0x16b>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  80d6e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d6e4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d6e8:	66 29 45 f6          	sub    %ax,-0xa(%rbp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  80d6ec:	81 7d f0 fe ff 00 00 	cmpl   $0xfffe,-0x10(%rbp)
  80d6f3:	7e 2a                	jle    80d71f <pbuf_realloc+0x11a>
  80d6f5:	48 ba 01 1d 82 00 00 	movabs $0x821d01,%rdx
  80d6fc:	00 00 00 
  80d6ff:	be 2b 01 00 00       	mov    $0x12b,%esi
  80d704:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d70b:	00 00 00 
  80d70e:	b8 00 00 00 00       	mov    $0x0,%eax
  80d713:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d71a:	00 00 00 
  80d71d:	ff d1                	callq  *%rcx
    q->tot_len += (u16_t)grow;
  80d71f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d723:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d727:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80d72a:	01 c2                	add    %eax,%edx
  80d72c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d730:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* proceed to next pbuf in chain */
    q = q->next;
  80d734:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d738:	48 8b 00             	mov    (%rax),%rax
  80d73b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  80d73f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d744:	75 2a                	jne    80d770 <pbuf_realloc+0x16b>
  80d746:	48 ba 12 1d 82 00 00 	movabs $0x821d12,%rdx
  80d74d:	00 00 00 
  80d750:	be 2f 01 00 00       	mov    $0x12f,%esi
  80d755:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d75c:	00 00 00 
  80d75f:	b8 00 00 00 00       	mov    $0x0,%eax
  80d764:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d76b:	00 00 00 
  80d76e:	ff d1                	callq  *%rcx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80d770:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d774:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d778:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80d77c:	0f 82 5e ff ff ff    	jb     80d6e0 <pbuf_realloc+0xdb>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  80d782:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d786:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d78a:	84 c0                	test   %al,%al
  80d78c:	75 75                	jne    80d803 <pbuf_realloc+0x1fe>
  80d78e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d792:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d796:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80d79a:	74 67                	je     80d803 <pbuf_realloc+0x1fe>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  80d79c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d7a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d7a4:	48 89 c2             	mov    %rax,%rdx
  80d7a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d7ab:	48 29 c2             	sub    %rax,%rdx
  80d7ae:	48 89 d0             	mov    %rdx,%rax
  80d7b1:	89 c2                	mov    %eax,%edx
  80d7b3:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80d7b7:	01 c2                	add    %eax,%edx
  80d7b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d7bd:	89 d6                	mov    %edx,%esi
  80d7bf:	48 89 c7             	mov    %rax,%rdi
  80d7c2:	48 b8 4e c3 80 00 00 	movabs $0x80c34e,%rax
  80d7c9:	00 00 00 
  80d7cc:	ff d0                	callq  *%rax
  80d7ce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  80d7d2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d7d7:	75 2a                	jne    80d803 <pbuf_realloc+0x1fe>
  80d7d9:	48 ba 2a 1d 82 00 00 	movabs $0x821d2a,%rdx
  80d7e0:	00 00 00 
  80d7e3:	be 39 01 00 00       	mov    $0x139,%esi
  80d7e8:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d7ef:	00 00 00 
  80d7f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80d7f7:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d7fe:	00 00 00 
  80d801:	ff d1                	callq  *%rcx
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  80d803:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d807:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80d80b:	66 89 50 12          	mov    %dx,0x12(%rax)
  q->tot_len = q->len;
  80d80f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d813:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80d817:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d81b:	66 89 50 10          	mov    %dx,0x10(%rax)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  80d81f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d823:	48 8b 00             	mov    (%rax),%rax
  80d826:	48 85 c0             	test   %rax,%rax
  80d829:	74 16                	je     80d841 <pbuf_realloc+0x23c>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  80d82b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d82f:	48 8b 00             	mov    (%rax),%rax
  80d832:	48 89 c7             	mov    %rax,%rdi
  80d835:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  80d83c:	00 00 00 
  80d83f:	ff d0                	callq  *%rax
  }
  /* q is last packet in chain */
  q->next = NULL;
  80d841:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d845:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

}
  80d84c:	c9                   	leaveq 
  80d84d:	c3                   	retq   

000000000080d84e <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  80d84e:	55                   	push   %rbp
  80d84f:	48 89 e5             	mov    %rsp,%rbp
  80d852:	48 83 ec 20          	sub    $0x20,%rsp
  80d856:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d85a:	89 f0                	mov    %esi,%eax
  80d85c:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  80d860:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d865:	75 2a                	jne    80d891 <pbuf_header+0x43>
  80d867:	48 ba 45 1d 82 00 00 	movabs $0x821d45,%rdx
  80d86e:	00 00 00 
  80d871:	be 64 01 00 00       	mov    $0x164,%esi
  80d876:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d87d:	00 00 00 
  80d880:	b8 00 00 00 00       	mov    $0x0,%eax
  80d885:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d88c:	00 00 00 
  80d88f:	ff d1                	callq  *%rcx
  if ((header_size_increment == 0) || (p == NULL))
  80d891:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80d896:	74 07                	je     80d89f <pbuf_header+0x51>
  80d898:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d89d:	75 0a                	jne    80d8a9 <pbuf_header+0x5b>
    return 0;
  80d89f:	b8 00 00 00 00       	mov    $0x0,%eax
  80d8a4:	e9 64 01 00 00       	jmpq   80da0d <pbuf_header+0x1bf>
 
  if (header_size_increment < 0){
  80d8a9:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80d8ae:	79 42                	jns    80d8f2 <pbuf_header+0xa4>
    increment_magnitude = -header_size_increment;
  80d8b0:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d8b4:	f7 d8                	neg    %eax
  80d8b6:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80d8ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d8be:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d8c2:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80d8c6:	73 32                	jae    80d8fa <pbuf_header+0xac>
  80d8c8:	48 ba 4f 1d 82 00 00 	movabs $0x821d4f,%rdx
  80d8cf:	00 00 00 
  80d8d2:	be 6b 01 00 00       	mov    $0x16b,%esi
  80d8d7:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d8de:	00 00 00 
  80d8e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80d8e6:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d8ed:	00 00 00 
  80d8f0:	ff d1                	callq  *%rcx
  } else {
    increment_magnitude = header_size_increment;
  80d8f2:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d8f6:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  80d8fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d8fe:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d902:	0f b6 c0             	movzbl %al,%eax
  80d905:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  /* remember current payload pointer */
  payload = p->payload;
  80d909:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d90d:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d911:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80d915:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80d91a:	74 07                	je     80d923 <pbuf_header+0xd5>
  80d91c:	66 83 7d fc 03       	cmpw   $0x3,-0x4(%rbp)
  80d921:	75 48                	jne    80d96b <pbuf_header+0x11d>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  80d923:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d927:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d92b:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80d930:	48 f7 da             	neg    %rdx
  80d933:	48 01 c2             	add    %rax,%rdx
  80d936:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d93a:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80d93e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d942:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d946:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80d94a:	48 83 c2 18          	add    $0x18,%rdx
  80d94e:	48 39 d0             	cmp    %rdx,%rax
  80d951:	73 16                	jae    80d969 <pbuf_header+0x11b>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  80d953:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d957:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80d95b:	48 89 50 08          	mov    %rdx,0x8(%rax)
      /* bail out unsuccesfully */
      return 1;
  80d95f:	b8 01 00 00 00       	mov    $0x1,%eax
  80d964:	e9 a4 00 00 00       	jmpq   80da0d <pbuf_header+0x1bf>
  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80d969:	eb 71                	jmp    80d9dc <pbuf_header+0x18e>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  80d96b:	66 83 7d fc 02       	cmpw   $0x2,-0x4(%rbp)
  80d970:	74 07                	je     80d979 <pbuf_header+0x12b>
  80d972:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%rbp)
  80d977:	75 39                	jne    80d9b2 <pbuf_header+0x164>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80d979:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80d97e:	79 2b                	jns    80d9ab <pbuf_header+0x15d>
  80d980:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d984:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d988:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80d98c:	72 1d                	jb     80d9ab <pbuf_header+0x15d>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  80d98e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d992:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d996:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80d99b:	48 f7 da             	neg    %rdx
  80d99e:	48 01 c2             	add    %rax,%rdx
  80d9a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d9a5:	48 89 50 08          	mov    %rdx,0x8(%rax)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80d9a9:	eb 31                	jmp    80d9dc <pbuf_header+0x18e>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  80d9ab:	b8 01 00 00 00       	mov    $0x1,%eax
  80d9b0:	eb 5b                	jmp    80da0d <pbuf_header+0x1bf>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  80d9b2:	48 ba 6d 1d 82 00 00 	movabs $0x821d6d,%rdx
  80d9b9:	00 00 00 
  80d9bc:	be 9a 01 00 00       	mov    $0x19a,%esi
  80d9c1:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80d9c8:	00 00 00 
  80d9cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80d9d0:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80d9d7:	00 00 00 
  80d9da:	ff d1                	callq  *%rcx
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  80d9dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d9e0:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80d9e4:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d9e8:	01 c2                	add    %eax,%edx
  80d9ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d9ee:	66 89 50 12          	mov    %dx,0x12(%rax)
  p->tot_len += header_size_increment;
  80d9f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d9f6:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d9fa:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d9fe:	01 c2                	add    %eax,%edx
  80da00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da04:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  80da08:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80da0d:	c9                   	leaveq 
  80da0e:	c3                   	retq   

000000000080da0f <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80da0f:	55                   	push   %rbp
  80da10:	48 89 e5             	mov    %rsp,%rbp
  80da13:	48 83 ec 30          	sub    $0x30,%rsp
  80da17:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80da1b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80da20:	75 3b                	jne    80da5d <pbuf_free+0x4e>
    LWIP_ASSERT("p != NULL", p != NULL);
  80da22:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80da27:	75 2a                	jne    80da53 <pbuf_free+0x44>
  80da29:	48 ba 45 1d 82 00 00 	movabs $0x821d45,%rdx
  80da30:	00 00 00 
  80da33:	be d0 01 00 00       	mov    $0x1d0,%esi
  80da38:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80da3f:	00 00 00 
  80da42:	b8 00 00 00 00       	mov    $0x0,%eax
  80da47:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80da4e:	00 00 00 
  80da51:	ff d1                	callq  *%rcx
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
  80da53:	b8 00 00 00 00       	mov    $0x0,%eax
  80da58:	e9 65 01 00 00       	jmpq   80dbc2 <pbuf_free+0x1b3>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80da5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80da61:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80da65:	84 c0                	test   %al,%al
  80da67:	74 4e                	je     80dab7 <pbuf_free+0xa8>
  80da69:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80da6d:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80da71:	3c 01                	cmp    $0x1,%al
  80da73:	74 42                	je     80dab7 <pbuf_free+0xa8>
  80da75:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80da79:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80da7d:	3c 02                	cmp    $0x2,%al
  80da7f:	74 36                	je     80dab7 <pbuf_free+0xa8>
  80da81:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80da85:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80da89:	3c 03                	cmp    $0x3,%al
  80da8b:	74 2a                	je     80dab7 <pbuf_free+0xa8>
  80da8d:	48 ba 7b 1d 82 00 00 	movabs $0x821d7b,%rdx
  80da94:	00 00 00 
  80da97:	be db 01 00 00       	mov    $0x1db,%esi
  80da9c:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80daa3:	00 00 00 
  80daa6:	b8 00 00 00 00       	mov    $0x0,%eax
  80daab:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80dab2:	00 00 00 
  80dab5:	ff d1                	callq  *%rcx
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  80dab7:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80dabb:	e9 f3 00 00 00       	jmpq   80dbb3 <pbuf_free+0x1a4>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80dac0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dac4:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80dac8:	66 85 c0             	test   %ax,%ax
  80dacb:	75 2a                	jne    80daf7 <pbuf_free+0xe8>
  80dacd:	48 ba 90 1d 82 00 00 	movabs $0x821d90,%rdx
  80dad4:	00 00 00 
  80dad7:	be e8 01 00 00       	mov    $0x1e8,%esi
  80dadc:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80dae3:	00 00 00 
  80dae6:	b8 00 00 00 00       	mov    $0x0,%eax
  80daeb:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80daf2:	00 00 00 
  80daf5:	ff d1                	callq  *%rcx
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  80daf7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dafb:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80daff:	8d 50 ff             	lea    -0x1(%rax),%edx
  80db02:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db06:	66 89 50 16          	mov    %dx,0x16(%rax)
  80db0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db0e:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80db12:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  80db16:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80db1b:	0f 85 8a 00 00 00    	jne    80dbab <pbuf_free+0x19c>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  80db21:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db25:	48 8b 00             	mov    (%rax),%rax
  80db28:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  80db2c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db30:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80db34:	0f b6 c0             	movzbl %al,%eax
  80db37:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  80db3b:	66 83 7d ee 03       	cmpw   $0x3,-0x12(%rbp)
  80db40:	75 1a                	jne    80db5c <pbuf_free+0x14d>
        memp_free(MEMP_PBUF_POOL, p);
  80db42:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db46:	48 89 c6             	mov    %rax,%rsi
  80db49:	bf 0d 00 00 00       	mov    $0xd,%edi
  80db4e:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80db55:	00 00 00 
  80db58:	ff d0                	callq  *%rax
  80db5a:	eb 3b                	jmp    80db97 <pbuf_free+0x188>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  80db5c:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  80db61:	74 07                	je     80db6a <pbuf_free+0x15b>
  80db63:	66 83 7d ee 02       	cmpw   $0x2,-0x12(%rbp)
  80db68:	75 1a                	jne    80db84 <pbuf_free+0x175>
        memp_free(MEMP_PBUF, p);
  80db6a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db6e:	48 89 c6             	mov    %rax,%rsi
  80db71:	bf 0c 00 00 00       	mov    $0xc,%edi
  80db76:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80db7d:	00 00 00 
  80db80:	ff d0                	callq  *%rax
  80db82:	eb 13                	jmp    80db97 <pbuf_free+0x188>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  80db84:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db88:	48 89 c7             	mov    %rax,%rdi
  80db8b:	48 b8 c9 c1 80 00 00 	movabs $0x80c1c9,%rax
  80db92:	00 00 00 
  80db95:	ff d0                	callq  *%rax
      }
      count++;
  80db97:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80db9b:	83 c0 01             	add    $0x1,%eax
  80db9e:	88 45 ff             	mov    %al,-0x1(%rbp)
      /* proceed to next pbuf */
      p = q;
  80dba1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dba5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80dba9:	eb 08                	jmp    80dbb3 <pbuf_free+0x1a4>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
  80dbab:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80dbb2:	00 
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80dbb3:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dbb8:	0f 85 02 ff ff ff    	jne    80dac0 <pbuf_free+0xb1>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
  80dbbe:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80dbc2:	c9                   	leaveq 
  80dbc3:	c3                   	retq   

000000000080dbc4 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  80dbc4:	55                   	push   %rbp
  80dbc5:	48 89 e5             	mov    %rsp,%rbp
  80dbc8:	48 83 ec 18          	sub    $0x18,%rsp
  80dbcc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t len;

  len = 0;
  80dbd0:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  while (p != NULL) {
  80dbd4:	eb 0f                	jmp    80dbe5 <pbuf_clen+0x21>
    ++len;
  80dbd6:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
    p = p->next;
  80dbda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dbde:	48 8b 00             	mov    (%rax),%rax
  80dbe1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  80dbe5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80dbea:	75 ea                	jne    80dbd6 <pbuf_clen+0x12>
    ++len;
    p = p->next;
  }
  return len;
  80dbec:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80dbf0:	c9                   	leaveq 
  80dbf1:	c3                   	retq   

000000000080dbf2 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  80dbf2:	55                   	push   %rbp
  80dbf3:	48 89 e5             	mov    %rsp,%rbp
  80dbf6:	48 83 ec 08          	sub    $0x8,%rsp
  80dbfa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  80dbfe:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80dc03:	74 13                	je     80dc18 <pbuf_ref+0x26>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  80dc05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dc09:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80dc0d:	8d 50 01             	lea    0x1(%rax),%edx
  80dc10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dc14:	66 89 50 16          	mov    %dx,0x16(%rax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  80dc18:	c9                   	leaveq 
  80dc19:	c3                   	retq   

000000000080dc1a <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  80dc1a:	55                   	push   %rbp
  80dc1b:	48 89 e5             	mov    %rsp,%rbp
  80dc1e:	48 83 ec 20          	sub    $0x20,%rsp
  80dc22:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80dc26:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80dc2a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80dc2f:	74 07                	je     80dc38 <pbuf_cat+0x1e>
  80dc31:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80dc36:	75 2a                	jne    80dc62 <pbuf_cat+0x48>
  80dc38:	48 ba a8 1d 82 00 00 	movabs $0x821da8,%rdx
  80dc3f:	00 00 00 
  80dc42:	be 42 02 00 00       	mov    $0x242,%esi
  80dc47:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80dc4e:	00 00 00 
  80dc51:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc56:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80dc5d:	00 00 00 
  80dc60:	ff d1                	callq  *%rcx
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80dc62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc66:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80dc6a:	eb 25                	jmp    80dc91 <pbuf_cat+0x77>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  80dc6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dc70:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dc74:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80dc78:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dc7c:	01 c2                	add    %eax,%edx
  80dc7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dc82:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80dc86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dc8a:	48 8b 00             	mov    (%rax),%rax
  80dc8d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80dc91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dc95:	48 8b 00             	mov    (%rax),%rax
  80dc98:	48 85 c0             	test   %rax,%rax
  80dc9b:	75 cf                	jne    80dc6c <pbuf_cat+0x52>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  80dc9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dca1:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dca5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dca9:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dcad:	66 39 c2             	cmp    %ax,%dx
  80dcb0:	74 2a                	je     80dcdc <pbuf_cat+0xc2>
  80dcb2:	48 ba e0 1d 82 00 00 	movabs $0x821de0,%rdx
  80dcb9:	00 00 00 
  80dcbc:	be 4a 02 00 00       	mov    $0x24a,%esi
  80dcc1:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80dcc8:	00 00 00 
  80dccb:	b8 00 00 00 00       	mov    $0x0,%eax
  80dcd0:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80dcd7:	00 00 00 
  80dcda:	ff d1                	callq  *%rcx
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  80dcdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dce0:	48 8b 00             	mov    (%rax),%rax
  80dce3:	48 85 c0             	test   %rax,%rax
  80dce6:	74 2a                	je     80dd12 <pbuf_cat+0xf8>
  80dce8:	48 ba 0d 1e 82 00 00 	movabs $0x821e0d,%rdx
  80dcef:	00 00 00 
  80dcf2:	be 4b 02 00 00       	mov    $0x24b,%esi
  80dcf7:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80dcfe:	00 00 00 
  80dd01:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd06:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80dd0d:	00 00 00 
  80dd10:	ff d1                	callq  *%rcx
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  80dd12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dd16:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dd1a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80dd1e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dd22:	01 c2                	add    %eax,%edx
  80dd24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dd28:	66 89 50 10          	mov    %dx,0x10(%rax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  80dd2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dd30:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80dd34:	48 89 10             	mov    %rdx,(%rax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  80dd37:	c9                   	leaveq 
  80dd38:	c3                   	retq   

000000000080dd39 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  80dd39:	55                   	push   %rbp
  80dd3a:	48 89 e5             	mov    %rsp,%rbp
  80dd3d:	48 83 ec 10          	sub    $0x10,%rsp
  80dd41:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80dd45:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pbuf_cat(h, t);
  80dd49:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80dd4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dd51:	48 89 d6             	mov    %rdx,%rsi
  80dd54:	48 89 c7             	mov    %rax,%rdi
  80dd57:	48 b8 1a dc 80 00 00 	movabs $0x80dc1a,%rax
  80dd5e:	00 00 00 
  80dd61:	ff d0                	callq  *%rax
  /* t is now referenced by h */
  pbuf_ref(t);
  80dd63:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dd67:	48 89 c7             	mov    %rax,%rdi
  80dd6a:	48 b8 f2 db 80 00 00 	movabs $0x80dbf2,%rax
  80dd71:	00 00 00 
  80dd74:	ff d0                	callq  *%rax
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80dd76:	c9                   	leaveq 
  80dd77:	c3                   	retq   

000000000080dd78 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  80dd78:	55                   	push   %rbp
  80dd79:	48 89 e5             	mov    %rsp,%rbp
  80dd7c:	48 83 ec 20          	sub    $0x20,%rsp
  80dd80:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q;
  u8_t tail_gone = 1;
  80dd84:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  /* tail */
  q = p->next;
  80dd88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd8c:	48 8b 00             	mov    (%rax),%rax
  80dd8f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
  80dd93:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80dd98:	0f 84 9e 00 00 00    	je     80de3c <pbuf_dechain+0xc4>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  80dd9e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dda2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dda6:	0f b7 d0             	movzwl %ax,%edx
  80dda9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ddad:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80ddb1:	0f b7 c8             	movzwl %ax,%ecx
  80ddb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ddb8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80ddbc:	0f b7 c0             	movzwl %ax,%eax
  80ddbf:	29 c1                	sub    %eax,%ecx
  80ddc1:	89 c8                	mov    %ecx,%eax
  80ddc3:	39 c2                	cmp    %eax,%edx
  80ddc5:	74 2a                	je     80ddf1 <pbuf_dechain+0x79>
  80ddc7:	48 ba 20 1e 82 00 00 	movabs $0x821e20,%rdx
  80ddce:	00 00 00 
  80ddd1:	be 80 02 00 00       	mov    $0x280,%esi
  80ddd6:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80dddd:	00 00 00 
  80dde0:	b8 00 00 00 00       	mov    $0x0,%eax
  80dde5:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80ddec:	00 00 00 
  80ddef:	ff d1                	callq  *%rcx
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  80ddf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ddf5:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80ddf9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ddfd:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80de01:	29 c2                	sub    %eax,%edx
  80de03:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80de07:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* decouple pbuf from remainder */
    p->next = NULL;
  80de0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80de0f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  80de16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80de1a:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80de1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80de22:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  80de26:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80de2a:	48 89 c7             	mov    %rax,%rdi
  80de2d:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  80de34:	00 00 00 
  80de37:	ff d0                	callq  *%rax
  80de39:	88 45 ff             	mov    %al,-0x1(%rbp)
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  80de3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80de40:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80de44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80de48:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80de4c:	66 39 c2             	cmp    %ax,%dx
  80de4f:	74 2a                	je     80de7b <pbuf_dechain+0x103>
  80de51:	48 ba 42 1e 82 00 00 	movabs $0x821e42,%rdx
  80de58:	00 00 00 
  80de5b:	be 91 02 00 00       	mov    $0x291,%esi
  80de60:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80de67:	00 00 00 
  80de6a:	b8 00 00 00 00       	mov    $0x0,%eax
  80de6f:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80de76:	00 00 00 
  80de79:	ff d1                	callq  *%rcx
  return ((tail_gone > 0) ? NULL : q);
  80de7b:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80de7f:	75 06                	jne    80de87 <pbuf_dechain+0x10f>
  80de81:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80de85:	eb 05                	jmp    80de8c <pbuf_dechain+0x114>
  80de87:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80de8c:	c9                   	leaveq 
  80de8d:	c3                   	retq   

000000000080de8e <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  80de8e:	55                   	push   %rbp
  80de8f:	48 89 e5             	mov    %rsp,%rbp
  80de92:	48 83 ec 20          	sub    $0x20,%rsp
  80de96:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80de9a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u16_t offset_to=0, offset_from=0, len;
  80de9e:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  80dea4:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%rbp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  80deaa:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80deaf:	74 1c                	je     80decd <pbuf_copy+0x3f>
  80deb1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80deb6:	74 15                	je     80decd <pbuf_copy+0x3f>
  80deb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80debc:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dec0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80dec4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dec8:	66 39 c2             	cmp    %ax,%dx
  80decb:	73 2a                	jae    80def7 <pbuf_copy+0x69>
  80decd:	48 ba 58 1e 82 00 00 	movabs $0x821e58,%rdx
  80ded4:	00 00 00 
  80ded7:	be b1 02 00 00       	mov    $0x2b1,%esi
  80dedc:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80dee3:	00 00 00 
  80dee6:	b8 00 00 00 00       	mov    $0x0,%eax
  80deeb:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80def2:	00 00 00 
  80def5:	ff d1                	callq  *%rcx
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80def7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80defc:	75 2a                	jne    80df28 <pbuf_copy+0x9a>
  80defe:	48 ba 88 1e 82 00 00 	movabs $0x821e88,%rdx
  80df05:	00 00 00 
  80df08:	be b6 02 00 00       	mov    $0x2b6,%esi
  80df0d:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80df14:	00 00 00 
  80df17:	b8 00 00 00 00       	mov    $0x0,%eax
  80df1c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80df23:	00 00 00 
  80df26:	ff d1                	callq  *%rcx
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  80df28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80df2c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80df30:	0f b7 d0             	movzwl %ax,%edx
  80df33:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  80df37:	89 d1                	mov    %edx,%ecx
  80df39:	29 c1                	sub    %eax,%ecx
  80df3b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80df3f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80df43:	0f b7 d0             	movzwl %ax,%edx
  80df46:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  80df4a:	29 c2                	sub    %eax,%edx
  80df4c:	89 d0                	mov    %edx,%eax
  80df4e:	39 c1                	cmp    %eax,%ecx
  80df50:	7c 12                	jl     80df64 <pbuf_copy+0xd6>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  80df52:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80df56:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80df5a:	66 2b 45 fc          	sub    -0x4(%rbp),%ax
  80df5e:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
  80df62:	eb 10                	jmp    80df74 <pbuf_copy+0xe6>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  80df64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80df68:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80df6c:	66 2b 45 fe          	sub    -0x2(%rbp),%ax
  80df70:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  80df74:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80df78:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80df7c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80df80:	0f b7 55 fc          	movzwl -0x4(%rbp),%edx
  80df84:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80df88:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80df8c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80df90:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  80df94:	48 01 d1             	add    %rdx,%rcx
  80df97:	48 89 c2             	mov    %rax,%rdx
  80df9a:	48 89 cf             	mov    %rcx,%rdi
  80df9d:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  80dfa4:	00 00 00 
  80dfa7:	ff d0                	callq  *%rax
    offset_to += len;
  80dfa9:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80dfad:	66 01 45 fe          	add    %ax,-0x2(%rbp)
    offset_from += len;
  80dfb1:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80dfb5:	66 01 45 fc          	add    %ax,-0x4(%rbp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  80dfb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dfbd:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dfc1:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80dfc5:	73 2a                	jae    80dff1 <pbuf_copy+0x163>
  80dfc7:	48 ba 95 1e 82 00 00 	movabs $0x821e95,%rdx
  80dfce:	00 00 00 
  80dfd1:	be c2 02 00 00       	mov    $0x2c2,%esi
  80dfd6:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80dfdd:	00 00 00 
  80dfe0:	b8 00 00 00 00       	mov    $0x0,%eax
  80dfe5:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80dfec:	00 00 00 
  80dfef:	ff d1                	callq  *%rcx
    if (offset_to == p_to->len) {
  80dff1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dff5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dff9:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80dffd:	75 11                	jne    80e010 <pbuf_copy+0x182>
      /* on to next p_to (if any) */
      offset_to = 0;
  80dfff:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
      p_to = p_to->next;
  80e005:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e009:	48 8b 00             	mov    (%rax),%rax
  80e00c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  80e010:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e014:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e018:	66 3b 45 fc          	cmp    -0x4(%rbp),%ax
  80e01c:	73 2a                	jae    80e048 <pbuf_copy+0x1ba>
  80e01e:	48 ba ac 1e 82 00 00 	movabs $0x821eac,%rdx
  80e025:	00 00 00 
  80e028:	be c8 02 00 00       	mov    $0x2c8,%esi
  80e02d:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80e034:	00 00 00 
  80e037:	b8 00 00 00 00       	mov    $0x0,%eax
  80e03c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80e043:	00 00 00 
  80e046:	ff d1                	callq  *%rcx
    if (offset_from >= p_from->len) {
  80e048:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e04c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e050:	66 3b 45 fc          	cmp    -0x4(%rbp),%ax
  80e054:	77 11                	ja     80e067 <pbuf_copy+0x1d9>
      /* on to next p_from (if any) */
      offset_from = 0;
  80e056:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%rbp)
      p_from = p_from->next;
  80e05c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e060:	48 8b 00             	mov    (%rax),%rax
  80e063:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80e067:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e06c:	74 4b                	je     80e0b9 <pbuf_copy+0x22b>
  80e06e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e072:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e076:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e07a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e07e:	66 39 c2             	cmp    %ax,%dx
  80e081:	75 36                	jne    80e0b9 <pbuf_copy+0x22b>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80e083:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e087:	48 8b 00             	mov    (%rax),%rax
  80e08a:	48 85 c0             	test   %rax,%rax
  80e08d:	74 2a                	je     80e0b9 <pbuf_copy+0x22b>
  80e08f:	48 ba c8 1e 82 00 00 	movabs $0x821ec8,%rdx
  80e096:	00 00 00 
  80e099:	be d2 02 00 00       	mov    $0x2d2,%esi
  80e09e:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80e0a5:	00 00 00 
  80e0a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80e0ad:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80e0b4:	00 00 00 
  80e0b7:	ff d1                	callq  *%rcx
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80e0b9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e0be:	74 4b                	je     80e10b <pbuf_copy+0x27d>
  80e0c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e0c4:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e0c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e0cc:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e0d0:	66 39 c2             	cmp    %ax,%dx
  80e0d3:	75 36                	jne    80e10b <pbuf_copy+0x27d>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80e0d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e0d9:	48 8b 00             	mov    (%rax),%rax
  80e0dc:	48 85 c0             	test   %rax,%rax
  80e0df:	74 2a                	je     80e10b <pbuf_copy+0x27d>
  80e0e1:	48 ba c8 1e 82 00 00 	movabs $0x821ec8,%rdx
  80e0e8:	00 00 00 
  80e0eb:	be d7 02 00 00       	mov    $0x2d7,%esi
  80e0f0:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80e0f7:	00 00 00 
  80e0fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80e0ff:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80e106:	00 00 00 
  80e109:	ff d1                	callq  *%rcx
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80e10b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e110:	0f 85 e1 fd ff ff    	jne    80def7 <pbuf_copy+0x69>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
  80e116:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e11b:	c9                   	leaveq 
  80e11c:	c3                   	retq   

000000000080e11d <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  80e11d:	55                   	push   %rbp
  80e11e:	48 89 e5             	mov    %rsp,%rbp
  80e121:	48 83 ec 30          	sub    $0x30,%rsp
  80e125:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80e129:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80e12d:	89 c8                	mov    %ecx,%eax
  80e12f:	66 89 55 dc          	mov    %dx,-0x24(%rbp)
  80e133:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
  80e137:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%rbp)

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80e13d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e142:	75 2a                	jne    80e16e <pbuf_copy_partial+0x51>
  80e144:	48 ba f8 1e 82 00 00 	movabs $0x821ef8,%rdx
  80e14b:	00 00 00 
  80e14e:	be ef 02 00 00       	mov    $0x2ef,%esi
  80e153:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80e15a:	00 00 00 
  80e15d:	b8 00 00 00 00       	mov    $0x0,%eax
  80e162:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80e169:	00 00 00 
  80e16c:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  80e16e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e173:	75 2a                	jne    80e19f <pbuf_copy_partial+0x82>
  80e175:	48 ba 20 1f 82 00 00 	movabs $0x821f20,%rdx
  80e17c:	00 00 00 
  80e17f:	be f0 02 00 00       	mov    $0x2f0,%esi
  80e184:	48 bf cb 1b 82 00 00 	movabs $0x821bcb,%rdi
  80e18b:	00 00 00 
  80e18e:	b8 00 00 00 00       	mov    $0x0,%eax
  80e193:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80e19a:	00 00 00 
  80e19d:	ff d1                	callq  *%rcx

  left = 0;
  80e19f:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if((buf == NULL) || (dataptr == NULL)) {
  80e1a5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e1aa:	74 07                	je     80e1b3 <pbuf_copy_partial+0x96>
  80e1ac:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e1b1:	75 0a                	jne    80e1bd <pbuf_copy_partial+0xa0>
    return 0;
  80e1b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80e1b8:	e9 c2 00 00 00       	jmpq   80e27f <pbuf_copy_partial+0x162>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80e1bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1c1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e1c5:	e9 9f 00 00 00       	jmpq   80e269 <pbuf_copy_partial+0x14c>
    if ((offset != 0) && (offset >= p->len)) {
  80e1ca:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%rbp)
  80e1cf:	74 1c                	je     80e1ed <pbuf_copy_partial+0xd0>
  80e1d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e1d5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e1d9:	66 3b 45 d8          	cmp    -0x28(%rbp),%ax
  80e1dd:	77 0e                	ja     80e1ed <pbuf_copy_partial+0xd0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  80e1df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e1e3:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e1e7:	66 29 45 d8          	sub    %ax,-0x28(%rbp)
  80e1eb:	eb 71                	jmp    80e25e <pbuf_copy_partial+0x141>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  80e1ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e1f1:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e1f5:	66 2b 45 d8          	sub    -0x28(%rbp),%ax
  80e1f9:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      if (buf_copy_len > len)
  80e1fd:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e201:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80e205:	76 08                	jbe    80e20f <pbuf_copy_partial+0xf2>
          buf_copy_len = len;
  80e207:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80e20b:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80e20f:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e213:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80e217:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e21b:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80e21f:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80e223:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80e227:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e22b:	48 01 d1             	add    %rdx,%rcx
  80e22e:	48 89 c2             	mov    %rax,%rdx
  80e231:	48 89 cf             	mov    %rcx,%rdi
  80e234:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  80e23b:	00 00 00 
  80e23e:	ff d0                	callq  *%rax
      copied_total += buf_copy_len;
  80e240:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e244:	66 01 45 f2          	add    %ax,-0xe(%rbp)
      left += buf_copy_len;
  80e248:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e24c:	66 01 45 f6          	add    %ax,-0xa(%rbp)
      len -= buf_copy_len;
  80e250:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e254:	66 29 45 dc          	sub    %ax,-0x24(%rbp)
      offset = 0;
  80e258:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80e25e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e262:	48 8b 00             	mov    (%rax),%rax
  80e265:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e269:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80e26e:	74 0b                	je     80e27b <pbuf_copy_partial+0x15e>
  80e270:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e275:	0f 85 4f ff ff ff    	jne    80e1ca <pbuf_copy_partial+0xad>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
  80e27b:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
}
  80e27f:	c9                   	leaveq 
  80e280:	c3                   	retq   

000000000080e281 <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80e281:	55                   	push   %rbp
  80e282:	48 89 e5             	mov    %rsp,%rbp
  80e285:	48 83 ec 40          	sub    $0x40,%rsp
  80e289:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80e28c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  80e290:	48 b8 27 85 81 00 00 	movabs $0x818527,%rax
  80e297:	00 00 00 
  80e29a:	ff d0                	callq  *%rax
  80e29c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e2a0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e2a5:	74 0c                	je     80e2b3 <sys_mbox_fetch+0x32>
  80e2a7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e2ab:	48 8b 00             	mov    (%rax),%rax
  80e2ae:	48 85 c0             	test   %rax,%rax
  80e2b1:	75 25                	jne    80e2d8 <sys_mbox_fetch+0x57>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80e2b3:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e2b7:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e2ba:	ba 00 00 00 00       	mov    $0x0,%edx
  80e2bf:	48 89 ce             	mov    %rcx,%rsi
  80e2c2:	89 c7                	mov    %eax,%edi
  80e2c4:	48 b8 42 80 81 00 00 	movabs $0x818042,%rax
  80e2cb:	00 00 00 
  80e2ce:	ff d0                	callq  *%rax
  80e2d0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e2d3:	e9 e1 00 00 00       	jmpq   80e3b9 <sys_mbox_fetch+0x138>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  80e2d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e2dc:	48 8b 00             	mov    (%rax),%rax
  80e2df:	8b 40 08             	mov    0x8(%rax),%eax
  80e2e2:	85 c0                	test   %eax,%eax
  80e2e4:	74 27                	je     80e30d <sys_mbox_fetch+0x8c>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  80e2e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e2ea:	48 8b 00             	mov    (%rax),%rax
  80e2ed:	8b 50 08             	mov    0x8(%rax),%edx
  80e2f0:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e2f4:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e2f7:	48 89 ce             	mov    %rcx,%rsi
  80e2fa:	89 c7                	mov    %eax,%edi
  80e2fc:	48 b8 42 80 81 00 00 	movabs $0x818042,%rax
  80e303:	00 00 00 
  80e306:	ff d0                	callq  *%rax
  80e308:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e30b:	eb 07                	jmp    80e314 <sys_mbox_fetch+0x93>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e30d:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e314:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e318:	75 69                	jne    80e383 <sys_mbox_fetch+0x102>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e31a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e31e:	48 8b 00             	mov    (%rax),%rax
  80e321:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e325:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e329:	48 8b 10             	mov    (%rax),%rdx
  80e32c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e330:	48 89 10             	mov    %rdx,(%rax)
      h   = tmptimeout->h;
  80e333:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e337:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e33b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e33f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e343:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e347:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e34b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e34f:	48 89 c6             	mov    %rax,%rsi
  80e352:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e357:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80e35e:	00 00 00 
  80e361:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e363:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e367:	48 85 c0             	test   %rax,%rax
  80e36a:	74 12                	je     80e37e <sys_mbox_fetch+0xfd>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  80e36c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e370:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e374:	48 89 d7             	mov    %rdx,%rdi
  80e377:	ff d0                	callq  *%rax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e379:	e9 12 ff ff ff       	jmpq   80e290 <sys_mbox_fetch+0xf>
  80e37e:	e9 0d ff ff ff       	jmpq   80e290 <sys_mbox_fetch+0xf>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e383:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e387:	48 8b 00             	mov    (%rax),%rax
  80e38a:	8b 40 08             	mov    0x8(%rax),%eax
  80e38d:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e390:	76 19                	jbe    80e3ab <sys_mbox_fetch+0x12a>
        timeouts->next->time -= time_needed;
  80e392:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e396:	48 8b 00             	mov    (%rax),%rax
  80e399:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e39d:	48 8b 12             	mov    (%rdx),%rdx
  80e3a0:	8b 52 08             	mov    0x8(%rdx),%edx
  80e3a3:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e3a6:	89 50 08             	mov    %edx,0x8(%rax)
  80e3a9:	eb 0e                	jmp    80e3b9 <sys_mbox_fetch+0x138>
      } else {
        timeouts->next->time = 0;
  80e3ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e3af:	48 8b 00             	mov    (%rax),%rax
  80e3b2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e3b9:	c9                   	leaveq 
  80e3ba:	c3                   	retq   

000000000080e3bb <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80e3bb:	55                   	push   %rbp
  80e3bc:	48 89 e5             	mov    %rsp,%rbp
  80e3bf:	48 83 ec 40          	sub    $0x40,%rsp
  80e3c3:	89 7d cc             	mov    %edi,-0x34(%rbp)
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  80e3c6:	48 b8 27 85 81 00 00 	movabs $0x818527,%rax
  80e3cd:	00 00 00 
  80e3d0:	ff d0                	callq  *%rax
  80e3d2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e3d6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e3db:	74 0c                	je     80e3e9 <sys_sem_wait+0x2e>
  80e3dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e3e1:	48 8b 00             	mov    (%rax),%rax
  80e3e4:	48 85 c0             	test   %rax,%rax
  80e3e7:	75 1b                	jne    80e404 <sys_sem_wait+0x49>
    sys_arch_sem_wait(sem, 0);
  80e3e9:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e3ec:	be 00 00 00 00       	mov    $0x0,%esi
  80e3f1:	89 c7                	mov    %eax,%edi
  80e3f3:	48 b8 1c 7e 81 00 00 	movabs $0x817e1c,%rax
  80e3fa:	00 00 00 
  80e3fd:	ff d0                	callq  *%rax
  80e3ff:	e9 dc 00 00 00       	jmpq   80e4e0 <sys_sem_wait+0x125>
  } else {
    if (timeouts->next->time > 0) {
  80e404:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e408:	48 8b 00             	mov    (%rax),%rax
  80e40b:	8b 40 08             	mov    0x8(%rax),%eax
  80e40e:	85 c0                	test   %eax,%eax
  80e410:	74 22                	je     80e434 <sys_sem_wait+0x79>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80e412:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e416:	48 8b 00             	mov    (%rax),%rax
  80e419:	8b 50 08             	mov    0x8(%rax),%edx
  80e41c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e41f:	89 d6                	mov    %edx,%esi
  80e421:	89 c7                	mov    %eax,%edi
  80e423:	48 b8 1c 7e 81 00 00 	movabs $0x817e1c,%rax
  80e42a:	00 00 00 
  80e42d:	ff d0                	callq  *%rax
  80e42f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e432:	eb 07                	jmp    80e43b <sys_sem_wait+0x80>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e434:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e43b:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e43f:	75 69                	jne    80e4aa <sys_sem_wait+0xef>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e441:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e445:	48 8b 00             	mov    (%rax),%rax
  80e448:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e44c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e450:	48 8b 10             	mov    (%rax),%rdx
  80e453:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e457:	48 89 10             	mov    %rdx,(%rax)
      h = tmptimeout->h;
  80e45a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e45e:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e462:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e466:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e46a:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e46e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e472:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e476:	48 89 c6             	mov    %rax,%rsi
  80e479:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e47e:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80e485:	00 00 00 
  80e488:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e48a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e48e:	48 85 c0             	test   %rax,%rax
  80e491:	74 12                	je     80e4a5 <sys_sem_wait+0xea>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  80e493:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e497:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e49b:	48 89 d7             	mov    %rdx,%rdi
  80e49e:	ff d0                	callq  *%rax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e4a0:	e9 21 ff ff ff       	jmpq   80e3c6 <sys_sem_wait+0xb>
  80e4a5:	e9 1c ff ff ff       	jmpq   80e3c6 <sys_sem_wait+0xb>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e4aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e4ae:	48 8b 00             	mov    (%rax),%rax
  80e4b1:	8b 40 08             	mov    0x8(%rax),%eax
  80e4b4:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e4b7:	76 19                	jbe    80e4d2 <sys_sem_wait+0x117>
        timeouts->next->time -= time_needed;
  80e4b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e4bd:	48 8b 00             	mov    (%rax),%rax
  80e4c0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e4c4:	48 8b 12             	mov    (%rdx),%rdx
  80e4c7:	8b 52 08             	mov    0x8(%rdx),%edx
  80e4ca:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e4cd:	89 50 08             	mov    %edx,0x8(%rax)
  80e4d0:	eb 0e                	jmp    80e4e0 <sys_sem_wait+0x125>
      } else {
        timeouts->next->time = 0;
  80e4d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e4d6:	48 8b 00             	mov    (%rax),%rax
  80e4d9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e4e0:	c9                   	leaveq 
  80e4e1:	c3                   	retq   

000000000080e4e2 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80e4e2:	55                   	push   %rbp
  80e4e3:	48 89 e5             	mov    %rsp,%rbp
  80e4e6:	48 83 ec 40          	sub    $0x40,%rsp
  80e4ea:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80e4ed:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80e4f1:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80e4f5:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e4fa:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  80e501:	00 00 00 
  80e504:	ff d0                	callq  *%rax
  80e506:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (timeout == NULL) {
  80e50a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e50f:	75 36                	jne    80e547 <sys_timeout+0x65>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  80e511:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e516:	75 2a                	jne    80e542 <sys_timeout+0x60>
  80e518:	48 ba 48 1f 82 00 00 	movabs $0x821f48,%rdx
  80e51f:	00 00 00 
  80e522:	be c3 00 00 00       	mov    $0xc3,%esi
  80e527:	48 bf 65 1f 82 00 00 	movabs $0x821f65,%rdi
  80e52e:	00 00 00 
  80e531:	b8 00 00 00 00       	mov    $0x0,%eax
  80e536:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80e53d:	00 00 00 
  80e540:	ff d1                	callq  *%rcx
    return;
  80e542:	e9 7e 01 00 00       	jmpq   80e6c5 <sys_timeout+0x1e3>
  }
  timeout->next = NULL;
  80e547:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e54b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  timeout->h = h;
  80e552:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80e556:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e55a:	48 89 50 10          	mov    %rdx,0x10(%rax)
  timeout->arg = arg;
  80e55e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e562:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80e566:	48 89 50 18          	mov    %rdx,0x18(%rax)
  timeout->time = msecs;
  80e56a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e56e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80e571:	89 50 08             	mov    %edx,0x8(%rax)

  timeouts = sys_arch_timeouts();
  80e574:	48 b8 27 85 81 00 00 	movabs $0x818527,%rax
  80e57b:	00 00 00 
  80e57e:	ff d0                	callq  *%rax
  80e580:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80e584:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e589:	75 36                	jne    80e5c1 <sys_timeout+0xdf>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  80e58b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e590:	75 2a                	jne    80e5bc <sys_timeout+0xda>
  80e592:	48 ba 79 1f 82 00 00 	movabs $0x821f79,%rdx
  80e599:	00 00 00 
  80e59c:	be d1 00 00 00       	mov    $0xd1,%esi
  80e5a1:	48 bf 65 1f 82 00 00 	movabs $0x821f65,%rdi
  80e5a8:	00 00 00 
  80e5ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80e5b0:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80e5b7:	00 00 00 
  80e5ba:	ff d1                	callq  *%rcx
    return;
  80e5bc:	e9 04 01 00 00       	jmpq   80e6c5 <sys_timeout+0x1e3>
  }

  if (timeouts->next == NULL) {
  80e5c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e5c5:	48 8b 00             	mov    (%rax),%rax
  80e5c8:	48 85 c0             	test   %rax,%rax
  80e5cb:	75 10                	jne    80e5dd <sys_timeout+0xfb>
    timeouts->next = timeout;
  80e5cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e5d1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e5d5:	48 89 10             	mov    %rdx,(%rax)
    return;
  80e5d8:	e9 e8 00 00 00       	jmpq   80e6c5 <sys_timeout+0x1e3>
  }

  if (timeouts->next->time > msecs) {
  80e5dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e5e1:	48 8b 00             	mov    (%rax),%rax
  80e5e4:	8b 40 08             	mov    0x8(%rax),%eax
  80e5e7:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  80e5ea:	76 35                	jbe    80e621 <sys_timeout+0x13f>
    timeouts->next->time -= msecs;
  80e5ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e5f0:	48 8b 00             	mov    (%rax),%rax
  80e5f3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e5f7:	48 8b 12             	mov    (%rdx),%rdx
  80e5fa:	8b 52 08             	mov    0x8(%rdx),%edx
  80e5fd:	2b 55 dc             	sub    -0x24(%rbp),%edx
  80e600:	89 50 08             	mov    %edx,0x8(%rax)
    timeout->next = timeouts->next;
  80e603:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e607:	48 8b 10             	mov    (%rax),%rdx
  80e60a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e60e:	48 89 10             	mov    %rdx,(%rax)
    timeouts->next = timeout;
  80e611:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e615:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e619:	48 89 10             	mov    %rdx,(%rax)
  80e61c:	e9 a4 00 00 00       	jmpq   80e6c5 <sys_timeout+0x1e3>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e621:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e625:	48 8b 00             	mov    (%rax),%rax
  80e628:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e62c:	e9 89 00 00 00       	jmpq   80e6ba <sys_timeout+0x1d8>
      timeout->time -= t->time;
  80e631:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e635:	8b 50 08             	mov    0x8(%rax),%edx
  80e638:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e63c:	8b 40 08             	mov    0x8(%rax),%eax
  80e63f:	29 c2                	sub    %eax,%edx
  80e641:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e645:	89 50 08             	mov    %edx,0x8(%rax)
      if (t->next == NULL || t->next->time > timeout->time) {
  80e648:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e64c:	48 8b 00             	mov    (%rax),%rax
  80e64f:	48 85 c0             	test   %rax,%rax
  80e652:	74 15                	je     80e669 <sys_timeout+0x187>
  80e654:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e658:	48 8b 00             	mov    (%rax),%rax
  80e65b:	8b 50 08             	mov    0x8(%rax),%edx
  80e65e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e662:	8b 40 08             	mov    0x8(%rax),%eax
  80e665:	39 c2                	cmp    %eax,%edx
  80e667:	76 46                	jbe    80e6af <sys_timeout+0x1cd>
        if (t->next != NULL) {
  80e669:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e66d:	48 8b 00             	mov    (%rax),%rax
  80e670:	48 85 c0             	test   %rax,%rax
  80e673:	74 1f                	je     80e694 <sys_timeout+0x1b2>
          t->next->time -= timeout->time;
  80e675:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e679:	48 8b 00             	mov    (%rax),%rax
  80e67c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80e680:	48 8b 12             	mov    (%rdx),%rdx
  80e683:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80e686:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e68a:	8b 52 08             	mov    0x8(%rdx),%edx
  80e68d:	29 d1                	sub    %edx,%ecx
  80e68f:	89 ca                	mov    %ecx,%edx
  80e691:	89 50 08             	mov    %edx,0x8(%rax)
        }
        timeout->next = t->next;
  80e694:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e698:	48 8b 10             	mov    (%rax),%rdx
  80e69b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e69f:	48 89 10             	mov    %rdx,(%rax)
        t->next = timeout;
  80e6a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e6a6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e6aa:	48 89 10             	mov    %rdx,(%rax)
        break;
  80e6ad:	eb 16                	jmp    80e6c5 <sys_timeout+0x1e3>
  if (timeouts->next->time > msecs) {
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e6af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e6b3:	48 8b 00             	mov    (%rax),%rax
  80e6b6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e6ba:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e6bf:	0f 85 6c ff ff ff    	jne    80e631 <sys_timeout+0x14f>
        t->next = timeout;
        break;
      }
    }
  }
}
  80e6c5:	c9                   	leaveq 
  80e6c6:	c3                   	retq   

000000000080e6c7 <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80e6c7:	55                   	push   %rbp
  80e6c8:	48 89 e5             	mov    %rsp,%rbp
  80e6cb:	48 83 ec 30          	sub    $0x30,%rsp
  80e6cf:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80e6d3:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80e6d7:	48 b8 27 85 81 00 00 	movabs $0x818527,%rax
  80e6de:	00 00 00 
  80e6e1:	ff d0                	callq  *%rax
  80e6e3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  if (timeouts == NULL) {
  80e6e7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e6ec:	75 36                	jne    80e724 <sys_untimeout+0x5d>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  80e6ee:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e6f3:	75 2a                	jne    80e71f <sys_untimeout+0x58>
  80e6f5:	48 ba 98 1f 82 00 00 	movabs $0x821f98,%rdx
  80e6fc:	00 00 00 
  80e6ff:	be 00 01 00 00       	mov    $0x100,%esi
  80e704:	48 bf 65 1f 82 00 00 	movabs $0x821f65,%rdi
  80e70b:	00 00 00 
  80e70e:	b8 00 00 00 00       	mov    $0x0,%eax
  80e713:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80e71a:	00 00 00 
  80e71d:	ff d1                	callq  *%rcx
    return;
  80e71f:	e9 cc 00 00 00       	jmpq   80e7f0 <sys_untimeout+0x129>
  }
  if (timeouts->next == NULL) {
  80e724:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e728:	48 8b 00             	mov    (%rax),%rax
  80e72b:	48 85 c0             	test   %rax,%rax
  80e72e:	75 05                	jne    80e735 <sys_untimeout+0x6e>
    return;
  80e730:	e9 bb 00 00 00       	jmpq   80e7f0 <sys_untimeout+0x129>
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80e735:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e739:	48 8b 00             	mov    (%rax),%rax
  80e73c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80e740:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80e747:	00 
  80e748:	e9 97 00 00 00       	jmpq   80e7e4 <sys_untimeout+0x11d>
    if ((t->h == h) && (t->arg == arg)) {
  80e74d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e751:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e755:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80e759:	75 76                	jne    80e7d1 <sys_untimeout+0x10a>
  80e75b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e75f:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e763:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80e767:	75 68                	jne    80e7d1 <sys_untimeout+0x10a>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  80e769:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e76e:	75 10                	jne    80e780 <sys_untimeout+0xb9>
        timeouts->next = t->next;
  80e770:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e774:	48 8b 10             	mov    (%rax),%rdx
  80e777:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e77b:	48 89 10             	mov    %rdx,(%rax)
  80e77e:	eb 0e                	jmp    80e78e <sys_untimeout+0xc7>
      else
        prev_t->next = t->next;
  80e780:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e784:	48 8b 10             	mov    (%rax),%rdx
  80e787:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e78b:	48 89 10             	mov    %rdx,(%rax)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  80e78e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e792:	48 8b 00             	mov    (%rax),%rax
  80e795:	48 85 c0             	test   %rax,%rax
  80e798:	74 1d                	je     80e7b7 <sys_untimeout+0xf0>
        t->next->time += t->time;
  80e79a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e79e:	48 8b 00             	mov    (%rax),%rax
  80e7a1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e7a5:	48 8b 12             	mov    (%rdx),%rdx
  80e7a8:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80e7ab:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e7af:	8b 52 08             	mov    0x8(%rdx),%edx
  80e7b2:	01 ca                	add    %ecx,%edx
  80e7b4:	89 50 08             	mov    %edx,0x8(%rax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80e7b7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e7bb:	48 89 c6             	mov    %rax,%rsi
  80e7be:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e7c3:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80e7ca:	00 00 00 
  80e7cd:	ff d0                	callq  *%rax
      return;
  80e7cf:	eb 1f                	jmp    80e7f0 <sys_untimeout+0x129>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80e7d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e7d5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e7d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e7dd:	48 8b 00             	mov    (%rax),%rax
  80e7e0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80e7e4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e7e9:	0f 85 5e ff ff ff    	jne    80e74d <sys_untimeout+0x86>
        t->next->time += t->time;
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
  80e7ef:	90                   	nop
}
  80e7f0:	c9                   	leaveq 
  80e7f1:	c3                   	retq   

000000000080e7f2 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  80e7f2:	55                   	push   %rbp
  80e7f3:	48 89 e5             	mov    %rsp,%rbp
  80e7f6:	48 83 ec 20          	sub    $0x20,%rsp
  80e7fa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;
  80e7fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e802:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80e806:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e80a:	66 c7 00 01 00       	movw   $0x1,(%rax)
  sys_sem_signal(*(sswt_cb->psem));
  80e80f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e813:	48 8b 40 08          	mov    0x8(%rax),%rax
  80e817:	8b 00                	mov    (%rax),%eax
  80e819:	89 c7                	mov    %eax,%edi
  80e81b:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  80e822:	00 00 00 
  80e825:	ff d0                	callq  *%rax
}
  80e827:	c9                   	leaveq 
  80e828:	c3                   	retq   

000000000080e829 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  80e829:	55                   	push   %rbp
  80e82a:	48 89 e5             	mov    %rsp,%rbp
  80e82d:	48 83 ec 20          	sub    $0x20,%rsp
  80e831:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80e834:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80e837:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
  80e83b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sswt_cb.timeflag = 0;
  80e83f:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%rbp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80e845:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80e849:	74 1f                	je     80e86a <sys_sem_wait_timeout+0x41>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80e84b:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80e84f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80e852:	48 be f2 e7 80 00 00 	movabs $0x80e7f2,%rsi
  80e859:	00 00 00 
  80e85c:	89 c7                	mov    %eax,%edi
  80e85e:	48 b8 e2 e4 80 00 00 	movabs $0x80e4e2,%rax
  80e865:	00 00 00 
  80e868:	ff d0                	callq  *%rax
  }
  sys_sem_wait(sem);
  80e86a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80e86d:	89 c7                	mov    %eax,%edi
  80e86f:	48 b8 bb e3 80 00 00 	movabs $0x80e3bb,%rax
  80e876:	00 00 00 
  80e879:	ff d0                	callq  *%rax
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80e87b:	0f b7 45 f0          	movzwl -0x10(%rbp),%eax
  80e87f:	66 85 c0             	test   %ax,%ax
  80e882:	74 07                	je     80e88b <sys_sem_wait_timeout+0x62>
    /* timeout */
    return 0;
  80e884:	b8 00 00 00 00       	mov    $0x0,%eax
  80e889:	eb 22                	jmp    80e8ad <sys_sem_wait_timeout+0x84>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  80e88b:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80e88f:	48 89 c6             	mov    %rax,%rsi
  80e892:	48 bf f2 e7 80 00 00 	movabs $0x80e7f2,%rdi
  80e899:	00 00 00 
  80e89c:	48 b8 c7 e6 80 00 00 	movabs $0x80e6c7,%rax
  80e8a3:	00 00 00 
  80e8a6:	ff d0                	callq  *%rax
    return 1;
  80e8a8:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  80e8ad:	c9                   	leaveq 
  80e8ae:	c3                   	retq   

000000000080e8af <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80e8af:	55                   	push   %rbp
  80e8b0:	48 89 e5             	mov    %rsp,%rbp
  80e8b3:	48 83 ec 20          	sub    $0x20,%rsp
  80e8b7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  sys_sem_t delaysem = sys_sem_new(0);
  80e8ba:	bf 00 00 00 00       	mov    $0x0,%edi
  80e8bf:	48 b8 9b 7a 81 00 00 	movabs $0x817a9b,%rax
  80e8c6:	00 00 00 
  80e8c9:	ff d0                	callq  *%rax
  80e8cb:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sys_sem_wait_timeout(delaysem, ms);
  80e8ce:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80e8d1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80e8d4:	89 d6                	mov    %edx,%esi
  80e8d6:	89 c7                	mov    %eax,%edi
  80e8d8:	48 b8 29 e8 80 00 00 	movabs $0x80e829,%rax
  80e8df:	00 00 00 
  80e8e2:	ff d0                	callq  *%rax

  sys_sem_free(delaysem);
  80e8e4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80e8e7:	89 c7                	mov    %eax,%edi
  80e8e9:	48 b8 99 7b 81 00 00 	movabs $0x817b99,%rax
  80e8f0:	00 00 00 
  80e8f3:	ff d0                	callq  *%rax
}
  80e8f5:	c9                   	leaveq 
  80e8f6:	c3                   	retq   

000000000080e8f7 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  80e8f7:	55                   	push   %rbp
  80e8f8:	48 89 e5             	mov    %rsp,%rbp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  80e8fb:	48 b8 ea ff 80 00 00 	movabs $0x80ffea,%rax
  80e902:	00 00 00 
  80e905:	ff d0                	callq  *%rax

  if (++tcp_timer & 1) {
  80e907:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80e90e:	00 00 00 
  80e911:	0f b6 00             	movzbl (%rax),%eax
  80e914:	8d 50 01             	lea    0x1(%rax),%edx
  80e917:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80e91e:	00 00 00 
  80e921:	88 10                	mov    %dl,(%rax)
  80e923:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80e92a:	00 00 00 
  80e92d:	0f b6 00             	movzbl (%rax),%eax
  80e930:	0f b6 c0             	movzbl %al,%eax
  80e933:	83 e0 01             	and    $0x1,%eax
  80e936:	85 c0                	test   %eax,%eax
  80e938:	74 0c                	je     80e946 <tcp_tmr+0x4f>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80e93a:	48 b8 ae f7 80 00 00 	movabs $0x80f7ae,%rax
  80e941:	00 00 00 
  80e944:	ff d0                	callq  *%rax
  }
}
  80e946:	5d                   	pop    %rbp
  80e947:	c3                   	retq   

000000000080e948 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  80e948:	55                   	push   %rbp
  80e949:	48 89 e5             	mov    %rsp,%rbp
  80e94c:	48 83 ec 20          	sub    $0x20,%rsp
  80e950:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  80e954:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e958:	8b 40 18             	mov    0x18(%rax),%eax
  80e95b:	83 f8 07             	cmp    $0x7,%eax
  80e95e:	0f 87 37 02 00 00    	ja     80eb9b <tcp_close+0x253>
  80e964:	89 c0                	mov    %eax,%eax
  80e966:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80e96d:	00 
  80e96e:	48 b8 d0 1f 82 00 00 	movabs $0x821fd0,%rax
  80e975:	00 00 00 
  80e978:	48 01 d0             	add    %rdx,%rax
  80e97b:	48 8b 00             	mov    (%rax),%rax
  80e97e:	ff e0                	jmpq   *%rax
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  80e980:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  80e984:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80e98b:	00 00 00 
  80e98e:	48 8b 00             	mov    (%rax),%rax
  80e991:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80e995:	75 23                	jne    80e9ba <tcp_close+0x72>
  80e997:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80e99e:	00 00 00 
  80e9a1:	48 8b 00             	mov    (%rax),%rax
  80e9a4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80e9a8:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80e9af:	00 00 00 
  80e9b2:	48 89 10             	mov    %rdx,(%rax)
  80e9b5:	e9 94 00 00 00       	jmpq   80ea4e <tcp_close+0x106>
  80e9ba:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80e9c1:	00 00 00 
  80e9c4:	48 8b 10             	mov    (%rax),%rdx
  80e9c7:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e9ce:	00 00 00 
  80e9d1:	48 89 10             	mov    %rdx,(%rax)
  80e9d4:	eb 66                	jmp    80ea3c <tcp_close+0xf4>
  80e9d6:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e9dd:	00 00 00 
  80e9e0:	48 8b 00             	mov    (%rax),%rax
  80e9e3:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e9e7:	48 85 c0             	test   %rax,%rax
  80e9ea:	74 32                	je     80ea1e <tcp_close+0xd6>
  80e9ec:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e9f3:	00 00 00 
  80e9f6:	48 8b 00             	mov    (%rax),%rax
  80e9f9:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e9fd:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ea01:	75 1b                	jne    80ea1e <tcp_close+0xd6>
  80ea03:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ea0a:	00 00 00 
  80ea0d:	48 8b 00             	mov    (%rax),%rax
  80ea10:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80ea14:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80ea18:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ea1c:	eb 30                	jmp    80ea4e <tcp_close+0x106>
  80ea1e:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ea25:	00 00 00 
  80ea28:	48 8b 00             	mov    (%rax),%rax
  80ea2b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ea2f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ea36:	00 00 00 
  80ea39:	48 89 10             	mov    %rdx,(%rax)
  80ea3c:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ea43:	00 00 00 
  80ea46:	48 8b 00             	mov    (%rax),%rax
  80ea49:	48 85 c0             	test   %rax,%rax
  80ea4c:	75 88                	jne    80e9d6 <tcp_close+0x8e>
  80ea4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea52:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80ea59:	00 
    memp_free(MEMP_TCP_PCB, pcb);
  80ea5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea5e:	48 89 c6             	mov    %rax,%rsi
  80ea61:	bf 02 00 00 00       	mov    $0x2,%edi
  80ea66:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80ea6d:	00 00 00 
  80ea70:	ff d0                	callq  *%rax
    pcb = NULL;
  80ea72:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80ea79:	00 
    break;
  80ea7a:	e9 29 01 00 00       	jmpq   80eba8 <tcp_close+0x260>
  case LISTEN:
    err = ERR_OK;
  80ea7f:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  80ea83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea87:	48 89 c6             	mov    %rax,%rsi
  80ea8a:	48 bf 28 b0 b5 00 00 	movabs $0xb5b028,%rdi
  80ea91:	00 00 00 
  80ea94:	48 b8 78 07 81 00 00 	movabs $0x810778,%rax
  80ea9b:	00 00 00 
  80ea9e:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  80eaa0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eaa4:	48 89 c6             	mov    %rax,%rsi
  80eaa7:	bf 03 00 00 00       	mov    $0x3,%edi
  80eaac:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80eab3:	00 00 00 
  80eab6:	ff d0                	callq  *%rax
    pcb = NULL;
  80eab8:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80eabf:	00 
    break;
  80eac0:	e9 e3 00 00 00       	jmpq   80eba8 <tcp_close+0x260>
  case SYN_SENT:
    err = ERR_OK;
  80eac5:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80eac9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eacd:	48 89 c6             	mov    %rax,%rsi
  80ead0:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80ead7:	00 00 00 
  80eada:	48 b8 78 07 81 00 00 	movabs $0x810778,%rax
  80eae1:	00 00 00 
  80eae4:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80eae6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eaea:	48 89 c6             	mov    %rax,%rsi
  80eaed:	bf 02 00 00 00       	mov    $0x2,%edi
  80eaf2:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80eaf9:	00 00 00 
  80eafc:	ff d0                	callq  *%rax
    pcb = NULL;
  80eafe:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80eb05:	00 
    snmp_inc_tcpattemptfails();
    break;
  80eb06:	e9 9d 00 00 00       	jmpq   80eba8 <tcp_close+0x260>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80eb0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eb0f:	be 01 00 00 00       	mov    $0x1,%esi
  80eb14:	48 89 c7             	mov    %rax,%rdi
  80eb17:	48 b8 79 2d 81 00 00 	movabs $0x812d79,%rax
  80eb1e:	00 00 00 
  80eb21:	ff d0                	callq  *%rax
  80eb23:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80eb26:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80eb2a:	75 0d                	jne    80eb39 <tcp_close+0x1f1>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  80eb2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eb30:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80eb37:	eb 6f                	jmp    80eba8 <tcp_close+0x260>
  80eb39:	eb 6d                	jmp    80eba8 <tcp_close+0x260>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80eb3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eb3f:	be 01 00 00 00       	mov    $0x1,%esi
  80eb44:	48 89 c7             	mov    %rax,%rdi
  80eb47:	48 b8 79 2d 81 00 00 	movabs $0x812d79,%rax
  80eb4e:	00 00 00 
  80eb51:	ff d0                	callq  *%rax
  80eb53:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80eb56:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80eb5a:	75 0d                	jne    80eb69 <tcp_close+0x221>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  80eb5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eb60:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80eb67:	eb 3f                	jmp    80eba8 <tcp_close+0x260>
  80eb69:	eb 3d                	jmp    80eba8 <tcp_close+0x260>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80eb6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eb6f:	be 01 00 00 00       	mov    $0x1,%esi
  80eb74:	48 89 c7             	mov    %rax,%rdi
  80eb77:	48 b8 79 2d 81 00 00 	movabs $0x812d79,%rax
  80eb7e:	00 00 00 
  80eb81:	ff d0                	callq  *%rax
  80eb83:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80eb86:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80eb8a:	75 0d                	jne    80eb99 <tcp_close+0x251>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  80eb8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eb90:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
    }
    break;
  80eb97:	eb 0f                	jmp    80eba8 <tcp_close+0x260>
  80eb99:	eb 0d                	jmp    80eba8 <tcp_close+0x260>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  80eb9b:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    pcb = NULL;
  80eb9f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80eba6:	00 
    break;
  80eba7:	90                   	nop
  }

  if (pcb != NULL && err == ERR_OK) {
  80eba8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ebad:	74 19                	je     80ebc8 <tcp_close+0x280>
  80ebaf:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ebb3:	75 13                	jne    80ebc8 <tcp_close+0x280>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80ebb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ebb9:	48 89 c7             	mov    %rax,%rdi
  80ebbc:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  80ebc3:	00 00 00 
  80ebc6:	ff d0                	callq  *%rax
  }
  return err;
  80ebc8:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80ebcc:	c9                   	leaveq 
  80ebcd:	c3                   	retq   

000000000080ebce <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  80ebce:	55                   	push   %rbp
  80ebcf:	48 89 e5             	mov    %rsp,%rbp
  80ebd2:	48 83 ec 50          	sub    $0x50,%rsp
  80ebd6:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  80ebda:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ebde:	8b 40 18             	mov    0x18(%rax),%eax
  80ebe1:	83 f8 0a             	cmp    $0xa,%eax
  80ebe4:	75 3a                	jne    80ec20 <tcp_abort+0x52>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  80ebe6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ebea:	48 89 c6             	mov    %rax,%rsi
  80ebed:	48 bf 40 b0 b5 00 00 	movabs $0xb5b040,%rdi
  80ebf4:	00 00 00 
  80ebf7:	48 b8 78 07 81 00 00 	movabs $0x810778,%rax
  80ebfe:	00 00 00 
  80ec01:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80ec03:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec07:	48 89 c6             	mov    %rax,%rsi
  80ec0a:	bf 02 00 00 00       	mov    $0x2,%edi
  80ec0f:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80ec16:	00 00 00 
  80ec19:	ff d0                	callq  *%rax
  80ec1b:	e9 75 01 00 00       	jmpq   80ed95 <tcp_abort+0x1c7>
  } else {
    seqno = pcb->snd_nxt;
  80ec20:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec24:	8b 40 60             	mov    0x60(%rax),%eax
  80ec27:	89 45 fc             	mov    %eax,-0x4(%rbp)
    ackno = pcb->rcv_nxt;
  80ec2a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec2e:	8b 40 30             	mov    0x30(%rax),%eax
  80ec31:	89 45 f8             	mov    %eax,-0x8(%rbp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  80ec34:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec38:	48 85 c0             	test   %rax,%rax
  80ec3b:	74 08                	je     80ec45 <tcp_abort+0x77>
  80ec3d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec41:	8b 00                	mov    (%rax),%eax
  80ec43:	eb 05                	jmp    80ec4a <tcp_abort+0x7c>
  80ec45:	b8 00 00 00 00       	mov    $0x0,%eax
  80ec4a:	89 45 c0             	mov    %eax,-0x40(%rbp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  80ec4d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec51:	48 83 c0 04          	add    $0x4,%rax
  80ec55:	48 85 c0             	test   %rax,%rax
  80ec58:	74 09                	je     80ec63 <tcp_abort+0x95>
  80ec5a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec5e:	8b 40 04             	mov    0x4(%rax),%eax
  80ec61:	eb 05                	jmp    80ec68 <tcp_abort+0x9a>
  80ec63:	b8 00 00 00 00       	mov    $0x0,%eax
  80ec68:	89 45 d0             	mov    %eax,-0x30(%rbp)
    local_port = pcb->local_port;
  80ec6b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec6f:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80ec73:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    remote_port = pcb->remote_port;
  80ec77:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec7b:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  80ec7f:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80ec83:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec87:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80ec8e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  80ec92:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec96:	48 8b 40 20          	mov    0x20(%rax),%rax
  80ec9a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80ec9e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eca2:	48 89 c6             	mov    %rax,%rsi
  80eca5:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80ecac:	00 00 00 
  80ecaf:	48 b8 78 07 81 00 00 	movabs $0x810778,%rax
  80ecb6:	00 00 00 
  80ecb9:	ff d0                	callq  *%rax
    if (pcb->unacked != NULL) {
  80ecbb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ecbf:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80ecc6:	48 85 c0             	test   %rax,%rax
  80ecc9:	74 1a                	je     80ece5 <tcp_abort+0x117>
      tcp_segs_free(pcb->unacked);
  80eccb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eccf:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80ecd6:	48 89 c7             	mov    %rax,%rdi
  80ecd9:	48 b8 03 01 81 00 00 	movabs $0x810103,%rax
  80ece0:	00 00 00 
  80ece3:	ff d0                	callq  *%rax
    }
    if (pcb->unsent != NULL) {
  80ece5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ece9:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80ecf0:	48 85 c0             	test   %rax,%rax
  80ecf3:	74 1a                	je     80ed0f <tcp_abort+0x141>
      tcp_segs_free(pcb->unsent);
  80ecf5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ecf9:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80ed00:	48 89 c7             	mov    %rax,%rdi
  80ed03:	48 b8 03 01 81 00 00 	movabs $0x810103,%rax
  80ed0a:	00 00 00 
  80ed0d:	ff d0                	callq  *%rax
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  80ed0f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ed13:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ed1a:	48 85 c0             	test   %rax,%rax
  80ed1d:	74 1a                	je     80ed39 <tcp_abort+0x16b>
      tcp_segs_free(pcb->ooseq);
  80ed1f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ed23:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ed2a:	48 89 c7             	mov    %rax,%rdi
  80ed2d:	48 b8 03 01 81 00 00 	movabs $0x810103,%rax
  80ed34:	00 00 00 
  80ed37:	ff d0                	callq  *%rax
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  80ed39:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ed3d:	48 89 c6             	mov    %rax,%rsi
  80ed40:	bf 02 00 00 00       	mov    $0x2,%edi
  80ed45:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80ed4c:	00 00 00 
  80ed4f:	ff d0                	callq  *%rax
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  80ed51:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ed56:	74 12                	je     80ed6a <tcp_abort+0x19c>
  80ed58:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80ed5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed60:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80ed65:	48 89 d7             	mov    %rdx,%rdi
  80ed68:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  80ed6a:	44 0f b7 45 f4       	movzwl -0xc(%rbp),%r8d
  80ed6f:	0f b7 7d f6          	movzwl -0xa(%rbp),%edi
  80ed73:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80ed77:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80ed7b:	8b 75 f8             	mov    -0x8(%rbp),%esi
  80ed7e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ed81:	45 89 c1             	mov    %r8d,%r9d
  80ed84:	41 89 f8             	mov    %edi,%r8d
  80ed87:	89 c7                	mov    %eax,%edi
  80ed89:	48 b8 17 42 81 00 00 	movabs $0x814217,%rax
  80ed90:	00 00 00 
  80ed93:	ff d0                	callq  *%rax
  }
}
  80ed95:	c9                   	leaveq 
  80ed96:	c3                   	retq   

000000000080ed97 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80ed97:	55                   	push   %rbp
  80ed98:	48 89 e5             	mov    %rsp,%rbp
  80ed9b:	48 83 ec 30          	sub    $0x30,%rsp
  80ed9f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80eda3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80eda7:	89 d0                	mov    %edx,%eax
  80eda9:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80edad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80edb1:	8b 40 18             	mov    0x18(%rax),%eax
  80edb4:	85 c0                	test   %eax,%eax
  80edb6:	74 2a                	je     80ede2 <tcp_bind+0x4b>
  80edb8:	48 ba 10 20 82 00 00 	movabs $0x822010,%rdx
  80edbf:	00 00 00 
  80edc2:	be 05 01 00 00       	mov    $0x105,%esi
  80edc7:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  80edce:	00 00 00 
  80edd1:	b8 00 00 00 00       	mov    $0x0,%eax
  80edd6:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80eddd:	00 00 00 
  80ede0:	ff d1                	callq  *%rcx

  if (port == 0) {
  80ede2:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80ede7:	75 10                	jne    80edf9 <tcp_bind+0x62>
    port = tcp_new_port();
  80ede9:	48 b8 b0 f3 80 00 00 	movabs $0x80f3b0,%rax
  80edf0:	00 00 00 
  80edf3:	ff d0                	callq  *%rax
  80edf5:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80edf9:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80ee00:	00 00 00 
  80ee03:	48 8b 00             	mov    (%rax),%rax
  80ee06:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ee0a:	eb 58                	jmp    80ee64 <tcp_bind+0xcd>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80ee0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee10:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80ee14:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80ee18:	75 3e                	jne    80ee58 <tcp_bind+0xc1>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80ee1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee1e:	48 85 c0             	test   %rax,%rax
  80ee21:	74 2b                	je     80ee4e <tcp_bind+0xb7>
  80ee23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee27:	8b 00                	mov    (%rax),%eax
  80ee29:	85 c0                	test   %eax,%eax
  80ee2b:	74 21                	je     80ee4e <tcp_bind+0xb7>
  80ee2d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ee32:	74 1a                	je     80ee4e <tcp_bind+0xb7>
          ip_addr_isany(ipaddr) ||
  80ee34:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ee38:	8b 00                	mov    (%rax),%eax
  80ee3a:	85 c0                	test   %eax,%eax
  80ee3c:	74 10                	je     80ee4e <tcp_bind+0xb7>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80ee3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee42:	8b 10                	mov    (%rax),%edx
  80ee44:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ee48:	8b 00                	mov    (%rax),%eax
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80ee4a:	39 c2                	cmp    %eax,%edx
  80ee4c:	75 0a                	jne    80ee58 <tcp_bind+0xc1>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80ee4e:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80ee53:	e9 a2 01 00 00       	jmpq   80effa <tcp_bind+0x263>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80ee58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee5c:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ee60:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80ee64:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ee69:	75 a1                	jne    80ee0c <tcp_bind+0x75>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80ee6b:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80ee72:	00 00 00 
  80ee75:	48 8b 00             	mov    (%rax),%rax
  80ee78:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ee7c:	eb 58                	jmp    80eed6 <tcp_bind+0x13f>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80ee7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee82:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80ee86:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80ee8a:	75 3e                	jne    80eeca <tcp_bind+0x133>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80ee8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee90:	48 85 c0             	test   %rax,%rax
  80ee93:	74 2b                	je     80eec0 <tcp_bind+0x129>
  80ee95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee99:	8b 00                	mov    (%rax),%eax
  80ee9b:	85 c0                	test   %eax,%eax
  80ee9d:	74 21                	je     80eec0 <tcp_bind+0x129>
  80ee9f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80eea4:	74 1a                	je     80eec0 <tcp_bind+0x129>
          ip_addr_isany(ipaddr) ||
  80eea6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80eeaa:	8b 00                	mov    (%rax),%eax
  80eeac:	85 c0                	test   %eax,%eax
  80eeae:	74 10                	je     80eec0 <tcp_bind+0x129>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80eeb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eeb4:	8b 10                	mov    (%rax),%edx
  80eeb6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80eeba:	8b 00                	mov    (%rax),%eax
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80eebc:	39 c2                	cmp    %eax,%edx
  80eebe:	75 0a                	jne    80eeca <tcp_bind+0x133>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80eec0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80eec5:	e9 30 01 00 00       	jmpq   80effa <tcp_bind+0x263>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80eeca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eece:	48 8b 40 10          	mov    0x10(%rax),%rax
  80eed2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80eed6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80eedb:	75 a1                	jne    80ee7e <tcp_bind+0xe7>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80eedd:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80eee4:	00 00 00 
  80eee7:	48 8b 00             	mov    (%rax),%rax
  80eeea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80eeee:	eb 58                	jmp    80ef48 <tcp_bind+0x1b1>
    if (cpcb->local_port == port) {
  80eef0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eef4:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80eef8:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80eefc:	75 3e                	jne    80ef3c <tcp_bind+0x1a5>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80eefe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ef02:	48 85 c0             	test   %rax,%rax
  80ef05:	74 2b                	je     80ef32 <tcp_bind+0x19b>
  80ef07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ef0b:	8b 00                	mov    (%rax),%eax
  80ef0d:	85 c0                	test   %eax,%eax
  80ef0f:	74 21                	je     80ef32 <tcp_bind+0x19b>
  80ef11:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ef16:	74 1a                	je     80ef32 <tcp_bind+0x19b>
          ip_addr_isany(ipaddr) ||
  80ef18:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ef1c:	8b 00                	mov    (%rax),%eax
  80ef1e:	85 c0                	test   %eax,%eax
  80ef20:	74 10                	je     80ef32 <tcp_bind+0x19b>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80ef22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ef26:	8b 10                	mov    (%rax),%edx
  80ef28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ef2c:	8b 00                	mov    (%rax),%eax
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80ef2e:	39 c2                	cmp    %eax,%edx
  80ef30:	75 0a                	jne    80ef3c <tcp_bind+0x1a5>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80ef32:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80ef37:	e9 be 00 00 00       	jmpq   80effa <tcp_bind+0x263>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80ef3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ef40:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ef44:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ef48:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ef4d:	75 a1                	jne    80eef0 <tcp_bind+0x159>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80ef4f:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80ef56:	00 00 00 
  80ef59:	48 8b 00             	mov    (%rax),%rax
  80ef5c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ef60:	eb 31                	jmp    80ef93 <tcp_bind+0x1fc>
    if (cpcb->local_port == port) {
  80ef62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ef66:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80ef6a:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80ef6e:	75 17                	jne    80ef87 <tcp_bind+0x1f0>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80ef70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ef74:	8b 10                	mov    (%rax),%edx
  80ef76:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ef7a:	8b 00                	mov    (%rax),%eax
  80ef7c:	39 c2                	cmp    %eax,%edx
  80ef7e:	75 07                	jne    80ef87 <tcp_bind+0x1f0>
        return ERR_USE;
  80ef80:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80ef85:	eb 73                	jmp    80effa <tcp_bind+0x263>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80ef87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ef8b:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ef8f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ef93:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ef98:	75 c8                	jne    80ef62 <tcp_bind+0x1cb>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  80ef9a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ef9f:	74 16                	je     80efb7 <tcp_bind+0x220>
  80efa1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80efa5:	8b 00                	mov    (%rax),%eax
  80efa7:	85 c0                	test   %eax,%eax
  80efa9:	74 0c                	je     80efb7 <tcp_bind+0x220>
    pcb->local_ip = *ipaddr;
  80efab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80efaf:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80efb3:	8b 12                	mov    (%rdx),%edx
  80efb5:	89 10                	mov    %edx,(%rax)
  }
  pcb->local_port = port;
  80efb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80efbb:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80efbf:	66 89 50 28          	mov    %dx,0x28(%rax)
  TCP_REG(&tcp_bound_pcbs, pcb);
  80efc3:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80efca:	00 00 00 
  80efcd:	48 8b 10             	mov    (%rax),%rdx
  80efd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80efd4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80efd8:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80efdf:	00 00 00 
  80efe2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80efe6:	48 89 10             	mov    %rdx,(%rax)
  80efe9:	48 b8 c0 83 80 00 00 	movabs $0x8083c0,%rax
  80eff0:	00 00 00 
  80eff3:	ff d0                	callq  *%rax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  80eff5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80effa:	c9                   	leaveq 
  80effb:	c3                   	retq   

000000000080effc <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80effc:	55                   	push   %rbp
  80effd:	48 89 e5             	mov    %rsp,%rbp
  80f000:	48 83 ec 14          	sub    $0x14,%rsp
  80f004:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f008:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80f00c:	89 d0                	mov    %edx,%eax
  80f00e:	88 45 ec             	mov    %al,-0x14(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
  80f011:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  80f016:	c9                   	leaveq 
  80f017:	c3                   	retq   

000000000080f018 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  80f018:	55                   	push   %rbp
  80f019:	48 89 e5             	mov    %rsp,%rbp
  80f01c:	53                   	push   %rbx
  80f01d:	48 83 ec 28          	sub    $0x28,%rsp
  80f021:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80f025:	89 f0                	mov    %esi,%eax
  80f027:	88 45 d4             	mov    %al,-0x2c(%rbp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80f02a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f02e:	8b 40 18             	mov    0x18(%rax),%eax
  80f031:	85 c0                	test   %eax,%eax
  80f033:	74 2a                	je     80f05f <tcp_listen_with_backlog+0x47>
  80f035:	48 ba 50 20 82 00 00 	movabs $0x822050,%rdx
  80f03c:	00 00 00 
  80f03f:	be 60 01 00 00       	mov    $0x160,%esi
  80f044:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  80f04b:	00 00 00 
  80f04e:	b8 00 00 00 00       	mov    $0x0,%eax
  80f053:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80f05a:	00 00 00 
  80f05d:	ff d1                	callq  *%rcx

  /* already listening? */
  if (pcb->state == LISTEN) {
  80f05f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f063:	8b 40 18             	mov    0x18(%rax),%eax
  80f066:	83 f8 01             	cmp    $0x1,%eax
  80f069:	75 09                	jne    80f074 <tcp_listen_with_backlog+0x5c>
    return pcb;
  80f06b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f06f:	e9 e6 01 00 00       	jmpq   80f25a <tcp_listen_with_backlog+0x242>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80f074:	bf 03 00 00 00       	mov    $0x3,%edi
  80f079:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  80f080:	00 00 00 
  80f083:	ff d0                	callq  *%rax
  80f085:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (lpcb == NULL) {
  80f089:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80f08e:	75 0a                	jne    80f09a <tcp_listen_with_backlog+0x82>
    return NULL;
  80f090:	b8 00 00 00 00       	mov    $0x0,%eax
  80f095:	e9 c0 01 00 00       	jmpq   80f25a <tcp_listen_with_backlog+0x242>
  }
  lpcb->callback_arg = pcb->callback_arg;
  80f09a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f09e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80f0a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f0a6:	48 89 50 20          	mov    %rdx,0x20(%rax)
  lpcb->local_port = pcb->local_port;
  80f0aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f0ae:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f0b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f0b6:	66 89 50 28          	mov    %dx,0x28(%rax)
  lpcb->state = LISTEN;
  80f0ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f0be:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%rax)
  lpcb->so_options = pcb->so_options;
  80f0c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f0c9:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  80f0cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f0d1:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->so_options |= SOF_ACCEPTCONN;
  80f0d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f0d9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80f0dd:	83 c8 02             	or     $0x2,%eax
  80f0e0:	89 c2                	mov    %eax,%edx
  80f0e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f0e6:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->ttl = pcb->ttl;
  80f0ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f0ee:	0f b6 50 0b          	movzbl 0xb(%rax),%edx
  80f0f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f0f6:	88 50 0b             	mov    %dl,0xb(%rax)
  lpcb->tos = pcb->tos;
  80f0f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f0fd:	0f b6 50 0a          	movzbl 0xa(%rax),%edx
  80f101:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f105:	88 50 0a             	mov    %dl,0xa(%rax)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80f108:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f10c:	48 85 c0             	test   %rax,%rax
  80f10f:	74 08                	je     80f119 <tcp_listen_with_backlog+0x101>
  80f111:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f115:	8b 00                	mov    (%rax),%eax
  80f117:	eb 05                	jmp    80f11e <tcp_listen_with_backlog+0x106>
  80f119:	b8 00 00 00 00       	mov    $0x0,%eax
  80f11e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f122:	89 02                	mov    %eax,(%rdx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80f124:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f12b:	00 00 00 
  80f12e:	48 8b 00             	mov    (%rax),%rax
  80f131:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80f135:	75 23                	jne    80f15a <tcp_listen_with_backlog+0x142>
  80f137:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f13e:	00 00 00 
  80f141:	48 8b 00             	mov    (%rax),%rax
  80f144:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f148:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f14f:	00 00 00 
  80f152:	48 89 10             	mov    %rdx,(%rax)
  80f155:	e9 94 00 00 00       	jmpq   80f1ee <tcp_listen_with_backlog+0x1d6>
  80f15a:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f161:	00 00 00 
  80f164:	48 8b 10             	mov    (%rax),%rdx
  80f167:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f16e:	00 00 00 
  80f171:	48 89 10             	mov    %rdx,(%rax)
  80f174:	eb 66                	jmp    80f1dc <tcp_listen_with_backlog+0x1c4>
  80f176:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f17d:	00 00 00 
  80f180:	48 8b 00             	mov    (%rax),%rax
  80f183:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f187:	48 85 c0             	test   %rax,%rax
  80f18a:	74 32                	je     80f1be <tcp_listen_with_backlog+0x1a6>
  80f18c:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f193:	00 00 00 
  80f196:	48 8b 00             	mov    (%rax),%rax
  80f199:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f19d:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80f1a1:	75 1b                	jne    80f1be <tcp_listen_with_backlog+0x1a6>
  80f1a3:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f1aa:	00 00 00 
  80f1ad:	48 8b 00             	mov    (%rax),%rax
  80f1b0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80f1b4:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80f1b8:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f1bc:	eb 30                	jmp    80f1ee <tcp_listen_with_backlog+0x1d6>
  80f1be:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f1c5:	00 00 00 
  80f1c8:	48 8b 00             	mov    (%rax),%rax
  80f1cb:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f1cf:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f1d6:	00 00 00 
  80f1d9:	48 89 10             	mov    %rdx,(%rax)
  80f1dc:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f1e3:	00 00 00 
  80f1e6:	48 8b 00             	mov    (%rax),%rax
  80f1e9:	48 85 c0             	test   %rax,%rax
  80f1ec:	75 88                	jne    80f176 <tcp_listen_with_backlog+0x15e>
  80f1ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f1f2:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80f1f9:	00 
  memp_free(MEMP_TCP_PCB, pcb);
  80f1fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f1fe:	48 89 c6             	mov    %rax,%rsi
  80f201:	bf 02 00 00 00       	mov    $0x2,%edi
  80f206:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80f20d:	00 00 00 
  80f210:	ff d0                	callq  *%rax
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  80f212:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f216:	48 bb fc ef 80 00 00 	movabs $0x80effc,%rbx
  80f21d:	00 00 00 
  80f220:	48 89 58 30          	mov    %rbx,0x30(%rax)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80f224:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f22b:	00 00 00 
  80f22e:	48 8b 10             	mov    (%rax),%rdx
  80f231:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f235:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f239:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f240:	00 00 00 
  80f243:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f247:	48 89 10             	mov    %rdx,(%rax)
  80f24a:	48 b8 c0 83 80 00 00 	movabs $0x8083c0,%rax
  80f251:	00 00 00 
  80f254:	ff d0                	callq  *%rax
  return (struct tcp_pcb *)lpcb;
  80f256:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80f25a:	48 83 c4 28          	add    $0x28,%rsp
  80f25e:	5b                   	pop    %rbx
  80f25f:	5d                   	pop    %rbp
  80f260:	c3                   	retq   

000000000080f261 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  80f261:	55                   	push   %rbp
  80f262:	48 89 e5             	mov    %rsp,%rbp
  80f265:	48 83 ec 10          	sub    $0x10,%rsp
  80f269:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f26d:	89 f0                	mov    %esi,%eax
  80f26f:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  80f273:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f277:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f27b:	0f b7 d0             	movzwl %ax,%edx
  80f27e:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80f282:	01 d0                	add    %edx,%eax
  80f284:	3d c0 5d 00 00       	cmp    $0x5dc0,%eax
  80f289:	76 16                	jbe    80f2a1 <tcp_recved+0x40>
    pcb->rcv_wnd = TCP_WND;
  80f28b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f28f:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  80f295:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f299:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  80f29f:	eb 3b                	jmp    80f2dc <tcp_recved+0x7b>
  } else {
    pcb->rcv_wnd += len;
  80f2a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2a5:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f2a9:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80f2ad:	01 c2                	add    %eax,%edx
  80f2af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2b3:	66 89 50 34          	mov    %dx,0x34(%rax)
    if (pcb->rcv_wnd >= pcb->mss) {
  80f2b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2bb:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f2bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2c3:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f2c7:	66 39 c2             	cmp    %ax,%dx
  80f2ca:	72 10                	jb     80f2dc <tcp_recved+0x7b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80f2cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2d0:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f2d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2d8:	66 89 50 36          	mov    %dx,0x36(%rax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f2dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2e0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f2e4:	0f b6 c0             	movzbl %al,%eax
  80f2e7:	83 e0 01             	and    $0x1,%eax
  80f2ea:	85 c0                	test   %eax,%eax
  80f2ec:	75 77                	jne    80f365 <tcp_recved+0x104>
     !(pcb->flags & TF_ACK_NOW)) {
  80f2ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2f2:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f2f6:	0f b6 c0             	movzbl %al,%eax
  80f2f9:	83 e0 02             	and    $0x2,%eax
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f2fc:	85 c0                	test   %eax,%eax
  80f2fe:	75 65                	jne    80f365 <tcp_recved+0x104>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  80f300:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f304:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f308:	0f b6 c0             	movzbl %al,%eax
  80f30b:	83 e0 01             	and    $0x1,%eax
  80f30e:	85 c0                	test   %eax,%eax
  80f310:	74 3d                	je     80f34f <tcp_recved+0xee>
  80f312:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f316:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f31a:	83 e0 fe             	and    $0xfffffffe,%eax
  80f31d:	89 c2                	mov    %eax,%edx
  80f31f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f323:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f326:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f32a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f32e:	83 c8 02             	or     $0x2,%eax
  80f331:	89 c2                	mov    %eax,%edx
  80f333:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f337:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f33a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f33e:	48 89 c7             	mov    %rax,%rdi
  80f341:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  80f348:	00 00 00 
  80f34b:	ff d0                	callq  *%rax
  80f34d:	eb 5f                	jmp    80f3ae <tcp_recved+0x14d>
  80f34f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f353:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f357:	83 c8 01             	or     $0x1,%eax
  80f35a:	89 c2                	mov    %eax,%edx
  80f35c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f360:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f363:	eb 49                	jmp    80f3ae <tcp_recved+0x14d>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  80f365:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f369:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f36d:	0f b6 c0             	movzbl %al,%eax
  80f370:	83 e0 01             	and    $0x1,%eax
  80f373:	85 c0                	test   %eax,%eax
  80f375:	74 37                	je     80f3ae <tcp_recved+0x14d>
  80f377:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f37b:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f37f:	66 3d df 2e          	cmp    $0x2edf,%ax
  80f383:	76 29                	jbe    80f3ae <tcp_recved+0x14d>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  80f385:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f389:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f38d:	83 c8 02             	or     $0x2,%eax
  80f390:	89 c2                	mov    %eax,%edx
  80f392:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f396:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f399:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f39d:	48 89 c7             	mov    %rax,%rdi
  80f3a0:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  80f3a7:	00 00 00 
  80f3aa:	ff d0                	callq  *%rax
  80f3ac:	eb 00                	jmp    80f3ae <tcp_recved+0x14d>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  80f3ae:	c9                   	leaveq 
  80f3af:	c3                   	retq   

000000000080f3b0 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80f3b0:	55                   	push   %rbp
  80f3b1:	48 89 e5             	mov    %rsp,%rbp
  80f3b4:	48 83 ec 10          	sub    $0x10,%rsp
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80f3b8:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f3bf:	00 00 00 
  80f3c2:	0f b7 00             	movzwl (%rax),%eax
  80f3c5:	8d 50 01             	lea    0x1(%rax),%edx
  80f3c8:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f3cf:	00 00 00 
  80f3d2:	66 89 10             	mov    %dx,(%rax)
  80f3d5:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f3dc:	00 00 00 
  80f3df:	0f b7 00             	movzwl (%rax),%eax
  80f3e2:	66 85 c0             	test   %ax,%ax
  80f3e5:	79 0f                	jns    80f3f6 <tcp_new_port+0x46>
    port = TCP_LOCAL_PORT_RANGE_START;
  80f3e7:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f3ee:	00 00 00 
  80f3f1:	66 c7 00 00 10       	movw   $0x1000,(%rax)
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f3f6:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f3fd:	00 00 00 
  80f400:	48 8b 00             	mov    (%rax),%rax
  80f403:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f407:	eb 28                	jmp    80f431 <tcp_new_port+0x81>
    if (pcb->local_port == port) {
  80f409:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f40d:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f411:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f418:	00 00 00 
  80f41b:	0f b7 00             	movzwl (%rax),%eax
  80f41e:	66 39 c2             	cmp    %ax,%dx
  80f421:	75 02                	jne    80f425 <tcp_new_port+0x75>
      goto again;
  80f423:	eb 93                	jmp    80f3b8 <tcp_new_port+0x8>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f425:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f429:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f42d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f431:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f436:	75 d1                	jne    80f409 <tcp_new_port+0x59>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f438:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80f43f:	00 00 00 
  80f442:	48 8b 00             	mov    (%rax),%rax
  80f445:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f449:	eb 2b                	jmp    80f476 <tcp_new_port+0xc6>
    if (pcb->local_port == port) {
  80f44b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f44f:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f453:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f45a:	00 00 00 
  80f45d:	0f b7 00             	movzwl (%rax),%eax
  80f460:	66 39 c2             	cmp    %ax,%dx
  80f463:	75 05                	jne    80f46a <tcp_new_port+0xba>
      goto again;
  80f465:	e9 4e ff ff ff       	jmpq   80f3b8 <tcp_new_port+0x8>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f46a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f46e:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f472:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f476:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f47b:	75 ce                	jne    80f44b <tcp_new_port+0x9b>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f47d:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f484:	00 00 00 
  80f487:	48 8b 00             	mov    (%rax),%rax
  80f48a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f48e:	eb 2b                	jmp    80f4bb <tcp_new_port+0x10b>
    if (pcb->local_port == port) {
  80f490:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f494:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f498:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f49f:	00 00 00 
  80f4a2:	0f b7 00             	movzwl (%rax),%eax
  80f4a5:	66 39 c2             	cmp    %ax,%dx
  80f4a8:	75 05                	jne    80f4af <tcp_new_port+0xff>
      goto again;
  80f4aa:	e9 09 ff ff ff       	jmpq   80f3b8 <tcp_new_port+0x8>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f4af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4b3:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f4b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f4bb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f4c0:	75 ce                	jne    80f490 <tcp_new_port+0xe0>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
  80f4c2:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f4c9:	00 00 00 
  80f4cc:	0f b7 00             	movzwl (%rax),%eax
}
  80f4cf:	c9                   	leaveq 
  80f4d0:	c3                   	retq   

000000000080f4d1 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80f4d1:	55                   	push   %rbp
  80f4d2:	48 89 e5             	mov    %rsp,%rbp
  80f4d5:	48 83 ec 40          	sub    $0x40,%rsp
  80f4d9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80f4dd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80f4e1:	89 d0                	mov    %edx,%eax
  80f4e3:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80f4e7:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80f4eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4ef:	8b 40 18             	mov    0x18(%rax),%eax
  80f4f2:	85 c0                	test   %eax,%eax
  80f4f4:	74 2a                	je     80f520 <tcp_connect+0x4f>
  80f4f6:	48 ba 78 20 82 00 00 	movabs $0x822078,%rdx
  80f4fd:	00 00 00 
  80f500:	be ec 01 00 00       	mov    $0x1ec,%esi
  80f505:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  80f50c:	00 00 00 
  80f50f:	b8 00 00 00 00       	mov    $0x0,%eax
  80f514:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80f51b:	00 00 00 
  80f51e:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  80f520:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f525:	74 28                	je     80f54f <tcp_connect+0x7e>
    pcb->remote_ip = *ipaddr;
  80f527:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f52b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f52f:	8b 12                	mov    (%rdx),%edx
  80f531:	89 50 04             	mov    %edx,0x4(%rax)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80f534:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f538:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80f53c:	66 89 50 2a          	mov    %dx,0x2a(%rax)
  if (pcb->local_port == 0) {
  80f540:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f544:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f548:	66 85 c0             	test   %ax,%ax
  80f54b:	75 20                	jne    80f56d <tcp_connect+0x9c>
  80f54d:	eb 0a                	jmp    80f559 <tcp_connect+0x88>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  80f54f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80f554:	e9 53 02 00 00       	jmpq   80f7ac <tcp_connect+0x2db>
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
  80f559:	48 b8 b0 f3 80 00 00 	movabs $0x80f3b0,%rax
  80f560:	00 00 00 
  80f563:	ff d0                	callq  *%rax
  80f565:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f569:	66 89 42 28          	mov    %ax,0x28(%rdx)
  }
  iss = tcp_next_iss();
  80f56d:	48 b8 75 09 81 00 00 	movabs $0x810975,%rax
  80f574:	00 00 00 
  80f577:	ff d0                	callq  *%rax
  80f579:	89 45 fc             	mov    %eax,-0x4(%rbp)
  pcb->rcv_nxt = 0;
  80f57c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f580:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
  pcb->snd_nxt = iss;
  80f587:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f58b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80f58e:	89 50 60             	mov    %edx,0x60(%rax)
  pcb->lastack = iss - 1;
  80f591:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f594:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f597:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f59b:	89 50 54             	mov    %edx,0x54(%rax)
  pcb->snd_lbb = iss - 1;
  80f59e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f5a1:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f5a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f5a8:	89 50 74             	mov    %edx,0x74(%rax)
  pcb->rcv_wnd = TCP_WND;
  80f5ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f5af:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
  pcb->rcv_ann_wnd = TCP_WND;
  80f5b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f5b9:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  pcb->snd_wnd = TCP_WND;
  80f5bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f5c3:	66 c7 40 68 c0 5d    	movw   $0x5dc0,0x68(%rax)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80f5c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f5cd:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  80f5d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f5d7:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f5db:	0f b7 c0             	movzwl %ax,%eax
  80f5de:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f5e2:	48 89 d6             	mov    %rdx,%rsi
  80f5e5:	89 c7                	mov    %eax,%edi
  80f5e7:	48 b8 ad 09 81 00 00 	movabs $0x8109ad,%rax
  80f5ee:	00 00 00 
  80f5f1:	ff d0                	callq  *%rax
  80f5f3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f5f7:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  80f5fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f5ff:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
  pcb->ssthresh = pcb->mss * 10;
  80f605:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f609:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80f60d:	89 d0                	mov    %edx,%eax
  80f60f:	c1 e0 02             	shl    $0x2,%eax
  80f612:	01 d0                	add    %edx,%eax
  80f614:	01 c0                	add    %eax,%eax
  80f616:	89 c2                	mov    %eax,%edx
  80f618:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f61c:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  pcb->state = SYN_SENT;
  80f620:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f624:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%rax)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  80f62b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f62f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80f633:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80f63a:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f641:	00 00 00 
  80f644:	48 8b 00             	mov    (%rax),%rax
  80f647:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f64b:	75 23                	jne    80f670 <tcp_connect+0x19f>
  80f64d:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f654:	00 00 00 
  80f657:	48 8b 00             	mov    (%rax),%rax
  80f65a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f65e:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f665:	00 00 00 
  80f668:	48 89 10             	mov    %rdx,(%rax)
  80f66b:	e9 94 00 00 00       	jmpq   80f704 <tcp_connect+0x233>
  80f670:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f677:	00 00 00 
  80f67a:	48 8b 10             	mov    (%rax),%rdx
  80f67d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f684:	00 00 00 
  80f687:	48 89 10             	mov    %rdx,(%rax)
  80f68a:	eb 66                	jmp    80f6f2 <tcp_connect+0x221>
  80f68c:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f693:	00 00 00 
  80f696:	48 8b 00             	mov    (%rax),%rax
  80f699:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f69d:	48 85 c0             	test   %rax,%rax
  80f6a0:	74 32                	je     80f6d4 <tcp_connect+0x203>
  80f6a2:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f6a9:	00 00 00 
  80f6ac:	48 8b 00             	mov    (%rax),%rax
  80f6af:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f6b3:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f6b7:	75 1b                	jne    80f6d4 <tcp_connect+0x203>
  80f6b9:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f6c0:	00 00 00 
  80f6c3:	48 8b 00             	mov    (%rax),%rax
  80f6c6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f6ca:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80f6ce:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f6d2:	eb 30                	jmp    80f704 <tcp_connect+0x233>
  80f6d4:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f6db:	00 00 00 
  80f6de:	48 8b 00             	mov    (%rax),%rax
  80f6e1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f6e5:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f6ec:	00 00 00 
  80f6ef:	48 89 10             	mov    %rdx,(%rax)
  80f6f2:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f6f9:	00 00 00 
  80f6fc:	48 8b 00             	mov    (%rax),%rax
  80f6ff:	48 85 c0             	test   %rax,%rax
  80f702:	75 88                	jne    80f68c <tcp_connect+0x1bb>
  80f704:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f708:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80f70f:	00 
  TCP_REG(&tcp_active_pcbs, pcb);
  80f710:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f717:	00 00 00 
  80f71a:	48 8b 10             	mov    (%rax),%rdx
  80f71d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f721:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f725:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f72c:	00 00 00 
  80f72f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f733:	48 89 10             	mov    %rdx,(%rax)
  80f736:	48 b8 c0 83 80 00 00 	movabs $0x8083c0,%rax
  80f73d:	00 00 00 
  80f740:	ff d0                	callq  *%rax

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  80f742:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  80f747:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  80f74e:	00 00 00 
  80f751:	ff d0                	callq  *%rax
  80f753:	89 45 f4             	mov    %eax,-0xc(%rbp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80f756:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  80f75a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f75e:	c7 04 24 04 00 00 00 	movl   $0x4,(%rsp)
  80f765:	49 89 d1             	mov    %rdx,%r9
  80f768:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80f76e:	b9 02 00 00 00       	mov    $0x2,%ecx
  80f773:	ba 00 00 00 00       	mov    $0x0,%edx
  80f778:	be 00 00 00 00       	mov    $0x0,%esi
  80f77d:	48 89 c7             	mov    %rax,%rdi
  80f780:	48 b8 56 2e 81 00 00 	movabs $0x812e56,%rax
  80f787:	00 00 00 
  80f78a:	ff d0                	callq  *%rax
  80f78c:	88 45 fb             	mov    %al,-0x5(%rbp)
  if (ret == ERR_OK) { 
  80f78f:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  80f793:	75 13                	jne    80f7a8 <tcp_connect+0x2d7>
    tcp_output(pcb);
  80f795:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f799:	48 89 c7             	mov    %rax,%rdi
  80f79c:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  80f7a3:	00 00 00 
  80f7a6:	ff d0                	callq  *%rax
  }
  return ret;
  80f7a8:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
} 
  80f7ac:	c9                   	leaveq 
  80f7ad:	c3                   	retq   

000000000080f7ae <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80f7ae:	55                   	push   %rbp
  80f7af:	48 89 e5             	mov    %rsp,%rbp
  80f7b2:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  80f7b6:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)

  ++tcp_ticks;
  80f7ba:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f7c1:	00 00 00 
  80f7c4:	8b 00                	mov    (%rax),%eax
  80f7c6:	8d 50 01             	lea    0x1(%rax),%edx
  80f7c9:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f7d0:	00 00 00 
  80f7d3:	89 10                	mov    %edx,(%rax)

  /* Steps through all of the active PCBs. */
  prev = NULL;
  80f7d5:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80f7dc:	00 
  pcb = tcp_active_pcbs;
  80f7dd:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f7e4:	00 00 00 
  80f7e7:	48 8b 00             	mov    (%rax),%rax
  80f7ea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80f7ee:	e9 5e 06 00 00       	jmpq   80fe51 <tcp_slowtmr+0x6a3>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80f7f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7f7:	8b 40 18             	mov    0x18(%rax),%eax
  80f7fa:	85 c0                	test   %eax,%eax
  80f7fc:	75 2a                	jne    80f828 <tcp_slowtmr+0x7a>
  80f7fe:	48 ba b0 20 82 00 00 	movabs $0x8220b0,%rdx
  80f805:	00 00 00 
  80f808:	be 36 02 00 00       	mov    $0x236,%esi
  80f80d:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  80f814:	00 00 00 
  80f817:	b8 00 00 00 00       	mov    $0x0,%eax
  80f81c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80f823:	00 00 00 
  80f826:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80f828:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f82c:	8b 40 18             	mov    0x18(%rax),%eax
  80f82f:	83 f8 01             	cmp    $0x1,%eax
  80f832:	75 2a                	jne    80f85e <tcp_slowtmr+0xb0>
  80f834:	48 ba e0 20 82 00 00 	movabs $0x8220e0,%rdx
  80f83b:	00 00 00 
  80f83e:	be 37 02 00 00       	mov    $0x237,%esi
  80f843:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  80f84a:	00 00 00 
  80f84d:	b8 00 00 00 00       	mov    $0x0,%eax
  80f852:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80f859:	00 00 00 
  80f85c:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  80f85e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f862:	8b 40 18             	mov    0x18(%rax),%eax
  80f865:	83 f8 0a             	cmp    $0xa,%eax
  80f868:	75 2a                	jne    80f894 <tcp_slowtmr+0xe6>
  80f86a:	48 ba 10 21 82 00 00 	movabs $0x822110,%rdx
  80f871:	00 00 00 
  80f874:	be 38 02 00 00       	mov    $0x238,%esi
  80f879:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  80f880:	00 00 00 
  80f883:	b8 00 00 00 00       	mov    $0x0,%eax
  80f888:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80f88f:	00 00 00 
  80f892:	ff d1                	callq  *%rcx

    pcb_remove = 0;
  80f894:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  80f898:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f89c:	8b 40 18             	mov    0x18(%rax),%eax
  80f89f:	83 f8 02             	cmp    $0x2,%eax
  80f8a2:	75 15                	jne    80f8b9 <tcp_slowtmr+0x10b>
  80f8a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8a8:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80f8ac:	3c 06                	cmp    $0x6,%al
  80f8ae:	75 09                	jne    80f8b9 <tcp_slowtmr+0x10b>
      ++pcb_remove;
  80f8b0:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
  80f8b4:	e9 e4 01 00 00       	jmpq   80fa9d <tcp_slowtmr+0x2ef>
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80f8b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8bd:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80f8c1:	3c 0c                	cmp    $0xc,%al
  80f8c3:	75 09                	jne    80f8ce <tcp_slowtmr+0x120>
      ++pcb_remove;
  80f8c5:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  80f8c9:	e9 cf 01 00 00       	jmpq   80fa9d <tcp_slowtmr+0x2ef>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80f8ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8d2:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f8d9:	84 c0                	test   %al,%al
  80f8db:	0f 84 9a 00 00 00    	je     80f97b <tcp_slowtmr+0x1cd>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  80f8e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8e5:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80f8eb:	8d 50 01             	lea    0x1(%rax),%edx
  80f8ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8f2:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  80f8f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8fc:	8b 88 d4 00 00 00    	mov    0xd4(%rax),%ecx
  80f902:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f906:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f90d:	0f b6 c0             	movzbl %al,%eax
  80f910:	83 e8 01             	sub    $0x1,%eax
  80f913:	48 ba c5 1f 82 00 00 	movabs $0x821fc5,%rdx
  80f91a:	00 00 00 
  80f91d:	48 98                	cltq   
  80f91f:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80f923:	0f b6 c0             	movzbl %al,%eax
  80f926:	39 c1                	cmp    %eax,%ecx
  80f928:	0f 82 6f 01 00 00    	jb     80fa9d <tcp_slowtmr+0x2ef>
          pcb->persist_cnt = 0;
  80f92e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f932:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80f939:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80f93c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f940:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f947:	3c 06                	cmp    $0x6,%al
  80f949:	77 18                	ja     80f963 <tcp_slowtmr+0x1b5>
            pcb->persist_backoff++;
  80f94b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f94f:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f956:	8d 50 01             	lea    0x1(%rax),%edx
  80f959:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f95d:	88 90 d8 00 00 00    	mov    %dl,0xd8(%rax)
          }
          tcp_zero_window_probe(pcb);
  80f963:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f967:	48 89 c7             	mov    %rax,%rdi
  80f96a:	48 b8 e9 47 81 00 00 	movabs $0x8147e9,%rax
  80f971:	00 00 00 
  80f974:	ff d0                	callq  *%rax
  80f976:	e9 22 01 00 00       	jmpq   80fa9d <tcp_slowtmr+0x2ef>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  80f97b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f97f:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80f983:	66 85 c0             	test   %ax,%ax
  80f986:	78 13                	js     80f99b <tcp_slowtmr+0x1ed>
          ++pcb->rtime;
  80f988:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f98c:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80f990:	8d 50 01             	lea    0x1(%rax),%edx
  80f993:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f997:	66 89 50 3e          	mov    %dx,0x3e(%rax)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  80f99b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f99f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80f9a6:	48 85 c0             	test   %rax,%rax
  80f9a9:	0f 84 ee 00 00 00    	je     80fa9d <tcp_slowtmr+0x2ef>
  80f9af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9b3:	0f b7 50 3e          	movzwl 0x3e(%rax),%edx
  80f9b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9bb:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80f9bf:	66 39 c2             	cmp    %ax,%dx
  80f9c2:	0f 8c d5 00 00 00    	jl     80fa9d <tcp_slowtmr+0x2ef>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  80f9c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9cc:	8b 40 18             	mov    0x18(%rax),%eax
  80f9cf:	83 f8 02             	cmp    $0x2,%eax
  80f9d2:	74 49                	je     80fa1d <tcp_slowtmr+0x26f>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  80f9d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9d8:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80f9dc:	66 c1 f8 03          	sar    $0x3,%ax
  80f9e0:	0f bf d0             	movswl %ax,%edx
  80f9e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9e7:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  80f9eb:	98                   	cwtl   
  80f9ec:	8d 34 02             	lea    (%rdx,%rax,1),%esi
  80f9ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9f3:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80f9f7:	0f b6 c0             	movzbl %al,%eax
  80f9fa:	48 ba b8 1f 82 00 00 	movabs $0x821fb8,%rdx
  80fa01:	00 00 00 
  80fa04:	48 98                	cltq   
  80fa06:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80fa0a:	0f b6 c0             	movzbl %al,%eax
  80fa0d:	89 c1                	mov    %eax,%ecx
  80fa0f:	d3 e6                	shl    %cl,%esi
  80fa11:	89 f0                	mov    %esi,%eax
  80fa13:	89 c2                	mov    %eax,%edx
  80fa15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa19:	66 89 50 50          	mov    %dx,0x50(%rax)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  80fa1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa21:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  80fa27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa2b:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  80fa2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa33:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  80fa37:	66 39 c2             	cmp    %ax,%dx
  80fa3a:	0f 46 c2             	cmovbe %edx,%eax
  80fa3d:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
          pcb->ssthresh = eff_wnd >> 1;
  80fa41:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  80fa45:	66 d1 e8             	shr    %ax
  80fa48:	89 c2                	mov    %eax,%edx
  80fa4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa4e:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          if (pcb->ssthresh < pcb->mss) {
  80fa52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa56:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  80fa5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa5e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80fa62:	66 39 c2             	cmp    %ax,%dx
  80fa65:	73 13                	jae    80fa7a <tcp_slowtmr+0x2cc>
            pcb->ssthresh = pcb->mss * 2;
  80fa67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa6b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80fa6f:	8d 14 00             	lea    (%rax,%rax,1),%edx
  80fa72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa76:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          }
          pcb->cwnd = pcb->mss;
  80fa7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa7e:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80fa82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa86:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  80fa8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa8e:	48 89 c7             	mov    %rax,%rdi
  80fa91:	48 b8 21 44 81 00 00 	movabs $0x814421,%rax
  80fa98:	00 00 00 
  80fa9b:	ff d0                	callq  *%rax
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  80fa9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80faa1:	8b 40 18             	mov    0x18(%rax),%eax
  80faa4:	83 f8 06             	cmp    $0x6,%eax
  80faa7:	75 20                	jne    80fac9 <tcp_slowtmr+0x31b>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80faa9:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fab0:	00 00 00 
  80fab3:	8b 10                	mov    (%rax),%edx
  80fab5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fab9:	8b 40 38             	mov    0x38(%rax),%eax
  80fabc:	29 c2                	sub    %eax,%edx
  80fabe:	89 d0                	mov    %edx,%eax
  80fac0:	83 f8 28             	cmp    $0x28,%eax
  80fac3:	76 04                	jbe    80fac9 <tcp_slowtmr+0x31b>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80fac5:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80fac9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80facd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80fad1:	0f b7 c0             	movzwl %ax,%eax
  80fad4:	83 e0 08             	and    $0x8,%eax
  80fad7:	85 c0                	test   %eax,%eax
  80fad9:	0f 84 01 01 00 00    	je     80fbe0 <tcp_slowtmr+0x432>
       ((pcb->state == ESTABLISHED) || 
  80fadf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fae3:	8b 40 18             	mov    0x18(%rax),%eax
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80fae6:	83 f8 04             	cmp    $0x4,%eax
  80fae9:	74 10                	je     80fafb <tcp_slowtmr+0x34d>
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
  80faeb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80faef:	8b 40 18             	mov    0x18(%rax),%eax
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
       ((pcb->state == ESTABLISHED) || 
  80faf2:	83 f8 07             	cmp    $0x7,%eax
  80faf5:	0f 85 e5 00 00 00    	jne    80fbe0 <tcp_slowtmr+0x432>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fafb:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fb02:	00 00 00 
  80fb05:	8b 10                	mov    (%rax),%edx
  80fb07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb0b:	8b 40 38             	mov    0x38(%rax),%eax
  80fb0e:	29 c2                	sub    %eax,%edx
  80fb10:	89 d0                	mov    %edx,%eax
  80fb12:	89 c1                	mov    %eax,%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  80fb14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb18:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80fb1e:	89 c0                	mov    %eax,%eax
  80fb20:	48 05 b8 4c 0a 00    	add    $0xa4cb8,%rax
  80fb26:	48 c1 e8 02          	shr    $0x2,%rax
  80fb2a:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80fb31:	9b c4 20 
  80fb34:	48 f7 e2             	mul    %rdx
  80fb37:	48 89 d0             	mov    %rdx,%rax
  80fb3a:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fb3e:	48 39 c1             	cmp    %rax,%rcx
  80fb41:	76 18                	jbe    80fb5b <tcp_slowtmr+0x3ad>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80fb43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb47:	48 89 c7             	mov    %rax,%rdi
  80fb4a:	48 b8 ce eb 80 00 00 	movabs $0x80ebce,%rax
  80fb51:	00 00 00 
  80fb54:	ff d0                	callq  *%rax
  80fb56:	e9 85 00 00 00       	jmpq   80fbe0 <tcp_slowtmr+0x432>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fb5b:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fb62:	00 00 00 
  80fb65:	8b 10                	mov    (%rax),%edx
  80fb67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb6b:	8b 40 38             	mov    0x38(%rax),%eax
  80fb6e:	29 c2                	sub    %eax,%edx
  80fb70:	89 d0                	mov    %edx,%eax
  80fb72:	89 c1                	mov    %eax,%ecx
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  80fb74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb78:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80fb7e:	89 c2                	mov    %eax,%edx
  80fb80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb84:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80fb8b:	0f b6 c0             	movzbl %al,%eax
  80fb8e:	48 69 c0 f8 24 01 00 	imul   $0x124f8,%rax,%rax
  80fb95:	48 01 d0             	add    %rdx,%rax
              / TCP_SLOW_INTERVAL)
  80fb98:	48 c1 e8 02          	shr    $0x2,%rax
  80fb9c:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80fba3:	9b c4 20 
  80fba6:	48 f7 e2             	mul    %rdx
  80fba9:	48 89 d0             	mov    %rdx,%rax
  80fbac:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fbb0:	48 39 c1             	cmp    %rax,%rcx
  80fbb3:	76 2b                	jbe    80fbe0 <tcp_slowtmr+0x432>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  80fbb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbb9:	48 89 c7             	mov    %rax,%rdi
  80fbbc:	48 b8 c4 45 81 00 00 	movabs $0x8145c4,%rax
  80fbc3:	00 00 00 
  80fbc6:	ff d0                	callq  *%rax
        pcb->keep_cnt_sent++;
  80fbc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbcc:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80fbd3:	8d 50 01             	lea    0x1(%rax),%edx
  80fbd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbda:	88 90 d9 00 00 00    	mov    %dl,0xd9(%rax)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80fbe0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbe4:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80fbeb:	48 85 c0             	test   %rax,%rax
  80fbee:	74 57                	je     80fc47 <tcp_slowtmr+0x499>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  80fbf0:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fbf7:	00 00 00 
  80fbfa:	8b 10                	mov    (%rax),%edx
  80fbfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc00:	8b 40 38             	mov    0x38(%rax),%eax
  80fc03:	89 d1                	mov    %edx,%ecx
  80fc05:	29 c1                	sub    %eax,%ecx
  80fc07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc0b:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80fc0f:	0f bf d0             	movswl %ax,%edx
  80fc12:	89 d0                	mov    %edx,%eax
  80fc14:	01 c0                	add    %eax,%eax
  80fc16:	01 d0                	add    %edx,%eax
  80fc18:	01 c0                	add    %eax,%eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80fc1a:	39 c1                	cmp    %eax,%ecx
  80fc1c:	72 29                	jb     80fc47 <tcp_slowtmr+0x499>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  80fc1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc22:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80fc29:	48 89 c7             	mov    %rax,%rdi
  80fc2c:	48 b8 03 01 81 00 00 	movabs $0x810103,%rax
  80fc33:	00 00 00 
  80fc36:	ff d0                	callq  *%rax
      pcb->ooseq = NULL;
  80fc38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc3c:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  80fc43:	00 00 00 00 
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  80fc47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc4b:	8b 40 18             	mov    0x18(%rax),%eax
  80fc4e:	83 f8 03             	cmp    $0x3,%eax
  80fc51:	75 20                	jne    80fc73 <tcp_slowtmr+0x4c5>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80fc53:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fc5a:	00 00 00 
  80fc5d:	8b 10                	mov    (%rax),%edx
  80fc5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc63:	8b 40 38             	mov    0x38(%rax),%eax
  80fc66:	29 c2                	sub    %eax,%edx
  80fc68:	89 d0                	mov    %edx,%eax
  80fc6a:	83 f8 28             	cmp    $0x28,%eax
  80fc6d:	76 04                	jbe    80fc73 <tcp_slowtmr+0x4c5>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80fc6f:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  80fc73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc77:	8b 40 18             	mov    0x18(%rax),%eax
  80fc7a:	83 f8 09             	cmp    $0x9,%eax
  80fc7d:	75 22                	jne    80fca1 <tcp_slowtmr+0x4f3>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80fc7f:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fc86:	00 00 00 
  80fc89:	8b 10                	mov    (%rax),%edx
  80fc8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc8f:	8b 40 38             	mov    0x38(%rax),%eax
  80fc92:	29 c2                	sub    %eax,%edx
  80fc94:	89 d0                	mov    %edx,%eax
  80fc96:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80fc9b:	76 04                	jbe    80fca1 <tcp_slowtmr+0x4f3>
        ++pcb_remove;
  80fc9d:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80fca1:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80fca5:	0f 84 19 01 00 00    	je     80fdc4 <tcp_slowtmr+0x616>
      tcp_pcb_purge(pcb);      
  80fcab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcaf:	48 89 c7             	mov    %rax,%rdi
  80fcb2:	48 b8 76 06 81 00 00 	movabs $0x810676,%rax
  80fcb9:	00 00 00 
  80fcbc:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  80fcbe:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80fcc3:	74 4f                	je     80fd14 <tcp_slowtmr+0x566>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80fcc5:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fccc:	00 00 00 
  80fccf:	48 8b 00             	mov    (%rax),%rax
  80fcd2:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80fcd6:	75 2a                	jne    80fd02 <tcp_slowtmr+0x554>
  80fcd8:	48 ba 40 21 82 00 00 	movabs $0x822140,%rdx
  80fcdf:	00 00 00 
  80fce2:	be c1 02 00 00       	mov    $0x2c1,%esi
  80fce7:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  80fcee:	00 00 00 
  80fcf1:	b8 00 00 00 00       	mov    $0x0,%eax
  80fcf6:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80fcfd:	00 00 00 
  80fd00:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  80fd02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd06:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fd0a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80fd0e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80fd12:	eb 52                	jmp    80fd66 <tcp_slowtmr+0x5b8>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80fd14:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fd1b:	00 00 00 
  80fd1e:	48 8b 00             	mov    (%rax),%rax
  80fd21:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80fd25:	74 2a                	je     80fd51 <tcp_slowtmr+0x5a3>
  80fd27:	48 ba 70 21 82 00 00 	movabs $0x822170,%rdx
  80fd2e:	00 00 00 
  80fd31:	be c5 02 00 00       	mov    $0x2c5,%esi
  80fd36:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  80fd3d:	00 00 00 
  80fd40:	b8 00 00 00 00       	mov    $0x0,%eax
  80fd45:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80fd4c:	00 00 00 
  80fd4f:	ff d1                	callq  *%rcx
        tcp_active_pcbs = pcb->next;
  80fd51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd55:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fd59:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fd60:	00 00 00 
  80fd63:	48 89 10             	mov    %rdx,(%rax)
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  80fd66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd6a:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80fd71:	48 85 c0             	test   %rax,%rax
  80fd74:	74 1d                	je     80fd93 <tcp_slowtmr+0x5e5>
  80fd76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd7a:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80fd81:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80fd85:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  80fd89:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80fd8e:	48 89 d7             	mov    %rdx,%rdi
  80fd91:	ff d0                	callq  *%rax

      pcb2 = pcb->next;
  80fd93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd97:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fd9b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  80fd9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fda3:	48 89 c6             	mov    %rax,%rsi
  80fda6:	bf 02 00 00 00       	mov    $0x2,%edi
  80fdab:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80fdb2:	00 00 00 
  80fdb5:	ff d0                	callq  *%rax
      pcb = pcb2;
  80fdb7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80fdbb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80fdbf:	e9 8d 00 00 00       	jmpq   80fe51 <tcp_slowtmr+0x6a3>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  80fdc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdc8:	0f b6 40 3c          	movzbl 0x3c(%rax),%eax
  80fdcc:	8d 50 01             	lea    0x1(%rax),%edx
  80fdcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdd3:	88 50 3c             	mov    %dl,0x3c(%rax)
      if (pcb->polltmr >= pcb->pollinterval) {
  80fdd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdda:	0f b6 50 3c          	movzbl 0x3c(%rax),%edx
  80fdde:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fde2:	0f b6 40 3d          	movzbl 0x3d(%rax),%eax
  80fde6:	38 c2                	cmp    %al,%dl
  80fde8:	72 53                	jb     80fe3d <tcp_slowtmr+0x68f>
        pcb->polltmr = 0;
  80fdea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdee:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  80fdf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdf6:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  80fdfd:	48 85 c0             	test   %rax,%rax
  80fe00:	74 22                	je     80fe24 <tcp_slowtmr+0x676>
  80fe02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe06:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  80fe0d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80fe11:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  80fe15:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80fe19:	48 89 ce             	mov    %rcx,%rsi
  80fe1c:	48 89 d7             	mov    %rdx,%rdi
  80fe1f:	ff d0                	callq  *%rax
  80fe21:	88 45 ee             	mov    %al,-0x12(%rbp)
        if (err == ERR_OK) {
  80fe24:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  80fe28:	75 13                	jne    80fe3d <tcp_slowtmr+0x68f>
          tcp_output(pcb);
  80fe2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe2e:	48 89 c7             	mov    %rax,%rdi
  80fe31:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  80fe38:	00 00 00 
  80fe3b:	ff d0                	callq  *%rax
        }
      }
      
      prev = pcb;
  80fe3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe41:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  80fe45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe49:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fe4d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80fe51:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80fe56:	0f 85 97 f9 ff ff    	jne    80f7f3 <tcp_slowtmr+0x45>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  80fe5c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80fe63:	00 
  pcb = tcp_tw_pcbs;
  80fe64:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80fe6b:	00 00 00 
  80fe6e:	48 8b 00             	mov    (%rax),%rax
  80fe71:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (pcb != NULL) {
  80fe75:	e9 63 01 00 00       	jmpq   80ffdd <tcp_slowtmr+0x82f>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80fe7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe7e:	8b 40 18             	mov    0x18(%rax),%eax
  80fe81:	83 f8 0a             	cmp    $0xa,%eax
  80fe84:	74 2a                	je     80feb0 <tcp_slowtmr+0x702>
  80fe86:	48 ba a0 21 82 00 00 	movabs $0x8221a0,%rdx
  80fe8d:	00 00 00 
  80fe90:	be e5 02 00 00       	mov    $0x2e5,%esi
  80fe95:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  80fe9c:	00 00 00 
  80fe9f:	b8 00 00 00 00       	mov    $0x0,%eax
  80fea4:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80feab:	00 00 00 
  80feae:	ff d1                	callq  *%rcx
    pcb_remove = 0;
  80feb0:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80feb4:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80febb:	00 00 00 
  80febe:	8b 10                	mov    (%rax),%edx
  80fec0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fec4:	8b 40 38             	mov    0x38(%rax),%eax
  80fec7:	29 c2                	sub    %eax,%edx
  80fec9:	89 d0                	mov    %edx,%eax
  80fecb:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80fed0:	76 04                	jbe    80fed6 <tcp_slowtmr+0x728>
      ++pcb_remove;
  80fed2:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80fed6:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80feda:	0f 84 e9 00 00 00    	je     80ffc9 <tcp_slowtmr+0x81b>
      tcp_pcb_purge(pcb);      
  80fee0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fee4:	48 89 c7             	mov    %rax,%rdi
  80fee7:	48 b8 76 06 81 00 00 	movabs $0x810676,%rax
  80feee:	00 00 00 
  80fef1:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  80fef3:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80fef8:	74 4f                	je     80ff49 <tcp_slowtmr+0x79b>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  80fefa:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80ff01:	00 00 00 
  80ff04:	48 8b 00             	mov    (%rax),%rax
  80ff07:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80ff0b:	75 2a                	jne    80ff37 <tcp_slowtmr+0x789>
  80ff0d:	48 ba d0 21 82 00 00 	movabs $0x8221d0,%rdx
  80ff14:	00 00 00 
  80ff17:	be f4 02 00 00       	mov    $0x2f4,%esi
  80ff1c:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  80ff23:	00 00 00 
  80ff26:	b8 00 00 00 00       	mov    $0x0,%eax
  80ff2b:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80ff32:	00 00 00 
  80ff35:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  80ff37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff3b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ff3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ff43:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ff47:	eb 52                	jmp    80ff9b <tcp_slowtmr+0x7ed>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80ff49:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80ff50:	00 00 00 
  80ff53:	48 8b 00             	mov    (%rax),%rax
  80ff56:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80ff5a:	74 2a                	je     80ff86 <tcp_slowtmr+0x7d8>
  80ff5c:	48 ba f8 21 82 00 00 	movabs $0x8221f8,%rdx
  80ff63:	00 00 00 
  80ff66:	be f8 02 00 00       	mov    $0x2f8,%esi
  80ff6b:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  80ff72:	00 00 00 
  80ff75:	b8 00 00 00 00       	mov    $0x0,%eax
  80ff7a:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  80ff81:	00 00 00 
  80ff84:	ff d1                	callq  *%rcx
        tcp_tw_pcbs = pcb->next;
  80ff86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff8a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ff8e:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80ff95:	00 00 00 
  80ff98:	48 89 10             	mov    %rdx,(%rax)
      }
      pcb2 = pcb->next;
  80ff9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff9f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ffa3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  80ffa7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffab:	48 89 c6             	mov    %rax,%rsi
  80ffae:	bf 02 00 00 00       	mov    $0x2,%edi
  80ffb3:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  80ffba:	00 00 00 
  80ffbd:	ff d0                	callq  *%rax
      pcb = pcb2;
  80ffbf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ffc3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ffc7:	eb 14                	jmp    80ffdd <tcp_slowtmr+0x82f>
    } else {
      prev = pcb;
  80ffc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffcd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  80ffd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffd5:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ffd9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  80ffdd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ffe2:	0f 85 92 fe ff ff    	jne    80fe7a <tcp_slowtmr+0x6cc>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  80ffe8:	c9                   	leaveq 
  80ffe9:	c3                   	retq   

000000000080ffea <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  80ffea:	55                   	push   %rbp
  80ffeb:	48 89 e5             	mov    %rsp,%rbp
  80ffee:	48 83 ec 10          	sub    $0x10,%rsp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80fff2:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fff9:	00 00 00 
  80fffc:	48 8b 00             	mov    (%rax),%rax
  80ffff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810003:	e9 ee 00 00 00       	jmpq   8100f6 <tcp_fasttmr+0x10c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  810008:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81000c:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810013:	48 85 c0             	test   %rax,%rax
  810016:	0f 84 81 00 00 00    	je     81009d <tcp_fasttmr+0xb3>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81001c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810020:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  810027:	48 85 c0             	test   %rax,%rax
  81002a:	74 2e                	je     81005a <tcp_fasttmr+0x70>
  81002c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810030:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  810037:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81003b:	48 8b 92 98 00 00 00 	mov    0x98(%rdx),%rdx
  810042:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  810046:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81004a:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81004e:	b9 00 00 00 00       	mov    $0x0,%ecx
  810053:	ff d0                	callq  *%rax
  810055:	88 45 f7             	mov    %al,-0x9(%rbp)
  810058:	eb 2e                	jmp    810088 <tcp_fasttmr+0x9e>
  81005a:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  81005e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810062:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810069:	48 85 c0             	test   %rax,%rax
  81006c:	74 1a                	je     810088 <tcp_fasttmr+0x9e>
  81006e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810072:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810079:	48 89 c7             	mov    %rax,%rdi
  81007c:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  810083:	00 00 00 
  810086:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  810088:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  81008c:	75 0f                	jne    81009d <tcp_fasttmr+0xb3>
        pcb->refused_data = NULL;
  81008e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810092:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  810099:	00 00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  81009d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100a1:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8100a5:	0f b6 c0             	movzbl %al,%eax
  8100a8:	83 e0 01             	and    $0x1,%eax
  8100ab:	85 c0                	test   %eax,%eax
  8100ad:	74 3b                	je     8100ea <tcp_fasttmr+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  8100af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100b3:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8100b7:	83 c8 02             	or     $0x2,%eax
  8100ba:	89 c2                	mov    %eax,%edx
  8100bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100c0:	88 50 2c             	mov    %dl,0x2c(%rax)
  8100c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100c7:	48 89 c7             	mov    %rax,%rdi
  8100ca:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  8100d1:	00 00 00 
  8100d4:	ff d0                	callq  *%rax
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8100d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100da:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8100de:	83 e0 fc             	and    $0xfffffffc,%eax
  8100e1:	89 c2                	mov    %eax,%edx
  8100e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100e7:	88 50 2c             	mov    %dl,0x2c(%rax)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8100ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100ee:	48 8b 40 10          	mov    0x10(%rax),%rax
  8100f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8100f6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8100fb:	0f 85 07 ff ff ff    	jne    810008 <tcp_fasttmr+0x1e>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  810101:	c9                   	leaveq 
  810102:	c3                   	retq   

0000000000810103 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  810103:	55                   	push   %rbp
  810104:	48 89 e5             	mov    %rsp,%rbp
  810107:	48 83 ec 20          	sub    $0x20,%rsp
  81010b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  81010f:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct tcp_seg *next;
  while (seg != NULL) {
  810113:	eb 29                	jmp    81013e <tcp_segs_free+0x3b>
    next = seg->next;
  810115:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810119:	48 8b 00             	mov    (%rax),%rax
  81011c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    count += tcp_seg_free(seg);
  810120:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810124:	48 89 c7             	mov    %rax,%rdi
  810127:	48 b8 4b 01 81 00 00 	movabs $0x81014b,%rax
  81012e:	00 00 00 
  810131:	ff d0                	callq  *%rax
  810133:	00 45 ff             	add    %al,-0x1(%rbp)
    seg = next;
  810136:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81013a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  81013e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  810143:	75 d0                	jne    810115 <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
  810145:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  810149:	c9                   	leaveq 
  81014a:	c3                   	retq   

000000000081014b <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  81014b:	55                   	push   %rbp
  81014c:	48 89 e5             	mov    %rsp,%rbp
  81014f:	48 83 ec 20          	sub    $0x20,%rsp
  810153:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  810157:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  
  if (seg != NULL) {
  81015b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  810160:	74 3f                	je     8101a1 <tcp_seg_free+0x56>
    if (seg->p != NULL) {
  810162:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810166:	48 8b 40 08          	mov    0x8(%rax),%rax
  81016a:	48 85 c0             	test   %rax,%rax
  81016d:	74 1a                	je     810189 <tcp_seg_free+0x3e>
      count = pbuf_free(seg->p);
  81016f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810173:	48 8b 40 08          	mov    0x8(%rax),%rax
  810177:	48 89 c7             	mov    %rax,%rdi
  81017a:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  810181:	00 00 00 
  810184:	ff d0                	callq  *%rax
  810186:	88 45 ff             	mov    %al,-0x1(%rbp)
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  810189:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81018d:	48 89 c6             	mov    %rax,%rsi
  810190:	bf 04 00 00 00       	mov    $0x4,%edi
  810195:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81019c:	00 00 00 
  81019f:	ff d0                	callq  *%rax
  }
  return count;
  8101a1:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  8101a5:	c9                   	leaveq 
  8101a6:	c3                   	retq   

00000000008101a7 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8101a7:	55                   	push   %rbp
  8101a8:	48 89 e5             	mov    %rsp,%rbp
  8101ab:	48 83 ec 0c          	sub    $0xc,%rsp
  8101af:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8101b3:	89 f0                	mov    %esi,%eax
  8101b5:	88 45 f4             	mov    %al,-0xc(%rbp)
  pcb->prio = prio;
  8101b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101bc:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  8101c0:	88 50 1c             	mov    %dl,0x1c(%rax)
}
  8101c3:	c9                   	leaveq 
  8101c4:	c3                   	retq   

00000000008101c5 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8101c5:	55                   	push   %rbp
  8101c6:	48 89 e5             	mov    %rsp,%rbp
  8101c9:	48 83 ec 20          	sub    $0x20,%rsp
  8101cd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8101d1:	bf 04 00 00 00       	mov    $0x4,%edi
  8101d6:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  8101dd:	00 00 00 
  8101e0:	ff d0                	callq  *%rax
  8101e2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (cseg == NULL) {
  8101e6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8101eb:	75 07                	jne    8101f4 <tcp_seg_copy+0x2f>
    return NULL;
  8101ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8101f2:	eb 3a                	jmp    81022e <tcp_seg_copy+0x69>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  8101f4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8101f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101fc:	ba 28 00 00 00       	mov    $0x28,%edx
  810201:	48 89 ce             	mov    %rcx,%rsi
  810204:	48 89 c7             	mov    %rax,%rdi
  810207:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  81020e:	00 00 00 
  810211:	ff d0                	callq  *%rax
  pbuf_ref(cseg->p);
  810213:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810217:	48 8b 40 08          	mov    0x8(%rax),%rax
  81021b:	48 89 c7             	mov    %rax,%rdi
  81021e:	48 b8 f2 db 80 00 00 	movabs $0x80dbf2,%rax
  810225:	00 00 00 
  810228:	ff d0                	callq  *%rax
  return cseg;
  81022a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81022e:	c9                   	leaveq 
  81022f:	c3                   	retq   

0000000000810230 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  810230:	55                   	push   %rbp
  810231:	48 89 e5             	mov    %rsp,%rbp
  810234:	48 83 ec 20          	sub    $0x20,%rsp
  810238:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81023c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  810240:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  810244:	89 c8                	mov    %ecx,%eax
  810246:	88 45 e4             	mov    %al,-0x1c(%rbp)
  arg = arg;
  if (p != NULL) {
  810249:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81024e:	74 15                	je     810265 <tcp_recv_null+0x35>
    pbuf_free(p);
  810250:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810254:	48 89 c7             	mov    %rax,%rdi
  810257:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81025e:	00 00 00 
  810261:	ff d0                	callq  *%rax
  810263:	eb 1b                	jmp    810280 <tcp_recv_null+0x50>
  } else if (err == ERR_OK) {
  810265:	80 7d e4 00          	cmpb   $0x0,-0x1c(%rbp)
  810269:	75 15                	jne    810280 <tcp_recv_null+0x50>
    return tcp_close(pcb);
  81026b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81026f:	48 89 c7             	mov    %rax,%rdi
  810272:	48 b8 48 e9 80 00 00 	movabs $0x80e948,%rax
  810279:	00 00 00 
  81027c:	ff d0                	callq  *%rax
  81027e:	eb 05                	jmp    810285 <tcp_recv_null+0x55>
  }
  return ERR_OK;
  810280:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810285:	c9                   	leaveq 
  810286:	c3                   	retq   

0000000000810287 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
  810287:	55                   	push   %rbp
  810288:	48 89 e5             	mov    %rsp,%rbp
  81028b:	48 83 ec 30          	sub    $0x30,%rsp
  81028f:	89 f8                	mov    %edi,%eax
  810291:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  810294:	c6 45 eb 7f          	movb   $0x7f,-0x15(%rbp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  810298:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  81029f:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8102a6:	00 
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8102a7:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8102ae:	00 00 00 
  8102b1:	48 8b 00             	mov    (%rax),%rax
  8102b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8102b8:	eb 6f                	jmp    810329 <tcp_kill_prio+0xa2>
    if (pcb->prio <= prio &&
  8102ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102be:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8102c2:	3a 45 dc             	cmp    -0x24(%rbp),%al
  8102c5:	77 56                	ja     81031d <tcp_kill_prio+0x96>
       pcb->prio <= mprio &&
  8102c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102cb:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  8102cf:	3a 45 eb             	cmp    -0x15(%rbp),%al
  8102d2:	77 49                	ja     81031d <tcp_kill_prio+0x96>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8102d4:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8102db:	00 00 00 
  8102de:	8b 10                	mov    (%rax),%edx
  8102e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102e4:	8b 40 38             	mov    0x38(%rax),%eax
  8102e7:	29 c2                	sub    %eax,%edx
  8102e9:	89 d0                	mov    %edx,%eax
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  8102eb:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8102ee:	72 2d                	jb     81031d <tcp_kill_prio+0x96>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  8102f0:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8102f7:	00 00 00 
  8102fa:	8b 10                	mov    (%rax),%edx
  8102fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810300:	8b 40 38             	mov    0x38(%rax),%eax
  810303:	29 c2                	sub    %eax,%edx
  810305:	89 d0                	mov    %edx,%eax
  810307:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  81030a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81030e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      mprio = pcb->prio;
  810312:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810316:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81031a:	88 45 eb             	mov    %al,-0x15(%rbp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81031d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810321:	48 8b 40 10          	mov    0x10(%rax),%rax
  810325:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810329:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81032e:	75 8a                	jne    8102ba <tcp_kill_prio+0x33>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  810330:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810335:	74 13                	je     81034a <tcp_kill_prio+0xc3>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  810337:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81033b:	48 89 c7             	mov    %rax,%rdi
  81033e:	48 b8 ce eb 80 00 00 	movabs $0x80ebce,%rax
  810345:	00 00 00 
  810348:	ff d0                	callq  *%rax
  }      
}
  81034a:	c9                   	leaveq 
  81034b:	c3                   	retq   

000000000081034c <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
  81034c:	55                   	push   %rbp
  81034d:	48 89 e5             	mov    %rsp,%rbp
  810350:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  810354:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  81035b:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  810362:	00 
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810363:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81036a:	00 00 00 
  81036d:	48 8b 00             	mov    (%rax),%rax
  810370:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810374:	eb 4a                	jmp    8103c0 <tcp_kill_timewait+0x74>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  810376:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81037d:	00 00 00 
  810380:	8b 10                	mov    (%rax),%edx
  810382:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810386:	8b 40 38             	mov    0x38(%rax),%eax
  810389:	29 c2                	sub    %eax,%edx
  81038b:	89 d0                	mov    %edx,%eax
  81038d:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  810390:	72 22                	jb     8103b4 <tcp_kill_timewait+0x68>
      inactivity = tcp_ticks - pcb->tmr;
  810392:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810399:	00 00 00 
  81039c:	8b 10                	mov    (%rax),%edx
  81039e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103a2:	8b 40 38             	mov    0x38(%rax),%eax
  8103a5:	29 c2                	sub    %eax,%edx
  8103a7:	89 d0                	mov    %edx,%eax
  8103a9:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  8103ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103b0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8103b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103b8:	48 8b 40 10          	mov    0x10(%rax),%rax
  8103bc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8103c0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8103c5:	75 af                	jne    810376 <tcp_kill_timewait+0x2a>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  8103c7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8103cc:	74 13                	je     8103e1 <tcp_kill_timewait+0x95>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8103ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8103d2:	48 89 c7             	mov    %rax,%rdi
  8103d5:	48 b8 ce eb 80 00 00 	movabs $0x80ebce,%rax
  8103dc:	00 00 00 
  8103df:	ff d0                	callq  *%rax
  }      
}
  8103e1:	c9                   	leaveq 
  8103e2:	c3                   	retq   

00000000008103e3 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  8103e3:	55                   	push   %rbp
  8103e4:	48 89 e5             	mov    %rsp,%rbp
  8103e7:	48 83 ec 20          	sub    $0x20,%rsp
  8103eb:	89 f8                	mov    %edi,%eax
  8103ed:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  8103f0:	bf 02 00 00 00       	mov    $0x2,%edi
  8103f5:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  8103fc:	00 00 00 
  8103ff:	ff d0                	callq  *%rax
  810401:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
  810405:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81040a:	75 4f                	jne    81045b <tcp_alloc+0x78>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
  81040c:	48 b8 4c 03 81 00 00 	movabs $0x81034c,%rax
  810413:	00 00 00 
  810416:	ff d0                	callq  *%rax
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  810418:	bf 02 00 00 00       	mov    $0x2,%edi
  81041d:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  810424:	00 00 00 
  810427:	ff d0                	callq  *%rax
  810429:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (pcb == NULL) {
  81042d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810432:	75 27                	jne    81045b <tcp_alloc+0x78>
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
  810434:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
  810438:	89 c7                	mov    %eax,%edi
  81043a:	48 b8 87 02 81 00 00 	movabs $0x810287,%rax
  810441:	00 00 00 
  810444:	ff d0                	callq  *%rax
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  810446:	bf 02 00 00 00       	mov    $0x2,%edi
  81044b:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  810452:	00 00 00 
  810455:	ff d0                	callq  *%rax
  810457:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
  }
  if (pcb != NULL) {
  81045b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810460:	0f 84 23 01 00 00    	je     810589 <tcp_alloc+0x1a6>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  810466:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81046a:	ba e0 00 00 00       	mov    $0xe0,%edx
  81046f:	be 00 00 00 00       	mov    $0x0,%esi
  810474:	48 89 c7             	mov    %rax,%rdi
  810477:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  81047e:	00 00 00 
  810481:	ff d0                	callq  *%rax
    pcb->prio = TCP_PRIO_NORMAL;
  810483:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810487:	c6 40 1c 40          	movb   $0x40,0x1c(%rax)
    pcb->snd_buf = TCP_SND_BUF;
  81048b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81048f:	66 c7 40 7a 40 5b    	movw   $0x5b40,0x7a(%rax)
    pcb->snd_queuelen = 0;
  810495:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810499:	66 c7 40 7c 00 00    	movw   $0x0,0x7c(%rax)
    pcb->rcv_wnd = TCP_WND;
  81049f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104a3:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  8104a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104ad:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
    pcb->tos = 0;
  8104b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104b7:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
    pcb->ttl = TCP_TTL;
  8104bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104bf:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8104c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104c7:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8104cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104d1:	66 c7 40 50 06 00    	movw   $0x6,0x50(%rax)
    pcb->sa = 0;
  8104d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104db:	66 c7 40 4c 00 00    	movw   $0x0,0x4c(%rax)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8104e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104e5:	66 c7 40 4e 06 00    	movw   $0x6,0x4e(%rax)
    pcb->rtime = -1;
  8104eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104ef:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
    pcb->cwnd = 1;
  8104f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104f9:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
    iss = tcp_next_iss();
  8104ff:	48 b8 75 09 81 00 00 	movabs $0x810975,%rax
  810506:	00 00 00 
  810509:	ff d0                	callq  *%rax
  81050b:	89 45 f4             	mov    %eax,-0xc(%rbp)
    pcb->snd_wl2 = iss;
  81050e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810512:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810515:	89 50 70             	mov    %edx,0x70(%rax)
    pcb->snd_nxt = iss;
  810518:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81051c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81051f:	89 50 60             	mov    %edx,0x60(%rax)
    pcb->snd_max = iss;
  810522:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810526:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810529:	89 50 64             	mov    %edx,0x64(%rax)
    pcb->lastack = iss;
  81052c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810530:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810533:	89 50 54             	mov    %edx,0x54(%rax)
    pcb->snd_lbb = iss;   
  810536:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81053a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81053d:	89 50 74             	mov    %edx,0x74(%rax)
    pcb->tmr = tcp_ticks;
  810540:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810547:	00 00 00 
  81054a:	8b 10                	mov    (%rax),%edx
  81054c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810550:	89 50 38             	mov    %edx,0x38(%rax)

    pcb->polltmr = 0;
  810553:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810557:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  81055b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81055f:	48 b9 30 02 81 00 00 	movabs $0x810230,%rcx
  810566:	00 00 00 
  810569:	48 89 88 a8 00 00 00 	mov    %rcx,0xa8(%rax)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  810570:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810574:	c7 80 d0 00 00 00 00 	movl   $0x6ddd00,0xd0(%rax)
  81057b:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  81057e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810582:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)
  }
  return pcb;
  810589:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81058d:	c9                   	leaveq 
  81058e:	c3                   	retq   

000000000081058f <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  81058f:	55                   	push   %rbp
  810590:	48 89 e5             	mov    %rsp,%rbp
  return tcp_alloc(TCP_PRIO_NORMAL);
  810593:	bf 40 00 00 00       	mov    $0x40,%edi
  810598:	48 b8 e3 03 81 00 00 	movabs $0x8103e3,%rax
  81059f:	00 00 00 
  8105a2:	ff d0                	callq  *%rax
}
  8105a4:	5d                   	pop    %rbp
  8105a5:	c3                   	retq   

00000000008105a6 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8105a6:	55                   	push   %rbp
  8105a7:	48 89 e5             	mov    %rsp,%rbp
  8105aa:	48 83 ec 10          	sub    $0x10,%rsp
  8105ae:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8105b2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->callback_arg = arg;
  8105b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105ba:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8105be:	48 89 50 20          	mov    %rdx,0x20(%rax)
}
  8105c2:	c9                   	leaveq 
  8105c3:	c3                   	retq   

00000000008105c4 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  8105c4:	55                   	push   %rbp
  8105c5:	48 89 e5             	mov    %rsp,%rbp
  8105c8:	48 83 ec 10          	sub    $0x10,%rsp
  8105cc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8105d0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->recv = recv;
  8105d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105d8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8105dc:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
  8105e3:	c9                   	leaveq 
  8105e4:	c3                   	retq   

00000000008105e5 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  8105e5:	55                   	push   %rbp
  8105e6:	48 89 e5             	mov    %rsp,%rbp
  8105e9:	48 83 ec 10          	sub    $0x10,%rsp
  8105ed:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8105f1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->sent = sent;
  8105f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105f9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8105fd:	48 89 90 a0 00 00 00 	mov    %rdx,0xa0(%rax)
}
  810604:	c9                   	leaveq 
  810605:	c3                   	retq   

0000000000810606 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  810606:	55                   	push   %rbp
  810607:	48 89 e5             	mov    %rsp,%rbp
  81060a:	48 83 ec 10          	sub    $0x10,%rsp
  81060e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810612:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->errf = errf;
  810616:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81061a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81061e:	48 89 90 c8 00 00 00 	mov    %rdx,0xc8(%rax)
}
  810625:	c9                   	leaveq 
  810626:	c3                   	retq   

0000000000810627 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  810627:	55                   	push   %rbp
  810628:	48 89 e5             	mov    %rsp,%rbp
  81062b:	48 83 ec 10          	sub    $0x10,%rsp
  81062f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810633:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  810637:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81063b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81063f:	48 89 50 30          	mov    %rdx,0x30(%rax)
}
  810643:	c9                   	leaveq 
  810644:	c3                   	retq   

0000000000810645 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  810645:	55                   	push   %rbp
  810646:	48 89 e5             	mov    %rsp,%rbp
  810649:	48 83 ec 14          	sub    $0x14,%rsp
  81064d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810651:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  810655:	89 d0                	mov    %edx,%eax
  810657:	88 45 ec             	mov    %al,-0x14(%rbp)
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  81065a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81065e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810662:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  810669:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81066d:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  810671:	88 50 3d             	mov    %dl,0x3d(%rax)
}
  810674:	c9                   	leaveq 
  810675:	c3                   	retq   

0000000000810676 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  810676:	55                   	push   %rbp
  810677:	48 89 e5             	mov    %rsp,%rbp
  81067a:	48 83 ec 10          	sub    $0x10,%rsp
  81067e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (pcb->state != CLOSED &&
  810682:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810686:	8b 40 18             	mov    0x18(%rax),%eax
  810689:	85 c0                	test   %eax,%eax
  81068b:	0f 84 e5 00 00 00    	je     810776 <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
  810691:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810695:	8b 40 18             	mov    0x18(%rax),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  810698:	83 f8 0a             	cmp    $0xa,%eax
  81069b:	0f 84 d5 00 00 00    	je     810776 <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
  8106a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106a5:	8b 40 18             	mov    0x18(%rax),%eax
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  8106a8:	83 f8 01             	cmp    $0x1,%eax
  8106ab:	0f 84 c5 00 00 00    	je     810776 <tcp_pcb_purge+0x100>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  8106b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106b5:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8106bc:	48 85 c0             	test   %rax,%rax
  8106bf:	74 29                	je     8106ea <tcp_pcb_purge+0x74>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  8106c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106c5:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8106cc:	48 89 c7             	mov    %rax,%rdi
  8106cf:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8106d6:	00 00 00 
  8106d9:	ff d0                	callq  *%rax
      pcb->refused_data = NULL;
  8106db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106df:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  8106e6:	00 00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  8106ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106ee:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)

    tcp_segs_free(pcb->ooseq);
  8106f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106f8:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  8106ff:	48 89 c7             	mov    %rax,%rdi
  810702:	48 b8 03 01 81 00 00 	movabs $0x810103,%rax
  810709:	00 00 00 
  81070c:	ff d0                	callq  *%rax
    pcb->ooseq = NULL;
  81070e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810712:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  810719:	00 00 00 00 
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  81071d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810721:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  810728:	48 89 c7             	mov    %rax,%rdi
  81072b:	48 b8 03 01 81 00 00 	movabs $0x810103,%rax
  810732:	00 00 00 
  810735:	ff d0                	callq  *%rax
    tcp_segs_free(pcb->unacked);
  810737:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81073b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  810742:	48 89 c7             	mov    %rax,%rdi
  810745:	48 b8 03 01 81 00 00 	movabs $0x810103,%rax
  81074c:	00 00 00 
  81074f:	ff d0                	callq  *%rax
    pcb->unacked = pcb->unsent = NULL;
  810751:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810755:	48 c7 80 80 00 00 00 	movq   $0x0,0x80(%rax)
  81075c:	00 00 00 00 
  810760:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810764:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  81076b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81076f:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  }
}
  810776:	c9                   	leaveq 
  810777:	c3                   	retq   

0000000000810778 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  810778:	55                   	push   %rbp
  810779:	48 89 e5             	mov    %rsp,%rbp
  81077c:	48 83 ec 10          	sub    $0x10,%rsp
  810780:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810784:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  TCP_RMV(pcblist, pcb);
  810788:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81078c:	48 8b 00             	mov    (%rax),%rax
  81078f:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  810793:	75 17                	jne    8107ac <tcp_pcb_remove+0x34>
  810795:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810799:	48 8b 00             	mov    (%rax),%rax
  81079c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8107a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107a4:	48 89 10             	mov    %rdx,(%rax)
  8107a7:	e9 8e 00 00 00       	jmpq   81083a <tcp_pcb_remove+0xc2>
  8107ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107b0:	48 8b 10             	mov    (%rax),%rdx
  8107b3:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  8107ba:	00 00 00 
  8107bd:	48 89 10             	mov    %rdx,(%rax)
  8107c0:	eb 66                	jmp    810828 <tcp_pcb_remove+0xb0>
  8107c2:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  8107c9:	00 00 00 
  8107cc:	48 8b 00             	mov    (%rax),%rax
  8107cf:	48 8b 40 10          	mov    0x10(%rax),%rax
  8107d3:	48 85 c0             	test   %rax,%rax
  8107d6:	74 32                	je     81080a <tcp_pcb_remove+0x92>
  8107d8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  8107df:	00 00 00 
  8107e2:	48 8b 00             	mov    (%rax),%rax
  8107e5:	48 8b 40 10          	mov    0x10(%rax),%rax
  8107e9:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8107ed:	75 1b                	jne    81080a <tcp_pcb_remove+0x92>
  8107ef:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  8107f6:	00 00 00 
  8107f9:	48 8b 00             	mov    (%rax),%rax
  8107fc:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810800:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  810804:	48 89 50 10          	mov    %rdx,0x10(%rax)
  810808:	eb 30                	jmp    81083a <tcp_pcb_remove+0xc2>
  81080a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810811:	00 00 00 
  810814:	48 8b 00             	mov    (%rax),%rax
  810817:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81081b:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810822:	00 00 00 
  810825:	48 89 10             	mov    %rdx,(%rax)
  810828:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81082f:	00 00 00 
  810832:	48 8b 00             	mov    (%rax),%rax
  810835:	48 85 c0             	test   %rax,%rax
  810838:	75 88                	jne    8107c2 <tcp_pcb_remove+0x4a>
  81083a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81083e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  810845:	00 

  tcp_pcb_purge(pcb);
  810846:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81084a:	48 89 c7             	mov    %rax,%rdi
  81084d:	48 b8 76 06 81 00 00 	movabs $0x810676,%rax
  810854:	00 00 00 
  810857:	ff d0                	callq  *%rax
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  810859:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81085d:	8b 40 18             	mov    0x18(%rax),%eax
  810860:	83 f8 0a             	cmp    $0xa,%eax
  810863:	74 45                	je     8108aa <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
  810865:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810869:	8b 40 18             	mov    0x18(%rax),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  81086c:	83 f8 01             	cmp    $0x1,%eax
  81086f:	74 39                	je     8108aa <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  810871:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810875:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810879:	0f b6 c0             	movzbl %al,%eax
  81087c:	83 e0 01             	and    $0x1,%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  81087f:	85 c0                	test   %eax,%eax
  810881:	74 27                	je     8108aa <tcp_pcb_remove+0x132>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  810883:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810887:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81088b:	83 c8 02             	or     $0x2,%eax
  81088e:	89 c2                	mov    %eax,%edx
  810890:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810894:	88 50 2c             	mov    %dl,0x2c(%rax)
    tcp_output(pcb);
  810897:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81089b:	48 89 c7             	mov    %rax,%rdi
  81089e:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  8108a5:	00 00 00 
  8108a8:	ff d0                	callq  *%rax
  }

  if (pcb->state != LISTEN) {
  8108aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8108ae:	8b 40 18             	mov    0x18(%rax),%eax
  8108b1:	83 f8 01             	cmp    $0x1,%eax
  8108b4:	0f 84 ae 00 00 00    	je     810968 <tcp_pcb_remove+0x1f0>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  8108ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8108be:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8108c5:	48 85 c0             	test   %rax,%rax
  8108c8:	74 2a                	je     8108f4 <tcp_pcb_remove+0x17c>
  8108ca:	48 ba 1e 22 82 00 00 	movabs $0x82221e,%rdx
  8108d1:	00 00 00 
  8108d4:	be b4 04 00 00       	mov    $0x4b4,%esi
  8108d9:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  8108e0:	00 00 00 
  8108e3:	b8 00 00 00 00       	mov    $0x0,%eax
  8108e8:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8108ef:	00 00 00 
  8108f2:	ff d1                	callq  *%rcx
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  8108f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8108f8:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8108ff:	48 85 c0             	test   %rax,%rax
  810902:	74 2a                	je     81092e <tcp_pcb_remove+0x1b6>
  810904:	48 ba 36 22 82 00 00 	movabs $0x822236,%rdx
  81090b:	00 00 00 
  81090e:	be b5 04 00 00       	mov    $0x4b5,%esi
  810913:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  81091a:	00 00 00 
  81091d:	b8 00 00 00 00       	mov    $0x0,%eax
  810922:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  810929:	00 00 00 
  81092c:	ff d1                	callq  *%rcx
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  81092e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810932:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  810939:	48 85 c0             	test   %rax,%rax
  81093c:	74 2a                	je     810968 <tcp_pcb_remove+0x1f0>
  81093e:	48 ba 4f 22 82 00 00 	movabs $0x82224f,%rdx
  810945:	00 00 00 
  810948:	be b7 04 00 00       	mov    $0x4b7,%esi
  81094d:	48 bf 3b 20 82 00 00 	movabs $0x82203b,%rdi
  810954:	00 00 00 
  810957:	b8 00 00 00 00       	mov    $0x0,%eax
  81095c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  810963:	00 00 00 
  810966:	ff d1                	callq  *%rcx
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  810968:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81096c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  810973:	c9                   	leaveq 
  810974:	c3                   	retq   

0000000000810975 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  810975:	55                   	push   %rbp
  810976:	48 89 e5             	mov    %rsp,%rbp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  810979:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810980:	00 00 00 
  810983:	8b 10                	mov    (%rax),%edx
  810985:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81098c:	00 00 00 
  81098f:	8b 00                	mov    (%rax),%eax
  810991:	01 c2                	add    %eax,%edx
  810993:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  81099a:	00 00 00 
  81099d:	89 10                	mov    %edx,(%rax)
  return iss;
  81099f:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  8109a6:	00 00 00 
  8109a9:	8b 00                	mov    (%rax),%eax
}
  8109ab:	5d                   	pop    %rbp
  8109ac:	c3                   	retq   

00000000008109ad <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  8109ad:	55                   	push   %rbp
  8109ae:	48 89 e5             	mov    %rsp,%rbp
  8109b1:	48 83 ec 20          	sub    $0x20,%rsp
  8109b5:	89 f8                	mov    %edi,%eax
  8109b7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8109bb:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  8109bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8109c3:	48 89 c7             	mov    %rax,%rdi
  8109c6:	48 b8 ad 0a 81 00 00 	movabs $0x810aad,%rax
  8109cd:	00 00 00 
  8109d0:	ff d0                	callq  *%rax
  8109d2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((outif != NULL) && (outif->mtu != 0)) {
  8109d6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8109db:	74 2d                	je     810a0a <tcp_eff_send_mss+0x5d>
  8109dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109e1:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8109e5:	66 85 c0             	test   %ax,%ax
  8109e8:	74 20                	je     810a0a <tcp_eff_send_mss+0x5d>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  8109ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109ee:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8109f2:	83 e8 28             	sub    $0x28,%eax
  8109f5:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  8109f9:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8109fd:	66 39 45 f6          	cmp    %ax,-0xa(%rbp)
  810a01:	66 0f 46 45 f6       	cmovbe -0xa(%rbp),%ax
  810a06:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  }
  return sendmss;
  810a0a:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
}
  810a0e:	c9                   	leaveq 
  810a0f:	c3                   	retq   

0000000000810a10 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  810a10:	55                   	push   %rbp
  810a11:	48 89 e5             	mov    %rsp,%rbp
  810a14:	48 83 ec 20          	sub    $0x20,%rsp
  810a18:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  810a1c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u32_t addr2test;

  addr2test = addr->addr;
  810a20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810a24:	8b 00                	mov    (%rax),%eax
  810a26:	89 45 fc             	mov    %eax,-0x4(%rbp)
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  810a29:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  810a2d:	74 06                	je     810a35 <ip_addr_isbroadcast+0x25>
  810a2f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  810a33:	75 07                	jne    810a3c <ip_addr_isbroadcast+0x2c>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  810a35:	b8 01 00 00 00       	mov    $0x1,%eax
  810a3a:	eb 6f                	jmp    810aab <ip_addr_isbroadcast+0x9b>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  810a3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810a40:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  810a44:	0f b6 c0             	movzbl %al,%eax
  810a47:	83 e0 02             	and    $0x2,%eax
  810a4a:	85 c0                	test   %eax,%eax
  810a4c:	75 07                	jne    810a55 <ip_addr_isbroadcast+0x45>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  810a4e:	b8 00 00 00 00       	mov    $0x0,%eax
  810a53:	eb 56                	jmp    810aab <ip_addr_isbroadcast+0x9b>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  810a55:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810a59:	8b 40 08             	mov    0x8(%rax),%eax
  810a5c:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  810a5f:	75 07                	jne    810a68 <ip_addr_isbroadcast+0x58>
    return 0;
  810a61:	b8 00 00 00 00       	mov    $0x0,%eax
  810a66:	eb 43                	jmp    810aab <ip_addr_isbroadcast+0x9b>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  810a68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810a6c:	8b 10                	mov    (%rax),%edx
  810a6e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810a72:	8b 40 08             	mov    0x8(%rax),%eax
  810a75:	31 c2                	xor    %eax,%edx
  810a77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810a7b:	8b 40 0c             	mov    0xc(%rax),%eax
  810a7e:	21 d0                	and    %edx,%eax
  810a80:	85 c0                	test   %eax,%eax
  810a82:	75 22                	jne    810aa6 <ip_addr_isbroadcast+0x96>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  810a84:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810a88:	8b 40 0c             	mov    0xc(%rax),%eax
  810a8b:	f7 d0                	not    %eax
  810a8d:	23 45 fc             	and    -0x4(%rbp),%eax
  810a90:	89 c2                	mov    %eax,%edx
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
  810a92:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810a96:	8b 40 0c             	mov    0xc(%rax),%eax
  810a99:	f7 d0                	not    %eax
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  810a9b:	39 c2                	cmp    %eax,%edx
  810a9d:	75 07                	jne    810aa6 <ip_addr_isbroadcast+0x96>
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  810a9f:	b8 01 00 00 00       	mov    $0x1,%eax
  810aa4:	eb 05                	jmp    810aab <ip_addr_isbroadcast+0x9b>
  else
    return 0;
  810aa6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810aab:	c9                   	leaveq 
  810aac:	c3                   	retq   

0000000000810aad <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  810aad:	55                   	push   %rbp
  810aae:	48 89 e5             	mov    %rsp,%rbp
  810ab1:	48 83 ec 20          	sub    $0x20,%rsp
  810ab5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810ab9:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  810ac0:	00 00 00 
  810ac3:	48 8b 00             	mov    (%rax),%rax
  810ac6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810aca:	eb 44                	jmp    810b10 <ip_route+0x63>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  810acc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ad0:	48 89 c7             	mov    %rax,%rdi
  810ad3:	48 b8 0f d1 80 00 00 	movabs $0x80d10f,%rax
  810ada:	00 00 00 
  810add:	ff d0                	callq  *%rax
  810adf:	84 c0                	test   %al,%al
  810ae1:	74 22                	je     810b05 <ip_route+0x58>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  810ae3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ae7:	8b 10                	mov    (%rax),%edx
  810ae9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810aed:	8b 40 08             	mov    0x8(%rax),%eax
  810af0:	31 c2                	xor    %eax,%edx
  810af2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810af6:	8b 40 0c             	mov    0xc(%rax),%eax
  810af9:	21 d0                	and    %edx,%eax
  810afb:	85 c0                	test   %eax,%eax
  810afd:	75 06                	jne    810b05 <ip_route+0x58>
        /* return netif on which to forward IP packet */
        return netif;
  810aff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810b03:	eb 58                	jmp    810b5d <ip_route+0xb0>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810b05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810b09:	48 8b 00             	mov    (%rax),%rax
  810b0c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810b10:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810b15:	75 b5                	jne    810acc <ip_route+0x1f>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  810b17:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810b1e:	00 00 00 
  810b21:	48 8b 00             	mov    (%rax),%rax
  810b24:	48 85 c0             	test   %rax,%rax
  810b27:	74 20                	je     810b49 <ip_route+0x9c>
  810b29:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810b30:	00 00 00 
  810b33:	48 8b 00             	mov    (%rax),%rax
  810b36:	48 89 c7             	mov    %rax,%rdi
  810b39:	48 b8 0f d1 80 00 00 	movabs $0x80d10f,%rax
  810b40:	00 00 00 
  810b43:	ff d0                	callq  *%rax
  810b45:	84 c0                	test   %al,%al
  810b47:	75 07                	jne    810b50 <ip_route+0xa3>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  810b49:	b8 00 00 00 00       	mov    $0x0,%eax
  810b4e:	eb 0d                	jmp    810b5d <ip_route+0xb0>
  }
  /* no matching netif found, use default netif */
  return netif_default;
  810b50:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810b57:	00 00 00 
  810b5a:	48 8b 00             	mov    (%rax),%rax
}
  810b5d:	c9                   	leaveq 
  810b5e:	c3                   	retq   

0000000000810b5f <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  810b5f:	55                   	push   %rbp
  810b60:	48 89 e5             	mov    %rsp,%rbp
  810b63:	53                   	push   %rbx
  810b64:	48 83 ec 38          	sub    $0x38,%rsp
  810b68:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  810b6c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
  810b70:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  810b77:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810b7b:	48 8b 40 08          	mov    0x8(%rax),%rax
  810b7f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (IPH_V(iphdr) != 4) {
  810b83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810b87:	0f b7 00             	movzwl (%rax),%eax
  810b8a:	0f b7 c0             	movzwl %ax,%eax
  810b8d:	89 c7                	mov    %eax,%edi
  810b8f:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  810b96:	00 00 00 
  810b99:	ff d0                	callq  *%rax
  810b9b:	66 c1 e8 0c          	shr    $0xc,%ax
  810b9f:	66 83 f8 04          	cmp    $0x4,%ax
  810ba3:	74 1d                	je     810bc2 <ip_input+0x63>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  810ba5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810ba9:	48 89 c7             	mov    %rax,%rdi
  810bac:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  810bb3:	00 00 00 
  810bb6:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  810bb8:	b8 00 00 00 00       	mov    $0x0,%eax
  810bbd:	e9 19 04 00 00       	jmpq   810fdb <ip_input+0x47c>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  810bc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810bc6:	0f b7 00             	movzwl (%rax),%eax
  810bc9:	0f b7 c0             	movzwl %ax,%eax
  810bcc:	89 c7                	mov    %eax,%edi
  810bce:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  810bd5:	00 00 00 
  810bd8:	ff d0                	callq  *%rax
  810bda:	66 c1 e8 08          	shr    $0x8,%ax
  810bde:	83 e0 0f             	and    $0xf,%eax
  810be1:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  810be5:	66 c1 65 d6 02       	shlw   $0x2,-0x2a(%rbp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  810bea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810bee:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810bf2:	0f b7 c0             	movzwl %ax,%eax
  810bf5:	89 c7                	mov    %eax,%edi
  810bf7:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  810bfe:	00 00 00 
  810c01:	ff d0                	callq  *%rax
  810c03:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  810c07:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810c0b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  810c0f:	66 3b 45 d6          	cmp    -0x2a(%rbp),%ax
  810c13:	72 0e                	jb     810c23 <ip_input+0xc4>
  810c15:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810c19:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  810c1d:	66 3b 45 d4          	cmp    -0x2c(%rbp),%ax
  810c21:	73 1d                	jae    810c40 <ip_input+0xe1>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  810c23:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810c27:	48 89 c7             	mov    %rax,%rdi
  810c2a:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  810c31:	00 00 00 
  810c34:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  810c36:	b8 00 00 00 00       	mov    $0x0,%eax
  810c3b:	e9 9b 03 00 00       	jmpq   810fdb <ip_input+0x47c>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  810c40:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  810c44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810c48:	89 d6                	mov    %edx,%esi
  810c4a:	48 89 c7             	mov    %rax,%rdi
  810c4d:	48 b8 d0 27 81 00 00 	movabs $0x8127d0,%rax
  810c54:	00 00 00 
  810c57:	ff d0                	callq  *%rax
  810c59:	66 85 c0             	test   %ax,%ax
  810c5c:	74 1d                	je     810c7b <ip_input+0x11c>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  810c5e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810c62:	48 89 c7             	mov    %rax,%rdi
  810c65:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  810c6c:	00 00 00 
  810c6f:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  810c71:	b8 00 00 00 00       	mov    $0x0,%eax
  810c76:	e9 60 03 00 00       	jmpq   810fdb <ip_input+0x47c>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  810c7b:	0f b7 55 d4          	movzwl -0x2c(%rbp),%edx
  810c7f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810c83:	89 d6                	mov    %edx,%esi
  810c85:	48 89 c7             	mov    %rax,%rdi
  810c88:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  810c8f:	00 00 00 
  810c92:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  810c94:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    netif = inp;
  810c9b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810c9f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  810ca3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810ca7:	48 89 c7             	mov    %rax,%rdi
  810caa:	48 b8 0f d1 80 00 00 	movabs $0x80d10f,%rax
  810cb1:	00 00 00 
  810cb4:	ff d0                	callq  *%rax
  810cb6:	84 c0                	test   %al,%al
  810cb8:	74 4e                	je     810d08 <ip_input+0x1a9>
  810cba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810cbe:	48 83 c0 08          	add    $0x8,%rax
  810cc2:	48 85 c0             	test   %rax,%rax
  810cc5:	74 41                	je     810d08 <ip_input+0x1a9>
  810cc7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810ccb:	8b 40 08             	mov    0x8(%rax),%eax
  810cce:	85 c0                	test   %eax,%eax
  810cd0:	74 36                	je     810d08 <ip_input+0x1a9>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  810cd2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810cd6:	8b 50 10             	mov    0x10(%rax),%edx
  810cd9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810cdd:	8b 40 08             	mov    0x8(%rax),%eax
  810ce0:	39 c2                	cmp    %eax,%edx
  810ce2:	74 22                	je     810d06 <ip_input+0x1a7>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  810ce4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ce8:	48 8d 50 10          	lea    0x10(%rax),%rdx
  810cec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810cf0:	48 89 c6             	mov    %rax,%rsi
  810cf3:	48 89 d7             	mov    %rdx,%rdi
  810cf6:	48 b8 10 0a 81 00 00 	movabs $0x810a10,%rax
  810cfd:	00 00 00 
  810d00:	ff d0                	callq  *%rax
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  810d02:	84 c0                	test   %al,%al
  810d04:	74 02                	je     810d08 <ip_input+0x1a9>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
          LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
  810d06:	eb 4b                	jmp    810d53 <ip_input+0x1f4>
        }
      }
      if (first) {
  810d08:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  810d0c:	74 1a                	je     810d28 <ip_input+0x1c9>
        first = 0;
  810d0e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        netif = netif_list;
  810d15:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  810d1c:	00 00 00 
  810d1f:	48 8b 00             	mov    (%rax),%rax
  810d22:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  810d26:	eb 0b                	jmp    810d33 <ip_input+0x1d4>
      } else {
        netif = netif->next;
  810d28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810d2c:	48 8b 00             	mov    (%rax),%rax
  810d2f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
      if (netif == inp) {
  810d33:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810d37:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  810d3b:	75 0b                	jne    810d48 <ip_input+0x1e9>
        netif = netif->next;
  810d3d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810d41:	48 8b 00             	mov    (%rax),%rax
  810d44:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
    } while(netif != NULL);
  810d48:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810d4d:	0f 85 50 ff ff ff    	jne    810ca3 <ip_input+0x144>
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  810d53:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810d58:	75 59                	jne    810db3 <ip_input+0x254>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  810d5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810d5e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810d62:	0f b7 c0             	movzwl %ax,%eax
  810d65:	89 c7                	mov    %eax,%edi
  810d67:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  810d6e:	00 00 00 
  810d71:	ff d0                	callq  *%rax
  810d73:	0f b7 c0             	movzwl %ax,%eax
  810d76:	0f b6 c0             	movzbl %al,%eax
  810d79:	83 f8 11             	cmp    $0x11,%eax
  810d7c:	75 35                	jne    810db3 <ip_input+0x254>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  810d7e:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  810d82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810d86:	48 01 d0             	add    %rdx,%rax
  810d89:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810d8d:	0f b7 c0             	movzwl %ax,%eax
  810d90:	89 c7                	mov    %eax,%edi
  810d92:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  810d99:	00 00 00 
  810d9c:	ff d0                	callq  *%rax
  810d9e:	66 83 f8 44          	cmp    $0x44,%ax
  810da2:	75 0f                	jne    810db3 <ip_input+0x254>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  810da4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810da8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        check_ip_src = 0;
  810dac:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
  }
#endif /* LWIP_DHCP */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
  810db3:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  810db7:	74 6e                	je     810e27 <ip_input+0x2c8>
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  810db9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810dbd:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  810dc1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810dc5:	48 89 c6             	mov    %rax,%rsi
  810dc8:	48 89 d7             	mov    %rdx,%rdi
  810dcb:	48 b8 10 0a 81 00 00 	movabs $0x810a10,%rax
  810dd2:	00 00 00 
  810dd5:	ff d0                	callq  *%rax
  810dd7:	84 c0                	test   %al,%al
  810dd9:	75 2f                	jne    810e0a <ip_input+0x2ab>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  810ddb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ddf:	8b 58 0c             	mov    0xc(%rax),%ebx
  810de2:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  810de7:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  810dee:	00 00 00 
  810df1:	ff d0                	callq  *%rax
  810df3:	21 c3                	and    %eax,%ebx
  810df5:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  810dfa:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  810e01:	00 00 00 
  810e04:	ff d0                	callq  *%rax

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  810e06:	39 c3                	cmp    %eax,%ebx
  810e08:	75 1d                	jne    810e27 <ip_input+0x2c8>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  810e0a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e0e:	48 89 c7             	mov    %rax,%rdi
  810e11:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  810e18:	00 00 00 
  810e1b:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  810e1d:	b8 00 00 00 00       	mov    $0x0,%eax
  810e22:	e9 b4 01 00 00       	jmpq   810fdb <ip_input+0x47c>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  810e27:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810e2c:	75 1d                	jne    810e4b <ip_input+0x2ec>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  810e2e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e32:	48 89 c7             	mov    %rax,%rdi
  810e35:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  810e3c:	00 00 00 
  810e3f:	ff d0                	callq  *%rax
    return ERR_OK;
  810e41:	b8 00 00 00 00       	mov    $0x0,%eax
  810e46:	e9 90 01 00 00       	jmpq   810fdb <ip_input+0x47c>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  810e4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810e4f:	0f b7 58 06          	movzwl 0x6(%rax),%ebx
  810e53:	bf ff 3f 00 00       	mov    $0x3fff,%edi
  810e58:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  810e5f:	00 00 00 
  810e62:	ff d0                	callq  *%rax
  810e64:	21 d8                	and    %ebx,%eax
  810e66:	66 85 c0             	test   %ax,%ax
  810e69:	74 34                	je     810e9f <ip_input+0x340>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  810e6b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e6f:	48 89 c7             	mov    %rax,%rdi
  810e72:	48 b8 b8 1c 81 00 00 	movabs $0x811cb8,%rax
  810e79:	00 00 00 
  810e7c:	ff d0                	callq  *%rax
  810e7e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  810e82:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  810e87:	75 0a                	jne    810e93 <ip_input+0x334>
      return ERR_OK;
  810e89:	b8 00 00 00 00       	mov    $0x0,%eax
  810e8e:	e9 48 01 00 00       	jmpq   810fdb <ip_input+0x47c>
    }
    iphdr = p->payload;
  810e93:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e97:	48 8b 40 08          	mov    0x8(%rax),%rax
  810e9b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  810e9f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  810ea3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810ea7:	48 89 d6             	mov    %rdx,%rsi
  810eaa:	48 89 c7             	mov    %rax,%rdi
  810ead:	48 b8 03 fa 81 00 00 	movabs $0x81fa03,%rax
  810eb4:	00 00 00 
  810eb7:	ff d0                	callq  *%rax
  810eb9:	84 c0                	test   %al,%al
  810ebb:	0f 85 15 01 00 00    	jne    810fd6 <ip_input+0x477>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  810ec1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ec5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810ec9:	0f b7 c0             	movzwl %ax,%eax
  810ecc:	89 c7                	mov    %eax,%edi
  810ece:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  810ed5:	00 00 00 
  810ed8:	ff d0                	callq  *%rax
  810eda:	0f b7 c0             	movzwl %ax,%eax
  810edd:	0f b6 c0             	movzbl %al,%eax
  810ee0:	83 f8 06             	cmp    $0x6,%eax
  810ee3:	74 2b                	je     810f10 <ip_input+0x3b1>
  810ee5:	83 f8 11             	cmp    $0x11,%eax
  810ee8:	74 07                	je     810ef1 <ip_input+0x392>
  810eea:	83 f8 01             	cmp    $0x1,%eax
  810eed:	74 40                	je     810f2f <ip_input+0x3d0>
  810eef:	eb 5d                	jmp    810f4e <ip_input+0x3ef>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  810ef1:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  810ef5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810ef9:	48 89 d6             	mov    %rdx,%rsi
  810efc:	48 89 c7             	mov    %rax,%rdi
  810eff:	48 b8 4b 4a 81 00 00 	movabs $0x814a4b,%rax
  810f06:	00 00 00 
  810f09:	ff d0                	callq  *%rax
      break;
  810f0b:	e9 c6 00 00 00       	jmpq   810fd6 <ip_input+0x477>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  810f10:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  810f14:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f18:	48 89 d6             	mov    %rdx,%rsi
  810f1b:	48 89 c7             	mov    %rax,%rdi
  810f1e:	48 b8 e8 c0 81 00 00 	movabs $0x81c0e8,%rax
  810f25:	00 00 00 
  810f28:	ff d0                	callq  *%rax
      break;
  810f2a:	e9 a7 00 00 00       	jmpq   810fd6 <ip_input+0x477>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  810f2f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  810f33:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f37:	48 89 d6             	mov    %rdx,%rsi
  810f3a:	48 89 c7             	mov    %rax,%rdi
  810f3d:	48 b8 b4 fe 81 00 00 	movabs $0x81feb4,%rax
  810f44:	00 00 00 
  810f47:	ff d0                	callq  *%rax
      break;
  810f49:	e9 88 00 00 00       	jmpq   810fd6 <ip_input+0x477>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  810f4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810f52:	48 8d 50 10          	lea    0x10(%rax),%rdx
  810f56:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810f5a:	48 89 c6             	mov    %rax,%rsi
  810f5d:	48 89 d7             	mov    %rdx,%rdi
  810f60:	48 b8 10 0a 81 00 00 	movabs $0x810a10,%rax
  810f67:	00 00 00 
  810f6a:	ff d0                	callq  *%rax
  810f6c:	84 c0                	test   %al,%al
  810f6e:	75 53                	jne    810fc3 <ip_input+0x464>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  810f70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810f74:	8b 58 10             	mov    0x10(%rax),%ebx
  810f77:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  810f7c:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  810f83:	00 00 00 
  810f86:	ff d0                	callq  *%rax
  810f88:	21 c3                	and    %eax,%ebx
  810f8a:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  810f8f:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  810f96:	00 00 00 
  810f99:	ff d0                	callq  *%rax
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  810f9b:	39 c3                	cmp    %eax,%ebx
  810f9d:	74 24                	je     810fc3 <ip_input+0x464>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  810f9f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810fa3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810fa7:	48 89 50 08          	mov    %rdx,0x8(%rax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  810fab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810faf:	be 02 00 00 00       	mov    $0x2,%esi
  810fb4:	48 89 c7             	mov    %rax,%rdi
  810fb7:	48 b8 d7 03 82 00 00 	movabs $0x8203d7,%rax
  810fbe:	00 00 00 
  810fc1:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  810fc3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810fc7:	48 89 c7             	mov    %rax,%rdi
  810fca:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  810fd1:	00 00 00 
  810fd4:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
  810fd6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810fdb:	48 83 c4 38          	add    $0x38,%rsp
  810fdf:	5b                   	pop    %rbx
  810fe0:	5d                   	pop    %rbp
  810fe1:	c3                   	retq   

0000000000810fe2 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  810fe2:	55                   	push   %rbp
  810fe3:	48 89 e5             	mov    %rsp,%rbp
  810fe6:	53                   	push   %rbx
  810fe7:	48 83 ec 48          	sub    $0x48,%rsp
  810feb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  810fef:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  810ff3:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  810ff7:	89 c8                	mov    %ecx,%eax
  810ff9:	44 89 c1             	mov    %r8d,%ecx
  810ffc:	44 89 ca             	mov    %r9d,%edx
  810fff:	88 45 c4             	mov    %al,-0x3c(%rbp)
  811002:	88 4d c0             	mov    %cl,-0x40(%rbp)
  811005:	88 55 bc             	mov    %dl,-0x44(%rbp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  811008:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81100d:	0f 84 0e 02 00 00    	je     811221 <ip_output_if+0x23f>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  811013:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811017:	be 14 00 00 00       	mov    $0x14,%esi
  81101c:	48 89 c7             	mov    %rax,%rdi
  81101f:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  811026:	00 00 00 
  811029:	ff d0                	callq  *%rax
  81102b:	84 c0                	test   %al,%al
  81102d:	74 0a                	je     811039 <ip_output_if+0x57>
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  81102f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  811034:	e9 58 02 00 00       	jmpq   811291 <ip_output_if+0x2af>
    }

    iphdr = p->payload;
  811039:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81103d:	48 8b 40 08          	mov    0x8(%rax),%rax
  811041:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  811045:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811049:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81104d:	66 83 f8 13          	cmp    $0x13,%ax
  811051:	77 2a                	ja     81107d <ip_output_if+0x9b>
  811053:	48 ba 70 22 82 00 00 	movabs $0x822270,%rdx
  81105a:	00 00 00 
  81105d:	be ee 01 00 00       	mov    $0x1ee,%esi
  811062:	48 bf 9d 22 82 00 00 	movabs $0x82229d,%rdi
  811069:	00 00 00 
  81106c:	b8 00 00 00 00       	mov    $0x0,%eax
  811071:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  811078:	00 00 00 
  81107b:	ff d1                	callq  *%rcx
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  81107d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811081:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811085:	0f b7 c0             	movzwl %ax,%eax
  811088:	89 c7                	mov    %eax,%edi
  81108a:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  811091:	00 00 00 
  811094:	ff d0                	callq  *%rax
  811096:	0f b6 d0             	movzbl %al,%edx
  811099:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  81109d:	c1 e0 08             	shl    $0x8,%eax
  8110a0:	09 d0                	or     %edx,%eax
  8110a2:	0f b7 c0             	movzwl %ax,%eax
  8110a5:	89 c7                	mov    %eax,%edi
  8110a7:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8110ae:	00 00 00 
  8110b1:	ff d0                	callq  *%rax
  8110b3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8110b7:	66 89 42 08          	mov    %ax,0x8(%rdx)
    IPH_PROTO_SET(iphdr, proto);
  8110bb:	0f b6 5d bc          	movzbl -0x44(%rbp),%ebx
  8110bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8110c3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8110c7:	0f b7 c0             	movzwl %ax,%eax
  8110ca:	89 c7                	mov    %eax,%edi
  8110cc:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8110d3:	00 00 00 
  8110d6:	ff d0                	callq  *%rax
  8110d8:	66 c1 e8 08          	shr    $0x8,%ax
  8110dc:	0f b7 c0             	movzwl %ax,%eax
  8110df:	c1 e0 08             	shl    $0x8,%eax
  8110e2:	09 d8                	or     %ebx,%eax
  8110e4:	0f b7 c0             	movzwl %ax,%eax
  8110e7:	89 c7                	mov    %eax,%edi
  8110e9:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8110f0:	00 00 00 
  8110f3:	ff d0                	callq  *%rax
  8110f5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8110f9:	66 89 42 08          	mov    %ax,0x8(%rdx)

    ip_addr_set(&(iphdr->dest), dest);
  8110fd:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  811102:	74 08                	je     81110c <ip_output_if+0x12a>
  811104:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811108:	8b 00                	mov    (%rax),%eax
  81110a:	eb 05                	jmp    811111 <ip_output_if+0x12f>
  81110c:	b8 00 00 00 00       	mov    $0x0,%eax
  811111:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811115:	89 42 10             	mov    %eax,0x10(%rdx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  811118:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
  81111c:	80 cc 45             	or     $0x45,%ah
  81111f:	0f b7 c0             	movzwl %ax,%eax
  811122:	89 c7                	mov    %eax,%edi
  811124:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  81112b:	00 00 00 
  81112e:	ff d0                	callq  *%rax
  811130:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811134:	66 89 02             	mov    %ax,(%rdx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  811137:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81113b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81113f:	0f b7 c0             	movzwl %ax,%eax
  811142:	89 c7                	mov    %eax,%edi
  811144:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  81114b:	00 00 00 
  81114e:	ff d0                	callq  *%rax
  811150:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811154:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_OFFSET_SET(iphdr, 0);
  811158:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81115c:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_ID_SET(iphdr, htons(ip_id));
  811162:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  811169:	00 00 00 
  81116c:	0f b7 00             	movzwl (%rax),%eax
  81116f:	0f b7 c0             	movzwl %ax,%eax
  811172:	89 c7                	mov    %eax,%edi
  811174:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  81117b:	00 00 00 
  81117e:	ff d0                	callq  *%rax
  811180:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811184:	66 89 42 04          	mov    %ax,0x4(%rdx)
    ++ip_id;
  811188:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  81118f:	00 00 00 
  811192:	0f b7 00             	movzwl (%rax),%eax
  811195:	8d 50 01             	lea    0x1(%rax),%edx
  811198:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  81119f:	00 00 00 
  8111a2:	66 89 10             	mov    %dx,(%rax)

    if (ip_addr_isany(src)) {
  8111a5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8111aa:	74 0a                	je     8111b6 <ip_output_if+0x1d4>
  8111ac:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8111b0:	8b 00                	mov    (%rax),%eax
  8111b2:	85 c0                	test   %eax,%eax
  8111b4:	75 24                	jne    8111da <ip_output_if+0x1f8>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  8111b6:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8111ba:	48 83 c0 08          	add    $0x8,%rax
  8111be:	48 85 c0             	test   %rax,%rax
  8111c1:	74 09                	je     8111cc <ip_output_if+0x1ea>
  8111c3:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8111c7:	8b 40 08             	mov    0x8(%rax),%eax
  8111ca:	eb 05                	jmp    8111d1 <ip_output_if+0x1ef>
  8111cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8111d1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8111d5:	89 42 0c             	mov    %eax,0xc(%rdx)
  8111d8:	eb 1b                	jmp    8111f5 <ip_output_if+0x213>
    } else {
      ip_addr_set(&(iphdr->src), src);
  8111da:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8111df:	74 08                	je     8111e9 <ip_output_if+0x207>
  8111e1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8111e5:	8b 00                	mov    (%rax),%eax
  8111e7:	eb 05                	jmp    8111ee <ip_output_if+0x20c>
  8111e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8111ee:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8111f2:	89 42 0c             	mov    %eax,0xc(%rdx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  8111f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8111f9:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8111ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811203:	be 14 00 00 00       	mov    $0x14,%esi
  811208:	48 89 c7             	mov    %rax,%rdi
  81120b:	48 b8 d0 27 81 00 00 	movabs $0x8127d0,%rax
  811212:	00 00 00 
  811215:	ff d0                	callq  *%rax
  811217:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81121b:	66 89 42 0a          	mov    %ax,0xa(%rdx)
  81121f:	eb 18                	jmp    811239 <ip_output_if+0x257>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
  811221:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811225:	48 8b 40 08          	mov    0x8(%rax),%rax
  811229:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    dest = &(iphdr->dest);
  81122d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811231:	48 83 c0 10          	add    $0x10,%rax
  811235:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  811239:	48 8b 45 10          	mov    0x10(%rbp),%rax
  81123d:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  811241:	66 85 c0             	test   %ax,%ax
  811244:	74 32                	je     811278 <ip_output_if+0x296>
  811246:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81124a:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81124e:	48 8b 45 10          	mov    0x10(%rbp),%rax
  811252:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  811256:	66 39 c2             	cmp    %ax,%dx
  811259:	76 1d                	jbe    811278 <ip_output_if+0x296>
    return ip_frag(p,netif,dest);
  81125b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81125f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811263:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  811267:	48 89 c7             	mov    %rax,%rdi
  81126a:	48 b8 fe 20 81 00 00 	movabs $0x8120fe,%rax
  811271:	00 00 00 
  811274:	ff d0                	callq  *%rax
  811276:	eb 19                	jmp    811291 <ip_output_if+0x2af>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  811278:	48 8b 45 10          	mov    0x10(%rbp),%rax
  81127c:	48 8b 40 20          	mov    0x20(%rax),%rax
  811280:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  811284:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  811288:	48 89 ce             	mov    %rcx,%rsi
  81128b:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  81128f:	ff d0                	callq  *%rax
  }
}
  811291:	48 83 c4 48          	add    $0x48,%rsp
  811295:	5b                   	pop    %rbx
  811296:	5d                   	pop    %rbp
  811297:	c3                   	retq   

0000000000811298 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  811298:	55                   	push   %rbp
  811299:	48 89 e5             	mov    %rsp,%rbp
  81129c:	48 83 ec 40          	sub    $0x40,%rsp
  8112a0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8112a4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8112a8:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8112ac:	89 c8                	mov    %ecx,%eax
  8112ae:	44 89 c1             	mov    %r8d,%ecx
  8112b1:	44 89 ca             	mov    %r9d,%edx
  8112b4:	88 45 d4             	mov    %al,-0x2c(%rbp)
  8112b7:	88 4d d0             	mov    %cl,-0x30(%rbp)
  8112ba:	88 55 cc             	mov    %dl,-0x34(%rbp)
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  8112bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8112c1:	48 89 c7             	mov    %rax,%rdi
  8112c4:	48 b8 ad 0a 81 00 00 	movabs $0x810aad,%rax
  8112cb:	00 00 00 
  8112ce:	ff d0                	callq  *%rax
  8112d0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8112d4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8112d9:	75 07                	jne    8112e2 <ip_output+0x4a>
    return ERR_RTE;
  8112db:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8112e0:	eb 31                	jmp    811313 <ip_output+0x7b>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  8112e2:	44 0f b6 4d cc       	movzbl -0x34(%rbp),%r9d
  8112e7:	44 0f b6 45 d0       	movzbl -0x30(%rbp),%r8d
  8112ec:	0f b6 4d d4          	movzbl -0x2c(%rbp),%ecx
  8112f0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8112f4:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8112f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8112fc:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  811300:	48 89 3c 24          	mov    %rdi,(%rsp)
  811304:	48 89 c7             	mov    %rax,%rdi
  811307:	48 b8 e2 0f 81 00 00 	movabs $0x810fe2,%rax
  81130e:	00 00 00 
  811311:	ff d0                	callq  *%rax
}
  811313:	c9                   	leaveq 
  811314:	c3                   	retq   

0000000000811315 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  811315:	55                   	push   %rbp
  811316:	48 89 e5             	mov    %rsp,%rbp
  811319:	48 83 ec 20          	sub    $0x20,%rsp
  struct ip_reassdata *r, *prev = NULL;
  81131d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  811324:	00 

  r = reassdatagrams;
  811325:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  81132c:	00 00 00 
  81132f:	48 8b 00             	mov    (%rax),%rax
  811332:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (r != NULL) {
  811336:	eb 60                	jmp    811398 <ip_reass_tmr+0x83>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  811338:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81133c:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  811340:	84 c0                	test   %al,%al
  811342:	74 27                	je     81136b <ip_reass_tmr+0x56>
      r->timer--;
  811344:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811348:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  81134c:	8d 50 ff             	lea    -0x1(%rax),%edx
  81134f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811353:	88 50 27             	mov    %dl,0x27(%rax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  811356:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81135a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      r = r->next;
  81135e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811362:	48 8b 00             	mov    (%rax),%rax
  811365:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  811369:	eb 2d                	jmp    811398 <ip_reass_tmr+0x83>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
  81136b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81136f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* get the next pointer before freeing */
      r = r->next;
  811373:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811377:	48 8b 00             	mov    (%rax),%rax
  81137a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  81137e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  811382:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811386:	48 89 d6             	mov    %rdx,%rsi
  811389:	48 89 c7             	mov    %rax,%rdi
  81138c:	48 b8 a1 13 81 00 00 	movabs $0x8113a1,%rax
  811393:	00 00 00 
  811396:	ff d0                	callq  *%rax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  811398:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81139d:	75 99                	jne    811338 <ip_reass_tmr+0x23>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  81139f:	c9                   	leaveq 
  8113a0:	c3                   	retq   

00000000008113a1 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  8113a1:	55                   	push   %rbp
  8113a2:	48 89 e5             	mov    %rsp,%rbp
  8113a5:	48 83 ec 30          	sub    $0x30,%rsp
  8113a9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8113ad:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  int pbufs_freed = 0;
  8113b1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  8113b8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8113bc:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8113c0:	75 2a                	jne    8113ec <ip_reass_free_complete_datagram+0x4b>
  8113c2:	48 ba b8 22 82 00 00 	movabs $0x8222b8,%rdx
  8113c9:	00 00 00 
  8113cc:	be 99 00 00 00       	mov    $0x99,%esi
  8113d1:	48 bf c4 22 82 00 00 	movabs $0x8222c4,%rdi
  8113d8:	00 00 00 
  8113db:	b8 00 00 00 00       	mov    $0x0,%eax
  8113e0:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8113e7:	00 00 00 
  8113ea:	ff d1                	callq  *%rcx
  if (prev != NULL) {
  8113ec:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8113f1:	74 37                	je     81142a <ip_reass_free_complete_datagram+0x89>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  8113f3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8113f7:	48 8b 00             	mov    (%rax),%rax
  8113fa:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8113fe:	74 2a                	je     81142a <ip_reass_free_complete_datagram+0x89>
  811400:	48 ba e1 22 82 00 00 	movabs $0x8222e1,%rdx
  811407:	00 00 00 
  81140a:	be 9b 00 00 00       	mov    $0x9b,%esi
  81140f:	48 bf c4 22 82 00 00 	movabs $0x8222c4,%rdi
  811416:	00 00 00 
  811419:	b8 00 00 00 00       	mov    $0x0,%eax
  81141e:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  811425:	00 00 00 
  811428:	ff d1                	callq  *%rcx
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  81142a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81142e:	48 8b 40 08          	mov    0x8(%rax),%rax
  811432:	48 8b 40 08          	mov    0x8(%rax),%rax
  811436:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (iprh->start == 0) {
  81143a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81143e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811442:	66 85 c0             	test   %ax,%ax
  811445:	0f 85 86 00 00 00    	jne    8114d1 <ip_reass_free_complete_datagram+0x130>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
  81144b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81144f:	48 8b 40 08          	mov    0x8(%rax),%rax
  811453:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    ipr->p = iprh->next_pbuf;
  811457:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81145b:	48 8b 10             	mov    (%rax),%rdx
  81145e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811462:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  811466:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81146a:	48 8d 48 10          	lea    0x10(%rax),%rcx
  81146e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811472:	48 8b 40 08          	mov    0x8(%rax),%rax
  811476:	ba 14 00 00 00       	mov    $0x14,%edx
  81147b:	48 89 ce             	mov    %rcx,%rsi
  81147e:	48 89 c7             	mov    %rax,%rdi
  811481:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  811488:	00 00 00 
  81148b:	ff d0                	callq  *%rax
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  81148d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811491:	be 01 00 00 00       	mov    $0x1,%esi
  811496:	48 89 c7             	mov    %rax,%rdi
  811499:	48 b8 73 05 82 00 00 	movabs $0x820573,%rax
  8114a0:	00 00 00 
  8114a3:	ff d0                	callq  *%rax
    pbufs_freed += pbuf_clen(p);
  8114a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8114a9:	48 89 c7             	mov    %rax,%rdi
  8114ac:	48 b8 c4 db 80 00 00 	movabs $0x80dbc4,%rax
  8114b3:	00 00 00 
  8114b6:	ff d0                	callq  *%rax
  8114b8:	0f b6 c0             	movzbl %al,%eax
  8114bb:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(p);
  8114be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8114c2:	48 89 c7             	mov    %rax,%rdi
  8114c5:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8114cc:	00 00 00 
  8114cf:	ff d0                	callq  *%rax
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  8114d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8114d5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8114d9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (p != NULL) {
  8114dd:	eb 4b                	jmp    81152a <ip_reass_free_complete_datagram+0x189>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  8114df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8114e3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8114e7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    pcur = p;
  8114eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8114ef:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  8114f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8114f7:	48 8b 00             	mov    (%rax),%rax
  8114fa:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pbufs_freed += pbuf_clen(pcur);
  8114fe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811502:	48 89 c7             	mov    %rax,%rdi
  811505:	48 b8 c4 db 80 00 00 	movabs $0x80dbc4,%rax
  81150c:	00 00 00 
  81150f:	ff d0                	callq  *%rax
  811511:	0f b6 c0             	movzbl %al,%eax
  811514:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(pcur);    
  811517:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81151b:	48 89 c7             	mov    %rax,%rdi
  81151e:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  811525:	00 00 00 
  811528:	ff d0                	callq  *%rax
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  81152a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81152f:	75 ae                	jne    8114df <ip_reass_free_complete_datagram+0x13e>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  811531:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  811535:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811539:	48 89 d6             	mov    %rdx,%rsi
  81153c:	48 89 c7             	mov    %rax,%rdi
  81153f:	48 b8 a4 17 81 00 00 	movabs $0x8117a4,%rax
  811546:	00 00 00 
  811549:	ff d0                	callq  *%rax
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  81154b:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811552:	00 00 00 
  811555:	0f b7 00             	movzwl (%rax),%eax
  811558:	0f b7 c0             	movzwl %ax,%eax
  81155b:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  81155e:	7d 2a                	jge    81158a <ip_reass_free_complete_datagram+0x1e9>
  811560:	48 ba f3 22 82 00 00 	movabs $0x8222f3,%rdx
  811567:	00 00 00 
  81156a:	be bc 00 00 00       	mov    $0xbc,%esi
  81156f:	48 bf c4 22 82 00 00 	movabs $0x8222c4,%rdi
  811576:	00 00 00 
  811579:	b8 00 00 00 00       	mov    $0x0,%eax
  81157e:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  811585:	00 00 00 
  811588:	ff d1                	callq  *%rcx
  ip_reass_pbufcount -= pbufs_freed;
  81158a:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811591:	00 00 00 
  811594:	0f b7 10             	movzwl (%rax),%edx
  811597:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81159a:	29 c2                	sub    %eax,%edx
  81159c:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8115a3:	00 00 00 
  8115a6:	66 89 10             	mov    %dx,(%rax)

  return pbufs_freed;
  8115a9:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8115ac:	c9                   	leaveq 
  8115ad:	c3                   	retq   

00000000008115ae <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  8115ae:	55                   	push   %rbp
  8115af:	48 89 e5             	mov    %rsp,%rbp
  8115b2:	48 83 ec 40          	sub    $0x40,%rsp
  8115b6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8115ba:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  8115bd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  8115c4:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8115cb:	00 
    prev = NULL;
  8115cc:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8115d3:	00 
    other_datagrams = 0;
  8115d4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    r = reassdatagrams;
  8115db:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  8115e2:	00 00 00 
  8115e5:	48 8b 00             	mov    (%rax),%rax
  8115e8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (r != NULL) {
  8115ec:	e9 89 00 00 00       	jmpq   81167a <ip_reass_remove_oldest_datagram+0xcc>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  8115f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8115f5:	8b 50 1c             	mov    0x1c(%rax),%edx
  8115f8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8115fc:	8b 40 0c             	mov    0xc(%rax),%eax
  8115ff:	39 c2                	cmp    %eax,%edx
  811601:	75 27                	jne    81162a <ip_reass_remove_oldest_datagram+0x7c>
  811603:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811607:	8b 50 20             	mov    0x20(%rax),%edx
  81160a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81160e:	8b 40 10             	mov    0x10(%rax),%eax
  811611:	39 c2                	cmp    %eax,%edx
  811613:	75 15                	jne    81162a <ip_reass_remove_oldest_datagram+0x7c>
  811615:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811619:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  81161d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811621:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  811625:	66 39 c2             	cmp    %ax,%dx
  811628:	74 31                	je     81165b <ip_reass_remove_oldest_datagram+0xad>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  81162a:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
        if (oldest == NULL) {
  81162e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811633:	75 0a                	jne    81163f <ip_reass_remove_oldest_datagram+0x91>
          oldest = r;
  811635:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811639:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81163d:	eb 1c                	jmp    81165b <ip_reass_remove_oldest_datagram+0xad>
        } else if (r->timer <= oldest->timer) {
  81163f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811643:	0f b6 50 27          	movzbl 0x27(%rax),%edx
  811647:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81164b:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  81164f:	38 c2                	cmp    %al,%dl
  811651:	77 08                	ja     81165b <ip_reass_remove_oldest_datagram+0xad>
          /* older than the previous oldest */
          oldest = r;
  811653:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811657:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        }
      }
      if (r->next != NULL) {
  81165b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81165f:	48 8b 00             	mov    (%rax),%rax
  811662:	48 85 c0             	test   %rax,%rax
  811665:	74 08                	je     81166f <ip_reass_remove_oldest_datagram+0xc1>
        prev = r;
  811667:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81166b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      }
      r = r->next;
  81166f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811673:	48 8b 00             	mov    (%rax),%rax
  811676:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  81167a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81167f:	0f 85 6c ff ff ff    	jne    8115f1 <ip_reass_remove_oldest_datagram+0x43>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  811685:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81168a:	74 23                	je     8116af <ip_reass_remove_oldest_datagram+0x101>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  81168c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811690:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811694:	48 89 d6             	mov    %rdx,%rsi
  811697:	48 89 c7             	mov    %rax,%rdi
  81169a:	48 b8 a1 13 81 00 00 	movabs $0x8113a1,%rax
  8116a1:	00 00 00 
  8116a4:	ff d0                	callq  *%rax
  8116a6:	89 45 dc             	mov    %eax,-0x24(%rbp)
      pbufs_freed += pbufs_freed_current;
  8116a9:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8116ac:	01 45 e4             	add    %eax,-0x1c(%rbp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  8116af:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8116b2:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8116b5:	7d 0a                	jge    8116c1 <ip_reass_remove_oldest_datagram+0x113>
  8116b7:	83 7d e0 01          	cmpl   $0x1,-0x20(%rbp)
  8116bb:	0f 8f 03 ff ff ff    	jg     8115c4 <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
  8116c1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
}
  8116c4:	c9                   	leaveq 
  8116c5:	c3                   	retq   

00000000008116c6 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  8116c6:	55                   	push   %rbp
  8116c7:	48 89 e5             	mov    %rsp,%rbp
  8116ca:	48 83 ec 20          	sub    $0x20,%rsp
  8116ce:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8116d2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  8116d5:	bf 05 00 00 00       	mov    $0x5,%edi
  8116da:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  8116e1:	00 00 00 
  8116e4:	ff d0                	callq  *%rax
  8116e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (ipr == NULL) {
  8116ea:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8116ef:	75 40                	jne    811731 <ip_reass_enqueue_new_datagram+0x6b>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  8116f1:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8116f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8116f8:	89 d6                	mov    %edx,%esi
  8116fa:	48 89 c7             	mov    %rax,%rdi
  8116fd:	48 b8 ae 15 81 00 00 	movabs $0x8115ae,%rax
  811704:	00 00 00 
  811707:	ff d0                	callq  *%rax
  811709:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  81170c:	7c 15                	jl     811723 <ip_reass_enqueue_new_datagram+0x5d>
      ipr = memp_malloc(MEMP_REASSDATA);
  81170e:	bf 05 00 00 00       	mov    $0x5,%edi
  811713:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  81171a:	00 00 00 
  81171d:	ff d0                	callq  *%rax
  81171f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
    if (ipr == NULL)
  811723:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811728:	75 07                	jne    811731 <ip_reass_enqueue_new_datagram+0x6b>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
  81172a:	b8 00 00 00 00       	mov    $0x0,%eax
  81172f:	eb 71                	jmp    8117a2 <ip_reass_enqueue_new_datagram+0xdc>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  811731:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811735:	ba 28 00 00 00       	mov    $0x28,%edx
  81173a:	be 00 00 00 00       	mov    $0x0,%esi
  81173f:	48 89 c7             	mov    %rax,%rdi
  811742:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  811749:	00 00 00 
  81174c:	ff d0                	callq  *%rax
  ipr->timer = IP_REASS_MAXAGE;
  81174e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811752:	c6 40 27 03          	movb   $0x3,0x27(%rax)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  811756:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  81175d:	00 00 00 
  811760:	48 8b 10             	mov    (%rax),%rdx
  811763:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811767:	48 89 10             	mov    %rdx,(%rax)
  reassdatagrams = ipr;
  81176a:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811771:	00 00 00 
  811774:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  811778:	48 89 10             	mov    %rdx,(%rax)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  81177b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81177f:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811783:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811787:	ba 14 00 00 00       	mov    $0x14,%edx
  81178c:	48 89 c6             	mov    %rax,%rsi
  81178f:	48 89 cf             	mov    %rcx,%rdi
  811792:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  811799:	00 00 00 
  81179c:	ff d0                	callq  *%rax
  return ipr;
  81179e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8117a2:	c9                   	leaveq 
  8117a3:	c3                   	retq   

00000000008117a4 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  8117a4:	55                   	push   %rbp
  8117a5:	48 89 e5             	mov    %rsp,%rbp
  8117a8:	48 83 ec 10          	sub    $0x10,%rsp
  8117ac:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8117b0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  8117b4:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  8117bb:	00 00 00 
  8117be:	48 8b 00             	mov    (%rax),%rax
  8117c1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8117c5:	75 16                	jne    8117dd <ip_reass_dequeue_datagram+0x39>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  8117c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8117cb:	48 8b 10             	mov    (%rax),%rdx
  8117ce:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  8117d5:	00 00 00 
  8117d8:	48 89 10             	mov    %rdx,(%rax)
  8117db:	eb 3f                	jmp    81181c <ip_reass_dequeue_datagram+0x78>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  8117dd:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8117e2:	75 2a                	jne    81180e <ip_reass_dequeue_datagram+0x6a>
  8117e4:	48 ba 0e 23 82 00 00 	movabs $0x82230e,%rdx
  8117eb:	00 00 00 
  8117ee:	be 29 01 00 00       	mov    $0x129,%esi
  8117f3:	48 bf c4 22 82 00 00 	movabs $0x8222c4,%rdi
  8117fa:	00 00 00 
  8117fd:	b8 00 00 00 00       	mov    $0x0,%eax
  811802:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  811809:	00 00 00 
  81180c:	ff d1                	callq  *%rcx
    prev->next = ipr->next;
  81180e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811812:	48 8b 10             	mov    (%rax),%rdx
  811815:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811819:	48 89 10             	mov    %rdx,(%rax)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  81181c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811820:	48 89 c6             	mov    %rax,%rsi
  811823:	bf 05 00 00 00       	mov    $0x5,%edi
  811828:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81182f:	00 00 00 
  811832:	ff d0                	callq  *%rax
}
  811834:	c9                   	leaveq 
  811835:	c3                   	retq   

0000000000811836 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  811836:	55                   	push   %rbp
  811837:	48 89 e5             	mov    %rsp,%rbp
  81183a:	53                   	push   %rbx
  81183b:	48 83 ec 58          	sub    $0x58,%rsp
  81183f:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  811843:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  811847:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81184e:	00 
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  81184f:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  811856:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81185a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81185e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  811862:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811866:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  81186a:	0f b7 c0             	movzwl %ax,%eax
  81186d:	89 c7                	mov    %eax,%edi
  81186f:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  811876:	00 00 00 
  811879:	ff d0                	callq  *%rax
  81187b:	89 c3                	mov    %eax,%ebx
  81187d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811881:	0f b7 00             	movzwl (%rax),%eax
  811884:	0f b7 c0             	movzwl %ax,%eax
  811887:	89 c7                	mov    %eax,%edi
  811889:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  811890:	00 00 00 
  811893:	ff d0                	callq  *%rax
  811895:	66 c1 e8 08          	shr    $0x8,%ax
  811899:	83 e0 0f             	and    $0xf,%eax
  81189c:	89 c2                	mov    %eax,%edx
  81189e:	b8 00 00 00 00       	mov    $0x0,%eax
  8118a3:	29 d0                	sub    %edx,%eax
  8118a5:	c1 e0 02             	shl    $0x2,%eax
  8118a8:	01 d8                	add    %ebx,%eax
  8118aa:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  8118ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8118b2:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  8118b6:	0f b7 c0             	movzwl %ax,%eax
  8118b9:	89 c7                	mov    %eax,%edi
  8118bb:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8118c2:	00 00 00 
  8118c5:	ff d0                	callq  *%rax
  8118c7:	66 25 ff 1f          	and    $0x1fff,%ax
  8118cb:	c1 e0 03             	shl    $0x3,%eax
  8118ce:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  8118d2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8118d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8118da:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  iprh->next_pbuf = NULL;
  8118de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118e2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  iprh->start = offset;
  8118e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118ed:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  8118f1:	66 89 50 08          	mov    %dx,0x8(%rax)
  iprh->end = offset + len;
  8118f5:	0f b7 45 c6          	movzwl -0x3a(%rbp),%eax
  8118f9:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  8118fd:	01 c2                	add    %eax,%edx
  8118ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811903:	66 89 50 0a          	mov    %dx,0xa(%rax)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  811907:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81190b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81190f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  811913:	e9 ed 00 00 00       	jmpq   811a05 <ip_reass_chain_frag_into_datagram_and_validate+0x1cf>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  811918:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81191c:	48 8b 40 08          	mov    0x8(%rax),%rax
  811920:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    if (iprh->start < iprh_tmp->start) {
  811924:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811928:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  81192c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811930:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811934:	66 39 c2             	cmp    %ax,%dx
  811937:	73 62                	jae    81199b <ip_reass_chain_frag_into_datagram_and_validate+0x165>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  811939:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81193d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  811941:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev != NULL) {
  811944:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811949:	74 42                	je     81198d <ip_reass_chain_frag_into_datagram_and_validate+0x157>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  81194b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81194f:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811953:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811957:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  81195b:	66 39 c2             	cmp    %ax,%dx
  81195e:	0f 82 01 03 00 00    	jb     811c65 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
  811964:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811968:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  81196c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811970:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811974:	66 39 c2             	cmp    %ax,%dx
  811977:	0f 87 e8 02 00 00    	ja     811c65 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  81197d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811981:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811985:	48 89 10             	mov    %rdx,(%rax)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
  811988:	e9 83 00 00 00       	jmpq   811a10 <ip_reass_chain_frag_into_datagram_and_validate+0x1da>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  81198d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811991:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811995:	48 89 50 08          	mov    %rdx,0x8(%rax)
      }
      break;
  811999:	eb 75                	jmp    811a10 <ip_reass_chain_frag_into_datagram_and_validate+0x1da>
    } else if(iprh->start == iprh_tmp->start) {
  81199b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81199f:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  8119a3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8119a7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8119ab:	66 39 c2             	cmp    %ax,%dx
  8119ae:	75 05                	jne    8119b5 <ip_reass_chain_frag_into_datagram_and_validate+0x17f>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
  8119b0:	e9 b0 02 00 00       	jmpq   811c65 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  8119b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8119b9:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  8119bd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8119c1:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  8119c5:	66 39 c2             	cmp    %ax,%dx
  8119c8:	73 05                	jae    8119cf <ip_reass_chain_frag_into_datagram_and_validate+0x199>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
  8119ca:	e9 96 02 00 00       	jmpq   811c65 <ip_reass_chain_frag_into_datagram_and_validate+0x42f>
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  8119cf:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8119d4:	74 1c                	je     8119f2 <ip_reass_chain_frag_into_datagram_and_validate+0x1bc>
        if (iprh_prev->end != iprh_tmp->start) {
  8119d6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8119da:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  8119de:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8119e2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8119e6:	66 39 c2             	cmp    %ax,%dx
  8119e9:	74 07                	je     8119f2 <ip_reass_chain_frag_into_datagram_and_validate+0x1bc>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  8119eb:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  8119f2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8119f6:	48 8b 00             	mov    (%rax),%rax
  8119f9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    iprh_prev = iprh_tmp;
  8119fd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811a01:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  811a05:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811a0a:	0f 85 08 ff ff ff    	jne    811918 <ip_reass_chain_frag_into_datagram_and_validate+0xe2>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  811a10:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811a15:	0f 85 b2 00 00 00    	jne    811acd <ip_reass_chain_frag_into_datagram_and_validate+0x297>
    if (iprh_prev != NULL) {
  811a1b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811a20:	74 68                	je     811a8a <ip_reass_chain_frag_into_datagram_and_validate+0x254>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  811a22:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811a26:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811a2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811a2e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811a32:	66 39 c2             	cmp    %ax,%dx
  811a35:	76 2a                	jbe    811a61 <ip_reass_chain_frag_into_datagram_and_validate+0x22b>
  811a37:	48 ba 27 23 82 00 00 	movabs $0x822327,%rdx
  811a3e:	00 00 00 
  811a41:	be 83 01 00 00       	mov    $0x183,%esi
  811a46:	48 bf c4 22 82 00 00 	movabs $0x8222c4,%rdi
  811a4d:	00 00 00 
  811a50:	b8 00 00 00 00       	mov    $0x0,%eax
  811a55:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  811a5c:	00 00 00 
  811a5f:	ff d1                	callq  *%rcx
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  811a61:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811a65:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811a69:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev->end != iprh->start) {
  811a6c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811a70:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811a74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811a78:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811a7c:	66 39 c2             	cmp    %ax,%dx
  811a7f:	74 4c                	je     811acd <ip_reass_chain_frag_into_datagram_and_validate+0x297>
        valid = 0;
  811a81:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  811a88:	eb 43                	jmp    811acd <ip_reass_chain_frag_into_datagram_and_validate+0x297>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  811a8a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811a8e:	48 8b 40 08          	mov    0x8(%rax),%rax
  811a92:	48 85 c0             	test   %rax,%rax
  811a95:	74 2a                	je     811ac1 <ip_reass_chain_frag_into_datagram_and_validate+0x28b>
  811a97:	48 ba 48 23 82 00 00 	movabs $0x822348,%rdx
  811a9e:	00 00 00 
  811aa1:	be 8c 01 00 00       	mov    $0x18c,%esi
  811aa6:	48 bf c4 22 82 00 00 	movabs $0x8222c4,%rdi
  811aad:	00 00 00 
  811ab0:	b8 00 00 00 00       	mov    $0x0,%eax
  811ab5:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  811abc:	00 00 00 
  811abf:	ff d1                	callq  *%rcx
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  811ac1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811ac5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811ac9:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  811acd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811ad1:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  811ad5:	0f b6 c0             	movzbl %al,%eax
  811ad8:	83 e0 01             	and    $0x1,%eax
  811adb:	85 c0                	test   %eax,%eax
  811add:	0f 84 7b 01 00 00    	je     811c5e <ip_reass_chain_frag_into_datagram_and_validate+0x428>
    /* and had no wholes so far */
    if (valid) {
  811ae3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811ae7:	0f 84 6c 01 00 00    	je     811c59 <ip_reass_chain_frag_into_datagram_and_validate+0x423>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  811aed:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811af1:	48 8b 40 08          	mov    0x8(%rax),%rax
  811af5:	48 8b 40 08          	mov    0x8(%rax),%rax
  811af9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811afd:	66 85 c0             	test   %ax,%ax
  811b00:	74 0c                	je     811b0e <ip_reass_chain_frag_into_datagram_and_validate+0x2d8>
        valid = 0;
  811b02:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  811b09:	e9 4b 01 00 00       	jmpq   811c59 <ip_reass_chain_frag_into_datagram_and_validate+0x423>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
  811b0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b12:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        q = iprh->next_pbuf;
  811b16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b1a:	48 8b 00             	mov    (%rax),%rax
  811b1d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        while (q != NULL) {
  811b21:	eb 3d                	jmp    811b60 <ip_reass_chain_frag_into_datagram_and_validate+0x32a>
          iprh = (struct ip_reass_helper*)q->payload;
  811b23:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811b27:	48 8b 40 08          	mov    0x8(%rax),%rax
  811b2b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
          if (iprh_prev->end != iprh->start) {
  811b2f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811b33:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811b37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b3b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811b3f:	66 39 c2             	cmp    %ax,%dx
  811b42:	74 09                	je     811b4d <ip_reass_chain_frag_into_datagram_and_validate+0x317>
            valid = 0;
  811b44:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
            break;
  811b4b:	eb 1a                	jmp    811b67 <ip_reass_chain_frag_into_datagram_and_validate+0x331>
          }
          iprh_prev = iprh;
  811b4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b51:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          q = iprh->next_pbuf;
  811b55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b59:	48 8b 00             	mov    (%rax),%rax
  811b5c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  811b60:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811b65:	75 bc                	jne    811b23 <ip_reass_chain_frag_into_datagram_and_validate+0x2ed>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
  811b67:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811b6b:	0f 84 e8 00 00 00    	je     811c59 <ip_reass_chain_frag_into_datagram_and_validate+0x423>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  811b71:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811b75:	48 8b 40 08          	mov    0x8(%rax),%rax
  811b79:	48 85 c0             	test   %rax,%rax
  811b7c:	75 2a                	jne    811ba8 <ip_reass_chain_frag_into_datagram_and_validate+0x372>
  811b7e:	48 ba 7f 23 82 00 00 	movabs $0x82237f,%rdx
  811b85:	00 00 00 
  811b88:	be ac 01 00 00       	mov    $0x1ac,%esi
  811b8d:	48 bf c4 22 82 00 00 	movabs $0x8222c4,%rdi
  811b94:	00 00 00 
  811b97:	b8 00 00 00 00       	mov    $0x0,%eax
  811b9c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  811ba3:	00 00 00 
  811ba6:	ff d1                	callq  *%rcx
          LWIP_ASSERT("sanity check",
  811ba8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811bac:	48 8b 40 08          	mov    0x8(%rax),%rax
  811bb0:	48 8b 40 08          	mov    0x8(%rax),%rax
  811bb4:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  811bb8:	75 2a                	jne    811be4 <ip_reass_chain_frag_into_datagram_and_validate+0x3ae>
  811bba:	48 ba 7f 23 82 00 00 	movabs $0x82237f,%rdx
  811bc1:	00 00 00 
  811bc4:	be ae 01 00 00       	mov    $0x1ae,%esi
  811bc9:	48 bf c4 22 82 00 00 	movabs $0x8222c4,%rdi
  811bd0:	00 00 00 
  811bd3:	b8 00 00 00 00       	mov    $0x0,%eax
  811bd8:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  811bdf:	00 00 00 
  811be2:	ff d1                	callq  *%rcx
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  811be4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811be8:	48 8b 00             	mov    (%rax),%rax
  811beb:	48 85 c0             	test   %rax,%rax
  811bee:	74 2a                	je     811c1a <ip_reass_chain_frag_into_datagram_and_validate+0x3e4>
  811bf0:	48 ba 90 23 82 00 00 	movabs $0x822390,%rdx
  811bf7:	00 00 00 
  811bfa:	be b0 01 00 00       	mov    $0x1b0,%esi
  811bff:	48 bf c4 22 82 00 00 	movabs $0x8222c4,%rdi
  811c06:	00 00 00 
  811c09:	b8 00 00 00 00       	mov    $0x0,%eax
  811c0e:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  811c15:	00 00 00 
  811c18:	ff d1                	callq  *%rcx
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  811c1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c1e:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811c22:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811c26:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811c2a:	66 39 c2             	cmp    %ax,%dx
  811c2d:	74 2a                	je     811c59 <ip_reass_chain_frag_into_datagram_and_validate+0x423>
  811c2f:	48 ba b8 23 82 00 00 	movabs $0x8223b8,%rdx
  811c36:	00 00 00 
  811c39:	be b2 01 00 00       	mov    $0x1b2,%esi
  811c3e:	48 bf c4 22 82 00 00 	movabs $0x8222c4,%rdi
  811c45:	00 00 00 
  811c48:	b8 00 00 00 00       	mov    $0x0,%eax
  811c4d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  811c54:	00 00 00 
  811c57:	ff d1                	callq  *%rcx
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
  811c59:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  811c5c:	eb 53                	jmp    811cb1 <ip_reass_chain_frag_into_datagram_and_validate+0x47b>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
  811c5e:	b8 00 00 00 00       	mov    $0x0,%eax
  811c63:	eb 4c                	jmp    811cb1 <ip_reass_chain_frag_into_datagram_and_validate+0x47b>
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  811c65:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811c6c:	00 00 00 
  811c6f:	0f b7 18             	movzwl (%rax),%ebx
  811c72:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811c76:	48 89 c7             	mov    %rax,%rdi
  811c79:	48 b8 c4 db 80 00 00 	movabs $0x80dbc4,%rax
  811c80:	00 00 00 
  811c83:	ff d0                	callq  *%rax
  811c85:	0f b6 c0             	movzbl %al,%eax
  811c88:	29 c3                	sub    %eax,%ebx
  811c8a:	89 da                	mov    %ebx,%edx
  811c8c:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811c93:	00 00 00 
  811c96:	66 89 10             	mov    %dx,(%rax)
  pbuf_free(new_p);
  811c99:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811c9d:	48 89 c7             	mov    %rax,%rdi
  811ca0:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  811ca7:	00 00 00 
  811caa:	ff d0                	callq  *%rax
  return 0;
  811cac:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_REASS_CHECK_OVERLAP */
}
  811cb1:	48 83 c4 58          	add    $0x58,%rsp
  811cb5:	5b                   	pop    %rbx
  811cb6:	5d                   	pop    %rbp
  811cb7:	c3                   	retq   

0000000000811cb8 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  811cb8:	55                   	push   %rbp
  811cb9:	48 89 e5             	mov    %rsp,%rbp
  811cbc:	53                   	push   %rbx
  811cbd:	48 83 ec 48          	sub    $0x48,%rsp
  811cc1:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  811cc5:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  811ccc:	00 

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  811ccd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811cd1:	48 8b 40 08          	mov    0x8(%rax),%rax
  811cd5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  811cd9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811cdd:	0f b7 00             	movzwl (%rax),%eax
  811ce0:	0f b7 c0             	movzwl %ax,%eax
  811ce3:	89 c7                	mov    %eax,%edi
  811ce5:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  811cec:	00 00 00 
  811cef:	ff d0                	callq  *%rax
  811cf1:	66 c1 e8 08          	shr    $0x8,%ax
  811cf5:	0f b7 c0             	movzwl %ax,%eax
  811cf8:	83 e0 0f             	and    $0xf,%eax
  811cfb:	c1 e0 02             	shl    $0x2,%eax
  811cfe:	83 f8 14             	cmp    $0x14,%eax
  811d01:	74 05                	je     811d08 <ip_reass+0x50>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  811d03:	e9 d7 03 00 00       	jmpq   8120df <ip_reass+0x427>
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  811d08:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811d0c:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811d10:	0f b7 c0             	movzwl %ax,%eax
  811d13:	89 c7                	mov    %eax,%edi
  811d15:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  811d1c:	00 00 00 
  811d1f:	ff d0                	callq  *%rax
  811d21:	66 25 ff 1f          	and    $0x1fff,%ax
  811d25:	c1 e0 03             	shl    $0x3,%eax
  811d28:	66 89 45 ce          	mov    %ax,-0x32(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  811d2c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811d30:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  811d34:	0f b7 c0             	movzwl %ax,%eax
  811d37:	89 c7                	mov    %eax,%edi
  811d39:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  811d40:	00 00 00 
  811d43:	ff d0                	callq  *%rax
  811d45:	89 c3                	mov    %eax,%ebx
  811d47:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811d4b:	0f b7 00             	movzwl (%rax),%eax
  811d4e:	0f b7 c0             	movzwl %ax,%eax
  811d51:	89 c7                	mov    %eax,%edi
  811d53:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  811d5a:	00 00 00 
  811d5d:	ff d0                	callq  *%rax
  811d5f:	66 c1 e8 08          	shr    $0x8,%ax
  811d63:	83 e0 0f             	and    $0xf,%eax
  811d66:	89 c2                	mov    %eax,%edx
  811d68:	b8 00 00 00 00       	mov    $0x0,%eax
  811d6d:	29 d0                	sub    %edx,%eax
  811d6f:	c1 e0 02             	shl    $0x2,%eax
  811d72:	01 d8                	add    %ebx,%eax
  811d74:	66 89 45 cc          	mov    %ax,-0x34(%rbp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  811d78:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811d7c:	48 89 c7             	mov    %rax,%rdi
  811d7f:	48 b8 c4 db 80 00 00 	movabs $0x80dbc4,%rax
  811d86:	00 00 00 
  811d89:	ff d0                	callq  *%rax
  811d8b:	88 45 cb             	mov    %al,-0x35(%rbp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  811d8e:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811d95:	00 00 00 
  811d98:	0f b7 00             	movzwl (%rax),%eax
  811d9b:	0f b7 d0             	movzwl %ax,%edx
  811d9e:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  811da2:	01 d0                	add    %edx,%eax
  811da4:	83 f8 0a             	cmp    $0xa,%eax
  811da7:	7e 3d                	jle    811de6 <ip_reass+0x12e>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  811da9:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  811dad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811db1:	89 d6                	mov    %edx,%esi
  811db3:	48 89 c7             	mov    %rax,%rdi
  811db6:	48 b8 ae 15 81 00 00 	movabs $0x8115ae,%rax
  811dbd:	00 00 00 
  811dc0:	ff d0                	callq  *%rax
  811dc2:	85 c0                	test   %eax,%eax
  811dc4:	74 1b                	je     811de1 <ip_reass+0x129>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  811dc6:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811dcd:	00 00 00 
  811dd0:	0f b7 00             	movzwl (%rax),%eax
  811dd3:	0f b7 d0             	movzwl %ax,%edx
  811dd6:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  811dda:	01 d0                	add    %edx,%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  811ddc:	83 f8 0a             	cmp    $0xa,%eax
  811ddf:	7e 05                	jle    811de6 <ip_reass+0x12e>
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
  811de1:	e9 f9 02 00 00       	jmpq   8120df <ip_reass+0x427>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  811de6:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811ded:	00 00 00 
  811df0:	48 8b 00             	mov    (%rax),%rax
  811df3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  811df7:	eb 4e                	jmp    811e47 <ip_reass+0x18f>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  811df9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811dfd:	8b 50 1c             	mov    0x1c(%rax),%edx
  811e00:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811e04:	8b 40 0c             	mov    0xc(%rax),%eax
  811e07:	39 c2                	cmp    %eax,%edx
  811e09:	75 29                	jne    811e34 <ip_reass+0x17c>
  811e0b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811e0f:	8b 50 20             	mov    0x20(%rax),%edx
  811e12:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811e16:	8b 40 10             	mov    0x10(%rax),%eax
  811e19:	39 c2                	cmp    %eax,%edx
  811e1b:	75 17                	jne    811e34 <ip_reass+0x17c>
  811e1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811e21:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  811e25:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811e29:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  811e2d:	66 39 c2             	cmp    %ax,%dx
  811e30:	75 02                	jne    811e34 <ip_reass+0x17c>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
  811e32:	eb 1a                	jmp    811e4e <ip_reass+0x196>
    }
    ipr_prev = ipr;
  811e34:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811e38:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  811e3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811e40:	48 8b 00             	mov    (%rax),%rax
  811e43:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  811e47:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811e4c:	75 ab                	jne    811df9 <ip_reass+0x141>
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  811e4e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811e53:	75 29                	jne    811e7e <ip_reass+0x1c6>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
  811e55:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  811e59:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811e5d:	89 d6                	mov    %edx,%esi
  811e5f:	48 89 c7             	mov    %rax,%rdi
  811e62:	48 b8 c6 16 81 00 00 	movabs $0x8116c6,%rax
  811e69:	00 00 00 
  811e6c:	ff d0                	callq  *%rax
  811e6e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  811e72:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811e77:	75 72                	jne    811eeb <ip_reass+0x233>
      goto nullreturn;
  811e79:	e9 61 02 00 00       	jmpq   8120df <ip_reass+0x427>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  811e7e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811e82:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811e86:	0f b7 c0             	movzwl %ax,%eax
  811e89:	89 c7                	mov    %eax,%edi
  811e8b:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  811e92:	00 00 00 
  811e95:	ff d0                	callq  *%rax
  811e97:	0f b7 c0             	movzwl %ax,%eax
  811e9a:	25 ff 1f 00 00       	and    $0x1fff,%eax
  811e9f:	85 c0                	test   %eax,%eax
  811ea1:	75 48                	jne    811eeb <ip_reass+0x233>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  811ea3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811ea7:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  811eab:	0f b7 c0             	movzwl %ax,%eax
  811eae:	89 c7                	mov    %eax,%edi
  811eb0:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  811eb7:	00 00 00 
  811eba:	ff d0                	callq  *%rax
  811ebc:	0f b7 c0             	movzwl %ax,%eax
  811ebf:	25 ff 1f 00 00       	and    $0x1fff,%eax
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  811ec4:	85 c0                	test   %eax,%eax
  811ec6:	74 23                	je     811eeb <ip_reass+0x233>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  811ec8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811ecc:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811ed0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811ed4:	ba 14 00 00 00       	mov    $0x14,%edx
  811ed9:	48 89 c6             	mov    %rax,%rsi
  811edc:	48 89 cf             	mov    %rcx,%rdi
  811edf:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  811ee6:	00 00 00 
  811ee9:	ff d0                	callq  *%rax
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  811eeb:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  811eef:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811ef6:	00 00 00 
  811ef9:	0f b7 00             	movzwl (%rax),%eax
  811efc:	01 c2                	add    %eax,%edx
  811efe:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811f05:	00 00 00 
  811f08:	66 89 10             	mov    %dx,(%rax)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  811f0b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811f0f:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811f13:	0f b7 c0             	movzwl %ax,%eax
  811f16:	89 c7                	mov    %eax,%edi
  811f18:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  811f1f:	00 00 00 
  811f22:	ff d0                	callq  *%rax
  811f24:	0f b7 c0             	movzwl %ax,%eax
  811f27:	25 00 20 00 00       	and    $0x2000,%eax
  811f2c:	85 c0                	test   %eax,%eax
  811f2e:	75 26                	jne    811f56 <ip_reass+0x29e>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  811f30:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f34:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  811f38:	83 c8 01             	or     $0x1,%eax
  811f3b:	89 c2                	mov    %eax,%edx
  811f3d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f41:	88 50 26             	mov    %dl,0x26(%rax)
    ipr->datagram_len = offset + len;
  811f44:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  811f48:	0f b7 55 ce          	movzwl -0x32(%rbp),%edx
  811f4c:	01 c2                	add    %eax,%edx
  811f4e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f52:	66 89 50 24          	mov    %dx,0x24(%rax)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
  811f56:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  811f5a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f5e:	48 89 d6             	mov    %rdx,%rsi
  811f61:	48 89 c7             	mov    %rax,%rdi
  811f64:	48 b8 36 18 81 00 00 	movabs $0x811836,%rax
  811f6b:	00 00 00 
  811f6e:	ff d0                	callq  *%rax
  811f70:	85 c0                	test   %eax,%eax
  811f72:	0f 84 60 01 00 00    	je     8120d8 <ip_reass+0x420>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  811f78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f7c:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811f80:	8d 50 14             	lea    0x14(%rax),%edx
  811f83:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f87:	66 89 50 24          	mov    %dx,0x24(%rax)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  811f8b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f8f:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f93:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f97:	48 8b 00             	mov    (%rax),%rax
  811f9a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
  811f9e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811fa2:	48 8b 40 08          	mov    0x8(%rax),%rax
  811fa6:	48 8b 40 08          	mov    0x8(%rax),%rax
  811faa:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  811fae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811fb2:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811fb6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811fba:	ba 14 00 00 00       	mov    $0x14,%edx
  811fbf:	48 89 ce             	mov    %rcx,%rsi
  811fc2:	48 89 c7             	mov    %rax,%rdi
  811fc5:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  811fcc:	00 00 00 
  811fcf:	ff d0                	callq  *%rax
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  811fd1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811fd5:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811fd9:	0f b7 c0             	movzwl %ax,%eax
  811fdc:	89 c7                	mov    %eax,%edi
  811fde:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  811fe5:	00 00 00 
  811fe8:	ff d0                	callq  *%rax
  811fea:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  811fee:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_OFFSET_SET(fraghdr, 0);
  811ff2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811ff6:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_CHKSUM_SET(fraghdr, 0);
  811ffc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812000:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  812006:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81200a:	be 14 00 00 00       	mov    $0x14,%esi
  81200f:	48 89 c7             	mov    %rax,%rdi
  812012:	48 b8 d0 27 81 00 00 	movabs $0x8127d0,%rax
  812019:	00 00 00 
  81201c:	ff d0                	callq  *%rax
  81201e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  812022:	66 89 42 0a          	mov    %ax,0xa(%rdx)

    p = ipr->p;
  812026:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81202a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81202e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  812032:	eb 49                	jmp    81207d <ip_reass+0x3c5>
      iprh = (struct ip_reass_helper*)r->payload;
  812034:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812038:	48 8b 40 08          	mov    0x8(%rax),%rax
  81203c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  812040:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812044:	be ec ff ff ff       	mov    $0xffffffec,%esi
  812049:	48 89 c7             	mov    %rax,%rdi
  81204c:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  812053:	00 00 00 
  812056:	ff d0                	callq  *%rax
      pbuf_cat(p, r);
  812058:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81205c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812060:	48 89 d6             	mov    %rdx,%rsi
  812063:	48 89 c7             	mov    %rax,%rdi
  812066:	48 b8 1a dc 80 00 00 	movabs $0x80dc1a,%rax
  81206d:	00 00 00 
  812070:	ff d0                	callq  *%rax
      r = iprh->next_pbuf;
  812072:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812076:	48 8b 00             	mov    (%rax),%rax
  812079:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  81207d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  812082:	75 b0                	jne    812034 <ip_reass+0x37c>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  812084:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  812088:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81208c:	48 89 d6             	mov    %rdx,%rsi
  81208f:	48 89 c7             	mov    %rax,%rdi
  812092:	48 b8 a4 17 81 00 00 	movabs $0x8117a4,%rax
  812099:	00 00 00 
  81209c:	ff d0                	callq  *%rax

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  81209e:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8120a5:	00 00 00 
  8120a8:	0f b7 18             	movzwl (%rax),%ebx
  8120ab:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8120af:	48 89 c7             	mov    %rax,%rdi
  8120b2:	48 b8 c4 db 80 00 00 	movabs $0x80dbc4,%rax
  8120b9:	00 00 00 
  8120bc:	ff d0                	callq  *%rax
  8120be:	0f b6 c0             	movzbl %al,%eax
  8120c1:	29 c3                	sub    %eax,%ebx
  8120c3:	89 da                	mov    %ebx,%edx
  8120c5:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8120cc:	00 00 00 
  8120cf:	66 89 10             	mov    %dx,(%rax)

    /* Return the pbuf chain */
    return p;
  8120d2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8120d6:	eb 1f                	jmp    8120f7 <ip_reass+0x43f>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  8120d8:	b8 00 00 00 00       	mov    $0x0,%eax
  8120dd:	eb 18                	jmp    8120f7 <ip_reass+0x43f>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  8120df:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8120e3:	48 89 c7             	mov    %rax,%rdi
  8120e6:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8120ed:	00 00 00 
  8120f0:	ff d0                	callq  *%rax
  return NULL;
  8120f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8120f7:	48 83 c4 48          	add    $0x48,%rsp
  8120fb:	5b                   	pop    %rbx
  8120fc:	5d                   	pop    %rbp
  8120fd:	c3                   	retq   

00000000008120fe <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  8120fe:	55                   	push   %rbp
  8120ff:	48 89 e5             	mov    %rsp,%rbp
  812102:	48 83 ec 50          	sub    $0x50,%rsp
  812106:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81210a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81210e:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  812112:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812116:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  81211a:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  81211e:	66 c7 45 fa 14 00    	movw   $0x14,-0x6(%rbp)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  812124:	ba 02 00 00 00       	mov    $0x2,%edx
  812129:	be 00 00 00 00       	mov    $0x0,%esi
  81212e:	bf 02 00 00 00       	mov    $0x2,%edi
  812133:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  81213a:	00 00 00 
  81213d:	ff d0                	callq  *%rax
  81213f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (rambuf == NULL) {
  812143:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  812148:	75 0a                	jne    812154 <ip_frag+0x56>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  81214a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81214f:	e9 7f 02 00 00       	jmpq   8123d3 <ip_frag+0x2d5>
  }
  rambuf->tot_len = rambuf->len = mtu;
  812154:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812158:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  81215c:	66 89 50 12          	mov    %dx,0x12(%rax)
  812160:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812164:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  812168:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81216c:	66 89 50 10          	mov    %dx,0x10(%rax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  812170:	48 b8 80 b0 b4 00 00 	movabs $0xb4b080,%rax
  812177:	00 00 00 
  81217a:	48 83 c0 03          	add    $0x3,%rax
  81217e:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  812182:	48 89 c2             	mov    %rax,%rdx
  812185:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812189:	48 89 50 08          	mov    %rdx,0x8(%rax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  81218d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812191:	48 8b 40 08          	mov    0x8(%rax),%rax
  812195:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  812199:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81219d:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8121a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8121a5:	ba 14 00 00 00       	mov    $0x14,%edx
  8121aa:	48 89 ce             	mov    %rcx,%rsi
  8121ad:	48 89 c7             	mov    %rax,%rdi
  8121b0:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  8121b7:	00 00 00 
  8121ba:	ff d0                	callq  *%rax
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8121bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8121c0:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  8121c4:	0f b7 c0             	movzwl %ax,%eax
  8121c7:	89 c7                	mov    %eax,%edi
  8121c9:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8121d0:	00 00 00 
  8121d3:	ff d0                	callq  *%rax
  8121d5:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
  ofo = tmp & IP_OFFMASK;
  8121d9:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  8121dd:	66 25 ff 1f          	and    $0x1fff,%ax
  8121e1:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  omf = tmp & IP_MF;
  8121e5:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  8121e9:	66 25 00 20          	and    $0x2000,%ax
  8121ed:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  left = p->tot_len - IP_HLEN;
  8121f1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8121f5:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8121f9:	83 e8 14             	sub    $0x14,%eax
  8121fc:	66 89 45 fe          	mov    %ax,-0x2(%rbp)

  nfb = (mtu - IP_HLEN) / 8;
  812200:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  812204:	83 e8 14             	sub    $0x14,%eax
  812207:	8d 50 07             	lea    0x7(%rax),%edx
  81220a:	85 c0                	test   %eax,%eax
  81220c:	0f 48 c2             	cmovs  %edx,%eax
  81220f:	c1 f8 03             	sar    $0x3,%eax
  812212:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  while (left) {
  812216:	e9 95 01 00 00       	jmpq   8123b0 <ip_frag+0x2b2>
    last = (left <= mtu - IP_HLEN);
  81221b:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81221f:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  812223:	83 ea 14             	sub    $0x14,%edx
  812226:	39 d0                	cmp    %edx,%eax
  812228:	0f 9e c0             	setle  %al
  81222b:	0f b6 c0             	movzbl %al,%eax
  81222e:	66 89 45 da          	mov    %ax,-0x26(%rbp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  812232:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812236:	66 25 ff 1f          	and    $0x1fff,%ax
  81223a:	66 0b 45 de          	or     -0x22(%rbp),%ax
  81223e:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
    if (!last)
  812242:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  812247:	75 06                	jne    81224f <ip_frag+0x151>
      tmp = tmp | IP_MF;
  812249:	66 81 4d f8 00 20    	orw    $0x2000,-0x8(%rbp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  81224f:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  812254:	75 09                	jne    81225f <ip_frag+0x161>
  812256:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81225a:	c1 e0 03             	shl    $0x3,%eax
  81225d:	eb 04                	jmp    812263 <ip_frag+0x165>
  81225f:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  812263:	66 89 45 d8          	mov    %ax,-0x28(%rbp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  812267:	0f b7 4d fa          	movzwl -0x6(%rbp),%ecx
  81226b:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  81226f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812273:	48 8d 70 14          	lea    0x14(%rax),%rsi
  812277:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81227b:	48 89 c7             	mov    %rax,%rdi
  81227e:	48 b8 1d e1 80 00 00 	movabs $0x80e11d,%rax
  812285:	00 00 00 
  812288:	ff d0                	callq  *%rax
  81228a:	66 01 45 fa          	add    %ax,-0x6(%rbp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  81228e:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  812292:	89 c7                	mov    %eax,%edi
  812294:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  81229b:	00 00 00 
  81229e:	ff d0                	callq  *%rax
  8122a0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8122a4:	66 89 42 06          	mov    %ax,0x6(%rdx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8122a8:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  8122ac:	83 c0 14             	add    $0x14,%eax
  8122af:	0f b7 c0             	movzwl %ax,%eax
  8122b2:	89 c7                	mov    %eax,%edi
  8122b4:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8122bb:	00 00 00 
  8122be:	ff d0                	callq  *%rax
  8122c0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8122c4:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_CHKSUM_SET(iphdr, 0);
  8122c8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122cc:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8122d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122d6:	be 14 00 00 00       	mov    $0x14,%esi
  8122db:	48 89 c7             	mov    %rax,%rdi
  8122de:	48 b8 d0 27 81 00 00 	movabs $0x8127d0,%rax
  8122e5:	00 00 00 
  8122e8:	ff d0                	callq  *%rax
  8122ea:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8122ee:	66 89 42 0a          	mov    %ax,0xa(%rdx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  8122f2:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  8122f7:	74 1f                	je     812318 <ip_frag+0x21a>
      pbuf_realloc(rambuf, left + IP_HLEN);
  8122f9:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  8122fd:	83 c0 14             	add    $0x14,%eax
  812300:	0f b7 d0             	movzwl %ax,%edx
  812303:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812307:	89 d6                	mov    %edx,%esi
  812309:	48 89 c7             	mov    %rax,%rdi
  81230c:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  812313:	00 00 00 
  812316:	ff d0                	callq  *%rax
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  812318:	ba 00 00 00 00       	mov    $0x0,%edx
  81231d:	be 00 00 00 00       	mov    $0x0,%esi
  812322:	bf 02 00 00 00       	mov    $0x2,%edi
  812327:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  81232e:	00 00 00 
  812331:	ff d0                	callq  *%rax
  812333:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (header != NULL) {
  812337:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81233c:	74 58                	je     812396 <ip_frag+0x298>
      pbuf_chain(header, rambuf);
  81233e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  812342:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812346:	48 89 d6             	mov    %rdx,%rsi
  812349:	48 89 c7             	mov    %rax,%rdi
  81234c:	48 b8 39 dd 80 00 00 	movabs $0x80dd39,%rax
  812353:	00 00 00 
  812356:	ff d0                	callq  *%rax
      netif->output(netif, header, dest);
  812358:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81235c:	48 8b 40 20          	mov    0x20(%rax),%rax
  812360:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  812364:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  812368:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  81236c:	48 89 cf             	mov    %rcx,%rdi
  81236f:	ff d0                	callq  *%rax
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  812371:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812375:	48 89 c7             	mov    %rax,%rdi
  812378:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81237f:	00 00 00 
  812382:	ff d0                	callq  *%rax
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  812384:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  812388:	66 29 45 fe          	sub    %ax,-0x2(%rbp)
    ofo += nfb;
  81238c:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  812390:	66 01 45 fc          	add    %ax,-0x4(%rbp)
  812394:	eb 1a                	jmp    8123b0 <ip_frag+0x2b2>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  812396:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81239a:	48 89 c7             	mov    %rax,%rdi
  81239d:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8123a4:	00 00 00 
  8123a7:	ff d0                	callq  *%rax
      return ERR_MEM;
  8123a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8123ae:	eb 23                	jmp    8123d3 <ip_frag+0x2d5>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  8123b0:	66 83 7d fe 00       	cmpw   $0x0,-0x2(%rbp)
  8123b5:	0f 85 60 fe ff ff    	jne    81221b <ip_frag+0x11d>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  8123bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8123bf:	48 89 c7             	mov    %rax,%rdi
  8123c2:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8123c9:	00 00 00 
  8123cc:	ff d0                	callq  *%rax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  8123ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8123d3:	c9                   	leaveq 
  8123d4:	c3                   	retq   

00000000008123d5 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  8123d5:	55                   	push   %rbp
  8123d6:	48 89 e5             	mov    %rsp,%rbp
  8123d9:	48 83 ec 30          	sub    $0x30,%rsp
  8123dd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8123e1:	89 f0                	mov    %esi,%eax
  8123e3:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  8123e7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  8123ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8123f2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (len > 1) {
  8123f6:	eb 35                	jmp    81242d <lwip_standard_chksum+0x58>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  8123f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8123fc:	0f b6 00             	movzbl (%rax),%eax
  8123ff:	0f b6 c0             	movzbl %al,%eax
  812402:	c1 e0 08             	shl    $0x8,%eax
  812405:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    octetptr++;
  812409:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    /* declare second octet as least significant */
    src |= (*octetptr);
  81240e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812412:	0f b6 00             	movzbl (%rax),%eax
  812415:	0f b6 c0             	movzbl %al,%eax
  812418:	66 09 45 ee          	or     %ax,-0x12(%rbp)
    octetptr++;
  81241c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    acc += src;
  812421:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  812425:	01 45 fc             	add    %eax,-0x4(%rbp)
    len -= 2;
  812428:	66 83 6d d4 02       	subw   $0x2,-0x2c(%rbp)
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  81242d:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%rbp)
  812432:	77 c4                	ja     8123f8 <lwip_standard_chksum+0x23>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  812434:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%rbp)
  812439:	74 18                	je     812453 <lwip_standard_chksum+0x7e>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  81243b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81243f:	0f b6 00             	movzbl (%rax),%eax
  812442:	0f b6 c0             	movzbl %al,%eax
  812445:	c1 e0 08             	shl    $0x8,%eax
  812448:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    acc += src;
  81244c:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  812450:	01 45 fc             	add    %eax,-0x4(%rbp)
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  812453:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812456:	c1 e8 10             	shr    $0x10,%eax
  812459:	89 c2                	mov    %eax,%edx
  81245b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81245e:	0f b7 c0             	movzwl %ax,%eax
  812461:	01 d0                	add    %edx,%eax
  812463:	89 45 fc             	mov    %eax,-0x4(%rbp)
  if ((acc & 0xffff0000) != 0) {
  812466:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812469:	66 b8 00 00          	mov    $0x0,%ax
  81246d:	85 c0                	test   %eax,%eax
  81246f:	74 13                	je     812484 <lwip_standard_chksum+0xaf>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  812471:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812474:	c1 e8 10             	shr    $0x10,%eax
  812477:	89 c2                	mov    %eax,%edx
  812479:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81247c:	0f b7 c0             	movzwl %ax,%eax
  81247f:	01 d0                	add    %edx,%eax
  812481:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  812484:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812487:	0f b7 c0             	movzwl %ax,%eax
  81248a:	89 c7                	mov    %eax,%edi
  81248c:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  812493:	00 00 00 
  812496:	ff d0                	callq  *%rax
}
  812498:	c9                   	leaveq 
  812499:	c3                   	retq   

000000000081249a <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  81249a:	55                   	push   %rbp
  81249b:	48 89 e5             	mov    %rsp,%rbp
  81249e:	48 83 ec 40          	sub    $0x40,%rsp
  8124a2:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8124a6:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8124aa:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8124ae:	89 c8                	mov    %ecx,%eax
  8124b0:	44 89 c2             	mov    %r8d,%edx
  8124b3:	88 45 c4             	mov    %al,-0x3c(%rbp)
  8124b6:	66 89 55 c0          	mov    %dx,-0x40(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  8124ba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  8124c1:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8124c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8124c9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8124cd:	eb 7d                	jmp    81254c <inet_chksum_pseudo+0xb2>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  8124cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8124d3:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8124d7:	0f b7 d0             	movzwl %ax,%edx
  8124da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8124de:	48 8b 40 08          	mov    0x8(%rax),%rax
  8124e2:	89 d6                	mov    %edx,%esi
  8124e4:	48 89 c7             	mov    %rax,%rdi
  8124e7:	48 b8 d5 23 81 00 00 	movabs $0x8123d5,%rax
  8124ee:	00 00 00 
  8124f1:	ff d0                	callq  *%rax
  8124f3:	0f b7 c0             	movzwl %ax,%eax
  8124f6:	01 45 fc             	add    %eax,-0x4(%rbp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  8124f9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124fc:	c1 e8 10             	shr    $0x10,%eax
  8124ff:	89 c2                	mov    %eax,%edx
  812501:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812504:	0f b7 c0             	movzwl %ax,%eax
  812507:	01 d0                	add    %edx,%eax
  812509:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  81250c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812510:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812514:	83 e0 01             	and    $0x1,%eax
  812517:	66 85 c0             	test   %ax,%ax
  81251a:	74 25                	je     812541 <inet_chksum_pseudo+0xa7>
      swapped = 1 - swapped;
  81251c:	b8 01 00 00 00       	mov    $0x1,%eax
  812521:	2a 45 ef             	sub    -0x11(%rbp),%al
  812524:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812527:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81252a:	c1 e0 08             	shl    $0x8,%eax
  81252d:	0f b7 c0             	movzwl %ax,%eax
  812530:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812533:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812539:	c1 ea 08             	shr    $0x8,%edx
  81253c:	09 d0                	or     %edx,%eax
  81253e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  812541:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812545:	48 8b 00             	mov    (%rax),%rax
  812548:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81254c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812551:	0f 85 78 ff ff ff    	jne    8124cf <inet_chksum_pseudo+0x35>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  812557:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81255b:	74 1a                	je     812577 <inet_chksum_pseudo+0xdd>
    acc = SWAP_BYTES_IN_WORD(acc);
  81255d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812560:	c1 e0 08             	shl    $0x8,%eax
  812563:	0f b7 c0             	movzwl %ax,%eax
  812566:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812569:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  81256f:	c1 ea 08             	shr    $0x8,%edx
  812572:	09 d0                	or     %edx,%eax
  812574:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  812577:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81257b:	8b 00                	mov    (%rax),%eax
  81257d:	0f b7 c0             	movzwl %ax,%eax
  812580:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  812583:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812587:	8b 00                	mov    (%rax),%eax
  812589:	c1 e8 10             	shr    $0x10,%eax
  81258c:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  81258f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812593:	8b 00                	mov    (%rax),%eax
  812595:	0f b7 c0             	movzwl %ax,%eax
  812598:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  81259b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81259f:	8b 00                	mov    (%rax),%eax
  8125a1:	c1 e8 10             	shr    $0x10,%eax
  8125a4:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  8125a7:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  8125ab:	89 c7                	mov    %eax,%edi
  8125ad:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8125b4:	00 00 00 
  8125b7:	ff d0                	callq  *%rax
  8125b9:	0f b7 c0             	movzwl %ax,%eax
  8125bc:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  8125bf:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  8125c3:	89 c7                	mov    %eax,%edi
  8125c5:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8125cc:	00 00 00 
  8125cf:	ff d0                	callq  *%rax
  8125d1:	0f b7 c0             	movzwl %ax,%eax
  8125d4:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8125d7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8125da:	c1 e8 10             	shr    $0x10,%eax
  8125dd:	89 c2                	mov    %eax,%edx
  8125df:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8125e2:	0f b7 c0             	movzwl %ax,%eax
  8125e5:	01 d0                	add    %edx,%eax
  8125e7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  8125ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8125ed:	c1 e8 10             	shr    $0x10,%eax
  8125f0:	89 c2                	mov    %eax,%edx
  8125f2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8125f5:	0f b7 c0             	movzwl %ax,%eax
  8125f8:	01 d0                	add    %edx,%eax
  8125fa:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8125fd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812600:	f7 d0                	not    %eax
}
  812602:	c9                   	leaveq 
  812603:	c3                   	retq   

0000000000812604 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  812604:	55                   	push   %rbp
  812605:	48 89 e5             	mov    %rsp,%rbp
  812608:	48 83 ec 50          	sub    $0x50,%rsp
  81260c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  812610:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  812614:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  812618:	89 c8                	mov    %ecx,%eax
  81261a:	44 89 c1             	mov    %r8d,%ecx
  81261d:	44 89 ca             	mov    %r9d,%edx
  812620:	88 45 c4             	mov    %al,-0x3c(%rbp)
  812623:	66 89 4d c0          	mov    %cx,-0x40(%rbp)
  812627:	66 89 55 bc          	mov    %dx,-0x44(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  81262b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  812632:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  812636:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81263a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81263e:	e9 ce 00 00 00       	jmpq   812711 <inet_chksum_pseudo_partial+0x10d>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  812643:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812647:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81264b:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    if (chklen > chksum_len) {
  81264f:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  812653:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  812657:	76 08                	jbe    812661 <inet_chksum_pseudo_partial+0x5d>
      chklen = chksum_len;
  812659:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  81265d:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  812661:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  812665:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812669:	48 8b 40 08          	mov    0x8(%rax),%rax
  81266d:	89 d6                	mov    %edx,%esi
  81266f:	48 89 c7             	mov    %rax,%rdi
  812672:	48 b8 d5 23 81 00 00 	movabs $0x8123d5,%rax
  812679:	00 00 00 
  81267c:	ff d0                	callq  *%rax
  81267e:	0f b7 c0             	movzwl %ax,%eax
  812681:	01 45 fc             	add    %eax,-0x4(%rbp)
    chksum_len -= chklen;
  812684:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  812688:	66 29 45 bc          	sub    %ax,-0x44(%rbp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  81268c:	66 81 7d bc fe 7f    	cmpw   $0x7ffe,-0x44(%rbp)
  812692:	76 2a                	jbe    8126be <inet_chksum_pseudo_partial+0xba>
  812694:	48 ba e8 23 82 00 00 	movabs $0x8223e8,%rdx
  81269b:	00 00 00 
  81269e:	be 60 01 00 00       	mov    $0x160,%esi
  8126a3:	48 bf f8 23 82 00 00 	movabs $0x8223f8,%rdi
  8126aa:	00 00 00 
  8126ad:	b8 00 00 00 00       	mov    $0x0,%eax
  8126b2:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8126b9:	00 00 00 
  8126bc:	ff d1                	callq  *%rcx
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  8126be:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8126c1:	c1 e8 10             	shr    $0x10,%eax
  8126c4:	89 c2                	mov    %eax,%edx
  8126c6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8126c9:	0f b7 c0             	movzwl %ax,%eax
  8126cc:	01 d0                	add    %edx,%eax
  8126ce:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  8126d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8126d5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8126d9:	83 e0 01             	and    $0x1,%eax
  8126dc:	66 85 c0             	test   %ax,%ax
  8126df:	74 25                	je     812706 <inet_chksum_pseudo_partial+0x102>
      swapped = 1 - swapped;
  8126e1:	b8 01 00 00 00       	mov    $0x1,%eax
  8126e6:	2a 45 ef             	sub    -0x11(%rbp),%al
  8126e9:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  8126ec:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8126ef:	c1 e0 08             	shl    $0x8,%eax
  8126f2:	0f b7 c0             	movzwl %ax,%eax
  8126f5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8126f8:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8126fe:	c1 ea 08             	shr    $0x8,%edx
  812701:	09 d0                	or     %edx,%eax
  812703:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  812706:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81270a:	48 8b 00             	mov    (%rax),%rax
  81270d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812711:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812716:	74 0b                	je     812723 <inet_chksum_pseudo_partial+0x11f>
  812718:	66 83 7d bc 00       	cmpw   $0x0,-0x44(%rbp)
  81271d:	0f 85 20 ff ff ff    	jne    812643 <inet_chksum_pseudo_partial+0x3f>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  812723:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812727:	74 1a                	je     812743 <inet_chksum_pseudo_partial+0x13f>
    acc = SWAP_BYTES_IN_WORD(acc);
  812729:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81272c:	c1 e0 08             	shl    $0x8,%eax
  81272f:	0f b7 c0             	movzwl %ax,%eax
  812732:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812735:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  81273b:	c1 ea 08             	shr    $0x8,%edx
  81273e:	09 d0                	or     %edx,%eax
  812740:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  812743:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812747:	8b 00                	mov    (%rax),%eax
  812749:	0f b7 c0             	movzwl %ax,%eax
  81274c:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  81274f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812753:	8b 00                	mov    (%rax),%eax
  812755:	c1 e8 10             	shr    $0x10,%eax
  812758:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  81275b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81275f:	8b 00                	mov    (%rax),%eax
  812761:	0f b7 c0             	movzwl %ax,%eax
  812764:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  812767:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81276b:	8b 00                	mov    (%rax),%eax
  81276d:	c1 e8 10             	shr    $0x10,%eax
  812770:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  812773:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  812777:	89 c7                	mov    %eax,%edi
  812779:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  812780:	00 00 00 
  812783:	ff d0                	callq  *%rax
  812785:	0f b7 c0             	movzwl %ax,%eax
  812788:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  81278b:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  81278f:	89 c7                	mov    %eax,%edi
  812791:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  812798:	00 00 00 
  81279b:	ff d0                	callq  *%rax
  81279d:	0f b7 c0             	movzwl %ax,%eax
  8127a0:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8127a3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127a6:	c1 e8 10             	shr    $0x10,%eax
  8127a9:	89 c2                	mov    %eax,%edx
  8127ab:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127ae:	0f b7 c0             	movzwl %ax,%eax
  8127b1:	01 d0                	add    %edx,%eax
  8127b3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  8127b6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127b9:	c1 e8 10             	shr    $0x10,%eax
  8127bc:	89 c2                	mov    %eax,%edx
  8127be:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127c1:	0f b7 c0             	movzwl %ax,%eax
  8127c4:	01 d0                	add    %edx,%eax
  8127c6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8127c9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127cc:	f7 d0                	not    %eax
}
  8127ce:	c9                   	leaveq 
  8127cf:	c3                   	retq   

00000000008127d0 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  8127d0:	55                   	push   %rbp
  8127d1:	48 89 e5             	mov    %rsp,%rbp
  8127d4:	48 83 ec 10          	sub    $0x10,%rsp
  8127d8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8127dc:	89 f0                	mov    %esi,%eax
  8127de:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  return ~LWIP_CHKSUM(dataptr, len);
  8127e2:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
  8127e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8127ea:	89 d6                	mov    %edx,%esi
  8127ec:	48 89 c7             	mov    %rax,%rdi
  8127ef:	48 b8 d5 23 81 00 00 	movabs $0x8123d5,%rax
  8127f6:	00 00 00 
  8127f9:	ff d0                	callq  *%rax
  8127fb:	f7 d0                	not    %eax
}
  8127fd:	c9                   	leaveq 
  8127fe:	c3                   	retq   

00000000008127ff <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  8127ff:	55                   	push   %rbp
  812800:	48 89 e5             	mov    %rsp,%rbp
  812803:	48 83 ec 30          	sub    $0x30,%rsp
  812807:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  81280b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  812812:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  for(q = p; q != NULL; q = q->next) {
  812816:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81281a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81281e:	eb 7d                	jmp    81289d <inet_chksum_pbuf+0x9e>
    acc += LWIP_CHKSUM(q->payload, q->len);
  812820:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812824:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812828:	0f b7 d0             	movzwl %ax,%edx
  81282b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81282f:	48 8b 40 08          	mov    0x8(%rax),%rax
  812833:	89 d6                	mov    %edx,%esi
  812835:	48 89 c7             	mov    %rax,%rdi
  812838:	48 b8 d5 23 81 00 00 	movabs $0x8123d5,%rax
  81283f:	00 00 00 
  812842:	ff d0                	callq  *%rax
  812844:	0f b7 c0             	movzwl %ax,%eax
  812847:	01 45 fc             	add    %eax,-0x4(%rbp)
    acc = FOLD_U32T(acc);
  81284a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81284d:	c1 e8 10             	shr    $0x10,%eax
  812850:	89 c2                	mov    %eax,%edx
  812852:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812855:	0f b7 c0             	movzwl %ax,%eax
  812858:	01 d0                	add    %edx,%eax
  81285a:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  81285d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812861:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812865:	83 e0 01             	and    $0x1,%eax
  812868:	66 85 c0             	test   %ax,%ax
  81286b:	74 25                	je     812892 <inet_chksum_pbuf+0x93>
      swapped = 1 - swapped;
  81286d:	b8 01 00 00 00       	mov    $0x1,%eax
  812872:	2a 45 ef             	sub    -0x11(%rbp),%al
  812875:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812878:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81287b:	c1 e0 08             	shl    $0x8,%eax
  81287e:	0f b7 c0             	movzwl %ax,%eax
  812881:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812884:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  81288a:	c1 ea 08             	shr    $0x8,%edx
  81288d:	09 d0                	or     %edx,%eax
  81288f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  812892:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812896:	48 8b 00             	mov    (%rax),%rax
  812899:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81289d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8128a2:	0f 85 78 ff ff ff    	jne    812820 <inet_chksum_pbuf+0x21>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  8128a8:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8128ac:	74 1a                	je     8128c8 <inet_chksum_pbuf+0xc9>
    acc = SWAP_BYTES_IN_WORD(acc);
  8128ae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8128b1:	c1 e0 08             	shl    $0x8,%eax
  8128b4:	0f b7 c0             	movzwl %ax,%eax
  8128b7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8128ba:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8128c0:	c1 ea 08             	shr    $0x8,%edx
  8128c3:	09 d0                	or     %edx,%eax
  8128c5:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  return (u16_t)~(acc & 0xffffUL);
  8128c8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8128cb:	f7 d0                	not    %eax
}
  8128cd:	c9                   	leaveq 
  8128ce:	c3                   	retq   

00000000008128cf <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  8128cf:	55                   	push   %rbp
  8128d0:	48 89 e5             	mov    %rsp,%rbp
  8128d3:	48 83 ec 20          	sub    $0x20,%rsp
  8128d7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  8128db:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8128df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8128e3:	48 89 d6             	mov    %rdx,%rsi
  8128e6:	48 89 c7             	mov    %rax,%rdi
  8128e9:	48 b8 05 29 81 00 00 	movabs $0x812905,%rax
  8128f0:	00 00 00 
  8128f3:	ff d0                	callq  *%rax
  8128f5:	85 c0                	test   %eax,%eax
  8128f7:	74 05                	je     8128fe <inet_addr+0x2f>
    return (val.s_addr);
  8128f9:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8128fc:	eb 05                	jmp    812903 <inet_addr+0x34>
  }
  return (INADDR_NONE);
  8128fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  812903:	c9                   	leaveq 
  812904:	c3                   	retq   

0000000000812905 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  812905:	55                   	push   %rbp
  812906:	48 89 e5             	mov    %rsp,%rbp
  812909:	48 83 ec 40          	sub    $0x40,%rsp
  81290d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  812911:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  812915:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812919:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  c = *cp;
  81291d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812921:	0f b6 00             	movzbl (%rax),%eax
  812924:	0f be c0             	movsbl %al,%eax
  812927:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  81292a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81292d:	3c 2f                	cmp    $0x2f,%al
  81292f:	76 07                	jbe    812938 <inet_aton+0x33>
  812931:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812934:	3c 39                	cmp    $0x39,%al
  812936:	76 0a                	jbe    812942 <inet_aton+0x3d>
      return (0);
  812938:	b8 00 00 00 00       	mov    $0x0,%eax
  81293d:	e9 68 02 00 00       	jmpq   812baa <inet_aton+0x2a5>
    val = 0;
  812942:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    base = 10;
  812949:	c7 45 f8 0a 00 00 00 	movl   $0xa,-0x8(%rbp)
    if (c == '0') {
  812950:	83 7d f4 30          	cmpl   $0x30,-0xc(%rbp)
  812954:	75 40                	jne    812996 <inet_aton+0x91>
      c = *++cp;
  812956:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  81295b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81295f:	0f b6 00             	movzbl (%rax),%eax
  812962:	0f be c0             	movsbl %al,%eax
  812965:	89 45 f4             	mov    %eax,-0xc(%rbp)
      if (c == 'x' || c == 'X') {
  812968:	83 7d f4 78          	cmpl   $0x78,-0xc(%rbp)
  81296c:	74 06                	je     812974 <inet_aton+0x6f>
  81296e:	83 7d f4 58          	cmpl   $0x58,-0xc(%rbp)
  812972:	75 1b                	jne    81298f <inet_aton+0x8a>
        base = 16;
  812974:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
        c = *++cp;
  81297b:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812980:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812984:	0f b6 00             	movzbl (%rax),%eax
  812987:	0f be c0             	movsbl %al,%eax
  81298a:	89 45 f4             	mov    %eax,-0xc(%rbp)
  81298d:	eb 07                	jmp    812996 <inet_aton+0x91>
      } else
        base = 8;
  81298f:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%rbp)
    }
    for (;;) {
      if (isdigit(c)) {
  812996:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812999:	3c 2f                	cmp    $0x2f,%al
  81299b:	76 2f                	jbe    8129cc <inet_aton+0xc7>
  81299d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8129a0:	3c 39                	cmp    $0x39,%al
  8129a2:	77 28                	ja     8129cc <inet_aton+0xc7>
        val = (val * base) + (int)(c - '0');
  8129a4:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8129a7:	0f af 45 fc          	imul   -0x4(%rbp),%eax
  8129ab:	89 c2                	mov    %eax,%edx
  8129ad:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8129b0:	01 d0                	add    %edx,%eax
  8129b2:	83 e8 30             	sub    $0x30,%eax
  8129b5:	89 45 fc             	mov    %eax,-0x4(%rbp)
        c = *++cp;
  8129b8:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  8129bd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8129c1:	0f b6 00             	movzbl (%rax),%eax
  8129c4:	0f be c0             	movsbl %al,%eax
  8129c7:	89 45 f4             	mov    %eax,-0xc(%rbp)
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
  8129ca:	eb ca                	jmp    812996 <inet_aton+0x91>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
  8129cc:	83 7d f8 10          	cmpl   $0x10,-0x8(%rbp)
  8129d0:	75 72                	jne    812a44 <inet_aton+0x13f>
  8129d2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8129d5:	3c 2f                	cmp    $0x2f,%al
  8129d7:	76 07                	jbe    8129e0 <inet_aton+0xdb>
  8129d9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8129dc:	3c 39                	cmp    $0x39,%al
  8129de:	76 1c                	jbe    8129fc <inet_aton+0xf7>
  8129e0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8129e3:	3c 60                	cmp    $0x60,%al
  8129e5:	76 07                	jbe    8129ee <inet_aton+0xe9>
  8129e7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8129ea:	3c 66                	cmp    $0x66,%al
  8129ec:	76 0e                	jbe    8129fc <inet_aton+0xf7>
  8129ee:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8129f1:	3c 40                	cmp    $0x40,%al
  8129f3:	76 4f                	jbe    812a44 <inet_aton+0x13f>
  8129f5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8129f8:	3c 46                	cmp    $0x46,%al
  8129fa:	77 48                	ja     812a44 <inet_aton+0x13f>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  8129fc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129ff:	c1 e0 04             	shl    $0x4,%eax
  812a02:	89 c2                	mov    %eax,%edx
  812a04:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812a07:	8d 48 0a             	lea    0xa(%rax),%ecx
  812a0a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812a0d:	3c 60                	cmp    $0x60,%al
  812a0f:	76 0e                	jbe    812a1f <inet_aton+0x11a>
  812a11:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812a14:	3c 7a                	cmp    $0x7a,%al
  812a16:	77 07                	ja     812a1f <inet_aton+0x11a>
  812a18:	b8 61 00 00 00       	mov    $0x61,%eax
  812a1d:	eb 05                	jmp    812a24 <inet_aton+0x11f>
  812a1f:	b8 41 00 00 00       	mov    $0x41,%eax
  812a24:	29 c1                	sub    %eax,%ecx
  812a26:	89 c8                	mov    %ecx,%eax
  812a28:	09 d0                	or     %edx,%eax
  812a2a:	89 45 fc             	mov    %eax,-0x4(%rbp)
        c = *++cp;
  812a2d:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812a32:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812a36:	0f b6 00             	movzbl (%rax),%eax
  812a39:	0f be c0             	movsbl %al,%eax
  812a3c:	89 45 f4             	mov    %eax,-0xc(%rbp)
      } else
        break;
    }
  812a3f:	e9 52 ff ff ff       	jmpq   812996 <inet_aton+0x91>
    if (c == '.') {
  812a44:	83 7d f4 2e          	cmpl   $0x2e,-0xc(%rbp)
  812a48:	75 40                	jne    812a8a <inet_aton+0x185>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  812a4a:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812a4e:	48 83 c0 0c          	add    $0xc,%rax
  812a52:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  812a56:	72 0a                	jb     812a62 <inet_aton+0x15d>
        return (0);
  812a58:	b8 00 00 00 00       	mov    $0x0,%eax
  812a5d:	e9 48 01 00 00       	jmpq   812baa <inet_aton+0x2a5>
      *pp++ = val;
  812a62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812a66:	48 8d 50 04          	lea    0x4(%rax),%rdx
  812a6a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  812a6e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812a71:	89 10                	mov    %edx,(%rax)
      c = *++cp;
  812a73:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812a78:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812a7c:	0f b6 00             	movzbl (%rax),%eax
  812a7f:	0f be c0             	movsbl %al,%eax
  812a82:	89 45 f4             	mov    %eax,-0xc(%rbp)
    } else
      break;
  }
  812a85:	e9 a0 fe ff ff       	jmpq   81292a <inet_aton+0x25>
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
      c = *++cp;
    } else
      break;
  812a8a:	90                   	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  812a8b:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  812a8f:	74 3c                	je     812acd <inet_aton+0x1c8>
  812a91:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812a94:	3c 1f                	cmp    $0x1f,%al
  812a96:	76 2b                	jbe    812ac3 <inet_aton+0x1be>
  812a98:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812a9b:	84 c0                	test   %al,%al
  812a9d:	78 24                	js     812ac3 <inet_aton+0x1be>
  812a9f:	83 7d f4 20          	cmpl   $0x20,-0xc(%rbp)
  812aa3:	74 28                	je     812acd <inet_aton+0x1c8>
  812aa5:	83 7d f4 0c          	cmpl   $0xc,-0xc(%rbp)
  812aa9:	74 22                	je     812acd <inet_aton+0x1c8>
  812aab:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  812aaf:	74 1c                	je     812acd <inet_aton+0x1c8>
  812ab1:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  812ab5:	74 16                	je     812acd <inet_aton+0x1c8>
  812ab7:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  812abb:	74 10                	je     812acd <inet_aton+0x1c8>
  812abd:	83 7d f4 0b          	cmpl   $0xb,-0xc(%rbp)
  812ac1:	74 0a                	je     812acd <inet_aton+0x1c8>
    return (0);
  812ac3:	b8 00 00 00 00       	mov    $0x0,%eax
  812ac8:	e9 dd 00 00 00       	jmpq   812baa <inet_aton+0x2a5>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  812acd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  812ad1:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812ad5:	48 29 c2             	sub    %rax,%rdx
  812ad8:	48 89 d0             	mov    %rdx,%rax
  812adb:	48 c1 f8 02          	sar    $0x2,%rax
  812adf:	83 c0 01             	add    $0x1,%eax
  812ae2:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  switch (n) {
  812ae5:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  812ae9:	0f 87 98 00 00 00    	ja     812b87 <inet_aton+0x282>
  812aef:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812af2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  812af9:	00 
  812afa:	48 b8 20 24 82 00 00 	movabs $0x822420,%rax
  812b01:	00 00 00 
  812b04:	48 01 d0             	add    %rdx,%rax
  812b07:	48 8b 00             	mov    (%rax),%rax
  812b0a:	ff e0                	jmpq   *%rax

  case 0:
    return (0);       /* initial nondigit */
  812b0c:	b8 00 00 00 00       	mov    $0x0,%eax
  812b11:	e9 94 00 00 00       	jmpq   812baa <inet_aton+0x2a5>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  812b16:	81 7d fc ff ff ff 00 	cmpl   $0xffffff,-0x4(%rbp)
  812b1d:	76 0a                	jbe    812b29 <inet_aton+0x224>
      return (0);
  812b1f:	b8 00 00 00 00       	mov    $0x0,%eax
  812b24:	e9 81 00 00 00       	jmpq   812baa <inet_aton+0x2a5>
    val |= parts[0] << 24;
  812b29:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812b2c:	c1 e0 18             	shl    $0x18,%eax
  812b2f:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812b32:	eb 53                	jmp    812b87 <inet_aton+0x282>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  812b34:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%rbp)
  812b3b:	76 07                	jbe    812b44 <inet_aton+0x23f>
      return (0);
  812b3d:	b8 00 00 00 00       	mov    $0x0,%eax
  812b42:	eb 66                	jmp    812baa <inet_aton+0x2a5>
    val |= (parts[0] << 24) | (parts[1] << 16);
  812b44:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812b47:	c1 e0 18             	shl    $0x18,%eax
  812b4a:	89 c2                	mov    %eax,%edx
  812b4c:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812b4f:	c1 e0 10             	shl    $0x10,%eax
  812b52:	09 d0                	or     %edx,%eax
  812b54:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812b57:	eb 2e                	jmp    812b87 <inet_aton+0x282>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  812b59:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  812b60:	76 07                	jbe    812b69 <inet_aton+0x264>
      return (0);
  812b62:	b8 00 00 00 00       	mov    $0x0,%eax
  812b67:	eb 41                	jmp    812baa <inet_aton+0x2a5>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  812b69:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812b6c:	c1 e0 18             	shl    $0x18,%eax
  812b6f:	89 c2                	mov    %eax,%edx
  812b71:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812b74:	c1 e0 10             	shl    $0x10,%eax
  812b77:	09 c2                	or     %eax,%edx
  812b79:	8b 45 d8             	mov    -0x28(%rbp),%eax
  812b7c:	c1 e0 08             	shl    $0x8,%eax
  812b7f:	09 d0                	or     %edx,%eax
  812b81:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812b84:	eb 01                	jmp    812b87 <inet_aton+0x282>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
  812b86:	90                   	nop
    if (val > 0xff)
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
  812b87:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  812b8c:	74 17                	je     812ba5 <inet_aton+0x2a0>
    addr->s_addr = htonl(val);
  812b8e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b91:	89 c7                	mov    %eax,%edi
  812b93:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  812b9a:	00 00 00 
  812b9d:	ff d0                	callq  *%rax
  812b9f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  812ba3:	89 02                	mov    %eax,(%rdx)
  return (1);
  812ba5:	b8 01 00 00 00       	mov    $0x1,%eax
}
  812baa:	c9                   	leaveq 
  812bab:	c3                   	retq   

0000000000812bac <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  812bac:	55                   	push   %rbp
  812bad:	48 89 e5             	mov    %rsp,%rbp
  812bb0:	48 83 ec 30          	sub    $0x30,%rsp
  812bb4:	89 7d d0             	mov    %edi,-0x30(%rbp)
  static char str[16];
  u32_t s_addr = addr.s_addr;
  812bb7:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812bba:	89 45 e8             	mov    %eax,-0x18(%rbp)
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  812bbd:	48 b8 60 b6 b4 00 00 	movabs $0xb4b660,%rax
  812bc4:	00 00 00 
  812bc7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  ap = (u8_t *)&s_addr;
  812bcb:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  812bcf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  for(n = 0; n < 4; n++) {
  812bd3:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  812bd7:	e9 e0 00 00 00       	jmpq   812cbc <inet_ntoa+0x110>
    i = 0;
  812bdc:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
    do {
      rem = *ap % (u8_t)10;
  812be0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812be4:	0f b6 08             	movzbl (%rax),%ecx
  812be7:	0f b6 d1             	movzbl %cl,%edx
  812bea:	89 d0                	mov    %edx,%eax
  812bec:	c1 e0 02             	shl    $0x2,%eax
  812bef:	01 d0                	add    %edx,%eax
  812bf1:	c1 e0 03             	shl    $0x3,%eax
  812bf4:	01 d0                	add    %edx,%eax
  812bf6:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  812bfd:	01 d0                	add    %edx,%eax
  812bff:	66 c1 e8 08          	shr    $0x8,%ax
  812c03:	c0 e8 03             	shr    $0x3,%al
  812c06:	88 45 ed             	mov    %al,-0x13(%rbp)
  812c09:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  812c0d:	89 d0                	mov    %edx,%eax
  812c0f:	c1 e0 02             	shl    $0x2,%eax
  812c12:	01 d0                	add    %edx,%eax
  812c14:	01 c0                	add    %eax,%eax
  812c16:	29 c1                	sub    %eax,%ecx
  812c18:	89 c8                	mov    %ecx,%eax
  812c1a:	88 45 ed             	mov    %al,-0x13(%rbp)
      *ap /= (u8_t)10;
  812c1d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812c21:	0f b6 00             	movzbl (%rax),%eax
  812c24:	0f b6 d0             	movzbl %al,%edx
  812c27:	89 d0                	mov    %edx,%eax
  812c29:	c1 e0 02             	shl    $0x2,%eax
  812c2c:	01 d0                	add    %edx,%eax
  812c2e:	c1 e0 03             	shl    $0x3,%eax
  812c31:	01 d0                	add    %edx,%eax
  812c33:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  812c3a:	01 d0                	add    %edx,%eax
  812c3c:	66 c1 e8 08          	shr    $0x8,%ax
  812c40:	89 c2                	mov    %eax,%edx
  812c42:	c0 ea 03             	shr    $0x3,%dl
  812c45:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812c49:	88 10                	mov    %dl,(%rax)
      inv[i++] = '0' + rem;
  812c4b:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  812c4f:	8d 50 01             	lea    0x1(%rax),%edx
  812c52:	88 55 ee             	mov    %dl,-0x12(%rbp)
  812c55:	0f b6 c0             	movzbl %al,%eax
  812c58:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  812c5c:	83 c2 30             	add    $0x30,%edx
  812c5f:	48 98                	cltq   
  812c61:	88 54 05 e0          	mov    %dl,-0x20(%rbp,%rax,1)
    } while(*ap);
  812c65:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812c69:	0f b6 00             	movzbl (%rax),%eax
  812c6c:	84 c0                	test   %al,%al
  812c6e:	0f 85 6c ff ff ff    	jne    812be0 <inet_ntoa+0x34>
    while(i--)
  812c74:	eb 1a                	jmp    812c90 <inet_ntoa+0xe4>
      *rp++ = inv[i];
  812c76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812c7a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  812c7e:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  812c82:	0f b6 55 ee          	movzbl -0x12(%rbp),%edx
  812c86:	48 63 d2             	movslq %edx,%rdx
  812c89:	0f b6 54 15 e0       	movzbl -0x20(%rbp,%rdx,1),%edx
  812c8e:	88 10                	mov    %dl,(%rax)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  812c90:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  812c94:	8d 50 ff             	lea    -0x1(%rax),%edx
  812c97:	88 55 ee             	mov    %dl,-0x12(%rbp)
  812c9a:	84 c0                	test   %al,%al
  812c9c:	75 d8                	jne    812c76 <inet_ntoa+0xca>
      *rp++ = inv[i];
    *rp++ = '.';
  812c9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812ca2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  812ca6:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  812caa:	c6 00 2e             	movb   $0x2e,(%rax)
    ap++;
  812cad:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  812cb2:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  812cb6:	83 c0 01             	add    $0x1,%eax
  812cb9:	88 45 ef             	mov    %al,-0x11(%rbp)
  812cbc:	80 7d ef 03          	cmpb   $0x3,-0x11(%rbp)
  812cc0:	0f 86 16 ff ff ff    	jbe    812bdc <inet_ntoa+0x30>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  812cc6:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
  812ccb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812ccf:	c6 00 00             	movb   $0x0,(%rax)
  return str;
  812cd2:	48 b8 60 b6 b4 00 00 	movabs $0xb4b660,%rax
  812cd9:	00 00 00 
}
  812cdc:	c9                   	leaveq 
  812cdd:	c3                   	retq   

0000000000812cde <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  812cde:	55                   	push   %rbp
  812cdf:	48 89 e5             	mov    %rsp,%rbp
  812ce2:	48 83 ec 04          	sub    $0x4,%rsp
  812ce6:	89 f8                	mov    %edi,%eax
  812ce8:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  812cec:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812cf0:	c1 e0 08             	shl    $0x8,%eax
  812cf3:	89 c2                	mov    %eax,%edx
  812cf5:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812cf9:	66 c1 e8 08          	shr    $0x8,%ax
  812cfd:	09 d0                	or     %edx,%eax
}
  812cff:	c9                   	leaveq 
  812d00:	c3                   	retq   

0000000000812d01 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  812d01:	55                   	push   %rbp
  812d02:	48 89 e5             	mov    %rsp,%rbp
  812d05:	48 83 ec 08          	sub    $0x8,%rsp
  812d09:	89 f8                	mov    %edi,%eax
  812d0b:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return htons(n);
  812d0f:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812d13:	89 c7                	mov    %eax,%edi
  812d15:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  812d1c:	00 00 00 
  812d1f:	ff d0                	callq  *%rax
}
  812d21:	c9                   	leaveq 
  812d22:	c3                   	retq   

0000000000812d23 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  812d23:	55                   	push   %rbp
  812d24:	48 89 e5             	mov    %rsp,%rbp
  812d27:	48 83 ec 04          	sub    $0x4,%rsp
  812d2b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return ((n & 0xff) << 24) |
  812d2e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812d31:	c1 e0 18             	shl    $0x18,%eax
  812d34:	89 c2                	mov    %eax,%edx
    ((n & 0xff00) << 8) |
  812d36:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812d39:	25 00 ff 00 00       	and    $0xff00,%eax
  812d3e:	c1 e0 08             	shl    $0x8,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  812d41:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
  812d43:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812d46:	25 00 00 ff 00       	and    $0xff0000,%eax
  812d4b:	48 c1 e8 08          	shr    $0x8,%rax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  812d4f:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  812d51:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812d54:	c1 e8 18             	shr    $0x18,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  812d57:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  812d59:	c9                   	leaveq 
  812d5a:	c3                   	retq   

0000000000812d5b <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  812d5b:	55                   	push   %rbp
  812d5c:	48 89 e5             	mov    %rsp,%rbp
  812d5f:	48 83 ec 08          	sub    $0x8,%rsp
  812d63:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return htonl(n);
  812d66:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812d69:	89 c7                	mov    %eax,%edi
  812d6b:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  812d72:	00 00 00 
  812d75:	ff d0                	callq  *%rax
}
  812d77:	c9                   	leaveq 
  812d78:	c3                   	retq   

0000000000812d79 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  812d79:	55                   	push   %rbp
  812d7a:	48 89 e5             	mov    %rsp,%rbp
  812d7d:	48 83 ec 20          	sub    $0x20,%rsp
  812d81:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  812d85:	89 f0                	mov    %esi,%eax
  812d87:	88 45 f4             	mov    %al,-0xc(%rbp)
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  812d8a:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  812d8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812d92:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  812d99:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  812d9f:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  812da5:	89 d1                	mov    %edx,%ecx
  812da7:	ba 00 00 00 00       	mov    $0x0,%edx
  812dac:	be 00 00 00 00       	mov    $0x0,%esi
  812db1:	48 89 c7             	mov    %rax,%rdi
  812db4:	48 b8 56 2e 81 00 00 	movabs $0x812e56,%rax
  812dbb:	00 00 00 
  812dbe:	ff d0                	callq  *%rax
}
  812dc0:	c9                   	leaveq 
  812dc1:	c3                   	retq   

0000000000812dc2 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  812dc2:	55                   	push   %rbp
  812dc3:	48 89 e5             	mov    %rsp,%rbp
  812dc6:	48 83 ec 20          	sub    $0x20,%rsp
  812dca:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  812dce:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  812dd2:	89 c8                	mov    %ecx,%eax
  812dd4:	66 89 55 ec          	mov    %dx,-0x14(%rbp)
  812dd8:	88 45 e8             	mov    %al,-0x18(%rbp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  812ddb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812ddf:	8b 40 18             	mov    0x18(%rax),%eax
  812de2:	83 f8 04             	cmp    $0x4,%eax
  812de5:	74 24                	je     812e0b <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
  812de7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812deb:	8b 40 18             	mov    0x18(%rax),%eax
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  812dee:	83 f8 07             	cmp    $0x7,%eax
  812df1:	74 18                	je     812e0b <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  812df3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812df7:	8b 40 18             	mov    0x18(%rax),%eax
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  812dfa:	83 f8 02             	cmp    $0x2,%eax
  812dfd:	74 0c                	je     812e0b <tcp_write+0x49>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
  812dff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812e03:	8b 40 18             	mov    0x18(%rax),%eax
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  812e06:	83 f8 03             	cmp    $0x3,%eax
  812e09:	75 44                	jne    812e4f <tcp_write+0x8d>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  812e0b:	66 83 7d ec 00       	cmpw   $0x0,-0x14(%rbp)
  812e10:	74 36                	je     812e48 <tcp_write+0x86>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  812e12:	0f b6 4d e8          	movzbl -0x18(%rbp),%ecx
  812e16:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  812e1a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  812e1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812e22:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  812e29:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  812e2f:	41 89 c8             	mov    %ecx,%r8d
  812e32:	b9 00 00 00 00       	mov    $0x0,%ecx
  812e37:	48 89 c7             	mov    %rax,%rdi
  812e3a:	48 b8 56 2e 81 00 00 	movabs $0x812e56,%rax
  812e41:	00 00 00 
  812e44:	ff d0                	callq  *%rax
  812e46:	eb 0c                	jmp    812e54 <tcp_write+0x92>
    }
    return ERR_OK;
  812e48:	b8 00 00 00 00       	mov    $0x0,%eax
  812e4d:	eb 05                	jmp    812e54 <tcp_write+0x92>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  812e4f:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  812e54:	c9                   	leaveq 
  812e55:	c3                   	retq   

0000000000812e56 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  812e56:	55                   	push   %rbp
  812e57:	48 89 e5             	mov    %rsp,%rbp
  812e5a:	41 54                	push   %r12
  812e5c:	53                   	push   %rbx
  812e5d:	48 83 ec 70          	sub    $0x70,%rsp
  812e61:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  812e65:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  812e69:	89 c8                	mov    %ecx,%eax
  812e6b:	44 89 c6             	mov    %r8d,%esi
  812e6e:	4c 89 4d 88          	mov    %r9,-0x78(%rbp)
  812e72:	8b 4d 10             	mov    0x10(%rbp),%ecx
  812e75:	66 89 55 9c          	mov    %dx,-0x64(%rbp)
  812e79:	88 45 98             	mov    %al,-0x68(%rbp)
  812e7c:	40 88 75 94          	mov    %sil,-0x6c(%rbp)
  812e80:	88 4d 90             	mov    %cl,-0x70(%rbp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  812e83:	66 83 7d 9c 00       	cmpw   $0x0,-0x64(%rbp)
  812e88:	74 30                	je     812eba <tcp_enqueue+0x64>
  812e8a:	80 7d 90 00          	cmpb   $0x0,-0x70(%rbp)
  812e8e:	74 2a                	je     812eba <tcp_enqueue+0x64>
  812e90:	48 ba 48 24 82 00 00 	movabs $0x822448,%rdx
  812e97:	00 00 00 
  812e9a:	be 90 00 00 00       	mov    $0x90,%esi
  812e9f:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  812ea6:	00 00 00 
  812ea9:	b8 00 00 00 00       	mov    $0x0,%eax
  812eae:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  812eb5:	00 00 00 
  812eb8:	ff d1                	callq  *%rcx
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  812eba:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  812ebf:	74 31                	je     812ef2 <tcp_enqueue+0x9c>
  812ec1:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  812ec6:	74 2a                	je     812ef2 <tcp_enqueue+0x9c>
  812ec8:	48 ba a0 24 82 00 00 	movabs $0x8224a0,%rdx
  812ecf:	00 00 00 
  812ed2:	be 92 00 00 00       	mov    $0x92,%esi
  812ed7:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  812ede:	00 00 00 
  812ee1:	b8 00 00 00 00       	mov    $0x0,%eax
  812ee6:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  812eed:	00 00 00 
  812ef0:	ff d1                	callq  *%rcx
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  812ef2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812ef6:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  812efa:	66 3b 45 9c          	cmp    -0x64(%rbp),%ax
  812efe:	73 1e                	jae    812f1e <tcp_enqueue+0xc8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  812f00:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f04:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  812f08:	83 c8 80             	or     $0xffffff80,%eax
  812f0b:	89 c2                	mov    %eax,%edx
  812f0d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f11:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  812f14:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  812f19:	e9 e5 09 00 00       	jmpq   813903 <tcp_enqueue+0xaad>
  }
  left = len;
  812f1e:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  812f22:	66 89 45 d2          	mov    %ax,-0x2e(%rbp)
  ptr = arg;
  812f26:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  812f2a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  812f2e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f32:	8b 40 74             	mov    0x74(%rax),%eax
  812f35:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  812f38:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f3c:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  812f40:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  812f44:	66 83 7d c6 1f       	cmpw   $0x1f,-0x3a(%rbp)
  812f49:	77 07                	ja     812f52 <tcp_enqueue+0xfc>
  812f4b:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  812f50:	76 1e                	jbe    812f70 <tcp_enqueue+0x11a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  812f52:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f56:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  812f5a:	83 c8 80             	or     $0xffffff80,%eax
  812f5d:	89 c2                	mov    %eax,%edx
  812f5f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f63:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  812f66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  812f6b:	e9 93 09 00 00       	jmpq   813903 <tcp_enqueue+0xaad>
  }
  if (queuelen != 0) {
  812f70:	66 83 7d c6 00       	cmpw   $0x0,-0x3a(%rbp)
  812f75:	74 4e                	je     812fc5 <tcp_enqueue+0x16f>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  812f77:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f7b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  812f82:	48 85 c0             	test   %rax,%rax
  812f85:	0f 85 84 00 00 00    	jne    81300f <tcp_enqueue+0x1b9>
  812f8b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f8f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  812f96:	48 85 c0             	test   %rax,%rax
  812f99:	75 74                	jne    81300f <tcp_enqueue+0x1b9>
  812f9b:	48 ba e8 24 82 00 00 	movabs $0x8224e8,%rdx
  812fa2:	00 00 00 
  812fa5:	be ae 00 00 00       	mov    $0xae,%esi
  812faa:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  812fb1:	00 00 00 
  812fb4:	b8 00 00 00 00       	mov    $0x0,%eax
  812fb9:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  812fc0:	00 00 00 
  812fc3:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  812fc5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812fc9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  812fd0:	48 85 c0             	test   %rax,%rax
  812fd3:	75 10                	jne    812fe5 <tcp_enqueue+0x18f>
  812fd5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812fd9:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  812fe0:	48 85 c0             	test   %rax,%rax
  812fe3:	74 2a                	je     81300f <tcp_enqueue+0x1b9>
  812fe5:	48 ba 28 25 82 00 00 	movabs $0x822528,%rdx
  812fec:	00 00 00 
  812fef:	be b1 00 00 00       	mov    $0xb1,%esi
  812ff4:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  812ffb:	00 00 00 
  812ffe:	b8 00 00 00 00       	mov    $0x0,%eax
  813003:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81300a:	00 00 00 
  81300d:	ff d1                	callq  *%rcx
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  81300f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  813016:	00 
  813017:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81301b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81301f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813023:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  seglen = 0;
  813027:	66 c7 45 d0 00 00    	movw   $0x0,-0x30(%rbp)
  while (queue == NULL || left > 0) {
  81302d:	e9 f9 04 00 00       	jmpq   81352b <tcp_enqueue+0x6d5>

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  813032:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813036:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81303a:	0f b7 45 d2          	movzwl -0x2e(%rbp),%eax
  81303e:	66 39 c2             	cmp    %ax,%dx
  813041:	0f 46 c2             	cmovbe %edx,%eax
  813044:	66 89 45 d0          	mov    %ax,-0x30(%rbp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  813048:	bf 04 00 00 00       	mov    $0x4,%edi
  81304d:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  813054:	00 00 00 
  813057:	ff d0                	callq  *%rax
  813059:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (seg == NULL) {
  81305d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813062:	75 05                	jne    813069 <tcp_enqueue+0x213>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
  813064:	e9 10 08 00 00       	jmpq   813879 <tcp_enqueue+0xa23>
    }
    seg->next = NULL;
  813069:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81306d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    seg->p = NULL;
  813074:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813078:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81307f:	00 

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  813080:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813085:	75 0a                	jne    813091 <tcp_enqueue+0x23b>
      queue = seg;
  813087:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81308b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81308f:	eb 3c                	jmp    8130cd <tcp_enqueue+0x277>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  813091:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813096:	75 2a                	jne    8130c2 <tcp_enqueue+0x26c>
  813098:	48 ba 5c 25 82 00 00 	movabs $0x82255c,%rdx
  81309f:	00 00 00 
  8130a2:	be ce 00 00 00       	mov    $0xce,%esi
  8130a7:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  8130ae:	00 00 00 
  8130b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8130b6:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8130bd:	00 00 00 
  8130c0:	ff d1                	callq  *%rcx
      useg->next = seg;
  8130c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8130c6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8130ca:	48 89 10             	mov    %rdx,(%rax)
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
  8130cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8130d1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  8130d5:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  8130da:	0f 84 ac 00 00 00    	je     81318c <tcp_enqueue+0x336>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  8130e0:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  8130e4:	ba 00 00 00 00       	mov    $0x0,%edx
  8130e9:	89 c6                	mov    %eax,%esi
  8130eb:	bf 00 00 00 00       	mov    $0x0,%edi
  8130f0:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  8130f7:	00 00 00 
  8130fa:	ff d0                	callq  *%rax
  8130fc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813100:	48 89 42 08          	mov    %rax,0x8(%rdx)
  813104:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813108:	48 8b 40 08          	mov    0x8(%rax),%rax
  81310c:	48 85 c0             	test   %rax,%rax
  81310f:	75 05                	jne    813116 <tcp_enqueue+0x2c0>
        goto memerr;
  813111:	e9 63 07 00 00       	jmpq   813879 <tcp_enqueue+0xa23>
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  813116:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81311a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81311e:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  813122:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  813126:	66 39 c2             	cmp    %ax,%dx
  813129:	73 2a                	jae    813155 <tcp_enqueue+0x2ff>
  81312b:	48 ba 70 25 82 00 00 	movabs $0x822570,%rdx
  813132:	00 00 00 
  813135:	be df 00 00 00       	mov    $0xdf,%esi
  81313a:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  813141:	00 00 00 
  813144:	b8 00 00 00 00       	mov    $0x0,%eax
  813149:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  813150:	00 00 00 
  813153:	ff d1                	callq  *%rcx
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  813155:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813159:	48 8b 40 08          	mov    0x8(%rax),%rax
  81315d:	48 89 c7             	mov    %rax,%rdi
  813160:	48 b8 c4 db 80 00 00 	movabs $0x80dbc4,%rax
  813167:	00 00 00 
  81316a:	ff d0                	callq  *%rax
  81316c:	0f b6 c0             	movzbl %al,%eax
  81316f:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      seg->dataptr = seg->p->payload;
  813173:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813177:	48 8b 40 08          	mov    0x8(%rax),%rax
  81317b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81317f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813183:	48 89 50 10          	mov    %rdx,0x10(%rax)
  813187:	e9 ba 01 00 00       	jmpq   813346 <tcp_enqueue+0x4f0>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  81318c:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  813190:	83 e0 01             	and    $0x1,%eax
  813193:	85 c0                	test   %eax,%eax
  813195:	0f 84 d6 00 00 00    	je     813271 <tcp_enqueue+0x41b>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  81319b:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  81319f:	ba 00 00 00 00       	mov    $0x0,%edx
  8131a4:	89 c6                	mov    %eax,%esi
  8131a6:	bf 00 00 00 00       	mov    $0x0,%edi
  8131ab:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  8131b2:	00 00 00 
  8131b5:	ff d0                	callq  *%rax
  8131b7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8131bb:	48 89 42 08          	mov    %rax,0x8(%rdx)
  8131bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8131c3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8131c7:	48 85 c0             	test   %rax,%rax
  8131ca:	75 05                	jne    8131d1 <tcp_enqueue+0x37b>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
  8131cc:	e9 a8 06 00 00       	jmpq   813879 <tcp_enqueue+0xa23>
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  8131d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8131d5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8131d9:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8131dd:	66 3b 45 d0          	cmp    -0x30(%rbp),%ax
  8131e1:	73 2a                	jae    81320d <tcp_enqueue+0x3b7>
  8131e3:	48 ba 98 25 82 00 00 	movabs $0x822598,%rdx
  8131ea:	00 00 00 
  8131ed:	be ea 00 00 00       	mov    $0xea,%esi
  8131f2:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  8131f9:	00 00 00 
  8131fc:	b8 00 00 00 00       	mov    $0x0,%eax
  813201:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  813208:	00 00 00 
  81320b:	ff d1                	callq  *%rcx
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  81320d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813211:	48 8b 40 08          	mov    0x8(%rax),%rax
  813215:	48 89 c7             	mov    %rax,%rdi
  813218:	48 b8 c4 db 80 00 00 	movabs $0x80dbc4,%rax
  81321f:	00 00 00 
  813222:	ff d0                	callq  *%rax
  813224:	0f b6 c0             	movzbl %al,%eax
  813227:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      if (arg != NULL) {
  81322b:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  813230:	74 26                	je     813258 <tcp_enqueue+0x402>
        MEMCPY(seg->p->payload, ptr, seglen);
  813232:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  813236:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81323a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81323e:	48 8b 40 08          	mov    0x8(%rax),%rax
  813242:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  813246:	48 89 ce             	mov    %rcx,%rsi
  813249:	48 89 c7             	mov    %rax,%rdi
  81324c:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  813253:	00 00 00 
  813256:	ff d0                	callq  *%rax
      }
      seg->dataptr = seg->p->payload;
  813258:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81325c:	48 8b 40 08          	mov    0x8(%rax),%rax
  813260:	48 8b 50 08          	mov    0x8(%rax),%rdx
  813264:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813268:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81326c:	e9 d5 00 00 00       	jmpq   813346 <tcp_enqueue+0x4f0>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  813271:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813275:	ba 01 00 00 00       	mov    $0x1,%edx
  81327a:	89 c6                	mov    %eax,%esi
  81327c:	bf 00 00 00 00       	mov    $0x0,%edi
  813281:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  813288:	00 00 00 
  81328b:	ff d0                	callq  *%rax
  81328d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  813291:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  813296:	75 05                	jne    81329d <tcp_enqueue+0x447>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
  813298:	e9 dc 05 00 00       	jmpq   813879 <tcp_enqueue+0xa23>
      }
      ++queuelen;
  81329d:	66 83 45 c6 01       	addw   $0x1,-0x3a(%rbp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  8132a2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8132a6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8132aa:	48 89 50 08          	mov    %rdx,0x8(%rax)
      seg->dataptr = ptr;
  8132ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8132b2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8132b6:	48 89 50 10          	mov    %rdx,0x10(%rax)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  8132ba:	ba 00 00 00 00       	mov    $0x0,%edx
  8132bf:	be 00 00 00 00       	mov    $0x0,%esi
  8132c4:	bf 00 00 00 00       	mov    $0x0,%edi
  8132c9:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  8132d0:	00 00 00 
  8132d3:	ff d0                	callq  *%rax
  8132d5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8132d9:	48 89 42 08          	mov    %rax,0x8(%rdx)
  8132dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8132e1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8132e5:	48 85 c0             	test   %rax,%rax
  8132e8:	75 18                	jne    813302 <tcp_enqueue+0x4ac>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  8132ea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8132ee:	48 89 c7             	mov    %rax,%rdi
  8132f1:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8132f8:	00 00 00 
  8132fb:	ff d0                	callq  *%rax
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  8132fd:	e9 77 05 00 00       	jmpq   813879 <tcp_enqueue+0xa23>
      }
      queuelen += pbuf_clen(seg->p);
  813302:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813306:	48 8b 40 08          	mov    0x8(%rax),%rax
  81330a:	48 89 c7             	mov    %rax,%rdi
  81330d:	48 b8 c4 db 80 00 00 	movabs $0x80dbc4,%rax
  813314:	00 00 00 
  813317:	ff d0                	callq  *%rax
  813319:	0f b6 c0             	movzbl %al,%eax
  81331c:	66 01 45 c6          	add    %ax,-0x3a(%rbp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  813320:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813324:	48 8b 40 08          	mov    0x8(%rax),%rax
  813328:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81332c:	48 89 d6             	mov    %rdx,%rsi
  81332f:	48 89 c7             	mov    %rax,%rdi
  813332:	48 b8 1a dc 80 00 00 	movabs $0x80dc1a,%rax
  813339:	00 00 00 
  81333c:	ff d0                	callq  *%rax
      p = NULL;
  81333e:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  813345:	00 
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  813346:	66 83 7d c6 20       	cmpw   $0x20,-0x3a(%rbp)
  81334b:	77 07                	ja     813354 <tcp_enqueue+0x4fe>
  81334d:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  813352:	76 05                	jbe    813359 <tcp_enqueue+0x503>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
  813354:	e9 20 05 00 00       	jmpq   813879 <tcp_enqueue+0xa23>
    }

    seg->len = seglen;
  813359:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81335d:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  813361:	66 89 50 18          	mov    %dx,0x18(%rax)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  813365:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813369:	48 8b 40 08          	mov    0x8(%rax),%rax
  81336d:	be 14 00 00 00       	mov    $0x14,%esi
  813372:	48 89 c7             	mov    %rax,%rdi
  813375:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  81337c:	00 00 00 
  81337f:	ff d0                	callq  *%rax
  813381:	84 c0                	test   %al,%al
  813383:	74 05                	je     81338a <tcp_enqueue+0x534>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
  813385:	e9 ef 04 00 00       	jmpq   813879 <tcp_enqueue+0xa23>
    }
    seg->tcphdr = seg->p->payload;
  81338a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81338e:	48 8b 40 08          	mov    0x8(%rax),%rax
  813392:	48 8b 50 08          	mov    0x8(%rax),%rdx
  813396:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81339a:	48 89 50 20          	mov    %rdx,0x20(%rax)
    seg->tcphdr->src = htons(pcb->local_port);
  81339e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8133a2:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8133a6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8133aa:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8133ae:	0f b7 c0             	movzwl %ax,%eax
  8133b1:	89 c7                	mov    %eax,%edi
  8133b3:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8133ba:	00 00 00 
  8133bd:	ff d0                	callq  *%rax
  8133bf:	66 89 03             	mov    %ax,(%rbx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  8133c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8133c6:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8133ca:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8133ce:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  8133d2:	0f b7 c0             	movzwl %ax,%eax
  8133d5:	89 c7                	mov    %eax,%edi
  8133d7:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8133de:	00 00 00 
  8133e1:	ff d0                	callq  *%rax
  8133e3:	66 89 43 02          	mov    %ax,0x2(%rbx)
    seg->tcphdr->seqno = htonl(seqno);
  8133e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8133eb:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8133ef:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8133f2:	89 c7                	mov    %eax,%edi
  8133f4:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  8133fb:	00 00 00 
  8133fe:	ff d0                	callq  *%rax
  813400:	89 43 04             	mov    %eax,0x4(%rbx)
    seg->tcphdr->urgp = 0;
  813403:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813407:	48 8b 40 20          	mov    0x20(%rax),%rax
  81340b:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  813411:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813415:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813419:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81341d:	48 8b 40 20          	mov    0x20(%rax),%rax
  813421:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813425:	0f b7 c0             	movzwl %ax,%eax
  813428:	89 c7                	mov    %eax,%edi
  81342a:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813431:	00 00 00 
  813434:	ff d0                	callq  *%rax
  813436:	83 e0 c0             	and    $0xffffffc0,%eax
  813439:	89 c2                	mov    %eax,%edx
  81343b:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  81343f:	09 d0                	or     %edx,%eax
  813441:	0f b7 c0             	movzwl %ax,%eax
  813444:	89 c7                	mov    %eax,%edi
  813446:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  81344d:	00 00 00 
  813450:	ff d0                	callq  *%rax
  813452:	66 89 43 0c          	mov    %ax,0xc(%rbx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  813456:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  81345b:	75 42                	jne    81349f <tcp_enqueue+0x649>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  81345d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813461:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813465:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813469:	48 8b 40 20          	mov    0x20(%rax),%rax
  81346d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813471:	0f b7 c0             	movzwl %ax,%eax
  813474:	89 c7                	mov    %eax,%edi
  813476:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81347d:	00 00 00 
  813480:	ff d0                	callq  *%rax
  813482:	83 e0 3f             	and    $0x3f,%eax
  813485:	80 cc 50             	or     $0x50,%ah
  813488:	0f b7 c0             	movzwl %ax,%eax
  81348b:	89 c7                	mov    %eax,%edi
  81348d:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  813494:	00 00 00 
  813497:	ff d0                	callq  *%rax
  813499:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  81349d:	eb 75                	jmp    813514 <tcp_enqueue+0x6be>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  81349f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134a3:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8134a7:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  8134ab:	c0 e8 02             	shr    $0x2,%al
  8134ae:	0f b6 c0             	movzbl %al,%eax
  8134b1:	83 c0 05             	add    $0x5,%eax
  8134b4:	c1 e0 0c             	shl    $0xc,%eax
  8134b7:	41 89 c4             	mov    %eax,%r12d
  8134ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134be:	48 8b 40 20          	mov    0x20(%rax),%rax
  8134c2:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8134c6:	0f b7 c0             	movzwl %ax,%eax
  8134c9:	89 c7                	mov    %eax,%edi
  8134cb:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8134d2:	00 00 00 
  8134d5:	ff d0                	callq  *%rax
  8134d7:	83 e0 3f             	and    $0x3f,%eax
  8134da:	44 09 e0             	or     %r12d,%eax
  8134dd:	0f b7 c0             	movzwl %ax,%eax
  8134e0:	89 c7                	mov    %eax,%edi
  8134e2:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8134e9:	00 00 00 
  8134ec:	ff d0                	callq  *%rax
  8134ee:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  8134f2:	0f b6 55 90          	movzbl -0x70(%rbp),%edx
  8134f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134fa:	48 8b 40 10          	mov    0x10(%rax),%rax
  8134fe:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  813502:	48 89 ce             	mov    %rcx,%rsi
  813505:	48 89 c7             	mov    %rax,%rdi
  813508:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  81350f:	00 00 00 
  813512:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  813514:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813518:	66 29 45 d2          	sub    %ax,-0x2e(%rbp)
    seqno += seglen;
  81351c:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813520:	01 45 d4             	add    %eax,-0x2c(%rbp)
    ptr = (void *)((u8_t *)ptr + seglen);
  813523:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813527:	48 01 45 c8          	add    %rax,-0x38(%rbp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  81352b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813530:	0f 84 fc fa ff ff    	je     813032 <tcp_enqueue+0x1dc>
  813536:	66 83 7d d2 00       	cmpw   $0x0,-0x2e(%rbp)
  81353b:	0f 85 f1 fa ff ff    	jne    813032 <tcp_enqueue+0x1dc>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  813541:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813545:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81354c:	48 85 c0             	test   %rax,%rax
  81354f:	75 0a                	jne    81355b <tcp_enqueue+0x705>
    useg = NULL;
  813551:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  813558:	00 
  813559:	eb 28                	jmp    813583 <tcp_enqueue+0x72d>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  81355b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81355f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813566:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81356a:	eb 0b                	jmp    813577 <tcp_enqueue+0x721>
  81356c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813570:	48 8b 00             	mov    (%rax),%rax
  813573:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813577:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81357b:	48 8b 00             	mov    (%rax),%rax
  81357e:	48 85 c0             	test   %rax,%rax
  813581:	75 e9                	jne    81356c <tcp_enqueue+0x716>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  813583:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813588:	0f 84 94 01 00 00    	je     813722 <tcp_enqueue+0x8cc>
    TCP_TCPLEN(useg) != 0 &&
  81358e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813592:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813596:	0f b7 d8             	movzwl %ax,%ebx
  813599:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81359d:	48 8b 40 20          	mov    0x20(%rax),%rax
  8135a1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8135a5:	0f b7 c0             	movzwl %ax,%eax
  8135a8:	89 c7                	mov    %eax,%edi
  8135aa:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8135b1:	00 00 00 
  8135b4:	ff d0                	callq  *%rax
  8135b6:	0f b7 c0             	movzwl %ax,%eax
  8135b9:	83 e0 01             	and    $0x1,%eax
  8135bc:	85 c0                	test   %eax,%eax
  8135be:	75 27                	jne    8135e7 <tcp_enqueue+0x791>
  8135c0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8135c4:	48 8b 40 20          	mov    0x20(%rax),%rax
  8135c8:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8135cc:	0f b7 c0             	movzwl %ax,%eax
  8135cf:	89 c7                	mov    %eax,%edi
  8135d1:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8135d8:	00 00 00 
  8135db:	ff d0                	callq  *%rax
  8135dd:	0f b7 c0             	movzwl %ax,%eax
  8135e0:	83 e0 02             	and    $0x2,%eax
  8135e3:	85 c0                	test   %eax,%eax
  8135e5:	74 07                	je     8135ee <tcp_enqueue+0x798>
  8135e7:	b8 01 00 00 00       	mov    $0x1,%eax
  8135ec:	eb 05                	jmp    8135f3 <tcp_enqueue+0x79d>
  8135ee:	b8 00 00 00 00       	mov    $0x0,%eax
  8135f3:	01 d8                	add    %ebx,%eax
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  8135f5:	85 c0                	test   %eax,%eax
  8135f7:	0f 84 25 01 00 00    	je     813722 <tcp_enqueue+0x8cc>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  8135fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813601:	48 8b 40 20          	mov    0x20(%rax),%rax
  813605:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813609:	0f b7 c0             	movzwl %ax,%eax
  81360c:	89 c7                	mov    %eax,%edi
  81360e:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813615:	00 00 00 
  813618:	ff d0                	callq  *%rax
  81361a:	0f b7 c0             	movzwl %ax,%eax
  81361d:	83 e0 03             	and    $0x3,%eax
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  813620:	85 c0                	test   %eax,%eax
  813622:	0f 85 fa 00 00 00    	jne    813722 <tcp_enqueue+0x8cc>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  813628:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  81362c:	83 e0 03             	and    $0x3,%eax

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  81362f:	85 c0                	test   %eax,%eax
  813631:	0f 85 eb 00 00 00    	jne    813722 <tcp_enqueue+0x8cc>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  813637:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81363b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81363f:	0f b7 d0             	movzwl %ax,%edx
  813642:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813646:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81364a:	0f b7 c0             	movzwl %ax,%eax
  81364d:	01 c2                	add    %eax,%edx
  81364f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813653:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  813657:	0f b7 c0             	movzwl %ax,%eax
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  81365a:	39 c2                	cmp    %eax,%edx
  81365c:	0f 8f c0 00 00 00    	jg     813722 <tcp_enqueue+0x8cc>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  813662:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813666:	48 8b 40 08          	mov    0x8(%rax),%rax
  81366a:	be ec ff ff ff       	mov    $0xffffffec,%esi
  81366f:	48 89 c7             	mov    %rax,%rdi
  813672:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  813679:	00 00 00 
  81367c:	ff d0                	callq  *%rax
  81367e:	84 c0                	test   %al,%al
  813680:	74 2a                	je     8136ac <tcp_enqueue+0x856>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  813682:	48 ba cb 25 82 00 00 	movabs $0x8225cb,%rdx
  813689:	00 00 00 
  81368c:	be 52 01 00 00       	mov    $0x152,%esi
  813691:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  813698:	00 00 00 
  81369b:	b8 00 00 00 00       	mov    $0x0,%eax
  8136a0:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8136a7:	00 00 00 
  8136aa:	ff d1                	callq  *%rcx
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  8136ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8136b0:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8136b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8136b8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8136bc:	48 89 d6             	mov    %rdx,%rsi
  8136bf:	48 89 c7             	mov    %rax,%rdi
  8136c2:	48 b8 1a dc 80 00 00 	movabs $0x80dc1a,%rax
  8136c9:	00 00 00 
  8136cc:	ff d0                	callq  *%rax
    useg->len += queue->len;
  8136ce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8136d2:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  8136d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8136da:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8136de:	01 c2                	add    %eax,%edx
  8136e0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8136e4:	66 89 50 18          	mov    %dx,0x18(%rax)
    useg->next = queue->next;
  8136e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8136ec:	48 8b 10             	mov    (%rax),%rdx
  8136ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8136f3:	48 89 10             	mov    %rdx,(%rax)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  8136f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136fa:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8136fe:	75 08                	jne    813708 <tcp_enqueue+0x8b2>
      seg = NULL;
  813700:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  813707:	00 
    }
    memp_free(MEMP_TCP_SEG, queue);
  813708:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81370c:	48 89 c6             	mov    %rax,%rsi
  81370f:	bf 04 00 00 00       	mov    $0x4,%edi
  813714:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81371b:	00 00 00 
  81371e:	ff d0                	callq  *%rax
  813720:	eb 23                	jmp    813745 <tcp_enqueue+0x8ef>
  }
  else {
    /* empty list */
    if (useg == NULL) {
  813722:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813727:	75 11                	jne    81373a <tcp_enqueue+0x8e4>
      /* initialize list with this segment */
      pcb->unsent = queue;
  813729:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81372d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813731:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  813738:	eb 0b                	jmp    813745 <tcp_enqueue+0x8ef>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  81373a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81373e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813742:	48 89 10             	mov    %rdx,(%rax)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  813745:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813749:	83 e0 02             	and    $0x2,%eax
  81374c:	85 c0                	test   %eax,%eax
  81374e:	75 0b                	jne    81375b <tcp_enqueue+0x905>
  813750:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813754:	83 e0 01             	and    $0x1,%eax
  813757:	85 c0                	test   %eax,%eax
  813759:	74 05                	je     813760 <tcp_enqueue+0x90a>
    ++len;
  81375b:	66 83 45 9c 01       	addw   $0x1,-0x64(%rbp)
  }
  if (flags & TCP_FIN) {
  813760:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813764:	83 e0 01             	and    $0x1,%eax
  813767:	85 c0                	test   %eax,%eax
  813769:	74 14                	je     81377f <tcp_enqueue+0x929>
    pcb->flags |= TF_FIN;
  81376b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81376f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813773:	83 c8 20             	or     $0x20,%eax
  813776:	89 c2                	mov    %eax,%edx
  813778:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81377c:	88 50 2c             	mov    %dl,0x2c(%rax)
  }
  pcb->snd_lbb += len;
  81377f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813783:	8b 50 74             	mov    0x74(%rax),%edx
  813786:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  81378a:	01 c2                	add    %eax,%edx
  81378c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813790:	89 50 74             	mov    %edx,0x74(%rax)

  pcb->snd_buf -= len;
  813793:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813797:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81379b:	66 2b 45 9c          	sub    -0x64(%rbp),%ax
  81379f:	89 c2                	mov    %eax,%edx
  8137a1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8137a5:	66 89 50 7a          	mov    %dx,0x7a(%rax)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  8137a9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8137ad:	0f b7 55 c6          	movzwl -0x3a(%rbp),%edx
  8137b1:	66 89 50 7c          	mov    %dx,0x7c(%rax)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  8137b5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8137b9:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  8137bd:	66 85 c0             	test   %ax,%ax
  8137c0:	74 4a                	je     81380c <tcp_enqueue+0x9b6>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  8137c2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8137c6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8137cd:	48 85 c0             	test   %rax,%rax
  8137d0:	75 3a                	jne    81380c <tcp_enqueue+0x9b6>
  8137d2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8137d6:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8137dd:	48 85 c0             	test   %rax,%rax
  8137e0:	75 2a                	jne    81380c <tcp_enqueue+0x9b6>
  8137e2:	48 ba e0 25 82 00 00 	movabs $0x8225e0,%rdx
  8137e9:	00 00 00 
  8137ec:	be 7a 01 00 00       	mov    $0x17a,%esi
  8137f1:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  8137f8:	00 00 00 
  8137fb:	b8 00 00 00 00       	mov    $0x0,%eax
  813800:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  813807:	00 00 00 
  81380a:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  81380c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813811:	74 5c                	je     81386f <tcp_enqueue+0xa19>
  813813:	66 83 7d d0 00       	cmpw   $0x0,-0x30(%rbp)
  813818:	74 55                	je     81386f <tcp_enqueue+0xa19>
  81381a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81381e:	48 8b 40 20          	mov    0x20(%rax),%rax
  813822:	48 85 c0             	test   %rax,%rax
  813825:	74 48                	je     81386f <tcp_enqueue+0xa19>
  813827:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  81382b:	83 e0 02             	and    $0x2,%eax
  81382e:	85 c0                	test   %eax,%eax
  813830:	75 3d                	jne    81386f <tcp_enqueue+0xa19>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  813832:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813836:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81383a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81383e:	48 8b 40 20          	mov    0x20(%rax),%rax
  813842:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813846:	0f b7 c0             	movzwl %ax,%eax
  813849:	89 c7                	mov    %eax,%edi
  81384b:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813852:	00 00 00 
  813855:	ff d0                	callq  *%rax
  813857:	83 c8 08             	or     $0x8,%eax
  81385a:	0f b7 c0             	movzwl %ax,%eax
  81385d:	89 c7                	mov    %eax,%edi
  81385f:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  813866:	00 00 00 
  813869:	ff d0                	callq  *%rax
  81386b:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  }

  return ERR_OK;
  81386f:	b8 00 00 00 00       	mov    $0x0,%eax
  813874:	e9 8a 00 00 00       	jmpq   813903 <tcp_enqueue+0xaad>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  813879:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81387d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813881:	83 c8 80             	or     $0xffffff80,%eax
  813884:	89 c2                	mov    %eax,%edx
  813886:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81388a:	88 50 2c             	mov    %dl,0x2c(%rax)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  81388d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813892:	74 13                	je     8138a7 <tcp_enqueue+0xa51>
    tcp_segs_free(queue);
  813894:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813898:	48 89 c7             	mov    %rax,%rdi
  81389b:	48 b8 03 01 81 00 00 	movabs $0x810103,%rax
  8138a2:	00 00 00 
  8138a5:	ff d0                	callq  *%rax
  }
  if (pcb->snd_queuelen != 0) {
  8138a7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8138ab:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  8138af:	66 85 c0             	test   %ax,%ax
  8138b2:	74 4a                	je     8138fe <tcp_enqueue+0xaa8>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  8138b4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8138b8:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8138bf:	48 85 c0             	test   %rax,%rax
  8138c2:	75 3a                	jne    8138fe <tcp_enqueue+0xaa8>
  8138c4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8138c8:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8138cf:	48 85 c0             	test   %rax,%rax
  8138d2:	75 2a                	jne    8138fe <tcp_enqueue+0xaa8>
  8138d4:	48 ba e0 25 82 00 00 	movabs $0x8225e0,%rdx
  8138db:	00 00 00 
  8138de:	be 8d 01 00 00       	mov    $0x18d,%esi
  8138e3:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  8138ea:	00 00 00 
  8138ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8138f2:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8138f9:	00 00 00 
  8138fc:	ff d1                	callq  *%rcx
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  8138fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  813903:	48 83 c4 70          	add    $0x70,%rsp
  813907:	5b                   	pop    %rbx
  813908:	41 5c                	pop    %r12
  81390a:	5d                   	pop    %rbp
  81390b:	c3                   	retq   

000000000081390c <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  81390c:	55                   	push   %rbp
  81390d:	48 89 e5             	mov    %rsp,%rbp
  813910:	41 54                	push   %r12
  813912:	53                   	push   %rbx
  813913:	48 83 ec 40          	sub    $0x40,%rsp
  813917:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  81391b:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  813922:	00 00 00 
  813925:	48 8b 00             	mov    (%rax),%rax
  813928:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  81392c:	75 0a                	jne    813938 <tcp_output+0x2c>
    return ERR_OK;
  81392e:	b8 00 00 00 00       	mov    $0x0,%eax
  813933:	e9 c0 06 00 00       	jmpq   813ff8 <tcp_output+0x6ec>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  813938:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81393c:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  813940:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813944:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  813948:	66 39 c2             	cmp    %ax,%dx
  81394b:	0f 46 c2             	cmovbe %edx,%eax
  81394e:	0f b7 c0             	movzwl %ax,%eax
  813951:	89 45 dc             	mov    %eax,-0x24(%rbp)

  seg = pcb->unsent;
  813954:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813958:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81395f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  813963:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813967:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81396e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (useg != NULL) {
  813972:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813977:	74 19                	je     813992 <tcp_output+0x86>
    for (; useg->next != NULL; useg = useg->next);
  813979:	eb 0b                	jmp    813986 <tcp_output+0x7a>
  81397b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81397f:	48 8b 00             	mov    (%rax),%rax
  813982:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813986:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81398a:	48 8b 00             	mov    (%rax),%rax
  81398d:	48 85 c0             	test   %rax,%rax
  813990:	75 e9                	jne    81397b <tcp_output+0x6f>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  813992:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813996:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81399a:	0f b6 c0             	movzbl %al,%eax
  81399d:	83 e0 02             	and    $0x2,%eax
  8139a0:	85 c0                	test   %eax,%eax
  8139a2:	0f 84 49 02 00 00    	je     813bf1 <tcp_output+0x2e5>
  8139a8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8139ad:	74 3a                	je     8139e9 <tcp_output+0xdd>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  8139af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8139b3:	48 8b 40 20          	mov    0x20(%rax),%rax
  8139b7:	8b 40 04             	mov    0x4(%rax),%eax
  8139ba:	89 c7                	mov    %eax,%edi
  8139bc:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  8139c3:	00 00 00 
  8139c6:	ff d0                	callq  *%rax
  8139c8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8139cc:	8b 52 54             	mov    0x54(%rdx),%edx
  8139cf:	29 d0                	sub    %edx,%eax
  8139d1:	89 c2                	mov    %eax,%edx
  8139d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8139d7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8139db:	0f b7 c0             	movzwl %ax,%eax
  8139de:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  8139e0:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8139e3:	0f 86 08 02 00 00    	jbe    813bf1 <tcp_output+0x2e5>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8139e9:	ba 00 00 00 00       	mov    $0x0,%edx
  8139ee:	be 14 00 00 00       	mov    $0x14,%esi
  8139f3:	bf 01 00 00 00       	mov    $0x1,%edi
  8139f8:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  8139ff:	00 00 00 
  813a02:	ff d0                	callq  *%rax
  813a04:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == NULL) {
  813a08:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  813a0d:	75 0a                	jne    813a19 <tcp_output+0x10d>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  813a0f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  813a14:	e9 df 05 00 00       	jmpq   813ff8 <tcp_output+0x6ec>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  813a19:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a1d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813a21:	83 e0 fc             	and    $0xfffffffc,%eax
  813a24:	89 c2                	mov    %eax,%edx
  813a26:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a2a:	88 50 2c             	mov    %dl,0x2c(%rax)

    tcphdr = p->payload;
  813a2d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813a31:	48 8b 40 08          	mov    0x8(%rax),%rax
  813a35:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    tcphdr->src = htons(pcb->local_port);
  813a39:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a3d:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  813a41:	0f b7 c0             	movzwl %ax,%eax
  813a44:	89 c7                	mov    %eax,%edi
  813a46:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  813a4d:	00 00 00 
  813a50:	ff d0                	callq  *%rax
  813a52:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813a56:	66 89 02             	mov    %ax,(%rdx)
    tcphdr->dest = htons(pcb->remote_port);
  813a59:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a5d:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  813a61:	0f b7 c0             	movzwl %ax,%eax
  813a64:	89 c7                	mov    %eax,%edi
  813a66:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  813a6d:	00 00 00 
  813a70:	ff d0                	callq  *%rax
  813a72:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813a76:	66 89 42 02          	mov    %ax,0x2(%rdx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  813a7a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a7e:	8b 40 60             	mov    0x60(%rax),%eax
  813a81:	89 c7                	mov    %eax,%edi
  813a83:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  813a8a:	00 00 00 
  813a8d:	ff d0                	callq  *%rax
  813a8f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813a93:	89 42 04             	mov    %eax,0x4(%rdx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  813a96:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a9a:	8b 40 30             	mov    0x30(%rax),%eax
  813a9d:	89 c7                	mov    %eax,%edi
  813a9f:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  813aa6:	00 00 00 
  813aa9:	ff d0                	callq  *%rax
  813aab:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813aaf:	89 42 08             	mov    %eax,0x8(%rdx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  813ab2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813ab6:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813aba:	0f b7 c0             	movzwl %ax,%eax
  813abd:	89 c7                	mov    %eax,%edi
  813abf:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813ac6:	00 00 00 
  813ac9:	ff d0                	callq  *%rax
  813acb:	83 e0 c0             	and    $0xffffffc0,%eax
  813ace:	83 c8 10             	or     $0x10,%eax
  813ad1:	0f b7 c0             	movzwl %ax,%eax
  813ad4:	89 c7                	mov    %eax,%edi
  813ad6:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  813add:	00 00 00 
  813ae0:	ff d0                	callq  *%rax
  813ae2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813ae6:	66 89 42 0c          	mov    %ax,0xc(%rdx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  813aea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813aee:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  813af2:	0f b7 c0             	movzwl %ax,%eax
  813af5:	89 c7                	mov    %eax,%edi
  813af7:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  813afe:	00 00 00 
  813b01:	ff d0                	callq  *%rax
  813b03:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813b07:	66 89 42 0e          	mov    %ax,0xe(%rdx)
    tcphdr->urgp = 0;
  813b0b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813b0f:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_HDRLEN_SET(tcphdr, 5);
  813b15:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813b19:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813b1d:	0f b7 c0             	movzwl %ax,%eax
  813b20:	89 c7                	mov    %eax,%edi
  813b22:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813b29:	00 00 00 
  813b2c:	ff d0                	callq  *%rax
  813b2e:	83 e0 3f             	and    $0x3f,%eax
  813b31:	80 cc 50             	or     $0x50,%ah
  813b34:	0f b7 c0             	movzwl %ax,%eax
  813b37:	89 c7                	mov    %eax,%edi
  813b39:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  813b40:	00 00 00 
  813b43:	ff d0                	callq  *%rax
  813b45:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813b49:	66 89 42 0c          	mov    %ax,0xc(%rdx)

    tcphdr->chksum = 0;
  813b4d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813b51:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
          IP_PROTO_TCP, p->tot_len);
  813b57:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813b5b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    tcphdr->urgp = 0;
    TCPH_HDRLEN_SET(tcphdr, 5);

    tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  813b5f:	0f b7 c8             	movzwl %ax,%ecx
  813b62:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813b66:	48 8d 50 04          	lea    0x4(%rax),%rdx
  813b6a:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813b6e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813b72:	41 89 c8             	mov    %ecx,%r8d
  813b75:	b9 06 00 00 00       	mov    $0x6,%ecx
  813b7a:	48 89 c7             	mov    %rax,%rdi
  813b7d:	48 b8 9a 24 81 00 00 	movabs $0x81249a,%rax
  813b84:	00 00 00 
  813b87:	ff d0                	callq  *%rax
  813b89:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813b8d:	66 89 42 10          	mov    %ax,0x10(%rdx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  813b91:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813b95:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  813b99:	0f b6 c8             	movzbl %al,%ecx
  813b9c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ba0:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  813ba4:	0f b6 d0             	movzbl %al,%edx
  813ba7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813bab:	48 8d 78 04          	lea    0x4(%rax),%rdi
  813baf:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813bb3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813bb7:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  813bbd:	41 89 c8             	mov    %ecx,%r8d
  813bc0:	89 d1                	mov    %edx,%ecx
  813bc2:	48 89 fa             	mov    %rdi,%rdx
  813bc5:	48 89 c7             	mov    %rax,%rdi
  813bc8:	48 b8 98 12 81 00 00 	movabs $0x811298,%rax
  813bcf:	00 00 00 
  813bd2:	ff d0                	callq  *%rax
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  813bd4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813bd8:	48 89 c7             	mov    %rax,%rdi
  813bdb:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  813be2:	00 00 00 
  813be5:	ff d0                	callq  *%rax

    return ERR_OK;
  813be7:	b8 00 00 00 00       	mov    $0x0,%eax
  813bec:	e9 07 04 00 00       	jmpq   813ff8 <tcp_output+0x6ec>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  813bf1:	e9 39 03 00 00       	jmpq   813f2f <tcp_output+0x623>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  813bf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813bfa:	48 8b 40 20          	mov    0x20(%rax),%rax
  813bfe:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813c02:	0f b7 c0             	movzwl %ax,%eax
  813c05:	89 c7                	mov    %eax,%edi
  813c07:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813c0e:	00 00 00 
  813c11:	ff d0                	callq  *%rax
  813c13:	0f b7 c0             	movzwl %ax,%eax
  813c16:	83 e0 04             	and    $0x4,%eax
  813c19:	85 c0                	test   %eax,%eax
  813c1b:	74 2a                	je     813c47 <tcp_output+0x33b>
  813c1d:	48 ba 00 26 82 00 00 	movabs $0x822600,%rdx
  813c24:	00 00 00 
  813c27:	be 05 02 00 00       	mov    $0x205,%esi
  813c2c:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  813c33:	00 00 00 
  813c36:	b8 00 00 00 00       	mov    $0x0,%eax
  813c3b:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  813c42:	00 00 00 
  813c45:	ff d1                	callq  *%rcx
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  813c47:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c4b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813c52:	48 85 c0             	test   %rax,%rax
  813c55:	74 35                	je     813c8c <tcp_output+0x380>
  813c57:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c5b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813c5f:	0f b6 c0             	movzbl %al,%eax
  813c62:	83 e0 40             	and    $0x40,%eax
  813c65:	85 c0                	test   %eax,%eax
  813c67:	75 23                	jne    813c8c <tcp_output+0x380>
  813c69:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c6d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813c74:	48 85 c0             	test   %rax,%rax
  813c77:	74 1a                	je     813c93 <tcp_output+0x387>
  813c79:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c7d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813c84:	48 8b 00             	mov    (%rax),%rax
  813c87:	48 85 c0             	test   %rax,%rax
  813c8a:	74 07                	je     813c93 <tcp_output+0x387>
  813c8c:	b8 01 00 00 00       	mov    $0x1,%eax
  813c91:	eb 05                	jmp    813c98 <tcp_output+0x38c>
  813c93:	b8 00 00 00 00       	mov    $0x0,%eax
  813c98:	85 c0                	test   %eax,%eax
  813c9a:	75 19                	jne    813cb5 <tcp_output+0x3a9>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
  813c9c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ca0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813ca4:	0f b6 c0             	movzbl %al,%eax
  813ca7:	25 a0 00 00 00       	and    $0xa0,%eax
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  813cac:	85 c0                	test   %eax,%eax
  813cae:	75 05                	jne    813cb5 <tcp_output+0x3a9>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
  813cb0:	e9 bb 02 00 00       	jmpq   813f70 <tcp_output+0x664>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  813cb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813cb9:	48 8b 10             	mov    (%rax),%rdx
  813cbc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813cc0:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)

    if (pcb->state != SYN_SENT) {
  813cc7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ccb:	8b 40 18             	mov    0x18(%rax),%eax
  813cce:	83 f8 02             	cmp    $0x2,%eax
  813cd1:	74 51                	je     813d24 <tcp_output+0x418>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  813cd3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813cd7:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813cdb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813cdf:	48 8b 40 20          	mov    0x20(%rax),%rax
  813ce3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813ce7:	0f b7 c0             	movzwl %ax,%eax
  813cea:	89 c7                	mov    %eax,%edi
  813cec:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813cf3:	00 00 00 
  813cf6:	ff d0                	callq  *%rax
  813cf8:	83 c8 10             	or     $0x10,%eax
  813cfb:	0f b7 c0             	movzwl %ax,%eax
  813cfe:	89 c7                	mov    %eax,%edi
  813d00:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  813d07:	00 00 00 
  813d0a:	ff d0                	callq  *%rax
  813d0c:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  813d10:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d14:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813d18:	83 e0 fc             	and    $0xfffffffc,%eax
  813d1b:	89 c2                	mov    %eax,%edx
  813d1d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d21:	88 50 2c             	mov    %dl,0x2c(%rax)
    }

    tcp_output_segment(seg, pcb);
  813d24:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813d28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d2c:	48 89 d6             	mov    %rdx,%rsi
  813d2f:	48 89 c7             	mov    %rax,%rdi
  813d32:	48 b8 01 40 81 00 00 	movabs $0x814001,%rax
  813d39:	00 00 00 
  813d3c:	ff d0                	callq  *%rax
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  813d3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d42:	48 8b 40 20          	mov    0x20(%rax),%rax
  813d46:	8b 40 04             	mov    0x4(%rax),%eax
  813d49:	89 c7                	mov    %eax,%edi
  813d4b:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  813d52:	00 00 00 
  813d55:	ff d0                	callq  *%rax
  813d57:	89 c3                	mov    %eax,%ebx
  813d59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d5d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813d61:	44 0f b7 e0          	movzwl %ax,%r12d
  813d65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d69:	48 8b 40 20          	mov    0x20(%rax),%rax
  813d6d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813d71:	0f b7 c0             	movzwl %ax,%eax
  813d74:	89 c7                	mov    %eax,%edi
  813d76:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813d7d:	00 00 00 
  813d80:	ff d0                	callq  *%rax
  813d82:	0f b7 c0             	movzwl %ax,%eax
  813d85:	83 e0 01             	and    $0x1,%eax
  813d88:	85 c0                	test   %eax,%eax
  813d8a:	75 27                	jne    813db3 <tcp_output+0x4a7>
  813d8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d90:	48 8b 40 20          	mov    0x20(%rax),%rax
  813d94:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813d98:	0f b7 c0             	movzwl %ax,%eax
  813d9b:	89 c7                	mov    %eax,%edi
  813d9d:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813da4:	00 00 00 
  813da7:	ff d0                	callq  *%rax
  813da9:	0f b7 c0             	movzwl %ax,%eax
  813dac:	83 e0 02             	and    $0x2,%eax
  813daf:	85 c0                	test   %eax,%eax
  813db1:	74 07                	je     813dba <tcp_output+0x4ae>
  813db3:	b8 01 00 00 00       	mov    $0x1,%eax
  813db8:	eb 05                	jmp    813dbf <tcp_output+0x4b3>
  813dba:	b8 00 00 00 00       	mov    $0x0,%eax
  813dbf:	44 01 e0             	add    %r12d,%eax
  813dc2:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  813dc5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813dc9:	89 50 60             	mov    %edx,0x60(%rax)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  813dcc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813dd0:	8b 50 64             	mov    0x64(%rax),%edx
  813dd3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813dd7:	8b 40 60             	mov    0x60(%rax),%eax
  813dda:	29 c2                	sub    %eax,%edx
  813ddc:	89 d0                	mov    %edx,%eax
  813dde:	85 c0                	test   %eax,%eax
  813de0:	79 0e                	jns    813df0 <tcp_output+0x4e4>
      pcb->snd_max = pcb->snd_nxt;
  813de2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813de6:	8b 50 60             	mov    0x60(%rax),%edx
  813de9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ded:	89 50 64             	mov    %edx,0x64(%rax)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  813df0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813df4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813df8:	0f b7 d8             	movzwl %ax,%ebx
  813dfb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813dff:	48 8b 40 20          	mov    0x20(%rax),%rax
  813e03:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813e07:	0f b7 c0             	movzwl %ax,%eax
  813e0a:	89 c7                	mov    %eax,%edi
  813e0c:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813e13:	00 00 00 
  813e16:	ff d0                	callq  *%rax
  813e18:	0f b7 c0             	movzwl %ax,%eax
  813e1b:	83 e0 01             	and    $0x1,%eax
  813e1e:	85 c0                	test   %eax,%eax
  813e20:	75 27                	jne    813e49 <tcp_output+0x53d>
  813e22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e26:	48 8b 40 20          	mov    0x20(%rax),%rax
  813e2a:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813e2e:	0f b7 c0             	movzwl %ax,%eax
  813e31:	89 c7                	mov    %eax,%edi
  813e33:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813e3a:	00 00 00 
  813e3d:	ff d0                	callq  *%rax
  813e3f:	0f b7 c0             	movzwl %ax,%eax
  813e42:	83 e0 02             	and    $0x2,%eax
  813e45:	85 c0                	test   %eax,%eax
  813e47:	74 07                	je     813e50 <tcp_output+0x544>
  813e49:	b8 01 00 00 00       	mov    $0x1,%eax
  813e4e:	eb 05                	jmp    813e55 <tcp_output+0x549>
  813e50:	b8 00 00 00 00       	mov    $0x0,%eax
  813e55:	01 d8                	add    %ebx,%eax
  813e57:	85 c0                	test   %eax,%eax
  813e59:	0f 8e ae 00 00 00    	jle    813f0d <tcp_output+0x601>
      seg->next = NULL;
  813e5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e63:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  813e6a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e6e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813e75:	48 85 c0             	test   %rax,%rax
  813e78:	75 1c                	jne    813e96 <tcp_output+0x58a>
        pcb->unacked = seg;
  813e7a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e7e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813e82:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
        useg = seg;
  813e89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e8d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813e91:	e9 8a 00 00 00       	jmpq   813f20 <tcp_output+0x614>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  813e96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e9a:	48 8b 40 20          	mov    0x20(%rax),%rax
  813e9e:	8b 40 04             	mov    0x4(%rax),%eax
  813ea1:	89 c7                	mov    %eax,%edi
  813ea3:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  813eaa:	00 00 00 
  813ead:	ff d0                	callq  *%rax
  813eaf:	89 c3                	mov    %eax,%ebx
  813eb1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813eb5:	48 8b 40 20          	mov    0x20(%rax),%rax
  813eb9:	8b 40 04             	mov    0x4(%rax),%eax
  813ebc:	89 c7                	mov    %eax,%edi
  813ebe:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  813ec5:	00 00 00 
  813ec8:	ff d0                	callq  *%rax
  813eca:	29 c3                	sub    %eax,%ebx
  813ecc:	89 d8                	mov    %ebx,%eax
  813ece:	85 c0                	test   %eax,%eax
  813ed0:	79 23                	jns    813ef5 <tcp_output+0x5e9>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  813ed2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ed6:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  813edd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813ee1:	48 89 10             	mov    %rdx,(%rax)
          pcb->unacked = seg;
  813ee4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ee8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813eec:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  813ef3:	eb 2b                	jmp    813f20 <tcp_output+0x614>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  813ef5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813ef9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813efd:	48 89 10             	mov    %rdx,(%rax)
          useg = useg->next;
  813f00:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813f04:	48 8b 00             	mov    (%rax),%rax
  813f07:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813f0b:	eb 13                	jmp    813f20 <tcp_output+0x614>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  813f0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f11:	48 89 c7             	mov    %rax,%rdi
  813f14:	48 b8 4b 01 81 00 00 	movabs $0x81014b,%rax
  813f1b:	00 00 00 
  813f1e:	ff d0                	callq  *%rax
    }
    seg = pcb->unsent;
  813f20:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f24:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813f2b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  813f2f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813f34:	74 3a                	je     813f70 <tcp_output+0x664>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  813f36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f3a:	48 8b 40 20          	mov    0x20(%rax),%rax
  813f3e:	8b 40 04             	mov    0x4(%rax),%eax
  813f41:	89 c7                	mov    %eax,%edi
  813f43:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  813f4a:	00 00 00 
  813f4d:	ff d0                	callq  *%rax
  813f4f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813f53:	8b 52 54             	mov    0x54(%rdx),%edx
  813f56:	29 d0                	sub    %edx,%eax
  813f58:	89 c2                	mov    %eax,%edx
  813f5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f5e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813f62:	0f b7 c0             	movzwl %ax,%eax
  813f65:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  813f67:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  813f6a:	0f 86 86 fc ff ff    	jbe    813bf6 <tcp_output+0x2ea>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  813f70:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813f75:	74 68                	je     813fdf <tcp_output+0x6d3>
  813f77:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f7b:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  813f82:	84 c0                	test   %al,%al
  813f84:	75 59                	jne    813fdf <tcp_output+0x6d3>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  813f86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f8a:	48 8b 40 20          	mov    0x20(%rax),%rax
  813f8e:	8b 40 04             	mov    0x4(%rax),%eax
  813f91:	89 c7                	mov    %eax,%edi
  813f93:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  813f9a:	00 00 00 
  813f9d:	ff d0                	callq  *%rax
  813f9f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813fa3:	8b 52 54             	mov    0x54(%rdx),%edx
  813fa6:	29 d0                	sub    %edx,%eax
  813fa8:	89 c2                	mov    %eax,%edx
  813faa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813fae:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813fb2:	0f b7 c0             	movzwl %ax,%eax
  813fb5:	01 c2                	add    %eax,%edx
  813fb7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813fbb:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  813fbf:	0f b7 c0             	movzwl %ax,%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  813fc2:	39 c2                	cmp    %eax,%edx
  813fc4:	76 19                	jbe    813fdf <tcp_output+0x6d3>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  813fc6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813fca:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  813fd1:	00 00 00 
    pcb->persist_backoff = 1;
  813fd4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813fd8:	c6 80 d8 00 00 00 01 	movb   $0x1,0xd8(%rax)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  813fdf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813fe3:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813fe7:	83 e0 7f             	and    $0x7f,%eax
  813fea:	89 c2                	mov    %eax,%edx
  813fec:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ff0:	88 50 2c             	mov    %dl,0x2c(%rax)
  return ERR_OK;
  813ff3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  813ff8:	48 83 c4 40          	add    $0x40,%rsp
  813ffc:	5b                   	pop    %rbx
  813ffd:	41 5c                	pop    %r12
  813fff:	5d                   	pop    %rbp
  814000:	c3                   	retq   

0000000000814001 <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
  814001:	55                   	push   %rbp
  814002:	48 89 e5             	mov    %rsp,%rbp
  814005:	53                   	push   %rbx
  814006:	48 83 ec 28          	sub    $0x28,%rsp
  81400a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81400e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  814012:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814016:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81401a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81401e:	8b 40 30             	mov    0x30(%rax),%eax
  814021:	89 c7                	mov    %eax,%edi
  814023:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  81402a:	00 00 00 
  81402d:	ff d0                	callq  *%rax
  81402f:	89 43 08             	mov    %eax,0x8(%rbx)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814032:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814036:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81403a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81403e:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  814042:	0f b7 c0             	movzwl %ax,%eax
  814045:	89 c7                	mov    %eax,%edi
  814047:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  81404e:	00 00 00 
  814051:	ff d0                	callq  *%rax
  814053:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  814057:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81405b:	48 85 c0             	test   %rax,%rax
  81405e:	74 0a                	je     81406a <tcp_output_segment+0x69>
  814060:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814064:	8b 00                	mov    (%rax),%eax
  814066:	85 c0                	test   %eax,%eax
  814068:	75 48                	jne    8140b2 <tcp_output_segment+0xb1>
    netif = ip_route(&(pcb->remote_ip));
  81406a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81406e:	48 83 c0 04          	add    $0x4,%rax
  814072:	48 89 c7             	mov    %rax,%rdi
  814075:	48 b8 ad 0a 81 00 00 	movabs $0x810aad,%rax
  81407c:	00 00 00 
  81407f:	ff d0                	callq  *%rax
  814081:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (netif == NULL) {
  814085:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81408a:	75 05                	jne    814091 <tcp_output_segment+0x90>
      return;
  81408c:	e9 7f 01 00 00       	jmpq   814210 <tcp_output_segment+0x20f>
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  814091:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814095:	48 83 c0 08          	add    $0x8,%rax
  814099:	48 85 c0             	test   %rax,%rax
  81409c:	74 09                	je     8140a7 <tcp_output_segment+0xa6>
  81409e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8140a2:	8b 40 08             	mov    0x8(%rax),%eax
  8140a5:	eb 05                	jmp    8140ac <tcp_output_segment+0xab>
  8140a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8140ac:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8140b0:	89 02                	mov    %eax,(%rdx)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  8140b2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8140b6:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8140ba:	66 83 f8 ff          	cmp    $0xffff,%ax
  8140be:	75 0a                	jne    8140ca <tcp_output_segment+0xc9>
    pcb->rtime = 0;
  8140c0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8140c4:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

  if (pcb->rttest == 0) {
  8140ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8140ce:	8b 40 44             	mov    0x44(%rax),%eax
  8140d1:	85 c0                	test   %eax,%eax
  8140d3:	75 33                	jne    814108 <tcp_output_segment+0x107>
    pcb->rttest = tcp_ticks;
  8140d5:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8140dc:	00 00 00 
  8140df:	8b 10                	mov    (%rax),%edx
  8140e1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8140e5:	89 50 44             	mov    %edx,0x44(%rax)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8140e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8140ec:	48 8b 40 20          	mov    0x20(%rax),%rax
  8140f0:	8b 40 04             	mov    0x4(%rax),%eax
  8140f3:	89 c7                	mov    %eax,%edi
  8140f5:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  8140fc:	00 00 00 
  8140ff:	ff d0                	callq  *%rax
  814101:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  814105:	89 42 48             	mov    %eax,0x48(%rdx)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  814108:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81410c:	48 8b 40 20          	mov    0x20(%rax),%rax
  814110:	48 89 c2             	mov    %rax,%rdx
  814113:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814117:	48 8b 40 08          	mov    0x8(%rax),%rax
  81411b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81411f:	48 29 c2             	sub    %rax,%rdx
  814122:	48 89 d0             	mov    %rdx,%rax
  814125:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)

  seg->p->len -= len;
  814129:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81412d:	48 8b 40 08          	mov    0x8(%rax),%rax
  814131:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814135:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  814139:	0f b7 52 12          	movzwl 0x12(%rdx),%edx
  81413d:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  814141:	66 89 50 12          	mov    %dx,0x12(%rax)
  seg->p->tot_len -= len;
  814145:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814149:	48 8b 40 08          	mov    0x8(%rax),%rax
  81414d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814151:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  814155:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  814159:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  81415d:	66 89 50 10          	mov    %dx,0x10(%rax)

  seg->p->payload = seg->tcphdr;
  814161:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814165:	48 8b 40 08          	mov    0x8(%rax),%rax
  814169:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81416d:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  814171:	48 89 50 08          	mov    %rdx,0x8(%rax)

  seg->tcphdr->chksum = 0;
  814175:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814179:	48 8b 40 20          	mov    0x20(%rax),%rax
  81417d:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  814183:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814187:	48 8b 58 20          	mov    0x20(%rax),%rbx
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  81418b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81418f:	48 8b 40 08          	mov    0x8(%rax),%rax
  814193:	0f b7 40 10          	movzwl 0x10(%rax),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  814197:	0f b7 c8             	movzwl %ax,%ecx
  81419a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81419e:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8141a2:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8141a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8141aa:	48 8b 40 08          	mov    0x8(%rax),%rax
  8141ae:	41 89 c8             	mov    %ecx,%r8d
  8141b1:	b9 06 00 00 00       	mov    $0x6,%ecx
  8141b6:	48 89 c7             	mov    %rax,%rdi
  8141b9:	48 b8 9a 24 81 00 00 	movabs $0x81249a,%rax
  8141c0:	00 00 00 
  8141c3:	ff d0                	callq  *%rax
  8141c5:	66 89 43 10          	mov    %ax,0x10(%rbx)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8141c9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8141cd:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  8141d1:	0f b6 c8             	movzbl %al,%ecx
  8141d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8141d8:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8141dc:	0f b6 d0             	movzbl %al,%edx
  8141df:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8141e3:	48 8d 78 04          	lea    0x4(%rax),%rdi
  8141e7:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8141eb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8141ef:	48 8b 40 08          	mov    0x8(%rax),%rax
  8141f3:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8141f9:	41 89 c8             	mov    %ecx,%r8d
  8141fc:	89 d1                	mov    %edx,%ecx
  8141fe:	48 89 fa             	mov    %rdi,%rdx
  814201:	48 89 c7             	mov    %rax,%rdi
  814204:	48 b8 98 12 81 00 00 	movabs $0x811298,%rax
  81420b:	00 00 00 
  81420e:	ff d0                	callq  *%rax
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
  814210:	48 83 c4 28          	add    $0x28,%rsp
  814214:	5b                   	pop    %rbx
  814215:	5d                   	pop    %rbp
  814216:	c3                   	retq   

0000000000814217 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  814217:	55                   	push   %rbp
  814218:	48 89 e5             	mov    %rsp,%rbp
  81421b:	48 83 ec 30          	sub    $0x30,%rsp
  81421f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  814222:	89 75 e8             	mov    %esi,-0x18(%rbp)
  814225:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  814229:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  81422d:	44 89 c2             	mov    %r8d,%edx
  814230:	44 89 c8             	mov    %r9d,%eax
  814233:	66 89 55 d4          	mov    %dx,-0x2c(%rbp)
  814237:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  81423b:	ba 00 00 00 00       	mov    $0x0,%edx
  814240:	be 14 00 00 00       	mov    $0x14,%esi
  814245:	bf 01 00 00 00       	mov    $0x1,%edi
  81424a:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  814251:	00 00 00 
  814254:	ff d0                	callq  *%rax
  814256:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p == NULL) {
  81425a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81425f:	75 05                	jne    814266 <tcp_rst+0x4f>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  814261:	e9 b9 01 00 00       	jmpq   81441f <tcp_rst+0x208>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814266:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81426a:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81426e:	66 83 f8 13          	cmp    $0x13,%ax
  814272:	77 2a                	ja     81429e <tcp_rst+0x87>
  814274:	48 ba 18 26 82 00 00 	movabs $0x822618,%rdx
  81427b:	00 00 00 
  81427e:	be be 02 00 00       	mov    $0x2be,%esi
  814283:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  81428a:	00 00 00 
  81428d:	b8 00 00 00 00       	mov    $0x0,%eax
  814292:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  814299:	00 00 00 
  81429c:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  81429e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8142a2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8142a6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(local_port);
  8142aa:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  8142ae:	89 c7                	mov    %eax,%edi
  8142b0:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8142b7:	00 00 00 
  8142ba:	ff d0                	callq  *%rax
  8142bc:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8142c0:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(remote_port);
  8142c3:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8142c7:	89 c7                	mov    %eax,%edi
  8142c9:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8142d0:	00 00 00 
  8142d3:	ff d0                	callq  *%rax
  8142d5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8142d9:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = htonl(seqno);
  8142dd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8142e0:	89 c7                	mov    %eax,%edi
  8142e2:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  8142e9:	00 00 00 
  8142ec:	ff d0                	callq  *%rax
  8142ee:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8142f2:	89 42 04             	mov    %eax,0x4(%rdx)
  tcphdr->ackno = htonl(ackno);
  8142f5:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8142f8:	89 c7                	mov    %eax,%edi
  8142fa:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  814301:	00 00 00 
  814304:	ff d0                	callq  *%rax
  814306:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81430a:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  81430d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814311:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814315:	0f b7 c0             	movzwl %ax,%eax
  814318:	89 c7                	mov    %eax,%edi
  81431a:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  814321:	00 00 00 
  814324:	ff d0                	callq  *%rax
  814326:	83 e0 c0             	and    $0xffffffc0,%eax
  814329:	83 c8 14             	or     $0x14,%eax
  81432c:	0f b7 c0             	movzwl %ax,%eax
  81432f:	89 c7                	mov    %eax,%edi
  814331:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  814338:	00 00 00 
  81433b:	ff d0                	callq  *%rax
  81433d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814341:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(TCP_WND);
  814345:	bf c0 5d 00 00       	mov    $0x5dc0,%edi
  81434a:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  814351:	00 00 00 
  814354:	ff d0                	callq  *%rax
  814356:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81435a:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  81435e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814362:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814368:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81436c:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814370:	0f b7 c0             	movzwl %ax,%eax
  814373:	89 c7                	mov    %eax,%edi
  814375:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81437c:	00 00 00 
  81437f:	ff d0                	callq  *%rax
  814381:	83 e0 3f             	and    $0x3f,%eax
  814384:	80 cc 50             	or     $0x50,%ah
  814387:	0f b7 c0             	movzwl %ax,%eax
  81438a:	89 c7                	mov    %eax,%edi
  81438c:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  814393:	00 00 00 
  814396:	ff d0                	callq  *%rax
  814398:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81439c:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  tcphdr->chksum = 0;
  8143a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8143a4:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
  8143aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8143ae:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  8143b2:	0f b7 c8             	movzwl %ax,%ecx
  8143b5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8143b9:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8143bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8143c1:	41 89 c8             	mov    %ecx,%r8d
  8143c4:	b9 06 00 00 00       	mov    $0x6,%ecx
  8143c9:	48 89 c7             	mov    %rax,%rdi
  8143cc:	48 b8 9a 24 81 00 00 	movabs $0x81249a,%rax
  8143d3:	00 00 00 
  8143d6:	ff d0                	callq  *%rax
  8143d8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8143dc:	66 89 42 10          	mov    %ax,0x10(%rdx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  8143e0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8143e4:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8143e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8143ec:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8143f2:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8143f8:	b9 ff 00 00 00       	mov    $0xff,%ecx
  8143fd:	48 89 c7             	mov    %rax,%rdi
  814400:	48 b8 98 12 81 00 00 	movabs $0x811298,%rax
  814407:	00 00 00 
  81440a:	ff d0                	callq  *%rax
  pbuf_free(p);
  81440c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814410:	48 89 c7             	mov    %rax,%rdi
  814413:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81441a:	00 00 00 
  81441d:	ff d0                	callq  *%rax
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  81441f:	c9                   	leaveq 
  814420:	c3                   	retq   

0000000000814421 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  814421:	55                   	push   %rbp
  814422:	48 89 e5             	mov    %rsp,%rbp
  814425:	48 83 ec 20          	sub    $0x20,%rsp
  814429:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  81442d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814431:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814438:	48 85 c0             	test   %rax,%rax
  81443b:	75 05                	jne    814442 <tcp_rexmit_rto+0x21>
    return;
  81443d:	e9 b6 00 00 00       	jmpq   8144f8 <tcp_rexmit_rto+0xd7>
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  814442:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814446:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81444d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814451:	eb 0b                	jmp    81445e <tcp_rexmit_rto+0x3d>
  814453:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814457:	48 8b 00             	mov    (%rax),%rax
  81445a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81445e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814462:	48 8b 00             	mov    (%rax),%rax
  814465:	48 85 c0             	test   %rax,%rax
  814468:	75 e9                	jne    814453 <tcp_rexmit_rto+0x32>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  81446a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81446e:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  814475:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814479:	48 89 10             	mov    %rdx,(%rax)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  81447c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814480:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  814487:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81448b:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  814492:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814496:	48 c7 80 88 00 00 00 	movq   $0x0,0x88(%rax)
  81449d:	00 00 00 00 

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8144a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144a5:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8144ac:	48 8b 40 20          	mov    0x20(%rax),%rax
  8144b0:	8b 40 04             	mov    0x4(%rax),%eax
  8144b3:	89 c7                	mov    %eax,%edi
  8144b5:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  8144bc:	00 00 00 
  8144bf:	ff d0                	callq  *%rax
  8144c1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8144c5:	89 42 60             	mov    %eax,0x60(%rdx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8144c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144cc:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  8144d0:	8d 50 01             	lea    0x1(%rax),%edx
  8144d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144d7:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8144da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144de:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission */
  tcp_output(pcb);
  8144e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144e9:	48 89 c7             	mov    %rax,%rdi
  8144ec:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  8144f3:	00 00 00 
  8144f6:	ff d0                	callq  *%rax
}
  8144f8:	c9                   	leaveq 
  8144f9:	c3                   	retq   

00000000008144fa <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  8144fa:	55                   	push   %rbp
  8144fb:	48 89 e5             	mov    %rsp,%rbp
  8144fe:	48 83 ec 20          	sub    $0x20,%rsp
  814502:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  814506:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81450a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814511:	48 85 c0             	test   %rax,%rax
  814514:	75 05                	jne    81451b <tcp_rexmit+0x21>
    return;
  814516:	e9 a7 00 00 00       	jmpq   8145c2 <tcp_rexmit+0xc8>
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  81451b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81451f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814526:	48 8b 00             	mov    (%rax),%rax
  814529:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pcb->unacked->next = pcb->unsent;
  81452d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814531:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814538:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81453c:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
  814543:	48 89 10             	mov    %rdx,(%rax)
  pcb->unsent = pcb->unacked;
  814546:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81454a:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  814551:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814555:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  pcb->unacked = seg;
  81455c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814560:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  814564:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  81456b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81456f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  814576:	48 8b 40 20          	mov    0x20(%rax),%rax
  81457a:	8b 40 04             	mov    0x4(%rax),%eax
  81457d:	89 c7                	mov    %eax,%edi
  81457f:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  814586:	00 00 00 
  814589:	ff d0                	callq  *%rax
  81458b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81458f:	89 42 60             	mov    %eax,0x60(%rdx)

  ++pcb->nrtx;
  814592:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814596:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  81459a:	8d 50 01             	lea    0x1(%rax),%edx
  81459d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8145a1:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  8145a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8145a8:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  8145af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8145b3:	48 89 c7             	mov    %rax,%rdi
  8145b6:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  8145bd:	00 00 00 
  8145c0:	ff d0                	callq  *%rax
}
  8145c2:	c9                   	leaveq 
  8145c3:	c3                   	retq   

00000000008145c4 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  8145c4:	55                   	push   %rbp
  8145c5:	48 89 e5             	mov    %rsp,%rbp
  8145c8:	48 83 ec 20          	sub    $0x20,%rsp
  8145cc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8145d0:	ba 00 00 00 00       	mov    $0x0,%edx
  8145d5:	be 14 00 00 00       	mov    $0x14,%esi
  8145da:	bf 01 00 00 00       	mov    $0x1,%edi
  8145df:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  8145e6:	00 00 00 
  8145e9:	ff d0                	callq  *%rax
  8145eb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
   
  if(p == NULL) {
  8145ef:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8145f4:	75 05                	jne    8145fb <tcp_keepalive+0x37>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  8145f6:	e9 ec 01 00 00       	jmpq   8147e7 <tcp_keepalive+0x223>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8145fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8145ff:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814603:	66 83 f8 13          	cmp    $0x13,%ax
  814607:	77 2a                	ja     814633 <tcp_keepalive+0x6f>
  814609:	48 ba 18 26 82 00 00 	movabs $0x822618,%rdx
  814610:	00 00 00 
  814613:	be 3a 03 00 00       	mov    $0x33a,%esi
  814618:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  81461f:	00 00 00 
  814622:	b8 00 00 00 00       	mov    $0x0,%eax
  814627:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81462e:	00 00 00 
  814631:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814633:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814637:	48 8b 40 08          	mov    0x8(%rax),%rax
  81463b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(pcb->local_port);
  81463f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814643:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  814647:	0f b7 c0             	movzwl %ax,%eax
  81464a:	89 c7                	mov    %eax,%edi
  81464c:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  814653:	00 00 00 
  814656:	ff d0                	callq  *%rax
  814658:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81465c:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(pcb->remote_port);
  81465f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814663:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  814667:	0f b7 c0             	movzwl %ax,%eax
  81466a:	89 c7                	mov    %eax,%edi
  81466c:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  814673:	00 00 00 
  814676:	ff d0                	callq  *%rax
  814678:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81467c:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  814680:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814684:	8b 40 60             	mov    0x60(%rax),%eax
  814687:	83 e8 01             	sub    $0x1,%eax
  81468a:	89 c7                	mov    %eax,%edi
  81468c:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  814693:	00 00 00 
  814696:	ff d0                	callq  *%rax
  814698:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81469c:	89 42 04             	mov    %eax,0x4(%rdx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  81469f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8146a3:	8b 40 30             	mov    0x30(%rax),%eax
  8146a6:	89 c7                	mov    %eax,%edi
  8146a8:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  8146af:	00 00 00 
  8146b2:	ff d0                	callq  *%rax
  8146b4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8146b8:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8146bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8146bf:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8146c3:	0f b7 c0             	movzwl %ax,%eax
  8146c6:	89 c7                	mov    %eax,%edi
  8146c8:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8146cf:	00 00 00 
  8146d2:	ff d0                	callq  *%rax
  8146d4:	0f b7 c0             	movzwl %ax,%eax
  8146d7:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8146dc:	89 c7                	mov    %eax,%edi
  8146de:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8146e5:	00 00 00 
  8146e8:	ff d0                	callq  *%rax
  8146ea:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8146ee:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8146f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8146f6:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  8146fa:	0f b7 c0             	movzwl %ax,%eax
  8146fd:	89 c7                	mov    %eax,%edi
  8146ff:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  814706:	00 00 00 
  814709:	ff d0                	callq  *%rax
  81470b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81470f:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  814713:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814717:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  81471d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814721:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814725:	0f b7 c0             	movzwl %ax,%eax
  814728:	89 c7                	mov    %eax,%edi
  81472a:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  814731:	00 00 00 
  814734:	ff d0                	callq  *%rax
  814736:	83 e0 3f             	and    $0x3f,%eax
  814739:	80 cc 50             	or     $0x50,%ah
  81473c:	0f b7 c0             	movzwl %ax,%eax
  81473f:	89 c7                	mov    %eax,%edi
  814741:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  814748:	00 00 00 
  81474b:	ff d0                	callq  *%rax
  81474d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814751:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  tcphdr->chksum = 0;
  814755:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814759:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  81475f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814763:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  814767:	0f b7 c8             	movzwl %ax,%ecx
  81476a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81476e:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814772:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814776:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81477a:	41 89 c8             	mov    %ecx,%r8d
  81477d:	b9 06 00 00 00       	mov    $0x6,%ecx
  814782:	48 89 c7             	mov    %rax,%rdi
  814785:	48 b8 9a 24 81 00 00 	movabs $0x81249a,%rax
  81478c:	00 00 00 
  81478f:	ff d0                	callq  *%rax
  814791:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814795:	66 89 42 10          	mov    %ax,0x10(%rdx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  814799:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81479d:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8147a1:	0f b6 d0             	movzbl %al,%edx
  8147a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8147a8:	48 8d 78 04          	lea    0x4(%rax),%rdi
  8147ac:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8147b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8147b4:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8147ba:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8147c0:	89 d1                	mov    %edx,%ecx
  8147c2:	48 89 fa             	mov    %rdi,%rdx
  8147c5:	48 89 c7             	mov    %rax,%rdi
  8147c8:	48 b8 98 12 81 00 00 	movabs $0x811298,%rax
  8147cf:	00 00 00 
  8147d2:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8147d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8147d8:	48 89 c7             	mov    %rax,%rdi
  8147db:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8147e2:	00 00 00 
  8147e5:	ff d0                	callq  *%rax

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8147e7:	c9                   	leaveq 
  8147e8:	c3                   	retq   

00000000008147e9 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  8147e9:	55                   	push   %rbp
  8147ea:	48 89 e5             	mov    %rsp,%rbp
  8147ed:	48 83 ec 30          	sub    $0x30,%rsp
  8147f1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  8147f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8147f9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814800:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  814804:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814809:	75 0f                	jne    81481a <tcp_zero_window_probe+0x31>
    seg = pcb->unsent;
  81480b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81480f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  814816:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  81481a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81481f:	75 05                	jne    814826 <tcp_zero_window_probe+0x3d>
    return;
  814821:	e9 23 02 00 00       	jmpq   814a49 <tcp_zero_window_probe+0x260>

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  814826:	ba 00 00 00 00       	mov    $0x0,%edx
  81482b:	be 15 00 00 00       	mov    $0x15,%esi
  814830:	bf 01 00 00 00       	mov    $0x1,%edi
  814835:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  81483c:	00 00 00 
  81483f:	ff d0                	callq  *%rax
  814841:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
   
  if(p == NULL) {
  814845:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81484a:	75 05                	jne    814851 <tcp_zero_window_probe+0x68>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  81484c:	e9 f8 01 00 00       	jmpq   814a49 <tcp_zero_window_probe+0x260>
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814851:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814855:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814859:	66 83 f8 13          	cmp    $0x13,%ax
  81485d:	77 2a                	ja     814889 <tcp_zero_window_probe+0xa0>
  81485f:	48 ba 18 26 82 00 00 	movabs $0x822618,%rdx
  814866:	00 00 00 
  814869:	be 8d 03 00 00       	mov    $0x38d,%esi
  81486e:	48 bf 87 24 82 00 00 	movabs $0x822487,%rdi
  814875:	00 00 00 
  814878:	b8 00 00 00 00       	mov    $0x0,%eax
  81487d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  814884:	00 00 00 
  814887:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814889:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81488d:	48 8b 40 08          	mov    0x8(%rax),%rax
  814891:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  tcphdr->src = htons(pcb->local_port);
  814895:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814899:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  81489d:	0f b7 c0             	movzwl %ax,%eax
  8148a0:	89 c7                	mov    %eax,%edi
  8148a2:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8148a9:	00 00 00 
  8148ac:	ff d0                	callq  *%rax
  8148ae:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8148b2:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(pcb->remote_port);
  8148b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8148b9:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  8148bd:	0f b7 c0             	movzwl %ax,%eax
  8148c0:	89 c7                	mov    %eax,%edi
  8148c2:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8148c9:	00 00 00 
  8148cc:	ff d0                	callq  *%rax
  8148ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8148d2:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = seg->tcphdr->seqno;
  8148d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8148da:	48 8b 40 20          	mov    0x20(%rax),%rax
  8148de:	8b 50 04             	mov    0x4(%rax),%edx
  8148e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148e5:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8148e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8148ec:	8b 40 30             	mov    0x30(%rax),%eax
  8148ef:	89 c7                	mov    %eax,%edi
  8148f1:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  8148f8:	00 00 00 
  8148fb:	ff d0                	callq  *%rax
  8148fd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814901:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, 0);
  814904:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814908:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81490c:	0f b7 c0             	movzwl %ax,%eax
  81490f:	89 c7                	mov    %eax,%edi
  814911:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  814918:	00 00 00 
  81491b:	ff d0                	callq  *%rax
  81491d:	0f b7 c0             	movzwl %ax,%eax
  814920:	25 c0 ff 00 00       	and    $0xffc0,%eax
  814925:	89 c7                	mov    %eax,%edi
  814927:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  81492e:	00 00 00 
  814931:	ff d0                	callq  *%rax
  814933:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814937:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  81493b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81493f:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  814943:	0f b7 c0             	movzwl %ax,%eax
  814946:	89 c7                	mov    %eax,%edi
  814948:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  81494f:	00 00 00 
  814952:	ff d0                	callq  *%rax
  814954:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814958:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  81495c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814960:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814966:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81496a:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81496e:	0f b7 c0             	movzwl %ax,%eax
  814971:	89 c7                	mov    %eax,%edi
  814973:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81497a:	00 00 00 
  81497d:	ff d0                	callq  *%rax
  81497f:	83 e0 3f             	and    $0x3f,%eax
  814982:	80 cc 50             	or     $0x50,%ah
  814985:	0f b7 c0             	movzwl %ax,%eax
  814988:	89 c7                	mov    %eax,%edi
  81498a:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  814991:	00 00 00 
  814994:	ff d0                	callq  *%rax
  814996:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81499a:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  81499e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8149a2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8149a6:	48 8d 50 14          	lea    0x14(%rax),%rdx
  8149aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8149ae:	48 8b 40 10          	mov    0x10(%rax),%rax
  8149b2:	0f b6 00             	movzbl (%rax),%eax
  8149b5:	88 02                	mov    %al,(%rdx)

  tcphdr->chksum = 0;
  8149b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149bb:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  8149c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8149c5:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  8149c9:	0f b7 c8             	movzwl %ax,%ecx
  8149cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8149d0:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8149d4:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8149d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8149dc:	41 89 c8             	mov    %ecx,%r8d
  8149df:	b9 06 00 00 00       	mov    $0x6,%ecx
  8149e4:	48 89 c7             	mov    %rax,%rdi
  8149e7:	48 b8 9a 24 81 00 00 	movabs $0x81249a,%rax
  8149ee:	00 00 00 
  8149f1:	ff d0                	callq  *%rax
  8149f3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8149f7:	66 89 42 10          	mov    %ax,0x10(%rdx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8149fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8149ff:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  814a03:	0f b6 d0             	movzbl %al,%edx
  814a06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814a0a:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814a0e:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  814a12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a16:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814a1c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  814a22:	89 d1                	mov    %edx,%ecx
  814a24:	48 89 fa             	mov    %rdi,%rdx
  814a27:	48 89 c7             	mov    %rax,%rdi
  814a2a:	48 b8 98 12 81 00 00 	movabs $0x811298,%rax
  814a31:	00 00 00 
  814a34:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  814a36:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a3a:	48 89 c7             	mov    %rax,%rdi
  814a3d:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  814a44:	00 00 00 
  814a47:	ff d0                	callq  *%rax

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  814a49:	c9                   	leaveq 
  814a4a:	c3                   	retq   

0000000000814a4b <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  814a4b:	55                   	push   %rbp
  814a4c:	48 89 e5             	mov    %rsp,%rbp
  814a4f:	53                   	push   %rbx
  814a50:	48 83 ec 58          	sub    $0x58,%rsp
  814a54:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  814a58:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  814a5c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814a60:	48 8b 40 08          	mov    0x8(%rax),%rax
  814a64:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  814a68:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814a6c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  814a70:	0f b7 d8             	movzwl %ax,%ebx
  814a73:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814a77:	0f b7 00             	movzwl (%rax),%eax
  814a7a:	0f b7 c0             	movzwl %ax,%eax
  814a7d:	89 c7                	mov    %eax,%edi
  814a7f:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  814a86:	00 00 00 
  814a89:	ff d0                	callq  *%rax
  814a8b:	66 c1 e8 08          	shr    $0x8,%ax
  814a8f:	0f b7 c0             	movzwl %ax,%eax
  814a92:	83 e0 0f             	and    $0xf,%eax
  814a95:	83 c0 02             	add    $0x2,%eax
  814a98:	c1 e0 02             	shl    $0x2,%eax
  814a9b:	39 c3                	cmp    %eax,%ebx
  814a9d:	7c 40                	jl     814adf <udp_input+0x94>
  814a9f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814aa3:	0f b7 00             	movzwl (%rax),%eax
  814aa6:	0f b7 c0             	movzwl %ax,%eax
  814aa9:	89 c7                	mov    %eax,%edi
  814aab:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  814ab2:	00 00 00 
  814ab5:	ff d0                	callq  *%rax
  814ab7:	66 c1 e8 08          	shr    $0x8,%ax
  814abb:	83 e0 0f             	and    $0xf,%eax
  814abe:	c1 e0 02             	shl    $0x2,%eax
  814ac1:	f7 d8                	neg    %eax
  814ac3:	0f bf d0             	movswl %ax,%edx
  814ac6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814aca:	89 d6                	mov    %edx,%esi
  814acc:	48 89 c7             	mov    %rax,%rdi
  814acf:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  814ad6:	00 00 00 
  814ad9:	ff d0                	callq  *%rax
  814adb:	84 c0                	test   %al,%al
  814add:	74 18                	je     814af7 <udp_input+0xac>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  814adf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814ae3:	48 89 c7             	mov    %rax,%rdi
  814ae6:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  814aed:	00 00 00 
  814af0:	ff d0                	callq  *%rax
    goto end;
  814af2:	e9 62 04 00 00       	jmpq   814f59 <udp_input+0x50e>
  }

  udphdr = (struct udp_hdr *)p->payload;
  814af7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814afb:	48 8b 40 08          	mov    0x8(%rax),%rax
  814aff:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  814b03:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814b07:	0f b7 00             	movzwl (%rax),%eax
  814b0a:	0f b7 c0             	movzwl %ax,%eax
  814b0d:	89 c7                	mov    %eax,%edi
  814b0f:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  814b16:	00 00 00 
  814b19:	ff d0                	callq  *%rax
  814b1b:	66 89 45 be          	mov    %ax,-0x42(%rbp)
  dest = ntohs(udphdr->dest);
  814b1f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814b23:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  814b27:	0f b7 c0             	movzwl %ax,%eax
  814b2a:	89 c7                	mov    %eax,%edi
  814b2c:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  814b33:	00 00 00 
  814b36:	ff d0                	callq  *%rax
  814b38:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
               ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
               ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
  814b3c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  814b43:	00 
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  814b44:	66 83 7d bc 44       	cmpw   $0x44,-0x44(%rbp)
  814b49:	0f 85 8c 00 00 00    	jne    814bdb <udp_input+0x190>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  814b4f:	66 83 7d be 43       	cmpw   $0x43,-0x42(%rbp)
  814b54:	0f 85 d3 01 00 00    	jne    814d2d <udp_input+0x2e2>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  814b5a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814b5e:	48 8b 40 38          	mov    0x38(%rax),%rax
  814b62:	48 85 c0             	test   %rax,%rax
  814b65:	0f 84 c2 01 00 00    	je     814d2d <udp_input+0x2e2>
  814b6b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814b6f:	48 8b 40 38          	mov    0x38(%rax),%rax
  814b73:	48 8b 40 08          	mov    0x8(%rax),%rax
  814b77:	48 85 c0             	test   %rax,%rax
  814b7a:	0f 84 ad 01 00 00    	je     814d2d <udp_input+0x2e2>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  814b80:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814b84:	48 8b 40 38          	mov    0x38(%rax),%rax
  814b88:	48 8b 40 08          	mov    0x8(%rax),%rax
  814b8c:	48 83 c0 04          	add    $0x4,%rax
  814b90:	48 85 c0             	test   %rax,%rax
  814b93:	74 31                	je     814bc6 <udp_input+0x17b>
  814b95:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814b99:	48 8b 40 38          	mov    0x38(%rax),%rax
  814b9d:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ba1:	8b 40 04             	mov    0x4(%rax),%eax
  814ba4:	85 c0                	test   %eax,%eax
  814ba6:	74 1e                	je     814bc6 <udp_input+0x17b>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  814ba8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814bac:	48 8b 40 38          	mov    0x38(%rax),%rax
  814bb0:	48 8b 40 08          	mov    0x8(%rax),%rax
  814bb4:	8b 50 04             	mov    0x4(%rax),%edx
  814bb7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814bbb:	8b 40 0c             	mov    0xc(%rax),%eax
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  814bbe:	39 c2                	cmp    %eax,%edx
  814bc0:	0f 85 67 01 00 00    	jne    814d2d <udp_input+0x2e2>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
          pcb = inp->dhcp->pcb;
  814bc6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814bca:	48 8b 40 38          	mov    0x38(%rax),%rax
  814bce:	48 8b 40 08          	mov    0x8(%rax),%rax
  814bd2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814bd6:	e9 52 01 00 00       	jmpq   814d2d <udp_input+0x2e2>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  814bdb:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  814be2:	00 
    local_match = 0;
  814be3:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
    uncon_pcb = NULL;
  814be7:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  814bee:	00 
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  814bef:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  814bf6:	00 00 00 
  814bf9:	48 8b 00             	mov    (%rax),%rax
  814bfc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814c00:	e9 0e 01 00 00       	jmpq   814d13 <udp_input+0x2c8>
      local_match = 0;
  814c05:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  814c09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c0d:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  814c11:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  814c15:	75 6b                	jne    814c82 <udp_input+0x237>
          (ip_addr_isany(&pcb->local_ip) ||
  814c17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  814c1b:	48 85 c0             	test   %rax,%rax
  814c1e:	74 3d                	je     814c5d <udp_input+0x212>
          (ip_addr_isany(&pcb->local_ip) ||
  814c20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c24:	8b 00                	mov    (%rax),%eax
  814c26:	85 c0                	test   %eax,%eax
  814c28:	74 33                	je     814c5d <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  814c2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c2e:	8b 10                	mov    (%rax),%edx
  814c30:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814c34:	8b 40 10             	mov    0x10(%rax),%eax
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
  814c37:	39 c2                	cmp    %eax,%edx
  814c39:	74 22                	je     814c5d <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  814c3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814c3f:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814c43:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814c47:	48 89 c6             	mov    %rax,%rsi
  814c4a:	48 89 d7             	mov    %rdx,%rdi
  814c4d:	48 b8 10 0a 81 00 00 	movabs $0x810a10,%rax
  814c54:	00 00 00 
  814c57:	ff d0                	callq  *%rax
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  814c59:	84 c0                	test   %al,%al
  814c5b:	74 25                	je     814c82 <udp_input+0x237>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
  814c5d:	c6 45 d7 01          	movb   $0x1,-0x29(%rbp)
        if ((uncon_pcb == NULL) && 
  814c61:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  814c66:	75 1a                	jne    814c82 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
  814c68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c6c:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  814c70:	0f b6 c0             	movzbl %al,%eax
  814c73:	83 e0 04             	and    $0x4,%eax
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  814c76:	85 c0                	test   %eax,%eax
  814c78:	75 08                	jne    814c82 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
  814c7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c7e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  814c82:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  814c86:	74 77                	je     814cff <udp_input+0x2b4>
          (pcb->remote_port == src) &&
  814c88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c8c:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  814c90:	66 3b 45 be          	cmp    -0x42(%rbp),%ax
  814c94:	75 69                	jne    814cff <udp_input+0x2b4>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  814c96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c9a:	48 83 c0 04          	add    $0x4,%rax
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  814c9e:	48 85 c0             	test   %rax,%rax
  814ca1:	74 1d                	je     814cc0 <udp_input+0x275>
          (ip_addr_isany(&pcb->remote_ip) ||
  814ca3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ca7:	8b 40 04             	mov    0x4(%rax),%eax
  814caa:	85 c0                	test   %eax,%eax
  814cac:	74 12                	je     814cc0 <udp_input+0x275>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  814cae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814cb2:	8b 50 04             	mov    0x4(%rax),%edx
  814cb5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814cb9:	8b 40 0c             	mov    0xc(%rax),%eax
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  814cbc:	39 c2                	cmp    %eax,%edx
  814cbe:	75 3f                	jne    814cff <udp_input+0x2b4>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  814cc0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  814cc5:	74 36                	je     814cfd <udp_input+0x2b2>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  814cc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ccb:	48 8b 50 10          	mov    0x10(%rax),%rdx
  814ccf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814cd3:	48 89 50 10          	mov    %rdx,0x10(%rax)
          pcb->next = udp_pcbs;
  814cd7:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  814cde:	00 00 00 
  814ce1:	48 8b 10             	mov    (%rax),%rdx
  814ce4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ce8:	48 89 50 10          	mov    %rdx,0x10(%rax)
          udp_pcbs = pcb;
  814cec:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  814cf3:	00 00 00 
  814cf6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814cfa:	48 89 10             	mov    %rdx,(%rax)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  814cfd:	eb 1f                	jmp    814d1e <udp_input+0x2d3>
      }
      prev = pcb;
  814cff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d03:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  814d07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d0b:	48 8b 40 10          	mov    0x10(%rax),%rax
  814d0f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814d13:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814d18:	0f 85 e7 fe ff ff    	jne    814c05 <udp_input+0x1ba>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  814d1e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814d23:	75 08                	jne    814d2d <udp_input+0x2e2>
      pcb = uncon_pcb;
  814d25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814d29:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  814d2d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814d32:	75 16                	jne    814d4a <udp_input+0x2ff>
  814d34:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814d38:	8b 50 08             	mov    0x8(%rax),%edx
  814d3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814d3f:	8b 40 10             	mov    0x10(%rax),%eax
  814d42:	39 c2                	cmp    %eax,%edx
  814d44:	0f 85 fc 01 00 00    	jne    814f46 <udp_input+0x4fb>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  814d4a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814d4e:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  814d52:	66 85 c0             	test   %ax,%ax
  814d55:	74 53                	je     814daa <udp_input+0x35f>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
  814d57:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d5b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  814d5f:	0f b7 c8             	movzwl %ax,%ecx
  814d62:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814d66:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814d6a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814d6e:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  814d72:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d76:	41 89 c8             	mov    %ecx,%r8d
  814d79:	b9 11 00 00 00       	mov    $0x11,%ecx
  814d7e:	48 89 c7             	mov    %rax,%rdi
  814d81:	48 b8 9a 24 81 00 00 	movabs $0x81249a,%rax
  814d88:	00 00 00 
  814d8b:	ff d0                	callq  *%rax
  814d8d:	66 85 c0             	test   %ax,%ax
  814d90:	74 18                	je     814daa <udp_input+0x35f>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  814d92:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d96:	48 89 c7             	mov    %rax,%rdi
  814d99:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  814da0:	00 00 00 
  814da3:	ff d0                	callq  *%rax
          goto end;
  814da5:	e9 af 01 00 00       	jmpq   814f59 <udp_input+0x50e>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  814daa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814dae:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
  814db3:	48 89 c7             	mov    %rax,%rdi
  814db6:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  814dbd:	00 00 00 
  814dc0:	ff d0                	callq  *%rax
  814dc2:	84 c0                	test   %al,%al
  814dc4:	74 2a                	je     814df0 <udp_input+0x3a5>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  814dc6:	48 ba 48 26 82 00 00 	movabs $0x822648,%rdx
  814dcd:	00 00 00 
  814dd0:	be 0a 01 00 00       	mov    $0x10a,%esi
  814dd5:	48 bf 5c 26 82 00 00 	movabs $0x82265c,%rdi
  814ddc:	00 00 00 
  814ddf:	b8 00 00 00 00       	mov    $0x0,%eax
  814de4:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  814deb:	00 00 00 
  814dee:	ff d1                	callq  *%rcx
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  814df0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814df5:	74 51                	je     814e48 <udp_input+0x3fd>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  814df7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814dfb:	48 8b 40 20          	mov    0x20(%rax),%rax
  814dff:	48 85 c0             	test   %rax,%rax
  814e02:	74 2c                	je     814e30 <udp_input+0x3e5>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  814e04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e08:	48 8b 40 20          	mov    0x20(%rax),%rax
  814e0c:	44 0f b7 45 be       	movzwl -0x42(%rbp),%r8d
  814e11:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  814e15:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  814e19:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814e1d:	48 8b 7a 28          	mov    0x28(%rdx),%rdi
  814e21:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  814e25:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814e29:	ff d0                	callq  *%rax
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  814e2b:	e9 29 01 00 00       	jmpq   814f59 <udp_input+0x50e>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  814e30:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814e34:	48 89 c7             	mov    %rax,%rdi
  814e37:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  814e3e:	00 00 00 
  814e41:	ff d0                	callq  *%rax
        goto end;
  814e43:	e9 11 01 00 00       	jmpq   814f59 <udp_input+0x50e>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  814e48:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814e4c:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814e50:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814e54:	48 89 c6             	mov    %rax,%rsi
  814e57:	48 89 d7             	mov    %rdx,%rdi
  814e5a:	48 b8 10 0a 81 00 00 	movabs $0x810a10,%rax
  814e61:	00 00 00 
  814e64:	ff d0                	callq  *%rax
  814e66:	84 c0                	test   %al,%al
  814e68:	0f 85 c3 00 00 00    	jne    814f31 <udp_input+0x4e6>
          !ip_addr_ismulticast(&iphdr->dest)) {
  814e6e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814e72:	8b 58 10             	mov    0x10(%rax),%ebx
  814e75:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  814e7a:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  814e81:	00 00 00 
  814e84:	ff d0                	callq  *%rax
  814e86:	21 c3                	and    %eax,%ebx
  814e88:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  814e8d:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  814e94:	00 00 00 
  814e97:	ff d0                	callq  *%rax
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  814e99:	39 c3                	cmp    %eax,%ebx
  814e9b:	0f 84 90 00 00 00    	je     814f31 <udp_input+0x4e6>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  814ea1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814ea5:	0f b7 00             	movzwl (%rax),%eax
  814ea8:	0f b7 c0             	movzwl %ax,%eax
  814eab:	89 c7                	mov    %eax,%edi
  814ead:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  814eb4:	00 00 00 
  814eb7:	ff d0                	callq  *%rax
  814eb9:	66 c1 e8 08          	shr    $0x8,%ax
  814ebd:	0f b7 c0             	movzwl %ax,%eax
  814ec0:	83 e0 0f             	and    $0xf,%eax
  814ec3:	83 c0 02             	add    $0x2,%eax
  814ec6:	c1 e0 02             	shl    $0x2,%eax
  814ec9:	0f bf d0             	movswl %ax,%edx
  814ecc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814ed0:	89 d6                	mov    %edx,%esi
  814ed2:	48 89 c7             	mov    %rax,%rdi
  814ed5:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  814edc:	00 00 00 
  814edf:	ff d0                	callq  *%rax
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  814ee1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814ee5:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ee9:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  814eed:	74 2a                	je     814f19 <udp_input+0x4ce>
  814eef:	48 ba 70 26 82 00 00 	movabs $0x822670,%rdx
  814ef6:	00 00 00 
  814ef9:	be 25 01 00 00       	mov    $0x125,%esi
  814efe:	48 bf 5c 26 82 00 00 	movabs $0x82265c,%rdi
  814f05:	00 00 00 
  814f08:	b8 00 00 00 00       	mov    $0x0,%eax
  814f0d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  814f14:	00 00 00 
  814f17:	ff d1                	callq  *%rcx
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  814f19:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f1d:	be 03 00 00 00       	mov    $0x3,%esi
  814f22:	48 89 c7             	mov    %rax,%rdi
  814f25:	48 b8 d7 03 82 00 00 	movabs $0x8203d7,%rax
  814f2c:	00 00 00 
  814f2f:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  814f31:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f35:	48 89 c7             	mov    %rax,%rdi
  814f38:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  814f3f:	00 00 00 
  814f42:	ff d0                	callq  *%rax
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  814f44:	eb 13                	jmp    814f59 <udp_input+0x50e>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
  814f46:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f4a:	48 89 c7             	mov    %rax,%rdi
  814f4d:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  814f54:	00 00 00 
  814f57:	ff d0                	callq  *%rax
  }
end:
  PERF_STOP("udp_input");
}
  814f59:	48 83 c4 58          	add    $0x58,%rsp
  814f5d:	5b                   	pop    %rbx
  814f5e:	5d                   	pop    %rbp
  814f5f:	c3                   	retq   

0000000000814f60 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  814f60:	55                   	push   %rbp
  814f61:	48 89 e5             	mov    %rsp,%rbp
  814f64:	48 83 ec 10          	sub    $0x10,%rsp
  814f68:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  814f6c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  814f70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814f74:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
  814f78:	0f b7 d0             	movzwl %ax,%edx
  814f7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814f7f:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814f83:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  814f87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814f8b:	89 d1                	mov    %edx,%ecx
  814f8d:	48 89 fa             	mov    %rdi,%rdx
  814f90:	48 89 c7             	mov    %rax,%rdi
  814f93:	48 b8 a1 4f 81 00 00 	movabs $0x814fa1,%rax
  814f9a:	00 00 00 
  814f9d:	ff d0                	callq  *%rax
}
  814f9f:	c9                   	leaveq 
  814fa0:	c3                   	retq   

0000000000814fa1 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  814fa1:	55                   	push   %rbp
  814fa2:	48 89 e5             	mov    %rsp,%rbp
  814fa5:	48 83 ec 30          	sub    $0x30,%rsp
  814fa9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  814fad:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  814fb1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  814fb5:	89 c8                	mov    %ecx,%eax
  814fb7:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  814fbb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814fbf:	48 89 c7             	mov    %rax,%rdi
  814fc2:	48 b8 ad 0a 81 00 00 	movabs $0x810aad,%rax
  814fc9:	00 00 00 
  814fcc:	ff d0                	callq  *%rax
  814fce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  814fd2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814fd7:	75 07                	jne    814fe0 <udp_sendto+0x3f>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  814fd9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  814fde:	eb 26                	jmp    815006 <udp_sendto+0x65>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  814fe0:	0f b7 4d d4          	movzwl -0x2c(%rbp),%ecx
  814fe4:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  814fe8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814fec:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  814ff0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ff4:	49 89 f8             	mov    %rdi,%r8
  814ff7:	48 89 c7             	mov    %rax,%rdi
  814ffa:	48 b8 08 50 81 00 00 	movabs $0x815008,%rax
  815001:	00 00 00 
  815004:	ff d0                	callq  *%rax
}
  815006:	c9                   	leaveq 
  815007:	c3                   	retq   

0000000000815008 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  815008:	55                   	push   %rbp
  815009:	48 89 e5             	mov    %rsp,%rbp
  81500c:	48 83 ec 50          	sub    $0x50,%rsp
  815010:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  815014:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  815018:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81501c:	89 c8                	mov    %ecx,%eax
  81501e:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  815022:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  815026:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81502a:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  81502e:	66 85 c0             	test   %ax,%ax
  815031:	75 37                	jne    81506a <udp_sendto_if+0x62>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  815033:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815037:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  81503b:	0f b7 d0             	movzwl %ax,%edx
  81503e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  815042:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815046:	48 89 ce             	mov    %rcx,%rsi
  815049:	48 89 c7             	mov    %rax,%rdi
  81504c:	48 b8 b9 52 81 00 00 	movabs $0x8152b9,%rax
  815053:	00 00 00 
  815056:	ff d0                	callq  *%rax
  815058:	88 45 ef             	mov    %al,-0x11(%rbp)
    if (err != ERR_OK) {
  81505b:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81505f:	74 09                	je     81506a <udp_sendto_if+0x62>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
  815061:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  815065:	e9 4d 02 00 00       	jmpq   8152b7 <udp_sendto_if+0x2af>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  81506a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81506e:	be 08 00 00 00       	mov    $0x8,%esi
  815073:	48 89 c7             	mov    %rax,%rdi
  815076:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  81507d:	00 00 00 
  815080:	ff d0                	callq  *%rax
  815082:	84 c0                	test   %al,%al
  815084:	74 4c                	je     8150d2 <udp_sendto_if+0xca>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  815086:	ba 00 00 00 00       	mov    $0x0,%edx
  81508b:	be 08 00 00 00       	mov    $0x8,%esi
  815090:	bf 01 00 00 00       	mov    $0x1,%edi
  815095:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  81509c:	00 00 00 
  81509f:	ff d0                	callq  *%rax
  8150a1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  8150a5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8150aa:	75 0a                	jne    8150b6 <udp_sendto_if+0xae>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  8150ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8150b1:	e9 01 02 00 00       	jmpq   8152b7 <udp_sendto_if+0x2af>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  8150b6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8150ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8150be:	48 89 d6             	mov    %rdx,%rsi
  8150c1:	48 89 c7             	mov    %rax,%rdi
  8150c4:	48 b8 39 dd 80 00 00 	movabs $0x80dd39,%rax
  8150cb:	00 00 00 
  8150ce:	ff d0                	callq  *%rax
  8150d0:	eb 08                	jmp    8150da <udp_sendto_if+0xd2>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  8150d2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8150d6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  8150da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8150de:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8150e2:	66 83 f8 07          	cmp    $0x7,%ax
  8150e6:	77 2a                	ja     815112 <udp_sendto_if+0x10a>
  8150e8:	48 ba 88 26 82 00 00 	movabs $0x822688,%rdx
  8150ef:	00 00 00 
  8150f2:	be b2 01 00 00       	mov    $0x1b2,%esi
  8150f7:	48 bf 5c 26 82 00 00 	movabs $0x82265c,%rdi
  8150fe:	00 00 00 
  815101:	b8 00 00 00 00       	mov    $0x0,%eax
  815106:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81510d:	00 00 00 
  815110:	ff d1                	callq  *%rcx
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  815112:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815116:	48 8b 40 08          	mov    0x8(%rax),%rax
  81511a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  udphdr->src = htons(pcb->local_port);
  81511e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815122:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815126:	0f b7 c0             	movzwl %ax,%eax
  815129:	89 c7                	mov    %eax,%edi
  81512b:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  815132:	00 00 00 
  815135:	ff d0                	callq  *%rax
  815137:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81513b:	66 89 02             	mov    %ax,(%rdx)
  udphdr->dest = htons(dst_port);
  81513e:	0f b7 45 c4          	movzwl -0x3c(%rbp),%eax
  815142:	89 c7                	mov    %eax,%edi
  815144:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  81514b:	00 00 00 
  81514e:	ff d0                	callq  *%rax
  815150:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815154:	66 89 42 02          	mov    %ax,0x2(%rdx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  815158:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81515c:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  815162:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815166:	48 85 c0             	test   %rax,%rax
  815169:	74 0a                	je     815175 <udp_sendto_if+0x16d>
  81516b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81516f:	8b 00                	mov    (%rax),%eax
  815171:	85 c0                	test   %eax,%eax
  815173:	75 0e                	jne    815183 <udp_sendto_if+0x17b>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  815175:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815179:	48 83 c0 08          	add    $0x8,%rax
  81517d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815181:	eb 48                	jmp    8151cb <udp_sendto_if+0x1c3>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  815183:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815187:	8b 10                	mov    (%rax),%edx
  815189:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81518d:	8b 40 08             	mov    0x8(%rax),%eax
  815190:	39 c2                	cmp    %eax,%edx
  815192:	74 2f                	je     8151c3 <udp_sendto_if+0x1bb>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  815194:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815198:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81519c:	74 1b                	je     8151b9 <udp_sendto_if+0x1b1>
        /* free the header pbuf */
        pbuf_free(q);
  81519e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8151a2:	48 89 c7             	mov    %rax,%rdi
  8151a5:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8151ac:	00 00 00 
  8151af:	ff d0                	callq  *%rax
        q = NULL;
  8151b1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8151b8:	00 
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  8151b9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8151be:	e9 f4 00 00 00       	jmpq   8152b7 <udp_sendto_if+0x2af>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  8151c3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8151c7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  8151cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8151cf:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8151d3:	0f b7 c0             	movzwl %ax,%eax
  8151d6:	89 c7                	mov    %eax,%edi
  8151d8:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8151df:	00 00 00 
  8151e2:	ff d0                	callq  *%rax
  8151e4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8151e8:	66 89 42 04          	mov    %ax,0x4(%rdx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  8151ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8151f0:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8151f4:	0f b6 c0             	movzbl %al,%eax
  8151f7:	83 e0 01             	and    $0x1,%eax
  8151fa:	85 c0                	test   %eax,%eax
  8151fc:	75 4d                	jne    81524b <udp_sendto_if+0x243>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  8151fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815202:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  815206:	0f b7 c8             	movzwl %ax,%ecx
  815209:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81520d:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  815211:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815215:	41 89 c8             	mov    %ecx,%r8d
  815218:	b9 11 00 00 00       	mov    $0x11,%ecx
  81521d:	48 89 c7             	mov    %rax,%rdi
  815220:	48 b8 9a 24 81 00 00 	movabs $0x81249a,%rax
  815227:	00 00 00 
  81522a:	ff d0                	callq  *%rax
  81522c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815230:	66 89 42 06          	mov    %ax,0x6(%rdx)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  815234:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815238:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  81523c:	66 85 c0             	test   %ax,%ax
  81523f:	75 0a                	jne    81524b <udp_sendto_if+0x243>
  815241:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815245:	66 c7 40 06 ff ff    	movw   $0xffff,0x6(%rax)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  81524b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81524f:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  815253:	44 0f b6 c0          	movzbl %al,%r8d
  815257:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81525b:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  81525f:	0f b6 c8             	movzbl %al,%ecx
  815262:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815266:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81526a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81526e:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  815272:	48 89 3c 24          	mov    %rdi,(%rsp)
  815276:	41 b9 11 00 00 00    	mov    $0x11,%r9d
  81527c:	48 89 c7             	mov    %rax,%rdi
  81527f:	48 b8 e2 0f 81 00 00 	movabs $0x810fe2,%rax
  815286:	00 00 00 
  815289:	ff d0                	callq  *%rax
  81528b:	88 45 ef             	mov    %al,-0x11(%rbp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  81528e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815292:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  815296:	74 1b                	je     8152b3 <udp_sendto_if+0x2ab>
    /* free the header pbuf */
    pbuf_free(q);
  815298:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81529c:	48 89 c7             	mov    %rax,%rdi
  81529f:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8152a6:	00 00 00 
  8152a9:	ff d0                	callq  *%rax
    q = NULL;
  8152ab:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8152b2:	00 
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  8152b3:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  8152b7:	c9                   	leaveq 
  8152b8:	c3                   	retq   

00000000008152b9 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8152b9:	55                   	push   %rbp
  8152ba:	48 89 e5             	mov    %rsp,%rbp
  8152bd:	48 83 ec 30          	sub    $0x30,%rsp
  8152c1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8152c5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8152c9:	89 d0                	mov    %edx,%eax
  8152cb:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  8152cf:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8152d3:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8152da:	00 00 00 
  8152dd:	48 8b 00             	mov    (%rax),%rax
  8152e0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8152e4:	eb 4a                	jmp    815330 <udp_bind+0x77>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  8152e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8152ea:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8152ee:	75 34                	jne    815324 <udp_bind+0x6b>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  8152f0:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8152f4:	74 2a                	je     815320 <udp_bind+0x67>
  8152f6:	48 ba b6 26 82 00 00 	movabs $0x8226b6,%rdx
  8152fd:	00 00 00 
  815300:	be 41 02 00 00       	mov    $0x241,%esi
  815305:	48 bf 5c 26 82 00 00 	movabs $0x82265c,%rdi
  81530c:	00 00 00 
  81530f:	b8 00 00 00 00       	mov    $0x0,%eax
  815314:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81531b:	00 00 00 
  81531e:	ff d1                	callq  *%rcx
      /* pcb already in list, just rebind */
      rebind = 1;
  815320:	c6 45 f7 01          	movb   $0x1,-0x9(%rbp)
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  815324:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815328:	48 8b 40 10          	mov    0x10(%rax),%rax
  81532c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815330:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815335:	75 af                	jne    8152e6 <udp_bind+0x2d>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  815337:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81533c:	74 08                	je     815346 <udp_bind+0x8d>
  81533e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815342:	8b 00                	mov    (%rax),%eax
  815344:	eb 05                	jmp    81534b <udp_bind+0x92>
  815346:	b8 00 00 00 00       	mov    $0x0,%eax
  81534b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81534f:	89 02                	mov    %eax,(%rdx)

  /* no port specified? */
  if (port == 0) {
  815351:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  815356:	75 6e                	jne    8153c6 <udp_bind+0x10d>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  815358:	66 c7 45 dc 00 10    	movw   $0x1000,-0x24(%rbp)
    ipcb = udp_pcbs;
  81535e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815365:	00 00 00 
  815368:	48 8b 00             	mov    (%rax),%rax
  81536b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  81536f:	eb 38                	jmp    8153a9 <udp_bind+0xf0>
      if (ipcb->local_port == port) {
  815371:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815375:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815379:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  81537d:	75 1e                	jne    81539d <udp_bind+0xe4>
        /* port is already used by another udp_pcb */
        port++;
  81537f:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  815383:	83 c0 01             	add    $0x1,%eax
  815386:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  81538a:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815391:	00 00 00 
  815394:	48 8b 00             	mov    (%rax),%rax
  815397:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81539b:	eb 0c                	jmp    8153a9 <udp_bind+0xf0>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  81539d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8153a1:	48 8b 40 10          	mov    0x10(%rax),%rax
  8153a5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8153a9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8153ae:	74 08                	je     8153b8 <udp_bind+0xff>
  8153b0:	66 81 7d dc ff 7f    	cmpw   $0x7fff,-0x24(%rbp)
  8153b6:	75 b9                	jne    815371 <udp_bind+0xb8>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  8153b8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8153bd:	74 07                	je     8153c6 <udp_bind+0x10d>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  8153bf:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8153c4:	eb 3d                	jmp    815403 <udp_bind+0x14a>
    }
  }
  pcb->local_port = port;
  8153c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8153ca:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8153ce:	66 89 50 1a          	mov    %dx,0x1a(%rax)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  8153d2:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8153d6:	75 26                	jne    8153fe <udp_bind+0x145>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  8153d8:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8153df:	00 00 00 
  8153e2:	48 8b 10             	mov    (%rax),%rdx
  8153e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8153e9:	48 89 50 10          	mov    %rdx,0x10(%rax)
    udp_pcbs = pcb;
  8153ed:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8153f4:	00 00 00 
  8153f7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8153fb:	48 89 10             	mov    %rdx,(%rax)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  8153fe:	b8 00 00 00 00       	mov    $0x0,%eax
}
  815403:	c9                   	leaveq 
  815404:	c3                   	retq   

0000000000815405 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  815405:	55                   	push   %rbp
  815406:	48 89 e5             	mov    %rsp,%rbp
  815409:	48 83 ec 30          	sub    $0x30,%rsp
  81540d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815411:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  815415:	89 d0                	mov    %edx,%eax
  815417:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  81541b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81541f:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815423:	66 85 c0             	test   %ax,%ax
  815426:	75 37                	jne    81545f <udp_connect+0x5a>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  815428:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81542c:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815430:	0f b7 d0             	movzwl %ax,%edx
  815433:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  815437:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81543b:	48 89 ce             	mov    %rcx,%rsi
  81543e:	48 89 c7             	mov    %rax,%rdi
  815441:	48 b8 b9 52 81 00 00 	movabs $0x8152b9,%rax
  815448:	00 00 00 
  81544b:	ff d0                	callq  *%rax
  81544d:	88 45 f7             	mov    %al,-0x9(%rbp)
    if (err != ERR_OK)
  815450:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  815454:	74 09                	je     81545f <udp_connect+0x5a>
      return err;
  815456:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  81545a:	e9 9d 00 00 00       	jmpq   8154fc <udp_connect+0xf7>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  81545f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  815464:	74 08                	je     81546e <udp_connect+0x69>
  815466:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81546a:	8b 00                	mov    (%rax),%eax
  81546c:	eb 05                	jmp    815473 <udp_connect+0x6e>
  81546e:	b8 00 00 00 00       	mov    $0x0,%eax
  815473:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815477:	89 42 04             	mov    %eax,0x4(%rdx)
  pcb->remote_port = port;
  81547a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81547e:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  815482:	66 89 50 1c          	mov    %dx,0x1c(%rax)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  815486:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81548a:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81548e:	83 c8 04             	or     $0x4,%eax
  815491:	89 c2                	mov    %eax,%edx
  815493:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815497:	88 50 18             	mov    %dl,0x18(%rax)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  81549a:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8154a1:	00 00 00 
  8154a4:	48 8b 00             	mov    (%rax),%rax
  8154a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8154ab:	eb 1d                	jmp    8154ca <udp_connect+0xc5>
    if (pcb == ipcb) {
  8154ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8154b1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8154b5:	75 07                	jne    8154be <udp_connect+0xb9>
      /* already on the list, just return */
      return ERR_OK;
  8154b7:	b8 00 00 00 00       	mov    $0x0,%eax
  8154bc:	eb 3e                	jmp    8154fc <udp_connect+0xf7>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8154be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8154c2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8154c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8154ca:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8154cf:	75 dc                	jne    8154ad <udp_connect+0xa8>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  8154d1:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8154d8:	00 00 00 
  8154db:	48 8b 10             	mov    (%rax),%rdx
  8154de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8154e2:	48 89 50 10          	mov    %rdx,0x10(%rax)
  udp_pcbs = pcb;
  8154e6:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8154ed:	00 00 00 
  8154f0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8154f4:	48 89 10             	mov    %rdx,(%rax)
  return ERR_OK;
  8154f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8154fc:	c9                   	leaveq 
  8154fd:	c3                   	retq   

00000000008154fe <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  8154fe:	55                   	push   %rbp
  8154ff:	48 89 e5             	mov    %rsp,%rbp
  815502:	48 83 ec 08          	sub    $0x8,%rsp
  815506:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  81550a:	48 b8 68 22 82 00 00 	movabs $0x822268,%rax
  815511:	00 00 00 
  815514:	8b 10                	mov    (%rax),%edx
  815516:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81551a:	89 50 04             	mov    %edx,0x4(%rax)
  pcb->remote_port = 0;
  81551d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815521:	66 c7 40 1c 00 00    	movw   $0x0,0x1c(%rax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  815527:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81552b:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81552f:	83 e0 fb             	and    $0xfffffffb,%eax
  815532:	89 c2                	mov    %eax,%edx
  815534:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815538:	88 50 18             	mov    %dl,0x18(%rax)
}
  81553b:	c9                   	leaveq 
  81553c:	c3                   	retq   

000000000081553d <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  81553d:	55                   	push   %rbp
  81553e:	48 89 e5             	mov    %rsp,%rbp
  815541:	48 83 ec 18          	sub    $0x18,%rsp
  815545:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  815549:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81554d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  815551:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815555:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815559:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  81555d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815561:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815565:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  815569:	c9                   	leaveq 
  81556a:	c3                   	retq   

000000000081556b <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  81556b:	55                   	push   %rbp
  81556c:	48 89 e5             	mov    %rsp,%rbp
  81556f:	48 83 ec 20          	sub    $0x20,%rsp
  815573:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  815577:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81557e:	00 00 00 
  815581:	48 8b 00             	mov    (%rax),%rax
  815584:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  815588:	75 20                	jne    8155aa <udp_remove+0x3f>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  81558a:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815591:	00 00 00 
  815594:	48 8b 00             	mov    (%rax),%rax
  815597:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81559b:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8155a2:	00 00 00 
  8155a5:	48 89 10             	mov    %rdx,(%rax)
  8155a8:	eb 51                	jmp    8155fb <udp_remove+0x90>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8155aa:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8155b1:	00 00 00 
  8155b4:	48 8b 00             	mov    (%rax),%rax
  8155b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8155bb:	eb 37                	jmp    8155f4 <udp_remove+0x89>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  8155bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8155c1:	48 8b 40 10          	mov    0x10(%rax),%rax
  8155c5:	48 85 c0             	test   %rax,%rax
  8155c8:	74 1e                	je     8155e8 <udp_remove+0x7d>
  8155ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8155ce:	48 8b 40 10          	mov    0x10(%rax),%rax
  8155d2:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8155d6:	75 10                	jne    8155e8 <udp_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  8155d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8155dc:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8155e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8155e4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8155e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8155ec:	48 8b 40 10          	mov    0x10(%rax),%rax
  8155f0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8155f4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8155f9:	75 c2                	jne    8155bd <udp_remove+0x52>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  8155fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8155ff:	48 89 c6             	mov    %rax,%rsi
  815602:	bf 01 00 00 00       	mov    $0x1,%edi
  815607:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81560e:	00 00 00 
  815611:	ff d0                	callq  *%rax
}
  815613:	c9                   	leaveq 
  815614:	c3                   	retq   

0000000000815615 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  815615:	55                   	push   %rbp
  815616:	48 89 e5             	mov    %rsp,%rbp
  815619:	48 83 ec 10          	sub    $0x10,%rsp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  81561d:	bf 01 00 00 00       	mov    $0x1,%edi
  815622:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  815629:	00 00 00 
  81562c:	ff d0                	callq  *%rax
  81562e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  815632:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815637:	74 25                	je     81565e <udp_new+0x49>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  815639:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81563d:	ba 30 00 00 00       	mov    $0x30,%edx
  815642:	be 00 00 00 00       	mov    $0x0,%esi
  815647:	48 89 c7             	mov    %rax,%rdi
  81564a:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  815651:	00 00 00 
  815654:	ff d0                	callq  *%rax
    pcb->ttl = UDP_TTL;
  815656:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81565a:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
  }
  return pcb;
  81565e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  815662:	c9                   	leaveq 
  815663:	c3                   	retq   

0000000000815664 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  815664:	55                   	push   %rbp
  815665:	48 89 e5             	mov    %rsp,%rbp
  815668:	48 83 ec 20          	sub    $0x20,%rsp
  81566c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  815670:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815675:	75 2a                	jne    8156a1 <free_etharp_q+0x3d>
  815677:	48 ba d4 26 82 00 00 	movabs $0x8226d4,%rdx
  81567e:	00 00 00 
  815681:	be 93 00 00 00       	mov    $0x93,%esi
  815686:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  81568d:	00 00 00 
  815690:	b8 00 00 00 00       	mov    $0x0,%eax
  815695:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81569c:	00 00 00 
  81569f:	ff d1                	callq  *%rcx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  8156a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8156a5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8156a9:	48 85 c0             	test   %rax,%rax
  8156ac:	75 2a                	jne    8156d8 <free_etharp_q+0x74>
  8156ae:	48 ba f6 26 82 00 00 	movabs $0x8226f6,%rdx
  8156b5:	00 00 00 
  8156b8:	be 94 00 00 00       	mov    $0x94,%esi
  8156bd:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  8156c4:	00 00 00 
  8156c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8156cc:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8156d3:	00 00 00 
  8156d6:	ff d1                	callq  *%rcx
  while (q) {
  8156d8:	eb 79                	jmp    815753 <free_etharp_q+0xef>
    r = q;
  8156da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8156de:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    q = q->next;
  8156e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8156e6:	48 8b 00             	mov    (%rax),%rax
  8156e9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8156ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8156f1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8156f5:	48 85 c0             	test   %rax,%rax
  8156f8:	75 2a                	jne    815724 <free_etharp_q+0xc0>
  8156fa:	48 ba 03 27 82 00 00 	movabs $0x822703,%rdx
  815701:	00 00 00 
  815704:	be 98 00 00 00       	mov    $0x98,%esi
  815709:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  815710:	00 00 00 
  815713:	b8 00 00 00 00       	mov    $0x0,%eax
  815718:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81571f:	00 00 00 
  815722:	ff d1                	callq  *%rcx
    pbuf_free(r->p);
  815724:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815728:	48 8b 40 08          	mov    0x8(%rax),%rax
  81572c:	48 89 c7             	mov    %rax,%rdi
  81572f:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  815736:	00 00 00 
  815739:	ff d0                	callq  *%rax
    memp_free(MEMP_ARP_QUEUE, r);
  81573b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81573f:	48 89 c6             	mov    %rax,%rsi
  815742:	bf 0a 00 00 00       	mov    $0xa,%edi
  815747:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81574e:	00 00 00 
  815751:	ff d0                	callq  *%rax
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  815753:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815758:	75 80                	jne    8156da <free_etharp_q+0x76>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  81575a:	c9                   	leaveq 
  81575b:	c3                   	retq   

000000000081575c <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  81575c:	55                   	push   %rbp
  81575d:	48 89 e5             	mov    %rsp,%rbp
  815760:	48 83 ec 10          	sub    $0x10,%rsp
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815764:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  815768:	e9 df 01 00 00       	jmpq   81594c <etharp_tmr+0x1f0>
    arp_table[i].ctime++;
  81576d:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
  815771:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815778:	00 00 00 
  81577b:	48 63 ca             	movslq %edx,%rcx
  81577e:	48 89 c8             	mov    %rcx,%rax
  815781:	48 c1 e0 02          	shl    $0x2,%rax
  815785:	48 01 c8             	add    %rcx,%rax
  815788:	48 c1 e0 03          	shl    $0x3,%rax
  81578c:	48 01 f0             	add    %rsi,%rax
  81578f:	48 83 c0 10          	add    $0x10,%rax
  815793:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815797:	8d 48 01             	lea    0x1(%rax),%ecx
  81579a:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  8157a1:	00 00 00 
  8157a4:	48 63 d2             	movslq %edx,%rdx
  8157a7:	48 89 d0             	mov    %rdx,%rax
  8157aa:	48 c1 e0 02          	shl    $0x2,%rax
  8157ae:	48 01 d0             	add    %rdx,%rax
  8157b1:	48 c1 e0 03          	shl    $0x3,%rax
  8157b5:	48 01 f0             	add    %rsi,%rax
  8157b8:	48 83 c0 10          	add    $0x10,%rax
  8157bc:	88 48 08             	mov    %cl,0x8(%rax)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  8157bf:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8157c3:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8157ca:	00 00 00 
  8157cd:	48 63 d0             	movslq %eax,%rdx
  8157d0:	48 89 d0             	mov    %rdx,%rax
  8157d3:	48 c1 e0 02          	shl    $0x2,%rax
  8157d7:	48 01 d0             	add    %rdx,%rax
  8157da:	48 c1 e0 03          	shl    $0x3,%rax
  8157de:	48 01 c8             	add    %rcx,%rax
  8157e1:	48 83 c0 10          	add    $0x10,%rax
  8157e5:	8b 40 04             	mov    0x4(%rax),%eax
  8157e8:	83 f8 02             	cmp    $0x2,%eax
  8157eb:	75 2e                	jne    81581b <etharp_tmr+0xbf>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  8157ed:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8157f1:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8157f8:	00 00 00 
  8157fb:	48 63 d0             	movslq %eax,%rdx
  8157fe:	48 89 d0             	mov    %rdx,%rax
  815801:	48 c1 e0 02          	shl    $0x2,%rax
  815805:	48 01 d0             	add    %rdx,%rax
  815808:	48 c1 e0 03          	shl    $0x3,%rax
  81580c:	48 01 c8             	add    %rcx,%rax
  81580f:	48 83 c0 10          	add    $0x10,%rax
  815813:	0f b6 40 08          	movzbl 0x8(%rax),%eax

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  815817:	3c ef                	cmp    $0xef,%al
  815819:	77 64                	ja     81587f <etharp_tmr+0x123>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  81581b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81581f:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815826:	00 00 00 
  815829:	48 63 d0             	movslq %eax,%rdx
  81582c:	48 89 d0             	mov    %rdx,%rax
  81582f:	48 c1 e0 02          	shl    $0x2,%rax
  815833:	48 01 d0             	add    %rdx,%rax
  815836:	48 c1 e0 03          	shl    $0x3,%rax
  81583a:	48 01 c8             	add    %rcx,%rax
  81583d:	48 83 c0 10          	add    $0x10,%rax
  815841:	8b 40 04             	mov    0x4(%rax),%eax
  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  815844:	83 f8 01             	cmp    $0x1,%eax
  815847:	0f 85 e6 00 00 00    	jne    815933 <etharp_tmr+0x1d7>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
  81584d:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815851:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815858:	00 00 00 
  81585b:	48 63 d0             	movslq %eax,%rdx
  81585e:	48 89 d0             	mov    %rdx,%rax
  815861:	48 c1 e0 02          	shl    $0x2,%rax
  815865:	48 01 d0             	add    %rdx,%rax
  815868:	48 c1 e0 03          	shl    $0x3,%rax
  81586c:	48 01 c8             	add    %rcx,%rax
  81586f:	48 83 c0 10          	add    $0x10,%rax
  815873:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  815877:	3c 01                	cmp    $0x1,%al
  815879:	0f 86 b4 00 00 00    	jbe    815933 <etharp_tmr+0x1d7>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  81587f:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815883:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81588a:	00 00 00 
  81588d:	48 63 d0             	movslq %eax,%rdx
  815890:	48 89 d0             	mov    %rdx,%rax
  815893:	48 c1 e0 02          	shl    $0x2,%rax
  815897:	48 01 d0             	add    %rdx,%rax
  81589a:	48 c1 e0 03          	shl    $0x3,%rax
  81589e:	48 01 c8             	add    %rcx,%rax
  8158a1:	48 8b 00             	mov    (%rax),%rax
  8158a4:	48 85 c0             	test   %rax,%rax
  8158a7:	74 5d                	je     815906 <etharp_tmr+0x1aa>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  8158a9:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8158ad:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8158b4:	00 00 00 
  8158b7:	48 63 d0             	movslq %eax,%rdx
  8158ba:	48 89 d0             	mov    %rdx,%rax
  8158bd:	48 c1 e0 02          	shl    $0x2,%rax
  8158c1:	48 01 d0             	add    %rdx,%rax
  8158c4:	48 c1 e0 03          	shl    $0x3,%rax
  8158c8:	48 01 c8             	add    %rcx,%rax
  8158cb:	48 8b 00             	mov    (%rax),%rax
  8158ce:	48 89 c7             	mov    %rax,%rdi
  8158d1:	48 b8 64 56 81 00 00 	movabs $0x815664,%rax
  8158d8:	00 00 00 
  8158db:	ff d0                	callq  *%rax
        arp_table[i].q = NULL;
  8158dd:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8158e1:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8158e8:	00 00 00 
  8158eb:	48 63 d0             	movslq %eax,%rdx
  8158ee:	48 89 d0             	mov    %rdx,%rax
  8158f1:	48 c1 e0 02          	shl    $0x2,%rax
  8158f5:	48 01 d0             	add    %rdx,%rax
  8158f8:	48 c1 e0 03          	shl    $0x3,%rax
  8158fc:	48 01 c8             	add    %rcx,%rax
  8158ff:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  815906:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81590a:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815911:	00 00 00 
  815914:	48 63 d0             	movslq %eax,%rdx
  815917:	48 89 d0             	mov    %rdx,%rax
  81591a:	48 c1 e0 02          	shl    $0x2,%rax
  81591e:	48 01 d0             	add    %rdx,%rax
  815921:	48 c1 e0 03          	shl    $0x3,%rax
  815925:	48 01 c8             	add    %rcx,%rax
  815928:	48 83 c0 10          	add    $0x10,%rax
  81592c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    }
#if ARP_QUEUEING
    /* still pending entry? (not expired) */
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815933:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815937:	48 63 d0             	movslq %eax,%rdx
  81593a:	48 89 d0             	mov    %rdx,%rax
  81593d:	48 c1 e0 02          	shl    $0x2,%rax
  815941:	48 01 d0             	add    %rdx,%rax
  815944:	48 c1 e0 03          	shl    $0x3,%rax
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815948:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
  81594c:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  815950:	0f 86 17 fe ff ff    	jbe    81576d <etharp_tmr+0x11>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  815956:	c9                   	leaveq 
  815957:	c3                   	retq   

0000000000815958 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  815958:	55                   	push   %rbp
  815959:	48 89 e5             	mov    %rsp,%rbp
  81595c:	48 83 ec 20          	sub    $0x20,%rsp
  815960:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815964:	89 f0                	mov    %esi,%eax
  815966:	88 45 e4             	mov    %al,-0x1c(%rbp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  815969:	c6 45 ff 0a          	movb   $0xa,-0x1(%rbp)
  81596d:	c6 45 fe 0a          	movb   $0xa,-0x2(%rbp)
  s8_t empty = ARP_TABLE_SIZE;
  815971:	c6 45 fd 0a          	movb   $0xa,-0x3(%rbp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
  815975:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  815979:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  81597d:	c6 45 fa 00          	movb   $0x0,-0x6(%rbp)
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  815981:	c6 45 f9 0a          	movb   $0xa,-0x7(%rbp)
  /* its age */
  u8_t age_queue = 0;
  815985:	c6 45 f8 00          	movb   $0x0,-0x8(%rbp)
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  815989:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81598e:	0f 84 87 00 00 00    	je     815a1b <find_entry+0xc3>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  815994:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  81599b:	00 00 00 
  81599e:	0f b6 00             	movzbl (%rax),%eax
  8159a1:	0f b6 c0             	movzbl %al,%eax
  8159a4:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8159ab:	00 00 00 
  8159ae:	48 63 d0             	movslq %eax,%rdx
  8159b1:	48 89 d0             	mov    %rdx,%rax
  8159b4:	48 c1 e0 02          	shl    $0x2,%rax
  8159b8:	48 01 d0             	add    %rdx,%rax
  8159bb:	48 c1 e0 03          	shl    $0x3,%rax
  8159bf:	48 01 c8             	add    %rcx,%rax
  8159c2:	48 83 c0 10          	add    $0x10,%rax
  8159c6:	8b 40 04             	mov    0x4(%rax),%eax
  8159c9:	83 f8 02             	cmp    $0x2,%eax
  8159cc:	75 4d                	jne    815a1b <find_entry+0xc3>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  8159ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8159d2:	8b 08                	mov    (%rax),%ecx
  8159d4:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  8159db:	00 00 00 
  8159de:	0f b6 00             	movzbl (%rax),%eax
  8159e1:	0f b6 c0             	movzbl %al,%eax
  8159e4:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  8159eb:	00 00 00 
  8159ee:	48 63 d0             	movslq %eax,%rdx
  8159f1:	48 89 d0             	mov    %rdx,%rax
  8159f4:	48 c1 e0 02          	shl    $0x2,%rax
  8159f8:	48 01 d0             	add    %rdx,%rax
  8159fb:	48 c1 e0 03          	shl    $0x3,%rax
  8159ff:	48 01 f0             	add    %rsi,%rax
  815a02:	8b 40 08             	mov    0x8(%rax),%eax
  815a05:	39 c1                	cmp    %eax,%ecx
  815a07:	75 12                	jne    815a1b <find_entry+0xc3>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  815a09:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815a10:	00 00 00 
  815a13:	0f b6 00             	movzbl (%rax),%eax
  815a16:	e9 cf 04 00 00       	jmpq   815eea <find_entry+0x592>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815a1b:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  815a1f:	e9 aa 02 00 00       	jmpq   815cce <find_entry+0x376>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  815a24:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  815a28:	75 39                	jne    815a63 <find_entry+0x10b>
  815a2a:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815a2e:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815a35:	00 00 00 
  815a38:	48 63 d0             	movslq %eax,%rdx
  815a3b:	48 89 d0             	mov    %rdx,%rax
  815a3e:	48 c1 e0 02          	shl    $0x2,%rax
  815a42:	48 01 d0             	add    %rdx,%rax
  815a45:	48 c1 e0 03          	shl    $0x3,%rax
  815a49:	48 01 c8             	add    %rcx,%rax
  815a4c:	48 83 c0 10          	add    $0x10,%rax
  815a50:	8b 40 04             	mov    0x4(%rax),%eax
  815a53:	85 c0                	test   %eax,%eax
  815a55:	75 0c                	jne    815a63 <find_entry+0x10b>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  815a57:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815a5b:	88 45 fd             	mov    %al,-0x3(%rbp)
  815a5e:	e9 67 02 00 00       	jmpq   815cca <find_entry+0x372>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815a63:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815a67:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815a6e:	00 00 00 
  815a71:	48 63 d0             	movslq %eax,%rdx
  815a74:	48 89 d0             	mov    %rdx,%rax
  815a77:	48 c1 e0 02          	shl    $0x2,%rax
  815a7b:	48 01 d0             	add    %rdx,%rax
  815a7e:	48 c1 e0 03          	shl    $0x3,%rax
  815a82:	48 01 c8             	add    %rcx,%rax
  815a85:	48 83 c0 10          	add    $0x10,%rax
  815a89:	8b 40 04             	mov    0x4(%rax),%eax
  815a8c:	83 f8 01             	cmp    $0x1,%eax
  815a8f:	0f 85 51 01 00 00    	jne    815be6 <find_entry+0x28e>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  815a95:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815a9a:	74 48                	je     815ae4 <find_entry+0x18c>
  815a9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815aa0:	8b 08                	mov    (%rax),%ecx
  815aa2:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815aa6:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815aad:	00 00 00 
  815ab0:	48 63 d0             	movslq %eax,%rdx
  815ab3:	48 89 d0             	mov    %rdx,%rax
  815ab6:	48 c1 e0 02          	shl    $0x2,%rax
  815aba:	48 01 d0             	add    %rdx,%rax
  815abd:	48 c1 e0 03          	shl    $0x3,%rax
  815ac1:	48 01 f0             	add    %rsi,%rax
  815ac4:	8b 40 08             	mov    0x8(%rax),%eax
  815ac7:	39 c1                	cmp    %eax,%ecx
  815ac9:	75 19                	jne    815ae4 <find_entry+0x18c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  815acb:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815ad2:	00 00 00 
  815ad5:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815ad9:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  815adb:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815adf:	e9 06 04 00 00       	jmpq   815eea <find_entry+0x592>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  815ae4:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815ae8:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815aef:	00 00 00 
  815af2:	48 63 d0             	movslq %eax,%rdx
  815af5:	48 89 d0             	mov    %rdx,%rax
  815af8:	48 c1 e0 02          	shl    $0x2,%rax
  815afc:	48 01 d0             	add    %rdx,%rax
  815aff:	48 c1 e0 03          	shl    $0x3,%rax
  815b03:	48 01 c8             	add    %rcx,%rax
  815b06:	48 8b 00             	mov    (%rax),%rax
  815b09:	48 85 c0             	test   %rax,%rax
  815b0c:	74 6c                	je     815b7a <find_entry+0x222>
        if (arp_table[i].ctime >= age_queue) {
  815b0e:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815b12:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815b19:	00 00 00 
  815b1c:	48 63 d0             	movslq %eax,%rdx
  815b1f:	48 89 d0             	mov    %rdx,%rax
  815b22:	48 c1 e0 02          	shl    $0x2,%rax
  815b26:	48 01 d0             	add    %rdx,%rax
  815b29:	48 c1 e0 03          	shl    $0x3,%rax
  815b2d:	48 01 c8             	add    %rcx,%rax
  815b30:	48 83 c0 10          	add    $0x10,%rax
  815b34:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815b38:	3a 45 f8             	cmp    -0x8(%rbp),%al
  815b3b:	0f 82 89 01 00 00    	jb     815cca <find_entry+0x372>
          old_queue = i;
  815b41:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815b45:	88 45 f9             	mov    %al,-0x7(%rbp)
          age_queue = arp_table[i].ctime;
  815b48:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815b4c:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815b53:	00 00 00 
  815b56:	48 63 d0             	movslq %eax,%rdx
  815b59:	48 89 d0             	mov    %rdx,%rax
  815b5c:	48 c1 e0 02          	shl    $0x2,%rax
  815b60:	48 01 d0             	add    %rdx,%rax
  815b63:	48 c1 e0 03          	shl    $0x3,%rax
  815b67:	48 01 c8             	add    %rcx,%rax
  815b6a:	48 83 c0 10          	add    $0x10,%rax
  815b6e:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815b72:	88 45 f8             	mov    %al,-0x8(%rbp)
  815b75:	e9 50 01 00 00       	jmpq   815cca <find_entry+0x372>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  815b7a:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815b7e:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815b85:	00 00 00 
  815b88:	48 63 d0             	movslq %eax,%rdx
  815b8b:	48 89 d0             	mov    %rdx,%rax
  815b8e:	48 c1 e0 02          	shl    $0x2,%rax
  815b92:	48 01 d0             	add    %rdx,%rax
  815b95:	48 c1 e0 03          	shl    $0x3,%rax
  815b99:	48 01 c8             	add    %rcx,%rax
  815b9c:	48 83 c0 10          	add    $0x10,%rax
  815ba0:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815ba4:	3a 45 fb             	cmp    -0x5(%rbp),%al
  815ba7:	0f 82 1d 01 00 00    	jb     815cca <find_entry+0x372>
          old_pending = i;
  815bad:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815bb1:	88 45 ff             	mov    %al,-0x1(%rbp)
          age_pending = arp_table[i].ctime;
  815bb4:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815bb8:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815bbf:	00 00 00 
  815bc2:	48 63 d0             	movslq %eax,%rdx
  815bc5:	48 89 d0             	mov    %rdx,%rax
  815bc8:	48 c1 e0 02          	shl    $0x2,%rax
  815bcc:	48 01 d0             	add    %rdx,%rax
  815bcf:	48 c1 e0 03          	shl    $0x3,%rax
  815bd3:	48 01 c8             	add    %rcx,%rax
  815bd6:	48 83 c0 10          	add    $0x10,%rax
  815bda:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815bde:	88 45 fb             	mov    %al,-0x5(%rbp)
  815be1:	e9 e4 00 00 00       	jmpq   815cca <find_entry+0x372>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  815be6:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815bea:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815bf1:	00 00 00 
  815bf4:	48 63 d0             	movslq %eax,%rdx
  815bf7:	48 89 d0             	mov    %rdx,%rax
  815bfa:	48 c1 e0 02          	shl    $0x2,%rax
  815bfe:	48 01 d0             	add    %rdx,%rax
  815c01:	48 c1 e0 03          	shl    $0x3,%rax
  815c05:	48 01 c8             	add    %rcx,%rax
  815c08:	48 83 c0 10          	add    $0x10,%rax
  815c0c:	8b 40 04             	mov    0x4(%rax),%eax
  815c0f:	83 f8 02             	cmp    $0x2,%eax
  815c12:	0f 85 b2 00 00 00    	jne    815cca <find_entry+0x372>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  815c18:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815c1d:	74 48                	je     815c67 <find_entry+0x30f>
  815c1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815c23:	8b 08                	mov    (%rax),%ecx
  815c25:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c29:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815c30:	00 00 00 
  815c33:	48 63 d0             	movslq %eax,%rdx
  815c36:	48 89 d0             	mov    %rdx,%rax
  815c39:	48 c1 e0 02          	shl    $0x2,%rax
  815c3d:	48 01 d0             	add    %rdx,%rax
  815c40:	48 c1 e0 03          	shl    $0x3,%rax
  815c44:	48 01 f0             	add    %rsi,%rax
  815c47:	8b 40 08             	mov    0x8(%rax),%eax
  815c4a:	39 c1                	cmp    %eax,%ecx
  815c4c:	75 19                	jne    815c67 <find_entry+0x30f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  815c4e:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815c55:	00 00 00 
  815c58:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815c5c:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  815c5e:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c62:	e9 83 02 00 00       	jmpq   815eea <find_entry+0x592>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  815c67:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c6b:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815c72:	00 00 00 
  815c75:	48 63 d0             	movslq %eax,%rdx
  815c78:	48 89 d0             	mov    %rdx,%rax
  815c7b:	48 c1 e0 02          	shl    $0x2,%rax
  815c7f:	48 01 d0             	add    %rdx,%rax
  815c82:	48 c1 e0 03          	shl    $0x3,%rax
  815c86:	48 01 c8             	add    %rcx,%rax
  815c89:	48 83 c0 10          	add    $0x10,%rax
  815c8d:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815c91:	3a 45 fa             	cmp    -0x6(%rbp),%al
  815c94:	72 34                	jb     815cca <find_entry+0x372>
        old_stable = i;
  815c96:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c9a:	88 45 fe             	mov    %al,-0x2(%rbp)
        age_stable = arp_table[i].ctime;
  815c9d:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815ca1:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815ca8:	00 00 00 
  815cab:	48 63 d0             	movslq %eax,%rdx
  815cae:	48 89 d0             	mov    %rdx,%rax
  815cb1:	48 c1 e0 02          	shl    $0x2,%rax
  815cb5:	48 01 d0             	add    %rdx,%rax
  815cb8:	48 c1 e0 03          	shl    $0x3,%rax
  815cbc:	48 01 c8             	add    %rcx,%rax
  815cbf:	48 83 c0 10          	add    $0x10,%rax
  815cc3:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815cc7:	88 45 fa             	mov    %al,-0x6(%rbp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815cca:	80 45 fc 01          	addb   $0x1,-0x4(%rbp)
  815cce:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  815cd2:	0f 86 4c fd ff ff    	jbe    815a24 <find_entry+0xcc>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  815cd8:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  815cdc:	75 0b                	jne    815ce9 <find_entry+0x391>
  815cde:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  815ce2:	83 e0 01             	and    $0x1,%eax
  815ce5:	85 c0                	test   %eax,%eax
  815ce7:	74 0b                	je     815cf4 <find_entry+0x39c>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  815ce9:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  815ced:	83 e0 02             	and    $0x2,%eax
  815cf0:	85 c0                	test   %eax,%eax
  815cf2:	74 0a                	je     815cfe <find_entry+0x3a6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  815cf4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  815cf9:	e9 ec 01 00 00       	jmpq   815eea <find_entry+0x592>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  815cfe:	80 7d fd 09          	cmpb   $0x9,-0x3(%rbp)
  815d02:	7f 0c                	jg     815d10 <find_entry+0x3b8>
    i = empty;
  815d04:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
  815d08:	88 45 fc             	mov    %al,-0x4(%rbp)
  815d0b:	e9 ea 00 00 00       	jmpq   815dfa <find_entry+0x4a2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  815d10:	80 7d fe 09          	cmpb   $0x9,-0x2(%rbp)
  815d14:	7f 5f                	jg     815d75 <find_entry+0x41d>
    /* recycle oldest stable*/
    i = old_stable;
  815d16:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
  815d1a:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  815d1d:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815d21:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815d28:	00 00 00 
  815d2b:	48 63 d0             	movslq %eax,%rdx
  815d2e:	48 89 d0             	mov    %rdx,%rax
  815d31:	48 c1 e0 02          	shl    $0x2,%rax
  815d35:	48 01 d0             	add    %rdx,%rax
  815d38:	48 c1 e0 03          	shl    $0x3,%rax
  815d3c:	48 01 c8             	add    %rcx,%rax
  815d3f:	48 8b 00             	mov    (%rax),%rax
  815d42:	48 85 c0             	test   %rax,%rax
  815d45:	0f 84 af 00 00 00    	je     815dfa <find_entry+0x4a2>
  815d4b:	48 ba 10 27 82 00 00 	movabs $0x822710,%rdx
  815d52:	00 00 00 
  815d55:	be 75 01 00 00       	mov    $0x175,%esi
  815d5a:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  815d61:	00 00 00 
  815d64:	b8 00 00 00 00       	mov    $0x0,%eax
  815d69:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  815d70:	00 00 00 
  815d73:	ff d1                	callq  *%rcx
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  815d75:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  815d79:	7f 09                	jg     815d84 <find_entry+0x42c>
    /* recycle oldest pending */
    i = old_pending;
  815d7b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815d7f:	88 45 fc             	mov    %al,-0x4(%rbp)
  815d82:	eb 76                	jmp    815dfa <find_entry+0x4a2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  815d84:	80 7d f9 09          	cmpb   $0x9,-0x7(%rbp)
  815d88:	7f 66                	jg     815df0 <find_entry+0x498>
    /* recycle oldest pending */
    i = old_queue;
  815d8a:	0f b6 45 f9          	movzbl -0x7(%rbp),%eax
  815d8e:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  815d91:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815d95:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815d9c:	00 00 00 
  815d9f:	48 63 d0             	movslq %eax,%rdx
  815da2:	48 89 d0             	mov    %rdx,%rax
  815da5:	48 c1 e0 02          	shl    $0x2,%rax
  815da9:	48 01 d0             	add    %rdx,%rax
  815dac:	48 c1 e0 03          	shl    $0x3,%rax
  815db0:	48 01 c8             	add    %rcx,%rax
  815db3:	48 8b 00             	mov    (%rax),%rax
  815db6:	48 89 c7             	mov    %rax,%rdi
  815db9:	48 b8 64 56 81 00 00 	movabs $0x815664,%rax
  815dc0:	00 00 00 
  815dc3:	ff d0                	callq  *%rax
    arp_table[i].q = NULL;
  815dc5:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815dc9:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815dd0:	00 00 00 
  815dd3:	48 63 d0             	movslq %eax,%rdx
  815dd6:	48 89 d0             	mov    %rdx,%rax
  815dd9:	48 c1 e0 02          	shl    $0x2,%rax
  815ddd:	48 01 d0             	add    %rdx,%rax
  815de0:	48 c1 e0 03          	shl    $0x3,%rax
  815de4:	48 01 c8             	add    %rcx,%rax
  815de7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  815dee:	eb 0a                	jmp    815dfa <find_entry+0x4a2>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  815df0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  815df5:	e9 f0 00 00 00       	jmpq   815eea <find_entry+0x592>
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  815dfa:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  815dfe:	76 2a                	jbe    815e2a <find_entry+0x4d2>
  815e00:	48 ba 27 27 82 00 00 	movabs $0x822727,%rdx
  815e07:	00 00 00 
  815e0a:	be 8b 01 00 00       	mov    $0x18b,%esi
  815e0f:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  815e16:	00 00 00 
  815e19:	b8 00 00 00 00       	mov    $0x0,%eax
  815e1e:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  815e25:	00 00 00 
  815e28:	ff d1                	callq  *%rcx

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  815e2a:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e2e:	48 63 d0             	movslq %eax,%rdx
  815e31:	48 89 d0             	mov    %rdx,%rax
  815e34:	48 c1 e0 02          	shl    $0x2,%rax
  815e38:	48 01 d0             	add    %rdx,%rax
  815e3b:	48 c1 e0 03          	shl    $0x3,%rax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  815e3f:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e43:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815e4a:	00 00 00 
  815e4d:	48 63 d0             	movslq %eax,%rdx
  815e50:	48 89 d0             	mov    %rdx,%rax
  815e53:	48 c1 e0 02          	shl    $0x2,%rax
  815e57:	48 01 d0             	add    %rdx,%rax
  815e5a:	48 c1 e0 03          	shl    $0x3,%rax
  815e5e:	48 01 c8             	add    %rcx,%rax
  815e61:	48 83 c0 10          	add    $0x10,%rax
  815e65:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)

  /* IP address given? */
  if (ipaddr != NULL) {
  815e6c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815e71:	74 39                	je     815eac <find_entry+0x554>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  815e73:	0f b6 4d fc          	movzbl -0x4(%rbp),%ecx
  815e77:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815e7c:	74 08                	je     815e86 <find_entry+0x52e>
  815e7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815e82:	8b 10                	mov    (%rax),%edx
  815e84:	eb 05                	jmp    815e8b <find_entry+0x533>
  815e86:	ba 00 00 00 00       	mov    $0x0,%edx
  815e8b:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815e92:	00 00 00 
  815e95:	48 63 c9             	movslq %ecx,%rcx
  815e98:	48 89 c8             	mov    %rcx,%rax
  815e9b:	48 c1 e0 02          	shl    $0x2,%rax
  815e9f:	48 01 c8             	add    %rcx,%rax
  815ea2:	48 c1 e0 03          	shl    $0x3,%rax
  815ea6:	48 01 f0             	add    %rsi,%rax
  815ea9:	89 50 08             	mov    %edx,0x8(%rax)
  }
  arp_table[i].ctime = 0;
  815eac:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815eb0:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815eb7:	00 00 00 
  815eba:	48 63 d0             	movslq %eax,%rdx
  815ebd:	48 89 d0             	mov    %rdx,%rax
  815ec0:	48 c1 e0 02          	shl    $0x2,%rax
  815ec4:	48 01 d0             	add    %rdx,%rax
  815ec7:	48 c1 e0 03          	shl    $0x3,%rax
  815ecb:	48 01 c8             	add    %rcx,%rax
  815ece:	48 83 c0 10          	add    $0x10,%rax
  815ed2:	c6 40 08 00          	movb   $0x0,0x8(%rax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  815ed6:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815edd:	00 00 00 
  815ee0:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815ee4:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  815ee6:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
}
  815eea:	c9                   	leaveq 
  815eeb:	c3                   	retq   

0000000000815eec <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  815eec:	55                   	push   %rbp
  815eed:	48 89 e5             	mov    %rsp,%rbp
  815ef0:	48 83 ec 30          	sub    $0x30,%rsp
  815ef4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815ef8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  815efc:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  815f00:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  struct eth_hdr *ethhdr = p->payload;
  815f04:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815f08:	48 8b 40 08          	mov    0x8(%rax),%rax
  815f0c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  815f10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815f14:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  815f18:	3c 06                	cmp    $0x6,%al
  815f1a:	74 2a                	je     815f46 <etharp_send_ip+0x5a>
  815f1c:	48 ba 40 27 82 00 00 	movabs $0x822740,%rdx
  815f23:	00 00 00 
  815f26:	be b3 01 00 00       	mov    $0x1b3,%esi
  815f2b:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  815f32:	00 00 00 
  815f35:	b8 00 00 00 00       	mov    $0x0,%eax
  815f3a:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  815f41:	00 00 00 
  815f44:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  815f46:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  while(k > 0) {
  815f4a:	eb 43                	jmp    815f8f <etharp_send_ip+0xa3>
    k--;
  815f4c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815f50:	83 e8 01             	sub    $0x1,%eax
  815f53:	88 45 ff             	mov    %al,-0x1(%rbp)
    ethhdr->dest.addr[k] = dst->addr[k];
  815f56:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  815f5a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815f5e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  815f62:	48 98                	cltq   
  815f64:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  815f68:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815f6c:	48 63 c6             	movslq %esi,%rax
  815f6f:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  815f72:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  815f76:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815f7a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  815f7e:	48 98                	cltq   
  815f80:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  815f84:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815f88:	48 63 c6             	movslq %esi,%rax
  815f8b:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  815f8f:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  815f93:	75 b7                	jne    815f4c <etharp_send_ip+0x60>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  815f95:	bf 00 08 00 00       	mov    $0x800,%edi
  815f9a:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  815fa1:	00 00 00 
  815fa4:	ff d0                	callq  *%rax
  815fa6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815faa:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  815fae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815fb2:	48 8b 40 28          	mov    0x28(%rax),%rax
  815fb6:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  815fba:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815fbe:	48 89 ce             	mov    %rcx,%rsi
  815fc1:	48 89 d7             	mov    %rdx,%rdi
  815fc4:	ff d0                	callq  *%rax
}
  815fc6:	c9                   	leaveq 
  815fc7:	c3                   	retq   

0000000000815fc8 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  815fc8:	55                   	push   %rbp
  815fc9:	48 89 e5             	mov    %rsp,%rbp
  815fcc:	53                   	push   %rbx
  815fcd:	48 83 ec 48          	sub    $0x48,%rsp
  815fd1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  815fd5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  815fd9:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  815fdd:	89 c8                	mov    %ecx,%eax
  815fdf:	88 45 b4             	mov    %al,-0x4c(%rbp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  815fe2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815fe6:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  815fea:	3c 06                	cmp    $0x6,%al
  815fec:	74 2a                	je     816018 <update_arp_entry+0x50>
  815fee:	48 ba 88 27 82 00 00 	movabs $0x822788,%rdx
  815ff5:	00 00 00 
  815ff8:	be d9 01 00 00       	mov    $0x1d9,%esi
  815ffd:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  816004:	00 00 00 
  816007:	b8 00 00 00 00       	mov    $0x0,%eax
  81600c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  816013:	00 00 00 
  816016:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  816018:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  81601d:	74 56                	je     816075 <update_arp_entry+0xad>
  81601f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816023:	8b 00                	mov    (%rax),%eax
  816025:	85 c0                	test   %eax,%eax
  816027:	74 4c                	je     816075 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
  816029:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81602d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816031:	48 89 d6             	mov    %rdx,%rsi
  816034:	48 89 c7             	mov    %rax,%rdi
  816037:	48 b8 10 0a 81 00 00 	movabs $0x810a10,%rax
  81603e:	00 00 00 
  816041:	ff d0                	callq  *%rax
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  816043:	84 c0                	test   %al,%al
  816045:	75 2e                	jne    816075 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  816047:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81604b:	8b 18                	mov    (%rax),%ebx
  81604d:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816052:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  816059:	00 00 00 
  81605c:	ff d0                	callq  *%rax
  81605e:	21 c3                	and    %eax,%ebx
  816060:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  816065:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  81606c:	00 00 00 
  81606f:	ff d0                	callq  *%rax
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  816071:	39 c3                	cmp    %eax,%ebx
  816073:	75 0a                	jne    81607f <update_arp_entry+0xb7>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  816075:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  81607a:	e9 f0 01 00 00       	jmpq   81626f <update_arp_entry+0x2a7>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  81607f:	0f b6 55 b4          	movzbl -0x4c(%rbp),%edx
  816083:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816087:	89 d6                	mov    %edx,%esi
  816089:	48 89 c7             	mov    %rax,%rdi
  81608c:	48 b8 58 59 81 00 00 	movabs $0x815958,%rax
  816093:	00 00 00 
  816096:	ff d0                	callq  *%rax
  816098:	88 45 ee             	mov    %al,-0x12(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  81609b:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  81609f:	79 09                	jns    8160aa <update_arp_entry+0xe2>
    return (err_t)i;
  8160a1:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  8160a5:	e9 c5 01 00 00       	jmpq   81626f <update_arp_entry+0x2a7>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  8160aa:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  8160ae:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8160b5:	00 00 00 
  8160b8:	48 63 d0             	movslq %eax,%rdx
  8160bb:	48 89 d0             	mov    %rdx,%rax
  8160be:	48 c1 e0 02          	shl    $0x2,%rax
  8160c2:	48 01 d0             	add    %rdx,%rax
  8160c5:	48 c1 e0 03          	shl    $0x3,%rax
  8160c9:	48 01 c8             	add    %rcx,%rax
  8160cc:	48 83 c0 10          	add    $0x10,%rax
  8160d0:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
  /* record network interface */
  arp_table[i].netif = netif;
  8160d7:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  8160db:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8160e2:	00 00 00 
  8160e5:	48 63 d0             	movslq %eax,%rdx
  8160e8:	48 89 d0             	mov    %rdx,%rax
  8160eb:	48 c1 e0 02          	shl    $0x2,%rax
  8160ef:	48 01 d0             	add    %rdx,%rax
  8160f2:	48 c1 e0 03          	shl    $0x3,%rax
  8160f6:	48 01 c8             	add    %rcx,%rax
  8160f9:	48 8d 50 20          	lea    0x20(%rax),%rdx
  8160fd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816101:	48 89 02             	mov    %rax,(%rdx)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  816104:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
  while (k > 0) {
  816108:	eb 48                	jmp    816152 <update_arp_entry+0x18a>
    k--;
  81610a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81610e:	83 e8 01             	sub    $0x1,%eax
  816111:	88 45 ef             	mov    %al,-0x11(%rbp)
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  816114:	44 0f be 45 ee       	movsbl -0x12(%rbp),%r8d
  816119:	0f b6 7d ef          	movzbl -0x11(%rbp),%edi
  81611d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816121:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816125:	48 98                	cltq   
  816127:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  81612b:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  816132:	00 00 00 
  816135:	48 63 ff             	movslq %edi,%rdi
  816138:	49 63 d0             	movslq %r8d,%rdx
  81613b:	48 89 d0             	mov    %rdx,%rax
  81613e:	48 c1 e0 02          	shl    $0x2,%rax
  816142:	48 01 d0             	add    %rdx,%rax
  816145:	48 c1 e0 03          	shl    $0x3,%rax
  816149:	48 01 f8             	add    %rdi,%rax
  81614c:	48 01 f0             	add    %rsi,%rax
  81614f:	88 48 0c             	mov    %cl,0xc(%rax)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  816152:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  816156:	75 b2                	jne    81610a <update_arp_entry+0x142>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  816158:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81615c:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816163:	00 00 00 
  816166:	48 63 d0             	movslq %eax,%rdx
  816169:	48 89 d0             	mov    %rdx,%rax
  81616c:	48 c1 e0 02          	shl    $0x2,%rax
  816170:	48 01 d0             	add    %rdx,%rax
  816173:	48 c1 e0 03          	shl    $0x3,%rax
  816177:	48 01 c8             	add    %rcx,%rax
  81617a:	48 83 c0 10          	add    $0x10,%rax
  81617e:	c6 40 08 00          	movb   $0x0,0x8(%rax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  816182:	e9 b5 00 00 00       	jmpq   81623c <update_arp_entry+0x274>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
  816187:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81618b:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816192:	00 00 00 
  816195:	48 63 d0             	movslq %eax,%rdx
  816198:	48 89 d0             	mov    %rdx,%rax
  81619b:	48 c1 e0 02          	shl    $0x2,%rax
  81619f:	48 01 d0             	add    %rdx,%rax
  8161a2:	48 c1 e0 03          	shl    $0x3,%rax
  8161a6:	48 01 c8             	add    %rcx,%rax
  8161a9:	48 8b 00             	mov    (%rax),%rax
  8161ac:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  8161b0:	0f be 55 ee          	movsbl -0x12(%rbp),%edx
  8161b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8161b8:	48 8b 08             	mov    (%rax),%rcx
  8161bb:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  8161c2:	00 00 00 
  8161c5:	48 63 d2             	movslq %edx,%rdx
  8161c8:	48 89 d0             	mov    %rdx,%rax
  8161cb:	48 c1 e0 02          	shl    $0x2,%rax
  8161cf:	48 01 d0             	add    %rdx,%rax
  8161d2:	48 c1 e0 03          	shl    $0x3,%rax
  8161d6:	48 01 f0             	add    %rsi,%rax
  8161d9:	48 89 08             	mov    %rcx,(%rax)
    /* get the packet pointer */
    p = q->p;
  8161dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8161e0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8161e4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  8161e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8161ec:	48 89 c6             	mov    %rax,%rsi
  8161ef:	bf 0a 00 00 00       	mov    $0xa,%edi
  8161f4:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  8161fb:	00 00 00 
  8161fe:	ff d0                	callq  *%rax
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  816200:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816204:	48 8d 78 41          	lea    0x41(%rax),%rdi
  816208:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81620c:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  816210:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816214:	48 89 d1             	mov    %rdx,%rcx
  816217:	48 89 fa             	mov    %rdi,%rdx
  81621a:	48 89 c7             	mov    %rax,%rdi
  81621d:	48 b8 ec 5e 81 00 00 	movabs $0x815eec,%rax
  816224:	00 00 00 
  816227:	ff d0                	callq  *%rax
    /* free the queued IP packet */
    pbuf_free(p);
  816229:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81622d:	48 89 c7             	mov    %rax,%rdi
  816230:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  816237:	00 00 00 
  81623a:	ff d0                	callq  *%rax
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  81623c:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  816240:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816247:	00 00 00 
  81624a:	48 63 d0             	movslq %eax,%rdx
  81624d:	48 89 d0             	mov    %rdx,%rax
  816250:	48 c1 e0 02          	shl    $0x2,%rax
  816254:	48 01 d0             	add    %rdx,%rax
  816257:	48 c1 e0 03          	shl    $0x3,%rax
  81625b:	48 01 c8             	add    %rcx,%rax
  81625e:	48 8b 00             	mov    (%rax),%rax
  816261:	48 85 c0             	test   %rax,%rax
  816264:	0f 85 1d ff ff ff    	jne    816187 <update_arp_entry+0x1bf>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
  81626a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81626f:	48 83 c4 48          	add    $0x48,%rsp
  816273:	5b                   	pop    %rbx
  816274:	5d                   	pop    %rbp
  816275:	c3                   	retq   

0000000000816276 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  816276:	55                   	push   %rbp
  816277:	48 89 e5             	mov    %rsp,%rbp
  81627a:	48 83 ec 30          	sub    $0x30,%rsp
  81627e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  816282:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  816286:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81628a:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  81628e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816292:	be 02 00 00 00       	mov    $0x2,%esi
  816297:	48 89 c7             	mov    %rax,%rdi
  81629a:	48 b8 58 59 81 00 00 	movabs $0x815958,%rax
  8162a1:	00 00 00 
  8162a4:	ff d0                	callq  *%rax
  8162a6:	88 45 ff             	mov    %al,-0x1(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  8162a9:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8162ad:	0f 88 8e 00 00 00    	js     816341 <etharp_find_addr+0xcb>
  8162b3:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8162b7:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8162be:	00 00 00 
  8162c1:	48 63 d0             	movslq %eax,%rdx
  8162c4:	48 89 d0             	mov    %rdx,%rax
  8162c7:	48 c1 e0 02          	shl    $0x2,%rax
  8162cb:	48 01 d0             	add    %rdx,%rax
  8162ce:	48 c1 e0 03          	shl    $0x3,%rax
  8162d2:	48 01 c8             	add    %rcx,%rax
  8162d5:	48 83 c0 10          	add    $0x10,%rax
  8162d9:	8b 40 04             	mov    0x4(%rax),%eax
  8162dc:	83 f8 02             	cmp    $0x2,%eax
  8162df:	75 60                	jne    816341 <etharp_find_addr+0xcb>
      *eth_ret = &arp_table[i].ethaddr;
  8162e1:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8162e5:	48 63 d0             	movslq %eax,%rdx
  8162e8:	48 89 d0             	mov    %rdx,%rax
  8162eb:	48 c1 e0 02          	shl    $0x2,%rax
  8162ef:	48 01 d0             	add    %rdx,%rax
  8162f2:	48 c1 e0 03          	shl    $0x3,%rax
  8162f6:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  8162fd:	00 00 00 
  816300:	48 01 d0             	add    %rdx,%rax
  816303:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  816307:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81630b:	48 89 10             	mov    %rdx,(%rax)
      *ip_ret = &arp_table[i].ipaddr;
  81630e:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  816312:	48 63 d0             	movslq %eax,%rdx
  816315:	48 89 d0             	mov    %rdx,%rax
  816318:	48 c1 e0 02          	shl    $0x2,%rax
  81631c:	48 01 d0             	add    %rdx,%rax
  81631f:	48 c1 e0 03          	shl    $0x3,%rax
  816323:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  81632a:	00 00 00 
  81632d:	48 01 d0             	add    %rdx,%rax
  816330:	48 8d 50 08          	lea    0x8(%rax),%rdx
  816334:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816338:	48 89 10             	mov    %rdx,(%rax)
      return i;
  81633b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81633f:	eb 05                	jmp    816346 <etharp_find_addr+0xd0>
  }
  return -1;
  816341:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  816346:	c9                   	leaveq 
  816347:	c3                   	retq   

0000000000816348 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  816348:	55                   	push   %rbp
  816349:	48 89 e5             	mov    %rsp,%rbp
  81634c:	48 83 ec 20          	sub    $0x20,%rsp
  816350:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  816354:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  816358:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81635d:	75 2a                	jne    816389 <etharp_ip_input+0x41>
  81635f:	48 ba af 27 82 00 00 	movabs $0x8227af,%rdx
  816366:	00 00 00 
  816369:	be 48 02 00 00       	mov    $0x248,%esi
  81636e:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  816375:	00 00 00 
  816378:	b8 00 00 00 00       	mov    $0x0,%eax
  81637d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  816384:	00 00 00 
  816387:	ff d1                	callq  *%rcx
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  816389:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81638d:	48 8b 40 08          	mov    0x8(%rax),%rax
  816391:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  816395:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816399:	8b 50 1c             	mov    0x1c(%rax),%edx
  81639c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8163a0:	8b 40 08             	mov    0x8(%rax),%eax
  8163a3:	31 c2                	xor    %eax,%edx
  8163a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8163a9:	8b 40 0c             	mov    0xc(%rax),%eax
  8163ac:	21 d0                	and    %edx,%eax
  8163ae:	85 c0                	test   %eax,%eax
  8163b0:	74 02                	je     8163b4 <etharp_ip_input+0x6c>
    /* do nothing */
    return;
  8163b2:	eb 28                	jmp    8163dc <etharp_ip_input+0x94>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  8163b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8163b8:	48 8d 50 06          	lea    0x6(%rax),%rdx
  8163bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8163c0:	48 8d 70 1c          	lea    0x1c(%rax),%rsi
  8163c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8163c8:	b9 00 00 00 00       	mov    $0x0,%ecx
  8163cd:	48 89 c7             	mov    %rax,%rdi
  8163d0:	48 b8 c8 5f 81 00 00 	movabs $0x815fc8,%rax
  8163d7:	00 00 00 
  8163da:	ff d0                	callq  *%rax
}
  8163dc:	c9                   	leaveq 
  8163dd:	c3                   	retq   

00000000008163de <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  8163de:	55                   	push   %rbp
  8163df:	48 89 e5             	mov    %rsp,%rbp
  8163e2:	53                   	push   %rbx
  8163e3:	48 83 ec 58          	sub    $0x58,%rsp
  8163e7:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8163eb:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8163ef:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8163f3:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8163f8:	75 2a                	jne    816424 <etharp_arp_input+0x46>
  8163fa:	48 ba af 27 82 00 00 	movabs $0x8227af,%rdx
  816401:	00 00 00 
  816404:	be 75 02 00 00       	mov    $0x275,%esi
  816409:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  816410:	00 00 00 
  816413:	b8 00 00 00 00       	mov    $0x0,%eax
  816418:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81641f:	00 00 00 
  816422:	ff d1                	callq  *%rcx
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  816424:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816428:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81642c:	66 83 f8 29          	cmp    $0x29,%ax
  816430:	77 18                	ja     81644a <etharp_arp_input+0x6c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  816432:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816436:	48 89 c7             	mov    %rax,%rdi
  816439:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  816440:	00 00 00 
  816443:	ff d0                	callq  *%rax
    return;
  816445:	e9 d3 02 00 00       	jmpq   81671d <etharp_arp_input+0x33f>
  }

  hdr = p->payload;
  81644a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81644e:	48 8b 40 08          	mov    0x8(%rax),%rax
  816452:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  816456:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81645a:	0f b7 58 0e          	movzwl 0xe(%rax),%ebx
  81645e:	bf 01 00 00 00       	mov    $0x1,%edi
  816463:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  81646a:	00 00 00 
  81646d:	ff d0                	callq  *%rax
  81646f:	66 39 c3             	cmp    %ax,%bx
  816472:	75 5a                	jne    8164ce <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  816474:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816478:	0f b7 58 12          	movzwl 0x12(%rax),%ebx
  81647c:	bf 04 06 00 00       	mov    $0x604,%edi
  816481:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  816488:	00 00 00 
  81648b:	ff d0                	callq  *%rax
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  81648d:	66 39 c3             	cmp    %ax,%bx
  816490:	75 3c                	jne    8164ce <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  816492:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816496:	0f b7 58 10          	movzwl 0x10(%rax),%ebx
  81649a:	bf 00 08 00 00       	mov    $0x800,%edi
  81649f:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8164a6:	00 00 00 
  8164a9:	ff d0                	callq  *%rax

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8164ab:	66 39 c3             	cmp    %ax,%bx
  8164ae:	75 1e                	jne    8164ce <etharp_arp_input+0xf0>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  8164b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8164b4:	0f b7 58 0c          	movzwl 0xc(%rax),%ebx
  8164b8:	bf 06 08 00 00       	mov    $0x806,%edi
  8164bd:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8164c4:	00 00 00 
  8164c7:	ff d0                	callq  *%rax
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8164c9:	66 39 c3             	cmp    %ax,%bx
  8164cc:	74 18                	je     8164e6 <etharp_arp_input+0x108>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8164ce:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8164d2:	48 89 c7             	mov    %rax,%rdi
  8164d5:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8164dc:	00 00 00 
  8164df:	ff d0                	callq  *%rax
    return;
  8164e1:	e9 37 02 00 00       	jmpq   81671d <etharp_arp_input+0x33f>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  8164e6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8164ea:	48 8d 48 1c          	lea    0x1c(%rax),%rcx
  8164ee:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8164f2:	ba 04 00 00 00       	mov    $0x4,%edx
  8164f7:	48 89 ce             	mov    %rcx,%rsi
  8164fa:	48 89 c7             	mov    %rax,%rdi
  8164fd:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  816504:	00 00 00 
  816507:	ff d0                	callq  *%rax
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  816509:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81650d:	48 8d 48 26          	lea    0x26(%rax),%rcx
  816511:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  816515:	ba 04 00 00 00       	mov    $0x4,%edx
  81651a:	48 89 ce             	mov    %rcx,%rsi
  81651d:	48 89 c7             	mov    %rax,%rdi
  816520:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  816527:	00 00 00 
  81652a:	ff d0                	callq  *%rax

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  81652c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816530:	8b 40 08             	mov    0x8(%rax),%eax
  816533:	85 c0                	test   %eax,%eax
  816535:	75 06                	jne    81653d <etharp_arp_input+0x15f>
    for_us = 0;
  816537:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
  81653b:	eb 12                	jmp    81654f <etharp_arp_input+0x171>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  81653d:	8b 55 c0             	mov    -0x40(%rbp),%edx
  816540:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816544:	8b 40 08             	mov    0x8(%rax),%eax
  816547:	39 c2                	cmp    %eax,%edx
  816549:	0f 94 c0             	sete   %al
  81654c:	88 45 ee             	mov    %al,-0x12(%rbp)
  }

  /* ARP message directed to us? */
  if (for_us) {
  81654f:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  816553:	74 26                	je     81657b <etharp_arp_input+0x19d>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  816555:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816559:	48 8d 50 16          	lea    0x16(%rax),%rdx
  81655d:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  816561:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816565:	b9 01 00 00 00       	mov    $0x1,%ecx
  81656a:	48 89 c7             	mov    %rax,%rdi
  81656d:	48 b8 c8 5f 81 00 00 	movabs $0x815fc8,%rax
  816574:	00 00 00 
  816577:	ff d0                	callq  *%rax
  816579:	eb 24                	jmp    81659f <etharp_arp_input+0x1c1>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  81657b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81657f:	48 8d 50 16          	lea    0x16(%rax),%rdx
  816583:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  816587:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81658b:	b9 00 00 00 00       	mov    $0x0,%ecx
  816590:	48 89 c7             	mov    %rax,%rdi
  816593:	48 b8 c8 5f 81 00 00 	movabs $0x815fc8,%rax
  81659a:	00 00 00 
  81659d:	ff d0                	callq  *%rax
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  81659f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8165a3:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  8165a7:	0f b7 c0             	movzwl %ax,%eax
  8165aa:	89 c7                	mov    %eax,%edi
  8165ac:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8165b3:	00 00 00 
  8165b6:	ff d0                	callq  *%rax
  8165b8:	0f b7 c0             	movzwl %ax,%eax
  8165bb:	83 f8 01             	cmp    $0x1,%eax
  8165be:	74 0e                	je     8165ce <etharp_arp_input+0x1f0>
  8165c0:	83 f8 02             	cmp    $0x2,%eax
  8165c3:	0f 84 26 01 00 00    	je     8166ef <etharp_arp_input+0x311>
#endif
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  8165c9:	e9 3c 01 00 00       	jmpq   81670a <etharp_arp_input+0x32c>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  8165ce:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  8165d2:	0f 84 15 01 00 00    	je     8166ed <etharp_arp_input+0x30f>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  8165d8:	bf 02 00 00 00       	mov    $0x2,%edi
  8165dd:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8165e4:	00 00 00 
  8165e7:	ff d0                	callq  *%rax
  8165e9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8165ed:	66 89 42 14          	mov    %ax,0x14(%rdx)

      hdr->dipaddr = hdr->sipaddr;
  8165f1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8165f5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8165f9:	8b 52 1c             	mov    0x1c(%rdx),%edx
  8165fc:	89 50 26             	mov    %edx,0x26(%rax)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  8165ff:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816603:	48 8d 50 08          	lea    0x8(%rax),%rdx
  816607:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81660b:	8b 12                	mov    (%rdx),%edx
  81660d:	89 50 1c             	mov    %edx,0x1c(%rax)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  816610:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816614:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816618:	3c 06                	cmp    $0x6,%al
  81661a:	74 2a                	je     816646 <etharp_arp_input+0x268>
  81661c:	48 ba 40 27 82 00 00 	movabs $0x822740,%rdx
  816623:	00 00 00 
  816626:	be c7 02 00 00       	mov    $0x2c7,%esi
  81662b:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  816632:	00 00 00 
  816635:	b8 00 00 00 00       	mov    $0x0,%eax
  81663a:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  816641:	00 00 00 
  816644:	ff d1                	callq  *%rcx
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
  816646:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  81664a:	eb 7f                	jmp    8166cb <etharp_arp_input+0x2ed>
        i--;
  81664c:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816650:	83 e8 01             	sub    $0x1,%eax
  816653:	88 45 ef             	mov    %al,-0x11(%rbp)
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  816656:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  81665a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81665e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816662:	48 98                	cltq   
  816664:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  816669:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81666d:	48 63 c6             	movslq %esi,%rax
  816670:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  816674:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816678:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81667c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816680:	48 98                	cltq   
  816682:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  816687:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81668b:	48 63 c6             	movslq %esi,%rax
  81668e:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  816691:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816695:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816699:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  81669d:	48 98                	cltq   
  81669f:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8166a3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8166a7:	48 63 c6             	movslq %esi,%rax
  8166aa:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  8166ae:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  8166b2:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8166b6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8166ba:	48 98                	cltq   
  8166bc:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8166c0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8166c4:	48 63 c6             	movslq %esi,%rax
  8166c7:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  8166cb:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8166cf:	0f 85 77 ff ff ff    	jne    81664c <etharp_arp_input+0x26e>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  8166d5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8166d9:	48 8b 40 28          	mov    0x28(%rax),%rax
  8166dd:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8166e1:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8166e5:	48 89 ce             	mov    %rcx,%rsi
  8166e8:	48 89 d7             	mov    %rdx,%rdi
  8166eb:	ff d0                	callq  *%rax
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
  8166ed:	eb 1b                	jmp    81670a <etharp_arp_input+0x32c>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  8166ef:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8166f3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8166f7:	48 89 d6             	mov    %rdx,%rsi
  8166fa:	48 89 c7             	mov    %rax,%rdi
  8166fd:	48 b8 37 a0 80 00 00 	movabs $0x80a037,%rax
  816704:	00 00 00 
  816707:	ff d0                	callq  *%rax
#endif
    break;
  816709:	90                   	nop
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  81670a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81670e:	48 89 c7             	mov    %rax,%rdi
  816711:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  816718:	00 00 00 
  81671b:	ff d0                	callq  *%rax
}
  81671d:	48 83 c4 58          	add    $0x58,%rsp
  816721:	5b                   	pop    %rbx
  816722:	5d                   	pop    %rbp
  816723:	c3                   	retq   

0000000000816724 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  816724:	55                   	push   %rbp
  816725:	48 89 e5             	mov    %rsp,%rbp
  816728:	53                   	push   %rbx
  816729:	48 83 ec 38          	sub    $0x38,%rsp
  81672d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  816731:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  816735:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  816739:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81673d:	be 0e 00 00 00       	mov    $0xe,%esi
  816742:	48 89 c7             	mov    %rax,%rdi
  816745:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  81674c:	00 00 00 
  81674f:	ff d0                	callq  *%rax
  816751:	84 c0                	test   %al,%al
  816753:	74 0a                	je     81675f <etharp_output+0x3b>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  816755:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  81675a:	e9 50 01 00 00       	jmpq   8168af <etharp_output+0x18b>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
  81675f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  816766:	00 
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  816767:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81676b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81676f:	48 89 d6             	mov    %rdx,%rsi
  816772:	48 89 c7             	mov    %rax,%rdi
  816775:	48 b8 10 0a 81 00 00 	movabs $0x810a10,%rax
  81677c:	00 00 00 
  81677f:	ff d0                	callq  *%rax
  816781:	84 c0                	test   %al,%al
  816783:	74 13                	je     816798 <etharp_output+0x74>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  816785:	48 b8 c8 26 82 00 00 	movabs $0x8226c8,%rax
  81678c:	00 00 00 
  81678f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  816793:	e9 ee 00 00 00       	jmpq   816886 <etharp_output+0x162>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  816798:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81679c:	8b 18                	mov    (%rax),%ebx
  81679e:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8167a3:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  8167aa:	00 00 00 
  8167ad:	ff d0                	callq  *%rax
  8167af:	21 c3                	and    %eax,%ebx
  8167b1:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8167b6:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  8167bd:	00 00 00 
  8167c0:	ff d0                	callq  *%rax
  8167c2:	39 c3                	cmp    %eax,%ebx
  8167c4:	75 64                	jne    81682a <etharp_output+0x106>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  8167c6:	c6 45 e0 01          	movb   $0x1,-0x20(%rbp)
    mcastaddr.addr[1] = 0x00;
  8167ca:	c6 45 e1 00          	movb   $0x0,-0x1f(%rbp)
    mcastaddr.addr[2] = 0x5e;
  8167ce:	c6 45 e2 5e          	movb   $0x5e,-0x1e(%rbp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  8167d2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8167d6:	8b 00                	mov    (%rax),%eax
  8167d8:	89 c7                	mov    %eax,%edi
  8167da:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  8167e1:	00 00 00 
  8167e4:	ff d0                	callq  *%rax
  8167e6:	c1 e8 10             	shr    $0x10,%eax
  8167e9:	83 e0 7f             	and    $0x7f,%eax
  8167ec:	88 45 e3             	mov    %al,-0x1d(%rbp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  8167ef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8167f3:	8b 00                	mov    (%rax),%eax
  8167f5:	89 c7                	mov    %eax,%edi
  8167f7:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  8167fe:	00 00 00 
  816801:	ff d0                	callq  *%rax
  816803:	c1 e8 08             	shr    $0x8,%eax
  816806:	88 45 e4             	mov    %al,-0x1c(%rbp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  816809:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81680d:	8b 00                	mov    (%rax),%eax
  81680f:	89 c7                	mov    %eax,%edi
  816811:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  816818:	00 00 00 
  81681b:	ff d0                	callq  *%rax
  81681d:	88 45 e5             	mov    %al,-0x1b(%rbp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  816820:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  816824:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  816828:	eb 5c                	jmp    816886 <etharp_output+0x162>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  81682a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81682e:	8b 10                	mov    (%rax),%edx
  816830:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816834:	8b 40 08             	mov    0x8(%rax),%eax
  816837:	31 c2                	xor    %eax,%edx
  816839:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81683d:	8b 40 0c             	mov    0xc(%rax),%eax
  816840:	21 d0                	and    %edx,%eax
  816842:	85 c0                	test   %eax,%eax
  816844:	74 20                	je     816866 <etharp_output+0x142>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  816846:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81684a:	8b 40 10             	mov    0x10(%rax),%eax
  81684d:	85 c0                	test   %eax,%eax
  81684f:	74 0e                	je     81685f <etharp_output+0x13b>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  816851:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816855:	48 83 c0 10          	add    $0x10,%rax
  816859:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  81685d:	eb 07                	jmp    816866 <etharp_output+0x142>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  81685f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  816864:	eb 49                	jmp    8168af <etharp_output+0x18b>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  816866:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81686a:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  81686e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816872:	48 89 ce             	mov    %rcx,%rsi
  816875:	48 89 c7             	mov    %rax,%rdi
  816878:	48 b8 b6 68 81 00 00 	movabs $0x8168b6,%rax
  81687f:	00 00 00 
  816882:	ff d0                	callq  *%rax
  816884:	eb 29                	jmp    8168af <etharp_output+0x18b>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  816886:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81688a:	48 8d 78 41          	lea    0x41(%rax),%rdi
  81688e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816892:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  816896:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81689a:	48 89 d1             	mov    %rdx,%rcx
  81689d:	48 89 fa             	mov    %rdi,%rdx
  8168a0:	48 89 c7             	mov    %rax,%rdi
  8168a3:	48 b8 ec 5e 81 00 00 	movabs $0x815eec,%rax
  8168aa:	00 00 00 
  8168ad:	ff d0                	callq  *%rax
}
  8168af:	48 83 c4 38          	add    $0x38,%rsp
  8168b3:	5b                   	pop    %rbx
  8168b4:	5d                   	pop    %rbp
  8168b5:	c3                   	retq   

00000000008168b6 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  8168b6:	55                   	push   %rbp
  8168b7:	48 89 e5             	mov    %rsp,%rbp
  8168ba:	53                   	push   %rbx
  8168bb:	48 83 ec 68          	sub    $0x68,%rsp
  8168bf:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8168c3:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8168c7:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  8168cb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8168cf:	48 83 c0 41          	add    $0x41,%rax
  8168d3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  err_t result = ERR_MEM;
  8168d7:	c6 45 ef ff          	movb   $0xff,-0x11(%rbp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  8168db:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8168df:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8168e3:	48 89 d6             	mov    %rdx,%rsi
  8168e6:	48 89 c7             	mov    %rax,%rdi
  8168e9:	48 b8 10 0a 81 00 00 	movabs $0x810a10,%rax
  8168f0:	00 00 00 
  8168f3:	ff d0                	callq  *%rax
  8168f5:	84 c0                	test   %al,%al
  8168f7:	75 3f                	jne    816938 <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  8168f9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8168fd:	8b 18                	mov    (%rax),%ebx
  8168ff:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816904:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  81690b:	00 00 00 
  81690e:	ff d0                	callq  *%rax
  816910:	21 c3                	and    %eax,%ebx
  816912:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  816917:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  81691e:	00 00 00 
  816921:	ff d0                	callq  *%rax
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  816923:	39 c3                	cmp    %eax,%ebx
  816925:	74 11                	je     816938 <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  816927:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  81692c:	74 0a                	je     816938 <etharp_query+0x82>
      ip_addr_isany(ipaddr)) {
  81692e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816932:	8b 00                	mov    (%rax),%eax
  816934:	85 c0                	test   %eax,%eax
  816936:	75 0a                	jne    816942 <etharp_query+0x8c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  816938:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  81693d:	e9 1f 04 00 00       	jmpq   816d61 <etharp_query+0x4ab>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  816942:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816946:	be 01 00 00 00       	mov    $0x1,%esi
  81694b:	48 89 c7             	mov    %rax,%rdi
  81694e:	48 b8 58 59 81 00 00 	movabs $0x815958,%rax
  816955:	00 00 00 
  816958:	ff d0                	callq  *%rax
  81695a:	88 45 c7             	mov    %al,-0x39(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  81695d:	80 7d c7 00          	cmpb   $0x0,-0x39(%rbp)
  816961:	79 09                	jns    81696c <etharp_query+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
  816963:	0f b6 45 c7          	movzbl -0x39(%rbp),%eax
  816967:	e9 f5 03 00 00       	jmpq   816d61 <etharp_query+0x4ab>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  81696c:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816970:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816977:	00 00 00 
  81697a:	48 63 d0             	movslq %eax,%rdx
  81697d:	48 89 d0             	mov    %rdx,%rax
  816980:	48 c1 e0 02          	shl    $0x2,%rax
  816984:	48 01 d0             	add    %rdx,%rax
  816987:	48 c1 e0 03          	shl    $0x3,%rax
  81698b:	48 01 c8             	add    %rcx,%rax
  81698e:	48 83 c0 10          	add    $0x10,%rax
  816992:	8b 40 04             	mov    0x4(%rax),%eax
  816995:	85 c0                	test   %eax,%eax
  816997:	75 2d                	jne    8169c6 <etharp_query+0x110>
    arp_table[i].state = ETHARP_STATE_PENDING;
  816999:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  81699d:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8169a4:	00 00 00 
  8169a7:	48 63 d0             	movslq %eax,%rdx
  8169aa:	48 89 d0             	mov    %rdx,%rax
  8169ad:	48 c1 e0 02          	shl    $0x2,%rax
  8169b1:	48 01 d0             	add    %rdx,%rax
  8169b4:	48 c1 e0 03          	shl    $0x3,%rax
  8169b8:	48 01 c8             	add    %rcx,%rax
  8169bb:	48 83 c0 10          	add    $0x10,%rax
  8169bf:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  8169c6:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8169ca:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8169d1:	00 00 00 
  8169d4:	48 63 d0             	movslq %eax,%rdx
  8169d7:	48 89 d0             	mov    %rdx,%rax
  8169da:	48 c1 e0 02          	shl    $0x2,%rax
  8169de:	48 01 d0             	add    %rdx,%rax
  8169e1:	48 c1 e0 03          	shl    $0x3,%rax
  8169e5:	48 01 c8             	add    %rcx,%rax
  8169e8:	48 83 c0 10          	add    $0x10,%rax
  8169ec:	8b 40 04             	mov    0x4(%rax),%eax
  8169ef:	83 f8 01             	cmp    $0x1,%eax
  8169f2:	74 58                	je     816a4c <etharp_query+0x196>
  8169f4:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8169f8:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8169ff:	00 00 00 
  816a02:	48 63 d0             	movslq %eax,%rdx
  816a05:	48 89 d0             	mov    %rdx,%rax
  816a08:	48 c1 e0 02          	shl    $0x2,%rax
  816a0c:	48 01 d0             	add    %rdx,%rax
  816a0f:	48 c1 e0 03          	shl    $0x3,%rax
  816a13:	48 01 c8             	add    %rcx,%rax
  816a16:	48 83 c0 10          	add    $0x10,%rax
  816a1a:	8b 40 04             	mov    0x4(%rax),%eax
  816a1d:	83 f8 02             	cmp    $0x2,%eax
  816a20:	74 2a                	je     816a4c <etharp_query+0x196>
  816a22:	48 ba c0 27 82 00 00 	movabs $0x8227c0,%rdx
  816a29:	00 00 00 
  816a2c:	be 92 03 00 00       	mov    $0x392,%esi
  816a31:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  816a38:	00 00 00 
  816a3b:	b8 00 00 00 00       	mov    $0x0,%eax
  816a40:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  816a47:	00 00 00 
  816a4a:	ff d1                	callq  *%rcx
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  816a4c:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816a50:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816a57:	00 00 00 
  816a5a:	48 63 d0             	movslq %eax,%rdx
  816a5d:	48 89 d0             	mov    %rdx,%rax
  816a60:	48 c1 e0 02          	shl    $0x2,%rax
  816a64:	48 01 d0             	add    %rdx,%rax
  816a67:	48 c1 e0 03          	shl    $0x3,%rax
  816a6b:	48 01 c8             	add    %rcx,%rax
  816a6e:	48 83 c0 10          	add    $0x10,%rax
  816a72:	8b 40 04             	mov    0x4(%rax),%eax
  816a75:	83 f8 01             	cmp    $0x1,%eax
  816a78:	74 07                	je     816a81 <etharp_query+0x1cb>
  816a7a:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816a7f:	75 1d                	jne    816a9e <etharp_query+0x1e8>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  816a81:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  816a85:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816a89:	48 89 d6             	mov    %rdx,%rsi
  816a8c:	48 89 c7             	mov    %rax,%rdi
  816a8f:	48 b8 9e 6f 81 00 00 	movabs $0x816f9e,%rax
  816a96:	00 00 00 
  816a99:	ff d0                	callq  *%rax
  816a9b:	88 45 ef             	mov    %al,-0x11(%rbp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  816a9e:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816aa3:	0f 84 b4 02 00 00    	je     816d5d <etharp_query+0x4a7>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  816aa9:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816aad:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816ab4:	00 00 00 
  816ab7:	48 63 d0             	movslq %eax,%rdx
  816aba:	48 89 d0             	mov    %rdx,%rax
  816abd:	48 c1 e0 02          	shl    $0x2,%rax
  816ac1:	48 01 d0             	add    %rdx,%rax
  816ac4:	48 c1 e0 03          	shl    $0x3,%rax
  816ac8:	48 01 c8             	add    %rcx,%rax
  816acb:	48 83 c0 10          	add    $0x10,%rax
  816acf:	8b 40 04             	mov    0x4(%rax),%eax
  816ad2:	83 f8 02             	cmp    $0x2,%eax
  816ad5:	75 49                	jne    816b20 <etharp_query+0x26a>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  816ad7:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816adb:	48 63 d0             	movslq %eax,%rdx
  816ade:	48 89 d0             	mov    %rdx,%rax
  816ae1:	48 c1 e0 02          	shl    $0x2,%rax
  816ae5:	48 01 d0             	add    %rdx,%rax
  816ae8:	48 c1 e0 03          	shl    $0x3,%rax
  816aec:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  816af3:	00 00 00 
  816af6:	48 01 d0             	add    %rdx,%rax
  816af9:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  816afd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  816b01:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  816b05:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816b09:	48 89 c7             	mov    %rax,%rdi
  816b0c:	48 b8 ec 5e 81 00 00 	movabs $0x815eec,%rax
  816b13:	00 00 00 
  816b16:	ff d0                	callq  *%rax
  816b18:	88 45 ef             	mov    %al,-0x11(%rbp)
  816b1b:	e9 3d 02 00 00       	jmpq   816d5d <etharp_query+0x4a7>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  816b20:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816b24:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816b2b:	00 00 00 
  816b2e:	48 63 d0             	movslq %eax,%rdx
  816b31:	48 89 d0             	mov    %rdx,%rax
  816b34:	48 c1 e0 02          	shl    $0x2,%rax
  816b38:	48 01 d0             	add    %rdx,%rax
  816b3b:	48 c1 e0 03          	shl    $0x3,%rax
  816b3f:	48 01 c8             	add    %rcx,%rax
  816b42:	48 83 c0 10          	add    $0x10,%rax
  816b46:	8b 40 04             	mov    0x4(%rax),%eax
  816b49:	83 f8 01             	cmp    $0x1,%eax
  816b4c:	0f 85 0b 02 00 00    	jne    816d5d <etharp_query+0x4a7>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
  816b52:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
  816b59:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  816b5d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      while (p) {
  816b61:	eb 6b                	jmp    816bce <etharp_query+0x318>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  816b63:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816b67:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  816b6b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816b6f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  816b73:	66 39 c2             	cmp    %ax,%dx
  816b76:	75 36                	jne    816bae <etharp_query+0x2f8>
  816b78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816b7c:	48 8b 00             	mov    (%rax),%rax
  816b7f:	48 85 c0             	test   %rax,%rax
  816b82:	74 2a                	je     816bae <etharp_query+0x2f8>
  816b84:	48 ba e8 27 82 00 00 	movabs $0x8227e8,%rdx
  816b8b:	00 00 00 
  816b8e:	be b1 03 00 00       	mov    $0x3b1,%esi
  816b93:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  816b9a:	00 00 00 
  816b9d:	b8 00 00 00 00       	mov    $0x0,%eax
  816ba2:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  816ba9:	00 00 00 
  816bac:	ff d1                	callq  *%rcx
        if(p->type != PBUF_ROM) {
  816bae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816bb2:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  816bb6:	3c 01                	cmp    $0x1,%al
  816bb8:	74 09                	je     816bc3 <etharp_query+0x30d>
          copy_needed = 1;
  816bba:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)
          break;
  816bc1:	eb 12                	jmp    816bd5 <etharp_query+0x31f>
        }
        p = p->next;
  816bc3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816bc7:	48 8b 00             	mov    (%rax),%rax
  816bca:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  816bce:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816bd3:	75 8e                	jne    816b63 <etharp_query+0x2ad>
          copy_needed = 1;
          break;
        }
        p = p->next;
      }
      if(copy_needed) {
  816bd5:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  816bd9:	74 69                	je     816c44 <etharp_query+0x38e>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  816bdb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816bdf:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  816be3:	0f b7 c0             	movzwl %ax,%eax
  816be6:	ba 00 00 00 00       	mov    $0x0,%edx
  816beb:	89 c6                	mov    %eax,%esi
  816bed:	bf 03 00 00 00       	mov    $0x3,%edi
  816bf2:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  816bf9:	00 00 00 
  816bfc:	ff d0                	callq  *%rax
  816bfe:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if(p != NULL) {
  816c02:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816c07:	74 56                	je     816c5f <etharp_query+0x3a9>
          if (pbuf_copy(p, q) != ERR_OK) {
  816c09:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  816c0d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816c11:	48 89 d6             	mov    %rdx,%rsi
  816c14:	48 89 c7             	mov    %rax,%rdi
  816c17:	48 b8 8e de 80 00 00 	movabs $0x80de8e,%rax
  816c1e:	00 00 00 
  816c21:	ff d0                	callq  *%rax
  816c23:	84 c0                	test   %al,%al
  816c25:	74 38                	je     816c5f <etharp_query+0x3a9>
            pbuf_free(p);
  816c27:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816c2b:	48 89 c7             	mov    %rax,%rdi
  816c2e:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  816c35:	00 00 00 
  816c38:	ff d0                	callq  *%rax
            p = NULL;
  816c3a:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  816c41:	00 
  816c42:	eb 1b                	jmp    816c5f <etharp_query+0x3a9>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
  816c44:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  816c48:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        pbuf_ref(p);
  816c4c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816c50:	48 89 c7             	mov    %rax,%rdi
  816c53:	48 b8 f2 db 80 00 00 	movabs $0x80dbf2,%rax
  816c5a:	00 00 00 
  816c5d:	ff d0                	callq  *%rax
      }
      /* packet could be taken over? */
      if (p != NULL) {
  816c5f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816c64:	0f 84 f3 00 00 00    	je     816d5d <etharp_query+0x4a7>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  816c6a:	bf 0a 00 00 00       	mov    $0xa,%edi
  816c6f:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  816c76:	00 00 00 
  816c79:	ff d0                	callq  *%rax
  816c7b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if (new_entry != NULL) {
  816c7f:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  816c84:	0f 84 c0 00 00 00    	je     816d4a <etharp_query+0x494>
          new_entry->next = 0;
  816c8a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816c8e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
          new_entry->p = p;
  816c95:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816c99:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816c9d:	48 89 50 08          	mov    %rdx,0x8(%rax)
          if(arp_table[i].q != NULL) {
  816ca1:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816ca5:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816cac:	00 00 00 
  816caf:	48 63 d0             	movslq %eax,%rdx
  816cb2:	48 89 d0             	mov    %rdx,%rax
  816cb5:	48 c1 e0 02          	shl    $0x2,%rax
  816cb9:	48 01 d0             	add    %rdx,%rax
  816cbc:	48 c1 e0 03          	shl    $0x3,%rax
  816cc0:	48 01 c8             	add    %rcx,%rax
  816cc3:	48 8b 00             	mov    (%rax),%rax
  816cc6:	48 85 c0             	test   %rax,%rax
  816cc9:	74 4f                	je     816d1a <etharp_query+0x464>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
  816ccb:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816ccf:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816cd6:	00 00 00 
  816cd9:	48 63 d0             	movslq %eax,%rdx
  816cdc:	48 89 d0             	mov    %rdx,%rax
  816cdf:	48 c1 e0 02          	shl    $0x2,%rax
  816ce3:	48 01 d0             	add    %rdx,%rax
  816ce6:	48 c1 e0 03          	shl    $0x3,%rax
  816cea:	48 01 c8             	add    %rcx,%rax
  816ced:	48 8b 00             	mov    (%rax),%rax
  816cf0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
            while (r->next != NULL) {
  816cf4:	eb 0b                	jmp    816d01 <etharp_query+0x44b>
              r = r->next;
  816cf6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816cfa:	48 8b 00             	mov    (%rax),%rax
  816cfd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  816d01:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816d05:	48 8b 00             	mov    (%rax),%rax
  816d08:	48 85 c0             	test   %rax,%rax
  816d0b:	75 e9                	jne    816cf6 <etharp_query+0x440>
              r = r->next;
            }
            r->next = new_entry;
  816d0d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816d11:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816d15:	48 89 10             	mov    %rdx,(%rax)
  816d18:	eb 2a                	jmp    816d44 <etharp_query+0x48e>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  816d1a:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816d1e:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816d25:	00 00 00 
  816d28:	48 63 d0             	movslq %eax,%rdx
  816d2b:	48 89 d0             	mov    %rdx,%rax
  816d2e:	48 c1 e0 02          	shl    $0x2,%rax
  816d32:	48 01 d0             	add    %rdx,%rax
  816d35:	48 c1 e0 03          	shl    $0x3,%rax
  816d39:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  816d3d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816d41:	48 89 02             	mov    %rax,(%rdx)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  816d44:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  816d48:	eb 13                	jmp    816d5d <etharp_query+0x4a7>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  816d4a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816d4e:	48 89 c7             	mov    %rax,%rdi
  816d51:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  816d58:	00 00 00 
  816d5b:	ff d0                	callq  *%rax
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
  816d5d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  816d61:	48 83 c4 68          	add    $0x68,%rsp
  816d65:	5b                   	pop    %rbx
  816d66:	5d                   	pop    %rbp
  816d67:	c3                   	retq   

0000000000816d68 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
  816d68:	55                   	push   %rbp
  816d69:	48 89 e5             	mov    %rsp,%rbp
  816d6c:	48 83 ec 60          	sub    $0x60,%rsp
  816d70:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  816d74:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  816d78:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  816d7c:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  816d80:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  816d84:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
  816d88:	8b 45 18             	mov    0x18(%rbp),%eax
  816d8b:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct pbuf *p;
  err_t result = ERR_OK;
  816d8f:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  816d93:	ba 00 00 00 00       	mov    $0x0,%edx
  816d98:	be 2a 00 00 00       	mov    $0x2a,%esi
  816d9d:	bf 02 00 00 00       	mov    $0x2,%edi
  816da2:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  816da9:	00 00 00 
  816dac:	ff d0                	callq  *%rax
  816dae:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  816db2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  816db7:	75 0a                	jne    816dc3 <etharp_raw+0x5b>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  816db9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  816dbe:	e9 d9 01 00 00       	jmpq   816f9c <etharp_raw+0x234>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  816dc3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  816dc7:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  816dcb:	66 83 f8 29          	cmp    $0x29,%ax
  816dcf:	77 2a                	ja     816dfb <etharp_raw+0x93>
  816dd1:	48 ba 08 28 82 00 00 	movabs $0x822808,%rdx
  816dd8:	00 00 00 
  816ddb:	be 1c 04 00 00       	mov    $0x41c,%esi
  816de0:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  816de7:	00 00 00 
  816dea:	b8 00 00 00 00       	mov    $0x0,%eax
  816def:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  816df6:	00 00 00 
  816df9:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  816dfb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  816dff:	48 8b 40 08          	mov    0x8(%rax),%rax
  816e03:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  816e07:	0f b7 45 ac          	movzwl -0x54(%rbp),%eax
  816e0b:	89 c7                	mov    %eax,%edi
  816e0d:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  816e14:	00 00 00 
  816e17:	ff d0                	callq  *%rax
  816e19:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816e1d:	66 89 42 14          	mov    %ax,0x14(%rdx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  816e21:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816e25:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816e29:	3c 06                	cmp    $0x6,%al
  816e2b:	74 2a                	je     816e57 <etharp_raw+0xef>
  816e2d:	48 ba 40 27 82 00 00 	movabs $0x822740,%rdx
  816e34:	00 00 00 
  816e37:	be 23 04 00 00       	mov    $0x423,%esi
  816e3c:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  816e43:	00 00 00 
  816e46:	b8 00 00 00 00       	mov    $0x0,%eax
  816e4b:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  816e52:	00 00 00 
  816e55:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  816e57:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  816e5b:	eb 7d                	jmp    816eda <etharp_raw+0x172>
    k--;
  816e5d:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816e61:	83 e8 01             	sub    $0x1,%eax
  816e64:	88 45 ff             	mov    %al,-0x1(%rbp)
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  816e67:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816e6b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816e6f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  816e73:	48 98                	cltq   
  816e75:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816e79:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816e7d:	48 63 c6             	movslq %esi,%rax
  816e80:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  816e84:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816e88:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816e8c:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  816e90:	48 98                	cltq   
  816e92:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816e96:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816e9a:	48 63 c6             	movslq %esi,%rax
  816e9d:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  816ea1:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816ea5:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816ea9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  816ead:	48 98                	cltq   
  816eaf:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816eb3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816eb7:	48 63 c6             	movslq %esi,%rax
  816eba:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  816ebd:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816ec1:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816ec5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  816ec9:	48 98                	cltq   
  816ecb:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816ecf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816ed3:	48 63 c6             	movslq %esi,%rax
  816ed6:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  816eda:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  816ede:	0f 85 79 ff ff ff    	jne    816e5d <etharp_raw+0xf5>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  816ee4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816ee8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816eec:	8b 12                	mov    (%rdx),%edx
  816eee:	89 50 1c             	mov    %edx,0x1c(%rax)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  816ef1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816ef5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  816ef9:	8b 12                	mov    (%rdx),%edx
  816efb:	89 50 26             	mov    %edx,0x26(%rax)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  816efe:	bf 01 00 00 00       	mov    $0x1,%edi
  816f03:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  816f0a:	00 00 00 
  816f0d:	ff d0                	callq  *%rax
  816f0f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816f13:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  hdr->proto = htons(ETHTYPE_IP);
  816f17:	bf 00 08 00 00       	mov    $0x800,%edi
  816f1c:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  816f23:	00 00 00 
  816f26:	ff d0                	callq  *%rax
  816f28:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816f2c:	66 89 42 10          	mov    %ax,0x10(%rdx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  816f30:	bf 04 06 00 00       	mov    $0x604,%edi
  816f35:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  816f3c:	00 00 00 
  816f3f:	ff d0                	callq  *%rax
  816f41:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816f45:	66 89 42 12          	mov    %ax,0x12(%rdx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  816f49:	bf 06 08 00 00       	mov    $0x806,%edi
  816f4e:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  816f55:	00 00 00 
  816f58:	ff d0                	callq  *%rax
  816f5a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816f5e:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  816f62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816f66:	48 8b 40 28          	mov    0x28(%rax),%rax
  816f6a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  816f6e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  816f72:	48 89 ce             	mov    %rcx,%rsi
  816f75:	48 89 d7             	mov    %rdx,%rdi
  816f78:	ff d0                	callq  *%rax
  816f7a:	88 45 fe             	mov    %al,-0x2(%rbp)
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  816f7d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  816f81:	48 89 c7             	mov    %rax,%rdi
  816f84:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  816f8b:	00 00 00 
  816f8e:	ff d0                	callq  *%rax
  p = NULL;
  816f90:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  816f97:	00 
  /* could not allocate pbuf for ARP request */

  return result;
  816f98:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
}
  816f9c:	c9                   	leaveq 
  816f9d:	c3                   	retq   

0000000000816f9e <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  816f9e:	55                   	push   %rbp
  816f9f:	48 89 e5             	mov    %rsp,%rbp
  816fa2:	48 83 ec 20          	sub    $0x20,%rsp
  816fa6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  816faa:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
  816fae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816fb2:	48 8d 78 08          	lea    0x8(%rax),%rdi
  816fb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816fba:	48 8d 48 41          	lea    0x41(%rax),%rcx
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  816fbe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816fc2:	48 8d 70 41          	lea    0x41(%rax),%rsi
  816fc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816fca:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
  816fd1:	00 
  816fd2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  816fd6:	48 89 14 24          	mov    %rdx,(%rsp)
  816fda:	49 b9 ce 26 82 00 00 	movabs $0x8226ce,%r9
  816fe1:	00 00 00 
  816fe4:	49 89 f8             	mov    %rdi,%r8
  816fe7:	48 ba c8 26 82 00 00 	movabs $0x8226c8,%rdx
  816fee:	00 00 00 
  816ff1:	48 89 c7             	mov    %rax,%rdi
  816ff4:	48 b8 68 6d 81 00 00 	movabs $0x816d68,%rax
  816ffb:	00 00 00 
  816ffe:	ff d0                	callq  *%rax
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  817000:	c9                   	leaveq 
  817001:	c3                   	retq   

0000000000817002 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  817002:	55                   	push   %rbp
  817003:	48 89 e5             	mov    %rsp,%rbp
  817006:	48 83 ec 20          	sub    $0x20,%rsp
  81700a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81700e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct eth_hdr* ethhdr;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
  817012:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817016:	48 8b 40 08          	mov    0x8(%rax),%rax
  81701a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  81701e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817022:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  817026:	0f b7 c0             	movzwl %ax,%eax
  817029:	89 c7                	mov    %eax,%edi
  81702b:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  817032:	00 00 00 
  817035:	ff d0                	callq  *%rax
  817037:	0f b7 c0             	movzwl %ax,%eax
  81703a:	3d 00 08 00 00       	cmp    $0x800,%eax
  81703f:	74 10                	je     817051 <ethernet_input+0x4f>
  817041:	3d 06 08 00 00       	cmp    $0x806,%eax
  817046:	0f 84 81 00 00 00    	je     8170cd <ethernet_input+0xcb>
  81704c:	e9 a0 00 00 00       	jmpq   8170f1 <ethernet_input+0xef>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  817051:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817055:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817059:	48 89 d6             	mov    %rdx,%rsi
  81705c:	48 89 c7             	mov    %rax,%rdi
  81705f:	48 b8 48 63 81 00 00 	movabs $0x816348,%rax
  817066:	00 00 00 
  817069:	ff d0                	callq  *%rax
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  81706b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81706f:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  817074:	48 89 c7             	mov    %rax,%rdi
  817077:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  81707e:	00 00 00 
  817081:	ff d0                	callq  *%rax
  817083:	84 c0                	test   %al,%al
  817085:	74 2a                	je     8170b1 <ethernet_input+0xaf>
        LWIP_ASSERT("Can't move over header in packet", 0);
  817087:	48 ba 40 28 82 00 00 	movabs $0x822840,%rdx
  81708e:	00 00 00 
  817091:	be 7e 04 00 00       	mov    $0x47e,%esi
  817096:	48 bf de 26 82 00 00 	movabs $0x8226de,%rdi
  81709d:	00 00 00 
  8170a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8170a5:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8170ac:	00 00 00 
  8170af:	ff d1                	callq  *%rcx
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  8170b1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8170b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8170b9:	48 89 d6             	mov    %rdx,%rsi
  8170bc:	48 89 c7             	mov    %rax,%rdi
  8170bf:	48 b8 5f 0b 81 00 00 	movabs $0x810b5f,%rax
  8170c6:	00 00 00 
  8170c9:	ff d0                	callq  *%rax
      }
      break;
  8170cb:	eb 40                	jmp    81710d <ethernet_input+0x10b>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  8170cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8170d1:	48 8d 48 41          	lea    0x41(%rax),%rcx
  8170d5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8170d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8170dd:	48 89 ce             	mov    %rcx,%rsi
  8170e0:	48 89 c7             	mov    %rax,%rdi
  8170e3:	48 b8 de 63 81 00 00 	movabs $0x8163de,%rax
  8170ea:	00 00 00 
  8170ed:	ff d0                	callq  *%rax
      break;
  8170ef:	eb 1c                	jmp    81710d <ethernet_input+0x10b>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  8170f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8170f5:	48 89 c7             	mov    %rax,%rdi
  8170f8:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8170ff:	00 00 00 
  817102:	ff d0                	callq  *%rax
      p = NULL;
  817104:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  81710b:	00 
      break;
  81710c:	90                   	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
  81710d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  817112:	c9                   	leaveq 
  817113:	c3                   	retq   

0000000000817114 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  817114:	55                   	push   %rbp
  817115:	48 89 e5             	mov    %rsp,%rbp
  817118:	53                   	push   %rbx
  817119:	48 83 ec 10          	sub    $0x10,%rsp
    int i = 0;
  81711d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    for (i = 0; i < NSEM; i++) {
  817124:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  81712b:	e9 ea 00 00 00       	jmpq   81721a <sys_init+0x106>
	sems[i].freed = 1;
  817130:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817137:	00 00 00 
  81713a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81713d:	48 63 d2             	movslq %edx,%rdx
  817140:	48 c1 e2 05          	shl    $0x5,%rdx
  817144:	48 01 d0             	add    %rdx,%rax
  817147:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  81714d:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817154:	00 00 00 
  817157:	48 8b 00             	mov    (%rax),%rax
  81715a:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  817161:	00 00 00 
  817164:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  817167:	48 63 c9             	movslq %ecx,%rcx
  81716a:	48 c1 e1 05          	shl    $0x5,%rcx
  81716e:	48 01 ca             	add    %rcx,%rdx
  817171:	48 83 c2 10          	add    $0x10,%rdx
  817175:	48 89 02             	mov    %rax,(%rdx)
  817178:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81717f:	00 00 00 
  817182:	8b 55 f4             	mov    -0xc(%rbp),%edx
  817185:	48 63 d2             	movslq %edx,%rdx
  817188:	48 c1 e2 05          	shl    $0x5,%rdx
  81718c:	48 01 d0             	add    %rdx,%rax
  81718f:	48 83 c0 10          	add    $0x10,%rax
  817193:	48 8b 00             	mov    (%rax),%rax
  817196:	48 85 c0             	test   %rax,%rax
  817199:	74 2c                	je     8171c7 <sys_init+0xb3>
  81719b:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  8171a2:	00 00 00 
  8171a5:	48 8b 00             	mov    (%rax),%rax
  8171a8:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8171ab:	48 63 d2             	movslq %edx,%rdx
  8171ae:	48 c1 e2 05          	shl    $0x5,%rdx
  8171b2:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
  8171b6:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  8171bd:	00 00 00 
  8171c0:	48 01 ca             	add    %rcx,%rdx
  8171c3:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8171c7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8171ca:	48 98                	cltq   
  8171cc:	48 c1 e0 05          	shl    $0x5,%rax
  8171d0:	48 89 c2             	mov    %rax,%rdx
  8171d3:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8171da:	00 00 00 
  8171dd:	48 01 c2             	add    %rax,%rdx
  8171e0:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  8171e7:	00 00 00 
  8171ea:	48 89 10             	mov    %rdx,(%rax)
  8171ed:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8171f4:	00 00 00 
  8171f7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8171fa:	48 63 d2             	movslq %edx,%rdx
  8171fd:	48 c1 e2 05          	shl    $0x5,%rdx
  817201:	48 01 d0             	add    %rdx,%rax
  817204:	48 83 c0 10          	add    $0x10,%rax
  817208:	48 bf 20 d8 b4 00 00 	movabs $0xb4d820,%rdi
  81720f:	00 00 00 
  817212:	48 89 78 08          	mov    %rdi,0x8(%rax)

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  817216:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  81721a:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%rbp)
  817221:	0f 8e 09 ff ff ff    	jle    817130 <sys_init+0x1c>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  817227:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  81722e:	e9 60 01 00 00       	jmpq   817393 <sys_init+0x27f>
	mboxes[i].freed = 1;
  817233:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81723a:	00 00 00 
  81723d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817240:	48 63 d0             	movslq %eax,%rdx
  817243:	48 89 d0             	mov    %rdx,%rax
  817246:	48 c1 e0 03          	shl    $0x3,%rax
  81724a:	48 01 d0             	add    %rdx,%rax
  81724d:	48 c1 e0 02          	shl    $0x2,%rax
  817251:	48 01 d0             	add    %rdx,%rax
  817254:	48 c1 e0 03          	shl    $0x3,%rax
  817258:	48 01 c8             	add    %rcx,%rax
  81725b:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  817261:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817268:	00 00 00 
  81726b:	48 8b 08             	mov    (%rax),%rcx
  81726e:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817275:	00 00 00 
  817278:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81727b:	48 63 d0             	movslq %eax,%rdx
  81727e:	48 89 d0             	mov    %rdx,%rax
  817281:	48 c1 e0 03          	shl    $0x3,%rax
  817285:	48 01 d0             	add    %rdx,%rax
  817288:	48 c1 e0 02          	shl    $0x2,%rax
  81728c:	48 01 d0             	add    %rdx,%rax
  81728f:	48 c1 e0 03          	shl    $0x3,%rax
  817293:	48 01 f0             	add    %rsi,%rax
  817296:	48 05 10 01 00 00    	add    $0x110,%rax
  81729c:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8172a0:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8172a7:	00 00 00 
  8172aa:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8172ad:	48 63 d0             	movslq %eax,%rdx
  8172b0:	48 89 d0             	mov    %rdx,%rax
  8172b3:	48 c1 e0 03          	shl    $0x3,%rax
  8172b7:	48 01 d0             	add    %rdx,%rax
  8172ba:	48 c1 e0 02          	shl    $0x2,%rax
  8172be:	48 01 d0             	add    %rdx,%rax
  8172c1:	48 c1 e0 03          	shl    $0x3,%rax
  8172c5:	48 01 c8             	add    %rcx,%rax
  8172c8:	48 05 10 01 00 00    	add    $0x110,%rax
  8172ce:	48 8b 40 08          	mov    0x8(%rax),%rax
  8172d2:	48 85 c0             	test   %rax,%rax
  8172d5:	74 47                	je     81731e <sys_init+0x20a>
  8172d7:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  8172de:	00 00 00 
  8172e1:	48 8b 08             	mov    (%rax),%rcx
  8172e4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8172e7:	48 63 d0             	movslq %eax,%rdx
  8172ea:	48 89 d0             	mov    %rdx,%rax
  8172ed:	48 c1 e0 03          	shl    $0x3,%rax
  8172f1:	48 01 d0             	add    %rdx,%rax
  8172f4:	48 c1 e0 02          	shl    $0x2,%rax
  8172f8:	48 01 d0             	add    %rdx,%rax
  8172fb:	48 c1 e0 03          	shl    $0x3,%rax
  8172ff:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  817306:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  81730d:	00 00 00 
  817310:	48 01 d0             	add    %rdx,%rax
  817313:	48 83 c0 08          	add    $0x8,%rax
  817317:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  81731e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817321:	48 63 d0             	movslq %eax,%rdx
  817324:	48 89 d0             	mov    %rdx,%rax
  817327:	48 c1 e0 03          	shl    $0x3,%rax
  81732b:	48 01 d0             	add    %rdx,%rax
  81732e:	48 c1 e0 02          	shl    $0x2,%rax
  817332:	48 01 d0             	add    %rdx,%rax
  817335:	48 c1 e0 03          	shl    $0x3,%rax
  817339:	48 ba 40 d8 b4 00 00 	movabs $0xb4d840,%rdx
  817340:	00 00 00 
  817343:	48 01 c2             	add    %rax,%rdx
  817346:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  81734d:	00 00 00 
  817350:	48 89 10             	mov    %rdx,(%rax)
  817353:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81735a:	00 00 00 
  81735d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817360:	48 63 d0             	movslq %eax,%rdx
  817363:	48 89 d0             	mov    %rdx,%rax
  817366:	48 c1 e0 03          	shl    $0x3,%rax
  81736a:	48 01 d0             	add    %rdx,%rax
  81736d:	48 c1 e0 02          	shl    $0x2,%rax
  817371:	48 01 d0             	add    %rdx,%rax
  817374:	48 c1 e0 03          	shl    $0x3,%rax
  817378:	48 01 c8             	add    %rcx,%rax
  81737b:	48 05 10 01 00 00    	add    $0x110,%rax
  817381:	48 bb 40 6c b5 00 00 	movabs $0xb56c40,%rbx
  817388:	00 00 00 
  81738b:	48 89 58 10          	mov    %rbx,0x10(%rax)
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  81738f:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  817393:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  817397:	0f 8e 96 fe ff ff    	jle    817233 <sys_init+0x11f>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  81739d:	48 83 c4 10          	add    $0x10,%rsp
  8173a1:	5b                   	pop    %rbx
  8173a2:	5d                   	pop    %rbp
  8173a3:	c3                   	retq   

00000000008173a4 <sys_mbox_new>:

sys_mbox_t
sys_mbox_new(int size)
{
  8173a4:	55                   	push   %rbp
  8173a5:	48 89 e5             	mov    %rsp,%rbp
  8173a8:	48 83 ec 20          	sub    $0x20,%rsp
  8173ac:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(size < MBOXSLOTS);
  8173af:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  8173b3:	7e 35                	jle    8173ea <sys_mbox_new+0x46>
  8173b5:	48 b9 68 28 82 00 00 	movabs $0x822868,%rcx
  8173bc:	00 00 00 
  8173bf:	48 ba 79 28 82 00 00 	movabs $0x822879,%rdx
  8173c6:	00 00 00 
  8173c9:	be 45 00 00 00       	mov    $0x45,%esi
  8173ce:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  8173d5:	00 00 00 
  8173d8:	b8 00 00 00 00       	mov    $0x0,%eax
  8173dd:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  8173e4:	00 00 00 
  8173e7:	41 ff d0             	callq  *%r8
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  8173ea:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  8173f1:	00 00 00 
  8173f4:	48 8b 00             	mov    (%rax),%rax
  8173f7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!mbe) {
  8173fb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817400:	75 25                	jne    817427 <sys_mbox_new+0x83>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  817402:	48 bf b0 28 82 00 00 	movabs $0x8228b0,%rdi
  817409:	00 00 00 
  81740c:	b8 00 00 00 00       	mov    $0x0,%eax
  817411:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  817418:	00 00 00 
  81741b:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  81741d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817422:	e9 5b 01 00 00       	jmpq   817582 <sys_mbox_new+0x1de>
    }
    LIST_REMOVE(mbe, link);
  817427:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81742b:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  817432:	48 85 c0             	test   %rax,%rax
  817435:	74 1d                	je     817454 <sys_mbox_new+0xb0>
  817437:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81743b:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  817442:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817446:	48 8b 92 20 01 00 00 	mov    0x120(%rdx),%rdx
  81744d:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
  817454:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817458:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
  81745f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817463:	48 8b 92 18 01 00 00 	mov    0x118(%rdx),%rdx
  81746a:	48 89 10             	mov    %rdx,(%rax)
    assert(mbe->freed);
  81746d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817471:	8b 00                	mov    (%rax),%eax
  817473:	85 c0                	test   %eax,%eax
  817475:	75 35                	jne    8174ac <sys_mbox_new+0x108>
  817477:	48 b9 d6 28 82 00 00 	movabs $0x8228d6,%rcx
  81747e:	00 00 00 
  817481:	48 ba 79 28 82 00 00 	movabs $0x822879,%rdx
  817488:	00 00 00 
  81748b:	be 4c 00 00 00       	mov    $0x4c,%esi
  817490:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  817497:	00 00 00 
  81749a:	b8 00 00 00 00       	mov    $0x0,%eax
  81749f:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  8174a6:	00 00 00 
  8174a9:	41 ff d0             	callq  *%r8
    mbe->freed = 0;
  8174ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8174b0:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    int i = mbe - &mboxes[0];
  8174b6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8174ba:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  8174c1:	00 00 00 
  8174c4:	48 29 c2             	sub    %rax,%rdx
  8174c7:	48 89 d0             	mov    %rdx,%rax
  8174ca:	48 c1 f8 03          	sar    $0x3,%rax
  8174ce:	48 89 c2             	mov    %rax,%rdx
  8174d1:	48 b8 ad 1b 4c 91 cf 	movabs $0x14c1bacf914c1bad,%rax
  8174d8:	ba c1 14 
  8174db:	48 0f af c2          	imul   %rdx,%rax
  8174df:	89 45 f4             	mov    %eax,-0xc(%rbp)
    mbe->head = -1;
  8174e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8174e6:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)
    mbe->nextq = 0;
  8174ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8174f1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    mbe->queued_msg = sys_sem_new(0);
  8174f8:	bf 00 00 00 00       	mov    $0x0,%edi
  8174fd:	48 b8 9b 7a 81 00 00 	movabs $0x817a9b,%rax
  817504:	00 00 00 
  817507:	ff d0                	callq  *%rax
  817509:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81750d:	89 82 10 01 00 00    	mov    %eax,0x110(%rdx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  817513:	bf 20 00 00 00       	mov    $0x20,%edi
  817518:	48 b8 9b 7a 81 00 00 	movabs $0x817a9b,%rax
  81751f:	00 00 00 
  817522:	ff d0                	callq  *%rax
  817524:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817528:	89 82 14 01 00 00    	mov    %eax,0x114(%rdx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  81752e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817532:	8b 80 10 01 00 00    	mov    0x110(%rax),%eax
  817538:	83 f8 ff             	cmp    $0xffffffff,%eax
  81753b:	74 0f                	je     81754c <sys_mbox_new+0x1a8>
	mbe->free_msg == SYS_SEM_NULL)
  81753d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817541:	8b 80 14 01 00 00    	mov    0x114(%rax),%eax
    mbe->head = -1;
    mbe->nextq = 0;
    mbe->queued_msg = sys_sem_new(0);
    mbe->free_msg = sys_sem_new(MBOXSLOTS);

    if (mbe->queued_msg == SYS_SEM_NULL ||
  817547:	83 f8 ff             	cmp    $0xffffffff,%eax
  81754a:	75 33                	jne    81757f <sys_mbox_new+0x1db>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  81754c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81754f:	89 c7                	mov    %eax,%edi
  817551:	48 b8 84 75 81 00 00 	movabs $0x817584,%rax
  817558:	00 00 00 
  81755b:	ff d0                	callq  *%rax
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  81755d:	48 bf e8 28 82 00 00 	movabs $0x8228e8,%rdi
  817564:	00 00 00 
  817567:	b8 00 00 00 00       	mov    $0x0,%eax
  81756c:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  817573:	00 00 00 
  817576:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  817578:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81757d:	eb 03                	jmp    817582 <sys_mbox_new+0x1de>
    }
    return i;
  81757f:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  817582:	c9                   	leaveq 
  817583:	c3                   	retq   

0000000000817584 <sys_mbox_free>:

void
sys_mbox_free(sys_mbox_t mbox)
{
  817584:	55                   	push   %rbp
  817585:	48 89 e5             	mov    %rsp,%rbp
  817588:	53                   	push   %rbx
  817589:	48 83 ec 18          	sub    $0x18,%rsp
  81758d:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(!mboxes[mbox].freed);
  817590:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817597:	00 00 00 
  81759a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81759d:	48 63 d0             	movslq %eax,%rdx
  8175a0:	48 89 d0             	mov    %rdx,%rax
  8175a3:	48 c1 e0 03          	shl    $0x3,%rax
  8175a7:	48 01 d0             	add    %rdx,%rax
  8175aa:	48 c1 e0 02          	shl    $0x2,%rax
  8175ae:	48 01 d0             	add    %rdx,%rax
  8175b1:	48 c1 e0 03          	shl    $0x3,%rax
  8175b5:	48 01 c8             	add    %rcx,%rax
  8175b8:	8b 00                	mov    (%rax),%eax
  8175ba:	85 c0                	test   %eax,%eax
  8175bc:	74 35                	je     8175f3 <sys_mbox_free+0x6f>
  8175be:	48 b9 11 29 82 00 00 	movabs $0x822911,%rcx
  8175c5:	00 00 00 
  8175c8:	48 ba 79 28 82 00 00 	movabs $0x822879,%rdx
  8175cf:	00 00 00 
  8175d2:	be 62 00 00 00       	mov    $0x62,%esi
  8175d7:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  8175de:	00 00 00 
  8175e1:	b8 00 00 00 00       	mov    $0x0,%eax
  8175e6:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  8175ed:	00 00 00 
  8175f0:	41 ff d0             	callq  *%r8
    sys_sem_free(mboxes[mbox].queued_msg);
  8175f3:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8175fa:	00 00 00 
  8175fd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817600:	48 63 d0             	movslq %eax,%rdx
  817603:	48 89 d0             	mov    %rdx,%rax
  817606:	48 c1 e0 03          	shl    $0x3,%rax
  81760a:	48 01 d0             	add    %rdx,%rax
  81760d:	48 c1 e0 02          	shl    $0x2,%rax
  817611:	48 01 d0             	add    %rdx,%rax
  817614:	48 c1 e0 03          	shl    $0x3,%rax
  817618:	48 01 c8             	add    %rcx,%rax
  81761b:	48 05 10 01 00 00    	add    $0x110,%rax
  817621:	8b 00                	mov    (%rax),%eax
  817623:	89 c7                	mov    %eax,%edi
  817625:	48 b8 99 7b 81 00 00 	movabs $0x817b99,%rax
  81762c:	00 00 00 
  81762f:	ff d0                	callq  *%rax
    sys_sem_free(mboxes[mbox].free_msg);
  817631:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817638:	00 00 00 
  81763b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81763e:	48 63 d0             	movslq %eax,%rdx
  817641:	48 89 d0             	mov    %rdx,%rax
  817644:	48 c1 e0 03          	shl    $0x3,%rax
  817648:	48 01 d0             	add    %rdx,%rax
  81764b:	48 c1 e0 02          	shl    $0x2,%rax
  81764f:	48 01 d0             	add    %rdx,%rax
  817652:	48 c1 e0 03          	shl    $0x3,%rax
  817656:	48 01 c8             	add    %rcx,%rax
  817659:	48 05 10 01 00 00    	add    $0x110,%rax
  81765f:	8b 40 04             	mov    0x4(%rax),%eax
  817662:	89 c7                	mov    %eax,%edi
  817664:	48 b8 99 7b 81 00 00 	movabs $0x817b99,%rax
  81766b:	00 00 00 
  81766e:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  817670:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817677:	00 00 00 
  81767a:	48 8b 08             	mov    (%rax),%rcx
  81767d:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817684:	00 00 00 
  817687:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81768a:	48 63 d0             	movslq %eax,%rdx
  81768d:	48 89 d0             	mov    %rdx,%rax
  817690:	48 c1 e0 03          	shl    $0x3,%rax
  817694:	48 01 d0             	add    %rdx,%rax
  817697:	48 c1 e0 02          	shl    $0x2,%rax
  81769b:	48 01 d0             	add    %rdx,%rax
  81769e:	48 c1 e0 03          	shl    $0x3,%rax
  8176a2:	48 01 f0             	add    %rsi,%rax
  8176a5:	48 05 10 01 00 00    	add    $0x110,%rax
  8176ab:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8176af:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8176b6:	00 00 00 
  8176b9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8176bc:	48 63 d0             	movslq %eax,%rdx
  8176bf:	48 89 d0             	mov    %rdx,%rax
  8176c2:	48 c1 e0 03          	shl    $0x3,%rax
  8176c6:	48 01 d0             	add    %rdx,%rax
  8176c9:	48 c1 e0 02          	shl    $0x2,%rax
  8176cd:	48 01 d0             	add    %rdx,%rax
  8176d0:	48 c1 e0 03          	shl    $0x3,%rax
  8176d4:	48 01 c8             	add    %rcx,%rax
  8176d7:	48 05 10 01 00 00    	add    $0x110,%rax
  8176dd:	48 8b 40 08          	mov    0x8(%rax),%rax
  8176e1:	48 85 c0             	test   %rax,%rax
  8176e4:	74 47                	je     81772d <sys_mbox_free+0x1a9>
  8176e6:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  8176ed:	00 00 00 
  8176f0:	48 8b 08             	mov    (%rax),%rcx
  8176f3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8176f6:	48 63 d0             	movslq %eax,%rdx
  8176f9:	48 89 d0             	mov    %rdx,%rax
  8176fc:	48 c1 e0 03          	shl    $0x3,%rax
  817700:	48 01 d0             	add    %rdx,%rax
  817703:	48 c1 e0 02          	shl    $0x2,%rax
  817707:	48 01 d0             	add    %rdx,%rax
  81770a:	48 c1 e0 03          	shl    $0x3,%rax
  81770e:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  817715:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  81771c:	00 00 00 
  81771f:	48 01 d0             	add    %rdx,%rax
  817722:	48 83 c0 08          	add    $0x8,%rax
  817726:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  81772d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817730:	48 63 d0             	movslq %eax,%rdx
  817733:	48 89 d0             	mov    %rdx,%rax
  817736:	48 c1 e0 03          	shl    $0x3,%rax
  81773a:	48 01 d0             	add    %rdx,%rax
  81773d:	48 c1 e0 02          	shl    $0x2,%rax
  817741:	48 01 d0             	add    %rdx,%rax
  817744:	48 c1 e0 03          	shl    $0x3,%rax
  817748:	48 ba 40 d8 b4 00 00 	movabs $0xb4d840,%rdx
  81774f:	00 00 00 
  817752:	48 01 c2             	add    %rax,%rdx
  817755:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  81775c:	00 00 00 
  81775f:	48 89 10             	mov    %rdx,(%rax)
  817762:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817769:	00 00 00 
  81776c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81776f:	48 63 d0             	movslq %eax,%rdx
  817772:	48 89 d0             	mov    %rdx,%rax
  817775:	48 c1 e0 03          	shl    $0x3,%rax
  817779:	48 01 d0             	add    %rdx,%rax
  81777c:	48 c1 e0 02          	shl    $0x2,%rax
  817780:	48 01 d0             	add    %rdx,%rax
  817783:	48 c1 e0 03          	shl    $0x3,%rax
  817787:	48 01 c8             	add    %rcx,%rax
  81778a:	48 05 10 01 00 00    	add    $0x110,%rax
  817790:	48 bb 40 6c b5 00 00 	movabs $0xb56c40,%rbx
  817797:	00 00 00 
  81779a:	48 89 58 10          	mov    %rbx,0x10(%rax)
    mboxes[mbox].freed = 1;
  81779e:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8177a5:	00 00 00 
  8177a8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8177ab:	48 63 d0             	movslq %eax,%rdx
  8177ae:	48 89 d0             	mov    %rdx,%rax
  8177b1:	48 c1 e0 03          	shl    $0x3,%rax
  8177b5:	48 01 d0             	add    %rdx,%rax
  8177b8:	48 c1 e0 02          	shl    $0x2,%rax
  8177bc:	48 01 d0             	add    %rdx,%rax
  8177bf:	48 c1 e0 03          	shl    $0x3,%rax
  8177c3:	48 01 c8             	add    %rcx,%rax
  8177c6:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
}
  8177cc:	48 83 c4 18          	add    $0x18,%rsp
  8177d0:	5b                   	pop    %rbx
  8177d1:	5d                   	pop    %rbp
  8177d2:	c3                   	retq   

00000000008177d3 <sys_mbox_post>:

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  8177d3:	55                   	push   %rbp
  8177d4:	48 89 e5             	mov    %rsp,%rbp
  8177d7:	48 83 ec 10          	sub    $0x10,%rsp
  8177db:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8177de:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  8177e2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8177e6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8177e9:	48 89 d6             	mov    %rdx,%rsi
  8177ec:	89 c7                	mov    %eax,%edi
  8177ee:	48 b8 35 78 81 00 00 	movabs $0x817835,%rax
  8177f5:	00 00 00 
  8177f8:	ff d0                	callq  *%rax
  8177fa:	84 c0                	test   %al,%al
  8177fc:	74 35                	je     817833 <sys_mbox_post+0x60>
  8177fe:	48 b9 28 29 82 00 00 	movabs $0x822928,%rcx
  817805:	00 00 00 
  817808:	48 ba 79 28 82 00 00 	movabs $0x822879,%rdx
  81780f:	00 00 00 
  817812:	be 6c 00 00 00       	mov    $0x6c,%esi
  817817:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  81781e:	00 00 00 
  817821:	b8 00 00 00 00       	mov    $0x0,%eax
  817826:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  81782d:	00 00 00 
  817830:	41 ff d0             	callq  *%r8
}
  817833:	c9                   	leaveq 
  817834:	c3                   	retq   

0000000000817835 <sys_mbox_trypost>:

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  817835:	55                   	push   %rbp
  817836:	48 89 e5             	mov    %rsp,%rbp
  817839:	48 83 ec 20          	sub    $0x20,%rsp
  81783d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  817840:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    assert(!mboxes[mbox].freed);
  817844:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81784b:	00 00 00 
  81784e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817851:	48 63 d0             	movslq %eax,%rdx
  817854:	48 89 d0             	mov    %rdx,%rax
  817857:	48 c1 e0 03          	shl    $0x3,%rax
  81785b:	48 01 d0             	add    %rdx,%rax
  81785e:	48 c1 e0 02          	shl    $0x2,%rax
  817862:	48 01 d0             	add    %rdx,%rax
  817865:	48 c1 e0 03          	shl    $0x3,%rax
  817869:	48 01 c8             	add    %rcx,%rax
  81786c:	8b 00                	mov    (%rax),%eax
  81786e:	85 c0                	test   %eax,%eax
  817870:	74 35                	je     8178a7 <sys_mbox_trypost+0x72>
  817872:	48 b9 11 29 82 00 00 	movabs $0x822911,%rcx
  817879:	00 00 00 
  81787c:	48 ba 79 28 82 00 00 	movabs $0x822879,%rdx
  817883:	00 00 00 
  817886:	be 72 00 00 00       	mov    $0x72,%esi
  81788b:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  817892:	00 00 00 
  817895:	b8 00 00 00 00       	mov    $0x0,%eax
  81789a:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  8178a1:	00 00 00 
  8178a4:	41 ff d0             	callq  *%r8

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  8178a7:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8178ae:	00 00 00 
  8178b1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8178b4:	48 63 d0             	movslq %eax,%rdx
  8178b7:	48 89 d0             	mov    %rdx,%rax
  8178ba:	48 c1 e0 03          	shl    $0x3,%rax
  8178be:	48 01 d0             	add    %rdx,%rax
  8178c1:	48 c1 e0 02          	shl    $0x2,%rax
  8178c5:	48 01 d0             	add    %rdx,%rax
  8178c8:	48 c1 e0 03          	shl    $0x3,%rax
  8178cc:	48 01 c8             	add    %rcx,%rax
  8178cf:	48 05 10 01 00 00    	add    $0x110,%rax
  8178d5:	8b 40 04             	mov    0x4(%rax),%eax
  8178d8:	be 00 00 00 00       	mov    $0x0,%esi
  8178dd:	89 c7                	mov    %eax,%edi
  8178df:	48 b8 1c 7e 81 00 00 	movabs $0x817e1c,%rax
  8178e6:	00 00 00 
  8178e9:	ff d0                	callq  *%rax
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  8178eb:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8178f2:	00 00 00 
  8178f5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8178f8:	48 63 d0             	movslq %eax,%rdx
  8178fb:	48 89 d0             	mov    %rdx,%rax
  8178fe:	48 c1 e0 03          	shl    $0x3,%rax
  817902:	48 01 d0             	add    %rdx,%rax
  817905:	48 c1 e0 02          	shl    $0x2,%rax
  817909:	48 01 d0             	add    %rdx,%rax
  81790c:	48 c1 e0 03          	shl    $0x3,%rax
  817910:	48 01 c8             	add    %rcx,%rax
  817913:	8b 48 08             	mov    0x8(%rax),%ecx
  817916:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  81791d:	00 00 00 
  817920:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817923:	48 63 d0             	movslq %eax,%rdx
  817926:	48 89 d0             	mov    %rdx,%rax
  817929:	48 c1 e0 03          	shl    $0x3,%rax
  81792d:	48 01 d0             	add    %rdx,%rax
  817930:	48 c1 e0 02          	shl    $0x2,%rax
  817934:	48 01 d0             	add    %rdx,%rax
  817937:	48 c1 e0 03          	shl    $0x3,%rax
  81793b:	48 01 f0             	add    %rsi,%rax
  81793e:	8b 40 04             	mov    0x4(%rax),%eax
  817941:	39 c1                	cmp    %eax,%ecx
  817943:	75 0a                	jne    81794f <sys_mbox_trypost+0x11a>
	return ERR_MEM;
  817945:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81794a:	e9 4a 01 00 00       	jmpq   817a99 <sys_mbox_trypost+0x264>

    int slot = mboxes[mbox].nextq;
  81794f:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817956:	00 00 00 
  817959:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81795c:	48 63 d0             	movslq %eax,%rdx
  81795f:	48 89 d0             	mov    %rdx,%rax
  817962:	48 c1 e0 03          	shl    $0x3,%rax
  817966:	48 01 d0             	add    %rdx,%rax
  817969:	48 c1 e0 02          	shl    $0x2,%rax
  81796d:	48 01 d0             	add    %rdx,%rax
  817970:	48 c1 e0 03          	shl    $0x3,%rax
  817974:	48 01 c8             	add    %rcx,%rax
  817977:	8b 40 08             	mov    0x8(%rax),%eax
  81797a:	89 45 fc             	mov    %eax,-0x4(%rbp)
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  81797d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817980:	8d 50 01             	lea    0x1(%rax),%edx
  817983:	89 d0                	mov    %edx,%eax
  817985:	c1 f8 1f             	sar    $0x1f,%eax
  817988:	c1 e8 1b             	shr    $0x1b,%eax
  81798b:	01 c2                	add    %eax,%edx
  81798d:	83 e2 1f             	and    $0x1f,%edx
  817990:	29 c2                	sub    %eax,%edx
  817992:	89 d0                	mov    %edx,%eax
  817994:	89 c1                	mov    %eax,%ecx
  817996:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  81799d:	00 00 00 
  8179a0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8179a3:	48 63 d0             	movslq %eax,%rdx
  8179a6:	48 89 d0             	mov    %rdx,%rax
  8179a9:	48 c1 e0 03          	shl    $0x3,%rax
  8179ad:	48 01 d0             	add    %rdx,%rax
  8179b0:	48 c1 e0 02          	shl    $0x2,%rax
  8179b4:	48 01 d0             	add    %rdx,%rax
  8179b7:	48 c1 e0 03          	shl    $0x3,%rax
  8179bb:	48 01 f0             	add    %rsi,%rax
  8179be:	89 48 08             	mov    %ecx,0x8(%rax)
    mboxes[mbox].msg[slot] = msg;
  8179c1:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8179c8:	00 00 00 
  8179cb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8179ce:	48 63 f0             	movslq %eax,%rsi
  8179d1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8179d4:	48 63 d0             	movslq %eax,%rdx
  8179d7:	48 89 d0             	mov    %rdx,%rax
  8179da:	48 c1 e0 03          	shl    $0x3,%rax
  8179de:	48 01 d0             	add    %rdx,%rax
  8179e1:	48 c1 e0 02          	shl    $0x2,%rax
  8179e5:	48 01 d0             	add    %rdx,%rax
  8179e8:	48 01 f0             	add    %rsi,%rax
  8179eb:	48 8d 50 02          	lea    0x2(%rax),%rdx
  8179ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8179f3:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)

    if (mboxes[mbox].head == -1)
  8179f7:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8179fe:	00 00 00 
  817a01:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817a04:	48 63 d0             	movslq %eax,%rdx
  817a07:	48 89 d0             	mov    %rdx,%rax
  817a0a:	48 c1 e0 03          	shl    $0x3,%rax
  817a0e:	48 01 d0             	add    %rdx,%rax
  817a11:	48 c1 e0 02          	shl    $0x2,%rax
  817a15:	48 01 d0             	add    %rdx,%rax
  817a18:	48 c1 e0 03          	shl    $0x3,%rax
  817a1c:	48 01 c8             	add    %rcx,%rax
  817a1f:	8b 40 04             	mov    0x4(%rax),%eax
  817a22:	83 f8 ff             	cmp    $0xffffffff,%eax
  817a25:	75 2f                	jne    817a56 <sys_mbox_trypost+0x221>
	mboxes[mbox].head = slot;
  817a27:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817a2e:	00 00 00 
  817a31:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817a34:	48 63 d0             	movslq %eax,%rdx
  817a37:	48 89 d0             	mov    %rdx,%rax
  817a3a:	48 c1 e0 03          	shl    $0x3,%rax
  817a3e:	48 01 d0             	add    %rdx,%rax
  817a41:	48 c1 e0 02          	shl    $0x2,%rax
  817a45:	48 01 d0             	add    %rdx,%rax
  817a48:	48 c1 e0 03          	shl    $0x3,%rax
  817a4c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  817a50:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817a53:	89 42 04             	mov    %eax,0x4(%rdx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  817a56:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817a5d:	00 00 00 
  817a60:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817a63:	48 63 d0             	movslq %eax,%rdx
  817a66:	48 89 d0             	mov    %rdx,%rax
  817a69:	48 c1 e0 03          	shl    $0x3,%rax
  817a6d:	48 01 d0             	add    %rdx,%rax
  817a70:	48 c1 e0 02          	shl    $0x2,%rax
  817a74:	48 01 d0             	add    %rdx,%rax
  817a77:	48 c1 e0 03          	shl    $0x3,%rax
  817a7b:	48 01 c8             	add    %rcx,%rax
  817a7e:	48 05 10 01 00 00    	add    $0x110,%rax
  817a84:	8b 00                	mov    (%rax),%eax
  817a86:	89 c7                	mov    %eax,%edi
  817a88:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  817a8f:	00 00 00 
  817a92:	ff d0                	callq  *%rax

    return ERR_OK;
  817a94:	b8 00 00 00 00       	mov    $0x0,%eax
}
  817a99:	c9                   	leaveq 
  817a9a:	c3                   	retq   

0000000000817a9b <sys_sem_new>:

sys_sem_t
sys_sem_new(u8_t count)
{
  817a9b:	55                   	push   %rbp
  817a9c:	48 89 e5             	mov    %rsp,%rbp
  817a9f:	48 83 ec 20          	sub    $0x20,%rsp
  817aa3:	89 f8                	mov    %edi,%eax
  817aa5:	88 45 ec             	mov    %al,-0x14(%rbp)
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  817aa8:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817aaf:	00 00 00 
  817ab2:	48 8b 00             	mov    (%rax),%rax
  817ab5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!se) {
  817ab9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817abe:	75 25                	jne    817ae5 <sys_sem_new+0x4a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  817ac0:	48 bf 50 29 82 00 00 	movabs $0x822950,%rdi
  817ac7:	00 00 00 
  817aca:	b8 00 00 00 00       	mov    $0x0,%eax
  817acf:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  817ad6:	00 00 00 
  817ad9:	ff d2                	callq  *%rdx
	return SYS_SEM_NULL;
  817adb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817ae0:	e9 b2 00 00 00       	jmpq   817b97 <sys_sem_new+0xfc>
    }
    LIST_REMOVE(se, link);
  817ae5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817ae9:	48 8b 40 10          	mov    0x10(%rax),%rax
  817aed:	48 85 c0             	test   %rax,%rax
  817af0:	74 14                	je     817b06 <sys_sem_new+0x6b>
  817af2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817af6:	48 8b 40 10          	mov    0x10(%rax),%rax
  817afa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817afe:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  817b02:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817b06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817b0a:	48 8b 40 18          	mov    0x18(%rax),%rax
  817b0e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817b12:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  817b16:	48 89 10             	mov    %rdx,(%rax)
    assert(se->freed);
  817b19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817b1d:	8b 00                	mov    (%rax),%eax
  817b1f:	85 c0                	test   %eax,%eax
  817b21:	75 35                	jne    817b58 <sys_sem_new+0xbd>
  817b23:	48 b9 76 29 82 00 00 	movabs $0x822976,%rcx
  817b2a:	00 00 00 
  817b2d:	48 ba 79 28 82 00 00 	movabs $0x822879,%rdx
  817b34:	00 00 00 
  817b37:	be 8d 00 00 00       	mov    $0x8d,%esi
  817b3c:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  817b43:	00 00 00 
  817b46:	b8 00 00 00 00       	mov    $0x0,%eax
  817b4b:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  817b52:	00 00 00 
  817b55:	41 ff d0             	callq  *%r8
    se->freed = 0;
  817b58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817b5c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    se->counter = count;
  817b62:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  817b66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817b6a:	66 89 50 08          	mov    %dx,0x8(%rax)
    se->gen++;
  817b6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817b72:	8b 40 04             	mov    0x4(%rax),%eax
  817b75:	8d 50 01             	lea    0x1(%rax),%edx
  817b78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817b7c:	89 50 04             	mov    %edx,0x4(%rax)
    return se - &sems[0];
  817b7f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817b83:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817b8a:	00 00 00 
  817b8d:	48 29 c2             	sub    %rax,%rdx
  817b90:	48 89 d0             	mov    %rdx,%rax
  817b93:	48 c1 f8 05          	sar    $0x5,%rax
}
  817b97:	c9                   	leaveq 
  817b98:	c3                   	retq   

0000000000817b99 <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  817b99:	55                   	push   %rbp
  817b9a:	48 89 e5             	mov    %rsp,%rbp
  817b9d:	53                   	push   %rbx
  817b9e:	48 83 ec 18          	sub    $0x18,%rsp
  817ba2:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(!sems[sem].freed);
  817ba5:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817bac:	00 00 00 
  817baf:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817bb2:	48 63 d2             	movslq %edx,%rdx
  817bb5:	48 c1 e2 05          	shl    $0x5,%rdx
  817bb9:	48 01 d0             	add    %rdx,%rax
  817bbc:	8b 00                	mov    (%rax),%eax
  817bbe:	85 c0                	test   %eax,%eax
  817bc0:	74 35                	je     817bf7 <sys_sem_free+0x5e>
  817bc2:	48 b9 80 29 82 00 00 	movabs $0x822980,%rcx
  817bc9:	00 00 00 
  817bcc:	48 ba 79 28 82 00 00 	movabs $0x822879,%rdx
  817bd3:	00 00 00 
  817bd6:	be 98 00 00 00       	mov    $0x98,%esi
  817bdb:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  817be2:	00 00 00 
  817be5:	b8 00 00 00 00       	mov    $0x0,%eax
  817bea:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  817bf1:	00 00 00 
  817bf4:	41 ff d0             	callq  *%r8
    sems[sem].freed = 1;
  817bf7:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817bfe:	00 00 00 
  817c01:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817c04:	48 63 d2             	movslq %edx,%rdx
  817c07:	48 c1 e2 05          	shl    $0x5,%rdx
  817c0b:	48 01 d0             	add    %rdx,%rax
  817c0e:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sems[sem].gen++;
  817c14:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817c1b:	00 00 00 
  817c1e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817c21:	48 63 d2             	movslq %edx,%rdx
  817c24:	48 c1 e2 05          	shl    $0x5,%rdx
  817c28:	48 01 d0             	add    %rdx,%rax
  817c2b:	8b 40 04             	mov    0x4(%rax),%eax
  817c2e:	8d 50 01             	lea    0x1(%rax),%edx
  817c31:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817c38:	00 00 00 
  817c3b:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  817c3e:	48 63 c9             	movslq %ecx,%rcx
  817c41:	48 c1 e1 05          	shl    $0x5,%rcx
  817c45:	48 01 c8             	add    %rcx,%rax
  817c48:	89 50 04             	mov    %edx,0x4(%rax)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  817c4b:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817c52:	00 00 00 
  817c55:	48 8b 00             	mov    (%rax),%rax
  817c58:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  817c5f:	00 00 00 
  817c62:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  817c65:	48 63 c9             	movslq %ecx,%rcx
  817c68:	48 c1 e1 05          	shl    $0x5,%rcx
  817c6c:	48 01 ca             	add    %rcx,%rdx
  817c6f:	48 83 c2 10          	add    $0x10,%rdx
  817c73:	48 89 02             	mov    %rax,(%rdx)
  817c76:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817c7d:	00 00 00 
  817c80:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817c83:	48 63 d2             	movslq %edx,%rdx
  817c86:	48 c1 e2 05          	shl    $0x5,%rdx
  817c8a:	48 01 d0             	add    %rdx,%rax
  817c8d:	48 83 c0 10          	add    $0x10,%rax
  817c91:	48 8b 00             	mov    (%rax),%rax
  817c94:	48 85 c0             	test   %rax,%rax
  817c97:	74 2c                	je     817cc5 <sys_sem_free+0x12c>
  817c99:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817ca0:	00 00 00 
  817ca3:	48 8b 00             	mov    (%rax),%rax
  817ca6:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817ca9:	48 63 d2             	movslq %edx,%rdx
  817cac:	48 c1 e2 05          	shl    $0x5,%rdx
  817cb0:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
  817cb4:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  817cbb:	00 00 00 
  817cbe:	48 01 ca             	add    %rcx,%rdx
  817cc1:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817cc5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817cc8:	48 98                	cltq   
  817cca:	48 c1 e0 05          	shl    $0x5,%rax
  817cce:	48 89 c2             	mov    %rax,%rdx
  817cd1:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817cd8:	00 00 00 
  817cdb:	48 01 c2             	add    %rax,%rdx
  817cde:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817ce5:	00 00 00 
  817ce8:	48 89 10             	mov    %rdx,(%rax)
  817ceb:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817cf2:	00 00 00 
  817cf5:	8b 55 ec             	mov    -0x14(%rbp),%edx
  817cf8:	48 63 d2             	movslq %edx,%rdx
  817cfb:	48 c1 e2 05          	shl    $0x5,%rdx
  817cff:	48 01 d0             	add    %rdx,%rax
  817d02:	48 83 c0 10          	add    $0x10,%rax
  817d06:	48 bb 20 d8 b4 00 00 	movabs $0xb4d820,%rbx
  817d0d:	00 00 00 
  817d10:	48 89 58 08          	mov    %rbx,0x8(%rax)
}
  817d14:	48 83 c4 18          	add    $0x18,%rsp
  817d18:	5b                   	pop    %rbx
  817d19:	5d                   	pop    %rbp
  817d1a:	c3                   	retq   

0000000000817d1b <sys_sem_signal>:

void
sys_sem_signal(sys_sem_t sem)
{
  817d1b:	55                   	push   %rbp
  817d1c:	48 89 e5             	mov    %rsp,%rbp
  817d1f:	48 83 ec 10          	sub    $0x10,%rsp
  817d23:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  817d26:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817d2d:	00 00 00 
  817d30:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817d33:	48 63 d2             	movslq %edx,%rdx
  817d36:	48 c1 e2 05          	shl    $0x5,%rdx
  817d3a:	48 01 d0             	add    %rdx,%rax
  817d3d:	8b 00                	mov    (%rax),%eax
  817d3f:	85 c0                	test   %eax,%eax
  817d41:	74 35                	je     817d78 <sys_sem_signal+0x5d>
  817d43:	48 b9 80 29 82 00 00 	movabs $0x822980,%rcx
  817d4a:	00 00 00 
  817d4d:	48 ba 79 28 82 00 00 	movabs $0x822879,%rdx
  817d54:	00 00 00 
  817d57:	be a1 00 00 00       	mov    $0xa1,%esi
  817d5c:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  817d63:	00 00 00 
  817d66:	b8 00 00 00 00       	mov    $0x0,%eax
  817d6b:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  817d72:	00 00 00 
  817d75:	41 ff d0             	callq  *%r8
    sems[sem].counter++;
  817d78:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817d7f:	00 00 00 
  817d82:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817d85:	48 63 d2             	movslq %edx,%rdx
  817d88:	48 c1 e2 05          	shl    $0x5,%rdx
  817d8c:	48 01 d0             	add    %rdx,%rax
  817d8f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  817d93:	8d 50 01             	lea    0x1(%rax),%edx
  817d96:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817d9d:	00 00 00 
  817da0:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  817da3:	48 63 c9             	movslq %ecx,%rcx
  817da6:	48 c1 e1 05          	shl    $0x5,%rcx
  817daa:	48 01 c8             	add    %rcx,%rax
  817dad:	66 89 50 08          	mov    %dx,0x8(%rax)
    if (sems[sem].waiters) {
  817db1:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817db8:	00 00 00 
  817dbb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817dbe:	48 63 d2             	movslq %edx,%rdx
  817dc1:	48 c1 e2 05          	shl    $0x5,%rdx
  817dc5:	48 01 d0             	add    %rdx,%rax
  817dc8:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  817dcc:	66 85 c0             	test   %ax,%ax
  817dcf:	74 49                	je     817e1a <sys_sem_signal+0xff>
	sems[sem].waiters = 0;
  817dd1:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817dd8:	00 00 00 
  817ddb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817dde:	48 63 d2             	movslq %edx,%rdx
  817de1:	48 c1 e2 05          	shl    $0x5,%rdx
  817de5:	48 01 d0             	add    %rdx,%rax
  817de8:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
	thread_wakeup(&sems[sem].v);
  817dee:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817df1:	48 98                	cltq   
  817df3:	48 c1 e0 05          	shl    $0x5,%rax
  817df7:	48 89 c2             	mov    %rax,%rdx
  817dfa:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817e01:	00 00 00 
  817e04:	48 01 d0             	add    %rdx,%rax
  817e07:	48 83 c0 08          	add    $0x8,%rax
  817e0b:	48 89 c7             	mov    %rax,%rdi
  817e0e:	48 b8 95 88 81 00 00 	movabs $0x818895,%rax
  817e15:	00 00 00 
  817e18:	ff d0                	callq  *%rax
    }
}
  817e1a:	c9                   	leaveq 
  817e1b:	c3                   	retq   

0000000000817e1c <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  817e1c:	55                   	push   %rbp
  817e1d:	48 89 e5             	mov    %rsp,%rbp
  817e20:	48 83 ec 30          	sub    $0x30,%rsp
  817e24:	89 7d dc             	mov    %edi,-0x24(%rbp)
  817e27:	89 75 d8             	mov    %esi,-0x28(%rbp)
    assert(!sems[sem].freed);
  817e2a:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817e31:	00 00 00 
  817e34:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817e37:	48 63 d2             	movslq %edx,%rdx
  817e3a:	48 c1 e2 05          	shl    $0x5,%rdx
  817e3e:	48 01 d0             	add    %rdx,%rax
  817e41:	8b 00                	mov    (%rax),%eax
  817e43:	85 c0                	test   %eax,%eax
  817e45:	74 35                	je     817e7c <sys_arch_sem_wait+0x60>
  817e47:	48 b9 80 29 82 00 00 	movabs $0x822980,%rcx
  817e4e:	00 00 00 
  817e51:	48 ba 79 28 82 00 00 	movabs $0x822879,%rdx
  817e58:	00 00 00 
  817e5b:	be ac 00 00 00       	mov    $0xac,%esi
  817e60:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  817e67:	00 00 00 
  817e6a:	b8 00 00 00 00       	mov    $0x0,%eax
  817e6f:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  817e76:	00 00 00 
  817e79:	41 ff d0             	callq  *%r8
    u32_t waited = 0;
  817e7c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

    int gen = sems[sem].gen;
  817e83:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817e8a:	00 00 00 
  817e8d:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817e90:	48 63 d2             	movslq %edx,%rdx
  817e93:	48 c1 e2 05          	shl    $0x5,%rdx
  817e97:	48 01 d0             	add    %rdx,%rax
  817e9a:	8b 40 04             	mov    0x4(%rax),%eax
  817e9d:	89 45 f8             	mov    %eax,-0x8(%rbp)

    while (tm_msec == 0 || waited < tm_msec) {
  817ea0:	e9 80 01 00 00       	jmpq   818025 <sys_arch_sem_wait+0x209>
	if (sems[sem].counter > 0) {
  817ea5:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817eac:	00 00 00 
  817eaf:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817eb2:	48 63 d2             	movslq %edx,%rdx
  817eb5:	48 c1 e2 05          	shl    $0x5,%rdx
  817eb9:	48 01 d0             	add    %rdx,%rax
  817ebc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  817ec0:	66 85 c0             	test   %ax,%ax
  817ec3:	74 41                	je     817f06 <sys_arch_sem_wait+0xea>
	    sems[sem].counter--;
  817ec5:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817ecc:	00 00 00 
  817ecf:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817ed2:	48 63 d2             	movslq %edx,%rdx
  817ed5:	48 c1 e2 05          	shl    $0x5,%rdx
  817ed9:	48 01 d0             	add    %rdx,%rax
  817edc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  817ee0:	8d 50 ff             	lea    -0x1(%rax),%edx
  817ee3:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817eea:	00 00 00 
  817eed:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  817ef0:	48 63 c9             	movslq %ecx,%rcx
  817ef3:	48 c1 e1 05          	shl    $0x5,%rcx
  817ef7:	48 01 c8             	add    %rcx,%rax
  817efa:	66 89 50 08          	mov    %dx,0x8(%rax)
	    return waited;
  817efe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817f01:	e9 3a 01 00 00       	jmpq   818040 <sys_arch_sem_wait+0x224>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  817f06:	83 7d d8 fe          	cmpl   $0xfffffffe,-0x28(%rbp)
  817f0a:	75 0a                	jne    817f16 <sys_arch_sem_wait+0xfa>
	    return SYS_ARCH_TIMEOUT;
  817f0c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817f11:	e9 2a 01 00 00       	jmpq   818040 <sys_arch_sem_wait+0x224>
	} else {
	    uint32_t a = sys_time_msec();
  817f16:	48 b8 56 29 80 00 00 	movabs $0x802956,%rax
  817f1d:	00 00 00 
  817f20:	ff d0                	callq  *%rax
  817f22:	89 45 f4             	mov    %eax,-0xc(%rbp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  817f25:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  817f29:	74 0f                	je     817f3a <sys_arch_sem_wait+0x11e>
  817f2b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817f2e:	8b 55 d8             	mov    -0x28(%rbp),%edx
  817f31:	29 c2                	sub    %eax,%edx
  817f33:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817f36:	01 d0                	add    %edx,%eax
  817f38:	eb 05                	jmp    817f3f <sys_arch_sem_wait+0x123>
  817f3a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817f3f:	89 45 f0             	mov    %eax,-0x10(%rbp)
	    sems[sem].waiters = 1;
  817f42:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817f49:	00 00 00 
  817f4c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817f4f:	48 63 d2             	movslq %edx,%rdx
  817f52:	48 c1 e2 05          	shl    $0x5,%rdx
  817f56:	48 01 d0             	add    %rdx,%rax
  817f59:	66 c7 40 0a 01 00    	movw   $0x1,0xa(%rax)
	    uint32_t cur_v = sems[sem].v;
  817f5f:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817f66:	00 00 00 
  817f69:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817f6c:	48 63 d2             	movslq %edx,%rdx
  817f6f:	48 c1 e2 05          	shl    $0x5,%rdx
  817f73:	48 01 d0             	add    %rdx,%rax
  817f76:	8b 40 08             	mov    0x8(%rax),%eax
  817f79:	89 45 ec             	mov    %eax,-0x14(%rbp)
	    lwip_core_unlock();
  817f7c:	48 b8 73 87 81 00 00 	movabs $0x818773,%rax
  817f83:	00 00 00 
  817f86:	ff d0                	callq  *%rax
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  817f88:	8b 45 dc             	mov    -0x24(%rbp),%eax
  817f8b:	48 98                	cltq   
  817f8d:	48 c1 e0 05          	shl    $0x5,%rax
  817f91:	48 89 c2             	mov    %rax,%rdx
  817f94:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817f9b:	00 00 00 
  817f9e:	48 01 d0             	add    %rdx,%rax
  817fa1:	48 8d 48 08          	lea    0x8(%rax),%rcx
  817fa5:	8b 55 f0             	mov    -0x10(%rbp),%edx
  817fa8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817fab:	89 c6                	mov    %eax,%esi
  817fad:	48 89 cf             	mov    %rcx,%rdi
  817fb0:	48 b8 e8 88 81 00 00 	movabs $0x8188e8,%rax
  817fb7:	00 00 00 
  817fba:	ff d0                	callq  *%rax
	    lwip_core_lock();
  817fbc:	48 b8 6d 87 81 00 00 	movabs $0x81876d,%rax
  817fc3:	00 00 00 
  817fc6:	ff d0                	callq  *%rax
	    if (gen != sems[sem].gen) {
  817fc8:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817fcf:	00 00 00 
  817fd2:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817fd5:	48 63 d2             	movslq %edx,%rdx
  817fd8:	48 c1 e2 05          	shl    $0x5,%rdx
  817fdc:	48 01 d0             	add    %rdx,%rax
  817fdf:	8b 40 04             	mov    0x4(%rax),%eax
  817fe2:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  817fe5:	74 22                	je     818009 <sys_arch_sem_wait+0x1ed>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  817fe7:	48 bf 98 29 82 00 00 	movabs $0x822998,%rdi
  817fee:	00 00 00 
  817ff1:	b8 00 00 00 00       	mov    $0x0,%eax
  817ff6:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  817ffd:	00 00 00 
  818000:	ff d2                	callq  *%rdx
		return SYS_ARCH_TIMEOUT;
  818002:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  818007:	eb 37                	jmp    818040 <sys_arch_sem_wait+0x224>
	    }
	    uint32_t b = sys_time_msec();
  818009:	48 b8 56 29 80 00 00 	movabs $0x802956,%rax
  818010:	00 00 00 
  818013:	ff d0                	callq  *%rax
  818015:	89 45 e8             	mov    %eax,-0x18(%rbp)
	    waited += (b - a);
  818018:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81801b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  81801e:	29 c2                	sub    %eax,%edx
  818020:	89 d0                	mov    %edx,%eax
  818022:	01 45 fc             	add    %eax,-0x4(%rbp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  818025:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  818029:	0f 84 76 fe ff ff    	je     817ea5 <sys_arch_sem_wait+0x89>
  81802f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818032:	3b 45 d8             	cmp    -0x28(%rbp),%eax
  818035:	0f 82 6a fe ff ff    	jb     817ea5 <sys_arch_sem_wait+0x89>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  81803b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  818040:	c9                   	leaveq 
  818041:	c3                   	retq   

0000000000818042 <sys_arch_mbox_fetch>:

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  818042:	55                   	push   %rbp
  818043:	48 89 e5             	mov    %rsp,%rbp
  818046:	48 83 ec 20          	sub    $0x20,%rsp
  81804a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81804d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  818051:	89 55 e8             	mov    %edx,-0x18(%rbp)
    assert(!mboxes[mbox].freed);
  818054:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81805b:	00 00 00 
  81805e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818061:	48 63 d0             	movslq %eax,%rdx
  818064:	48 89 d0             	mov    %rdx,%rax
  818067:	48 c1 e0 03          	shl    $0x3,%rax
  81806b:	48 01 d0             	add    %rdx,%rax
  81806e:	48 c1 e0 02          	shl    $0x2,%rax
  818072:	48 01 d0             	add    %rdx,%rax
  818075:	48 c1 e0 03          	shl    $0x3,%rax
  818079:	48 01 c8             	add    %rcx,%rax
  81807c:	8b 00                	mov    (%rax),%eax
  81807e:	85 c0                	test   %eax,%eax
  818080:	74 35                	je     8180b7 <sys_arch_mbox_fetch+0x75>
  818082:	48 b9 11 29 82 00 00 	movabs $0x822911,%rcx
  818089:	00 00 00 
  81808c:	48 ba 79 28 82 00 00 	movabs $0x822879,%rdx
  818093:	00 00 00 
  818096:	be ce 00 00 00       	mov    $0xce,%esi
  81809b:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  8180a2:	00 00 00 
  8180a5:	b8 00 00 00 00       	mov    $0x0,%eax
  8180aa:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  8180b1:	00 00 00 
  8180b4:	41 ff d0             	callq  *%r8

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  8180b7:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8180be:	00 00 00 
  8180c1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8180c4:	48 63 d0             	movslq %eax,%rdx
  8180c7:	48 89 d0             	mov    %rdx,%rax
  8180ca:	48 c1 e0 03          	shl    $0x3,%rax
  8180ce:	48 01 d0             	add    %rdx,%rax
  8180d1:	48 c1 e0 02          	shl    $0x2,%rax
  8180d5:	48 01 d0             	add    %rdx,%rax
  8180d8:	48 c1 e0 03          	shl    $0x3,%rax
  8180dc:	48 01 c8             	add    %rcx,%rax
  8180df:	48 05 10 01 00 00    	add    $0x110,%rax
  8180e5:	8b 00                	mov    (%rax),%eax
  8180e7:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8180ea:	89 d6                	mov    %edx,%esi
  8180ec:	89 c7                	mov    %eax,%edi
  8180ee:	48 b8 1c 7e 81 00 00 	movabs $0x817e1c,%rax
  8180f5:	00 00 00 
  8180f8:	ff d0                	callq  *%rax
  8180fa:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (waited == SYS_ARCH_TIMEOUT)
  8180fd:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  818101:	75 08                	jne    81810b <sys_arch_mbox_fetch+0xc9>
	return waited;
  818103:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818106:	e9 ad 01 00 00       	jmpq   8182b8 <sys_arch_mbox_fetch+0x276>

    int slot = mboxes[mbox].head;
  81810b:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  818112:	00 00 00 
  818115:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818118:	48 63 d0             	movslq %eax,%rdx
  81811b:	48 89 d0             	mov    %rdx,%rax
  81811e:	48 c1 e0 03          	shl    $0x3,%rax
  818122:	48 01 d0             	add    %rdx,%rax
  818125:	48 c1 e0 02          	shl    $0x2,%rax
  818129:	48 01 d0             	add    %rdx,%rax
  81812c:	48 c1 e0 03          	shl    $0x3,%rax
  818130:	48 01 c8             	add    %rcx,%rax
  818133:	8b 40 04             	mov    0x4(%rax),%eax
  818136:	89 45 f8             	mov    %eax,-0x8(%rbp)
    if (slot == -1)
  818139:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
  81813d:	75 2a                	jne    818169 <sys_arch_mbox_fetch+0x127>
	panic("lwip: sys_arch_mbox_fetch: no message");
  81813f:	48 ba c8 29 82 00 00 	movabs $0x8229c8,%rdx
  818146:	00 00 00 
  818149:	be d6 00 00 00       	mov    $0xd6,%esi
  81814e:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  818155:	00 00 00 
  818158:	b8 00 00 00 00       	mov    $0x0,%eax
  81815d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  818164:	00 00 00 
  818167:	ff d1                	callq  *%rcx
    if (msg)
  818169:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81816e:	74 39                	je     8181a9 <sys_arch_mbox_fetch+0x167>
	*msg = mboxes[mbox].msg[slot];
  818170:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  818177:	00 00 00 
  81817a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  81817d:	48 63 f0             	movslq %eax,%rsi
  818180:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818183:	48 63 d0             	movslq %eax,%rdx
  818186:	48 89 d0             	mov    %rdx,%rax
  818189:	48 c1 e0 03          	shl    $0x3,%rax
  81818d:	48 01 d0             	add    %rdx,%rax
  818190:	48 c1 e0 02          	shl    $0x2,%rax
  818194:	48 01 d0             	add    %rdx,%rax
  818197:	48 01 f0             	add    %rsi,%rax
  81819a:	48 83 c0 02          	add    $0x2,%rax
  81819e:	48 8b 14 c1          	mov    (%rcx,%rax,8),%rdx
  8181a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8181a6:	48 89 10             	mov    %rdx,(%rax)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  8181a9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8181ac:	8d 50 01             	lea    0x1(%rax),%edx
  8181af:	89 d0                	mov    %edx,%eax
  8181b1:	c1 f8 1f             	sar    $0x1f,%eax
  8181b4:	c1 e8 1b             	shr    $0x1b,%eax
  8181b7:	01 c2                	add    %eax,%edx
  8181b9:	83 e2 1f             	and    $0x1f,%edx
  8181bc:	29 c2                	sub    %eax,%edx
  8181be:	89 d0                	mov    %edx,%eax
  8181c0:	89 c1                	mov    %eax,%ecx
  8181c2:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  8181c9:	00 00 00 
  8181cc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8181cf:	48 63 d0             	movslq %eax,%rdx
  8181d2:	48 89 d0             	mov    %rdx,%rax
  8181d5:	48 c1 e0 03          	shl    $0x3,%rax
  8181d9:	48 01 d0             	add    %rdx,%rax
  8181dc:	48 c1 e0 02          	shl    $0x2,%rax
  8181e0:	48 01 d0             	add    %rdx,%rax
  8181e3:	48 c1 e0 03          	shl    $0x3,%rax
  8181e7:	48 01 f0             	add    %rsi,%rax
  8181ea:	89 48 04             	mov    %ecx,0x4(%rax)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  8181ed:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8181f4:	00 00 00 
  8181f7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8181fa:	48 63 d0             	movslq %eax,%rdx
  8181fd:	48 89 d0             	mov    %rdx,%rax
  818200:	48 c1 e0 03          	shl    $0x3,%rax
  818204:	48 01 d0             	add    %rdx,%rax
  818207:	48 c1 e0 02          	shl    $0x2,%rax
  81820b:	48 01 d0             	add    %rdx,%rax
  81820e:	48 c1 e0 03          	shl    $0x3,%rax
  818212:	48 01 c8             	add    %rcx,%rax
  818215:	8b 48 04             	mov    0x4(%rax),%ecx
  818218:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  81821f:	00 00 00 
  818222:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818225:	48 63 d0             	movslq %eax,%rdx
  818228:	48 89 d0             	mov    %rdx,%rax
  81822b:	48 c1 e0 03          	shl    $0x3,%rax
  81822f:	48 01 d0             	add    %rdx,%rax
  818232:	48 c1 e0 02          	shl    $0x2,%rax
  818236:	48 01 d0             	add    %rdx,%rax
  818239:	48 c1 e0 03          	shl    $0x3,%rax
  81823d:	48 01 f0             	add    %rsi,%rax
  818240:	8b 40 08             	mov    0x8(%rax),%eax
  818243:	39 c1                	cmp    %eax,%ecx
  818245:	75 2f                	jne    818276 <sys_arch_mbox_fetch+0x234>
	mboxes[mbox].head = -1;
  818247:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81824e:	00 00 00 
  818251:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818254:	48 63 d0             	movslq %eax,%rdx
  818257:	48 89 d0             	mov    %rdx,%rax
  81825a:	48 c1 e0 03          	shl    $0x3,%rax
  81825e:	48 01 d0             	add    %rdx,%rax
  818261:	48 c1 e0 02          	shl    $0x2,%rax
  818265:	48 01 d0             	add    %rdx,%rax
  818268:	48 c1 e0 03          	shl    $0x3,%rax
  81826c:	48 01 c8             	add    %rcx,%rax
  81826f:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)

    sys_sem_signal(mboxes[mbox].free_msg);
  818276:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81827d:	00 00 00 
  818280:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818283:	48 63 d0             	movslq %eax,%rdx
  818286:	48 89 d0             	mov    %rdx,%rax
  818289:	48 c1 e0 03          	shl    $0x3,%rax
  81828d:	48 01 d0             	add    %rdx,%rax
  818290:	48 c1 e0 02          	shl    $0x2,%rax
  818294:	48 01 d0             	add    %rdx,%rax
  818297:	48 c1 e0 03          	shl    $0x3,%rax
  81829b:	48 01 c8             	add    %rcx,%rax
  81829e:	48 05 10 01 00 00    	add    $0x110,%rax
  8182a4:	8b 40 04             	mov    0x4(%rax),%eax
  8182a7:	89 c7                	mov    %eax,%edi
  8182a9:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  8182b0:	00 00 00 
  8182b3:	ff d0                	callq  *%rax
    return waited;
  8182b5:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8182b8:	c9                   	leaveq 
  8182b9:	c3                   	retq   

00000000008182ba <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  8182ba:	55                   	push   %rbp
  8182bb:	48 89 e5             	mov    %rsp,%rbp
  8182be:	48 83 ec 10          	sub    $0x10,%rsp
  8182c2:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8182c5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  8182c9:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8182cd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8182d0:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  8182d5:	48 89 ce             	mov    %rcx,%rsi
  8182d8:	89 c7                	mov    %eax,%edi
  8182da:	48 b8 42 80 81 00 00 	movabs $0x818042,%rax
  8182e1:	00 00 00 
  8182e4:	ff d0                	callq  *%rax
}
  8182e6:	c9                   	leaveq 
  8182e7:	c3                   	retq   

00000000008182e8 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint64_t arg)
{
  8182e8:	55                   	push   %rbp
  8182e9:	48 89 e5             	mov    %rsp,%rbp
  8182ec:	48 83 ec 20          	sub    $0x20,%rsp
  8182f0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct lwip_thread *lt = (struct lwip_thread *)arg;
  8182f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8182f8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    lwip_core_lock();
  8182fc:	48 b8 6d 87 81 00 00 	movabs $0x81876d,%rax
  818303:	00 00 00 
  818306:	ff d0                	callq  *%rax
    lt->func(lt->arg);
  818308:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81830c:	48 8b 00             	mov    (%rax),%rax
  81830f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818313:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  818317:	48 89 d7             	mov    %rdx,%rdi
  81831a:	ff d0                	callq  *%rax
    lwip_core_unlock();
  81831c:	48 b8 73 87 81 00 00 	movabs $0x818773,%rax
  818323:	00 00 00 
  818326:	ff d0                	callq  *%rax
    free(lt);
  818328:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81832c:	48 89 c7             	mov    %rax,%rdi
  81832f:	48 b8 44 4e 80 00 00 	movabs $0x804e44,%rax
  818336:	00 00 00 
  818339:	ff d0                	callq  *%rax
}
  81833b:	c9                   	leaveq 
  81833c:	c3                   	retq   

000000000081833d <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  81833d:	55                   	push   %rbp
  81833e:	48 89 e5             	mov    %rsp,%rbp
  818341:	48 83 ec 30          	sub    $0x30,%rsp
  818345:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818349:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81834d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  818351:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  818354:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
    struct lwip_thread *lt = malloc(sizeof(*lt));
  818358:	bf 10 00 00 00       	mov    $0x10,%edi
  81835d:	48 b8 c6 4a 80 00 00 	movabs $0x804ac6,%rax
  818364:	00 00 00 
  818367:	ff d0                	callq  *%rax
  818369:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (lt == 0)
  81836d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818372:	75 2a                	jne    81839e <sys_thread_new+0x61>
	panic("sys_thread_new: cannot allocate thread struct");
  818374:	48 ba f0 29 82 00 00 	movabs $0x8229f0,%rdx
  81837b:	00 00 00 
  81837e:	be fd 00 00 00       	mov    $0xfd,%esi
  818383:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  81838a:	00 00 00 
  81838d:	b8 00 00 00 00       	mov    $0x0,%eax
  818392:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  818399:	00 00 00 
  81839c:	ff d1                	callq  *%rcx

    if (stacksize > PGSIZE)
  81839e:	81 7d d4 00 10 00 00 	cmpl   $0x1000,-0x2c(%rbp)
  8183a5:	7e 30                	jle    8183d7 <sys_thread_new+0x9a>
	panic("large stack %d", stacksize);
  8183a7:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8183aa:	89 c1                	mov    %eax,%ecx
  8183ac:	48 ba 1e 2a 82 00 00 	movabs $0x822a1e,%rdx
  8183b3:	00 00 00 
  8183b6:	be 00 01 00 00       	mov    $0x100,%esi
  8183bb:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  8183c2:	00 00 00 
  8183c5:	b8 00 00 00 00       	mov    $0x0,%eax
  8183ca:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  8183d1:	00 00 00 
  8183d4:	41 ff d0             	callq  *%r8

    lt->func = thread;
  8183d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8183db:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8183df:	48 89 10             	mov    %rdx,(%rax)
    lt->arg = arg;
  8183e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8183e6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8183ea:	48 89 50 08          	mov    %rdx,0x8(%rax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint64_t)lt);
  8183ee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8183f2:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8183f6:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8183fa:	48 89 d1             	mov    %rdx,%rcx
  8183fd:	48 ba e8 82 81 00 00 	movabs $0x8182e8,%rdx
  818404:	00 00 00 
  818407:	48 89 c7             	mov    %rax,%rdi
  81840a:	48 b8 5d 8b 81 00 00 	movabs $0x818b5d,%rax
  818411:	00 00 00 
  818414:	ff d0                	callq  *%rax
  818416:	89 45 f4             	mov    %eax,-0xc(%rbp)

    if (r < 0)
  818419:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  81841d:	79 3f                	jns    81845e <sys_thread_new+0x121>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  81841f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  818422:	89 c7                	mov    %eax,%edi
  818424:	48 b8 e5 91 81 00 00 	movabs $0x8191e5,%rax
  81842b:	00 00 00 
  81842e:	ff d0                	callq  *%rax
  818430:	48 89 c1             	mov    %rax,%rcx
  818433:	48 ba 30 2a 82 00 00 	movabs $0x822a30,%rdx
  81843a:	00 00 00 
  81843d:	be 09 01 00 00       	mov    $0x109,%esi
  818442:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  818449:	00 00 00 
  81844c:	b8 00 00 00 00       	mov    $0x0,%eax
  818451:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  818458:	00 00 00 
  81845b:	41 ff d0             	callq  *%r8

    return tid;
  81845e:	8b 45 f0             	mov    -0x10(%rbp),%eax
}
  818461:	c9                   	leaveq 
  818462:	c3                   	retq   

0000000000818463 <timeout_cleanup>:

static void
timeout_cleanup(thread_id_t tid)
{
  818463:	55                   	push   %rbp
  818464:	48 89 e5             	mov    %rsp,%rbp
  818467:	48 83 ec 20          	sub    $0x20,%rsp
  81846b:	89 7d ec             	mov    %edi,-0x14(%rbp)
    lwip_core_lock();
  81846e:	48 b8 6d 87 81 00 00 	movabs $0x81876d,%rax
  818475:	00 00 00 
  818478:	ff d0                	callq  *%rax

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  81847a:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  81847d:	89 ca                	mov    %ecx,%edx
  81847f:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818484:	48 0f af c2          	imul   %rdx,%rax
  818488:	48 c1 e8 20          	shr    $0x20,%rax
  81848c:	89 c2                	mov    %eax,%edx
  81848e:	c1 ea 08             	shr    $0x8,%edx
  818491:	89 d0                	mov    %edx,%eax
  818493:	c1 e0 08             	shl    $0x8,%eax
  818496:	01 d0                	add    %edx,%eax
  818498:	29 c1                	sub    %eax,%ecx
  81849a:	89 ca                	mov    %ecx,%edx
  81849c:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  8184a3:	00 00 00 
  8184a6:	89 d2                	mov    %edx,%edx
  8184a8:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8184ac:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8184b0:	eb 60                	jmp    818512 <timeout_cleanup+0xaf>
	if (t->tid == tid) {
  8184b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8184b6:	8b 00                	mov    (%rax),%eax
  8184b8:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8184bb:	75 49                	jne    818506 <timeout_cleanup+0xa3>
	    LIST_REMOVE(t, link);
  8184bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8184c1:	48 8b 40 10          	mov    0x10(%rax),%rax
  8184c5:	48 85 c0             	test   %rax,%rax
  8184c8:	74 14                	je     8184de <timeout_cleanup+0x7b>
  8184ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8184ce:	48 8b 40 10          	mov    0x10(%rax),%rax
  8184d2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8184d6:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  8184da:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8184de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8184e2:	48 8b 40 18          	mov    0x18(%rax),%rax
  8184e6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8184ea:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8184ee:	48 89 10             	mov    %rdx,(%rax)
	    free(t);
  8184f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8184f5:	48 89 c7             	mov    %rax,%rdi
  8184f8:	48 b8 44 4e 80 00 00 	movabs $0x804e44,%rax
  8184ff:	00 00 00 
  818502:	ff d0                	callq  *%rax
	    goto done;
  818504:	eb 13                	jmp    818519 <timeout_cleanup+0xb6>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818506:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81850a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81850e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818512:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818517:	75 99                	jne    8184b2 <timeout_cleanup+0x4f>
	    goto done;
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
  818519:	48 b8 73 87 81 00 00 	movabs $0x818773,%rax
  818520:	00 00 00 
  818523:	ff d0                	callq  *%rax
}
  818525:	c9                   	leaveq 
  818526:	c3                   	retq   

0000000000818527 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  818527:	55                   	push   %rbp
  818528:	48 89 e5             	mov    %rsp,%rbp
  81852b:	48 83 ec 10          	sub    $0x10,%rsp
    thread_id_t tid = thread_id();
  81852f:	48 b8 80 88 81 00 00 	movabs $0x818880,%rax
  818536:	00 00 00 
  818539:	ff d0                	callq  *%rax
  81853b:	89 45 f4             	mov    %eax,-0xc(%rbp)

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  81853e:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818541:	89 ca                	mov    %ecx,%edx
  818543:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818548:	48 0f af c2          	imul   %rdx,%rax
  81854c:	48 c1 e8 20          	shr    $0x20,%rax
  818550:	89 c2                	mov    %eax,%edx
  818552:	c1 ea 08             	shr    $0x8,%edx
  818555:	89 d0                	mov    %edx,%eax
  818557:	c1 e0 08             	shl    $0x8,%eax
  81855a:	01 d0                	add    %edx,%eax
  81855c:	29 c1                	sub    %eax,%ecx
  81855e:	89 ca                	mov    %ecx,%edx
  818560:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818567:	00 00 00 
  81856a:	89 d2                	mov    %edx,%edx
  81856c:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  818570:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818574:	eb 1c                	jmp    818592 <sys_arch_timeouts+0x6b>
	if (t->tid == tid)
  818576:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81857a:	8b 00                	mov    (%rax),%eax
  81857c:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  81857f:	75 05                	jne    818586 <sys_arch_timeouts+0x5f>
	    goto out;
  818581:	e9 dd 01 00 00       	jmpq   818763 <sys_arch_timeouts+0x23c>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818586:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81858a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81858e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818592:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818597:	75 dd                	jne    818576 <sys_arch_timeouts+0x4f>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  818599:	bf 20 00 00 00       	mov    $0x20,%edi
  81859e:	48 b8 c6 4a 80 00 00 	movabs $0x804ac6,%rax
  8185a5:	00 00 00 
  8185a8:	ff d0                	callq  *%rax
  8185aa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (t == 0)
  8185ae:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8185b3:	75 2a                	jne    8185df <sys_arch_timeouts+0xb8>
	panic("sys_arch_timeouts: cannot malloc");
  8185b5:	48 ba 60 2a 82 00 00 	movabs $0x822a60,%rdx
  8185bc:	00 00 00 
  8185bf:	be 2c 01 00 00       	mov    $0x12c,%esi
  8185c4:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  8185cb:	00 00 00 
  8185ce:	b8 00 00 00 00       	mov    $0x0,%eax
  8185d3:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8185da:	00 00 00 
  8185dd:	ff d1                	callq  *%rcx

    int r = thread_onhalt(timeout_cleanup);
  8185df:	48 bf 63 84 81 00 00 	movabs $0x818463,%rdi
  8185e6:	00 00 00 
  8185e9:	48 b8 16 8a 81 00 00 	movabs $0x818a16,%rax
  8185f0:	00 00 00 
  8185f3:	ff d0                	callq  *%rax
  8185f5:	89 45 f0             	mov    %eax,-0x10(%rbp)
    if (r < 0)
  8185f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8185fc:	79 3f                	jns    81863d <sys_arch_timeouts+0x116>
	panic("thread_onhalt failed: %s", e2s(r));
  8185fe:	8b 45 f0             	mov    -0x10(%rbp),%eax
  818601:	89 c7                	mov    %eax,%edi
  818603:	48 b8 e5 91 81 00 00 	movabs $0x8191e5,%rax
  81860a:	00 00 00 
  81860d:	ff d0                	callq  *%rax
  81860f:	48 89 c1             	mov    %rax,%rcx
  818612:	48 ba 81 2a 82 00 00 	movabs $0x822a81,%rdx
  818619:	00 00 00 
  81861c:	be 30 01 00 00       	mov    $0x130,%esi
  818621:	48 bf 8e 28 82 00 00 	movabs $0x82288e,%rdi
  818628:	00 00 00 
  81862b:	b8 00 00 00 00       	mov    $0x0,%eax
  818630:	49 b8 40 0f 80 00 00 	movabs $0x800f40,%r8
  818637:	00 00 00 
  81863a:	41 ff d0             	callq  *%r8

    t->tid = tid;
  81863d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818641:	8b 55 f4             	mov    -0xc(%rbp),%edx
  818644:	89 10                	mov    %edx,(%rax)
    memset(&t->tmo, 0, sizeof(t->tmo));
  818646:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81864a:	48 83 c0 08          	add    $0x8,%rax
  81864e:	ba 08 00 00 00       	mov    $0x8,%edx
  818653:	be 00 00 00 00       	mov    $0x0,%esi
  818658:	48 89 c7             	mov    %rax,%rdi
  81865b:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  818662:	00 00 00 
  818665:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  818667:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  81866a:	89 ca                	mov    %ecx,%edx
  81866c:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818671:	48 0f af c2          	imul   %rdx,%rax
  818675:	48 c1 e8 20          	shr    $0x20,%rax
  818679:	89 c2                	mov    %eax,%edx
  81867b:	c1 ea 08             	shr    $0x8,%edx
  81867e:	89 d0                	mov    %edx,%eax
  818680:	c1 e0 08             	shl    $0x8,%eax
  818683:	01 d0                	add    %edx,%eax
  818685:	29 c1                	sub    %eax,%ecx
  818687:	89 ca                	mov    %ecx,%edx
  818689:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818690:	00 00 00 
  818693:	89 d2                	mov    %edx,%edx
  818695:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  818699:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81869d:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8186a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8186a5:	48 8b 40 10          	mov    0x10(%rax),%rax
  8186a9:	48 85 c0             	test   %rax,%rax
  8186ac:	74 3e                	je     8186ec <sys_arch_timeouts+0x1c5>
  8186ae:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8186b1:	89 ca                	mov    %ecx,%edx
  8186b3:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  8186b8:	48 0f af c2          	imul   %rdx,%rax
  8186bc:	48 c1 e8 20          	shr    $0x20,%rax
  8186c0:	89 c2                	mov    %eax,%edx
  8186c2:	c1 ea 08             	shr    $0x8,%edx
  8186c5:	89 d0                	mov    %edx,%eax
  8186c7:	c1 e0 08             	shl    $0x8,%eax
  8186ca:	01 d0                	add    %edx,%eax
  8186cc:	29 c1                	sub    %eax,%ecx
  8186ce:	89 ca                	mov    %ecx,%edx
  8186d0:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  8186d7:	00 00 00 
  8186da:	89 d2                	mov    %edx,%edx
  8186dc:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8186e0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8186e4:	48 83 c2 10          	add    $0x10,%rdx
  8186e8:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8186ec:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8186ef:	89 ca                	mov    %ecx,%edx
  8186f1:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  8186f6:	48 0f af c2          	imul   %rdx,%rax
  8186fa:	48 c1 e8 20          	shr    $0x20,%rax
  8186fe:	89 c2                	mov    %eax,%edx
  818700:	c1 ea 08             	shr    $0x8,%edx
  818703:	89 d0                	mov    %edx,%eax
  818705:	c1 e0 08             	shl    $0x8,%eax
  818708:	01 d0                	add    %edx,%eax
  81870a:	29 c1                	sub    %eax,%ecx
  81870c:	89 ca                	mov    %ecx,%edx
  81870e:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818715:	00 00 00 
  818718:	89 d2                	mov    %edx,%edx
  81871a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81871e:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
  818722:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818725:	89 ca                	mov    %ecx,%edx
  818727:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  81872c:	48 0f af c2          	imul   %rdx,%rax
  818730:	48 c1 e8 20          	shr    $0x20,%rax
  818734:	89 c2                	mov    %eax,%edx
  818736:	c1 ea 08             	shr    $0x8,%edx
  818739:	89 d0                	mov    %edx,%eax
  81873b:	c1 e0 08             	shl    $0x8,%eax
  81873e:	01 d0                	add    %edx,%eax
  818740:	29 c1                	sub    %eax,%ecx
  818742:	89 ca                	mov    %ecx,%edx
  818744:	89 d0                	mov    %edx,%eax
  818746:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  81874d:	00 
  81874e:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818755:	00 00 00 
  818758:	48 01 c2             	add    %rax,%rdx
  81875b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81875f:	48 89 50 18          	mov    %rdx,0x18(%rax)

out:
    return &t->tmo;
  818763:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818767:	48 83 c0 08          	add    $0x8,%rax
}
  81876b:	c9                   	leaveq 
  81876c:	c3                   	retq   

000000000081876d <lwip_core_lock>:

void
lwip_core_lock(void)
{
  81876d:	55                   	push   %rbp
  81876e:	48 89 e5             	mov    %rsp,%rbp
}
  818771:	5d                   	pop    %rbp
  818772:	c3                   	retq   

0000000000818773 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  818773:	55                   	push   %rbp
  818774:	48 89 e5             	mov    %rsp,%rbp
}
  818777:	5d                   	pop    %rbp
  818778:	c3                   	retq   

0000000000818779 <threadq_init>:
    struct thread_context *tc_queue_link;
};

static inline void 
threadq_init(struct thread_queue *tq)
{
  818779:	55                   	push   %rbp
  81877a:	48 89 e5             	mov    %rsp,%rbp
  81877d:	48 83 ec 08          	sub    $0x8,%rsp
  818781:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    tq->tq_first = 0;
  818785:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818789:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    tq->tq_last = 0;
  818790:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818794:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81879b:	00 
}
  81879c:	c9                   	leaveq 
  81879d:	c3                   	retq   

000000000081879e <threadq_push>:

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
  81879e:	55                   	push   %rbp
  81879f:	48 89 e5             	mov    %rsp,%rbp
  8187a2:	48 83 ec 10          	sub    $0x10,%rsp
  8187a6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8187aa:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    tc->tc_queue_link = 0;
  8187ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8187b2:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8187b9:	00 00 00 00 
    if (!tq->tq_first) {
  8187bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187c1:	48 8b 00             	mov    (%rax),%rax
  8187c4:	48 85 c0             	test   %rax,%rax
  8187c7:	75 19                	jne    8187e2 <threadq_push+0x44>
	tq->tq_first = tc;
  8187c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187cd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8187d1:	48 89 10             	mov    %rdx,(%rax)
	tq->tq_last = tc;
  8187d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187d8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8187dc:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8187e0:	eb 1f                	jmp    818801 <threadq_push+0x63>
    } else {
	tq->tq_last->tc_queue_link = tc;
  8187e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187e6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8187ea:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8187ee:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)
	tq->tq_last = tc;
  8187f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187f9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8187fd:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
}
  818801:	c9                   	leaveq 
  818802:	c3                   	retq   

0000000000818803 <threadq_pop>:

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
  818803:	55                   	push   %rbp
  818804:	48 89 e5             	mov    %rsp,%rbp
  818807:	48 83 ec 18          	sub    $0x18,%rsp
  81880b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tq->tq_first)
  81880f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818813:	48 8b 00             	mov    (%rax),%rax
  818816:	48 85 c0             	test   %rax,%rax
  818819:	75 07                	jne    818822 <threadq_pop+0x1f>
	return 0;
  81881b:	b8 00 00 00 00       	mov    $0x0,%eax
  818820:	eb 30                	jmp    818852 <threadq_pop+0x4f>

    struct thread_context *tc = tq->tq_first;
  818822:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818826:	48 8b 00             	mov    (%rax),%rax
  818829:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    tq->tq_first = tc->tc_queue_link;
  81882d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818831:	48 8b 90 e8 00 00 00 	mov    0xe8(%rax),%rdx
  818838:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81883c:	48 89 10             	mov    %rdx,(%rax)
    tc->tc_queue_link = 0;
  81883f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818843:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  81884a:	00 00 00 00 
    return tc;
  81884e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  818852:	c9                   	leaveq 
  818853:	c3                   	retq   

0000000000818854 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  818854:	55                   	push   %rbp
  818855:	48 89 e5             	mov    %rsp,%rbp
    threadq_init(&thread_queue);
  818858:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  81885f:	00 00 00 
  818862:	48 b8 79 87 81 00 00 	movabs $0x818779,%rax
  818869:	00 00 00 
  81886c:	ff d0                	callq  *%rax
    max_tid = 0;
  81886e:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818875:	00 00 00 
  818878:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  81887e:	5d                   	pop    %rbp
  81887f:	c3                   	retq   

0000000000818880 <thread_id>:

uint32_t
thread_id(void) {
  818880:	55                   	push   %rbp
  818881:	48 89 e5             	mov    %rsp,%rbp
    return cur_tc->tc_tid;
  818884:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  81888b:	00 00 00 
  81888e:	48 8b 00             	mov    (%rax),%rax
  818891:	8b 00                	mov    (%rax),%eax
}
  818893:	5d                   	pop    %rbp
  818894:	c3                   	retq   

0000000000818895 <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  818895:	55                   	push   %rbp
  818896:	48 89 e5             	mov    %rsp,%rbp
  818899:	48 83 ec 18          	sub    $0x18,%rsp
  81889d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct thread_context *tc = thread_queue.tq_first;
  8188a1:	48 b8 80 74 b5 00 00 	movabs $0xb57480,%rax
  8188a8:	00 00 00 
  8188ab:	48 8b 00             	mov    (%rax),%rax
  8188ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (tc) {
  8188b2:	eb 2b                	jmp    8188df <thread_wakeup+0x4a>
	if (tc->tc_wait_addr == addr)
  8188b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8188b8:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  8188bf:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8188c3:	75 0b                	jne    8188d0 <thread_wakeup+0x3b>
	    tc->tc_wakeup = 1;
  8188c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8188c9:	c6 80 b8 00 00 00 01 	movb   $0x1,0xb8(%rax)
	tc = tc->tc_queue_link;
  8188d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8188d4:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8188db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  8188df:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8188e4:	75 ce                	jne    8188b4 <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  8188e6:	c9                   	leaveq 
  8188e7:	c3                   	retq   

00000000008188e8 <thread_wait>:

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  8188e8:	55                   	push   %rbp
  8188e9:	48 89 e5             	mov    %rsp,%rbp
  8188ec:	48 83 ec 20          	sub    $0x20,%rsp
  8188f0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8188f4:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8188f7:	89 55 e0             	mov    %edx,-0x20(%rbp)
    uint32_t s = sys_time_msec();
  8188fa:	48 b8 56 29 80 00 00 	movabs $0x802956,%rax
  818901:	00 00 00 
  818904:	ff d0                	callq  *%rax
  818906:	89 45 f8             	mov    %eax,-0x8(%rbp)
    uint32_t p = s;
  818909:	8b 45 f8             	mov    -0x8(%rbp),%eax
  81890c:	89 45 fc             	mov    %eax,-0x4(%rbp)

    cur_tc->tc_wait_addr = addr;
  81890f:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818916:	00 00 00 
  818919:	48 8b 00             	mov    (%rax),%rax
  81891c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  818920:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
    cur_tc->tc_wakeup = 0;
  818927:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  81892e:	00 00 00 
  818931:	48 8b 00             	mov    (%rax),%rax
  818934:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)

    while (p < msec) {
  81893b:	eb 53                	jmp    818990 <thread_wait+0xa8>
	if (p < s)
  81893d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818940:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  818943:	73 02                	jae    818947 <thread_wait+0x5f>
	    break;
  818945:	eb 51                	jmp    818998 <thread_wait+0xb0>
	if (addr && *addr != val)
  818947:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81894c:	74 0d                	je     81895b <thread_wait+0x73>
  81894e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818952:	8b 00                	mov    (%rax),%eax
  818954:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  818957:	74 02                	je     81895b <thread_wait+0x73>
	    break;
  818959:	eb 3d                	jmp    818998 <thread_wait+0xb0>
	if (cur_tc->tc_wakeup)
  81895b:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818962:	00 00 00 
  818965:	48 8b 00             	mov    (%rax),%rax
  818968:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  81896f:	84 c0                	test   %al,%al
  818971:	74 02                	je     818975 <thread_wait+0x8d>
	    break;
  818973:	eb 23                	jmp    818998 <thread_wait+0xb0>

	thread_yield();
  818975:	48 b8 dd 8d 81 00 00 	movabs $0x818ddd,%rax
  81897c:	00 00 00 
  81897f:	ff d0                	callq  *%rax
	p = sys_time_msec();
  818981:	48 b8 56 29 80 00 00 	movabs $0x802956,%rax
  818988:	00 00 00 
  81898b:	ff d0                	callq  *%rax
  81898d:	89 45 fc             	mov    %eax,-0x4(%rbp)
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  818990:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818993:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  818996:	72 a5                	jb     81893d <thread_wait+0x55>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  818998:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  81899f:	00 00 00 
  8189a2:	48 8b 00             	mov    (%rax),%rax
  8189a5:	48 c7 80 b0 00 00 00 	movq   $0x0,0xb0(%rax)
  8189ac:	00 00 00 00 
    cur_tc->tc_wakeup = 0;
  8189b0:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8189b7:	00 00 00 
  8189ba:	48 8b 00             	mov    (%rax),%rax
  8189bd:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)
}
  8189c4:	c9                   	leaveq 
  8189c5:	c3                   	retq   

00000000008189c6 <thread_wakeups_pending>:

int
thread_wakeups_pending(void)
{
  8189c6:	55                   	push   %rbp
  8189c7:	48 89 e5             	mov    %rsp,%rbp
  8189ca:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *tc = thread_queue.tq_first;
  8189ce:	48 b8 80 74 b5 00 00 	movabs $0xb57480,%rax
  8189d5:	00 00 00 
  8189d8:	48 8b 00             	mov    (%rax),%rax
  8189db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    int n = 0;
  8189df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    while (tc) {
  8189e6:	eb 22                	jmp    818a0a <thread_wakeups_pending+0x44>
	if (tc->tc_wakeup)
  8189e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189ec:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  8189f3:	84 c0                	test   %al,%al
  8189f5:	74 04                	je     8189fb <thread_wakeups_pending+0x35>
	    ++n;
  8189f7:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
	tc = tc->tc_queue_link;
  8189fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189ff:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818a06:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  818a0a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818a0f:	75 d7                	jne    8189e8 <thread_wakeups_pending+0x22>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
  818a11:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  818a14:	c9                   	leaveq 
  818a15:	c3                   	retq   

0000000000818a16 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  818a16:	55                   	push   %rbp
  818a17:	48 89 e5             	mov    %rsp,%rbp
  818a1a:	48 83 ec 08          	sub    $0x8,%rsp
  818a1e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  818a22:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818a29:	00 00 00 
  818a2c:	48 8b 00             	mov    (%rax),%rax
  818a2f:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  818a35:	83 f8 03             	cmp    $0x3,%eax
  818a38:	7e 07                	jle    818a41 <thread_onhalt+0x2b>
	return -E_NO_MEM;
  818a3a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818a3f:	eb 3d                	jmp    818a7e <thread_onhalt+0x68>

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  818a41:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818a48:	00 00 00 
  818a4b:	48 8b 08             	mov    (%rax),%rcx
  818a4e:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818a55:	00 00 00 
  818a58:	48 8b 00             	mov    (%rax),%rax
  818a5b:	8b 90 e0 00 00 00    	mov    0xe0(%rax),%edx
  818a61:	8d 72 01             	lea    0x1(%rdx),%esi
  818a64:	89 b0 e0 00 00 00    	mov    %esi,0xe0(%rax)
  818a6a:	48 63 c2             	movslq %edx,%rax
  818a6d:	48 8d 50 18          	lea    0x18(%rax),%rdx
  818a71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a75:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)
    return 0;
  818a79:	b8 00 00 00 00       	mov    $0x0,%eax
}
  818a7e:	c9                   	leaveq 
  818a7f:	c3                   	retq   

0000000000818a80 <alloc_tid>:

static thread_id_t
alloc_tid(void) {
  818a80:	55                   	push   %rbp
  818a81:	48 89 e5             	mov    %rsp,%rbp
  818a84:	48 83 ec 10          	sub    $0x10,%rsp
    int tid = max_tid++;
  818a88:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818a8f:	00 00 00 
  818a92:	8b 00                	mov    (%rax),%eax
  818a94:	8d 48 01             	lea    0x1(%rax),%ecx
  818a97:	48 ba 70 74 b5 00 00 	movabs $0xb57470,%rdx
  818a9e:	00 00 00 
  818aa1:	89 0a                	mov    %ecx,(%rdx)
  818aa3:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (max_tid == (uint32_t)~0)
  818aa6:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818aad:	00 00 00 
  818ab0:	8b 00                	mov    (%rax),%eax
  818ab2:	83 f8 ff             	cmp    $0xffffffff,%eax
  818ab5:	75 2a                	jne    818ae1 <alloc_tid+0x61>
	panic("alloc_tid: no more thread ids");
  818ab7:	48 ba 9a 2a 82 00 00 	movabs $0x822a9a,%rdx
  818abe:	00 00 00 
  818ac1:	be 54 00 00 00       	mov    $0x54,%esi
  818ac6:	48 bf b8 2a 82 00 00 	movabs $0x822ab8,%rdi
  818acd:	00 00 00 
  818ad0:	b8 00 00 00 00       	mov    $0x0,%eax
  818ad5:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  818adc:	00 00 00 
  818adf:	ff d1                	callq  *%rcx
    return tid;
  818ae1:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  818ae4:	c9                   	leaveq 
  818ae5:	c3                   	retq   

0000000000818ae6 <thread_set_name>:

static void
thread_set_name(struct thread_context *tc, const char *name)
{
  818ae6:	55                   	push   %rbp
  818ae7:	48 89 e5             	mov    %rsp,%rbp
  818aea:	48 83 ec 10          	sub    $0x10,%rsp
  818aee:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  818af2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    strncpy(tc->tc_name, name, name_size - 1);
  818af6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818afa:	48 8d 48 10          	lea    0x10(%rax),%rcx
  818afe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818b02:	ba 1f 00 00 00       	mov    $0x1f,%edx
  818b07:	48 89 c6             	mov    %rax,%rsi
  818b0a:	48 89 cf             	mov    %rcx,%rdi
  818b0d:	48 b8 c0 1d 80 00 00 	movabs $0x801dc0,%rax
  818b14:	00 00 00 
  818b17:	ff d0                	callq  *%rax
    tc->tc_name[name_size - 1] = 0;
  818b19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b1d:	c6 40 2f 00          	movb   $0x0,0x2f(%rax)
}
  818b21:	c9                   	leaveq 
  818b22:	c3                   	retq   

0000000000818b23 <thread_entry>:

static void
thread_entry(void) {
  818b23:	55                   	push   %rbp
  818b24:	48 89 e5             	mov    %rsp,%rbp
    cur_tc->tc_entry(cur_tc->tc_arg);
  818b27:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818b2e:	00 00 00 
  818b31:	48 8b 00             	mov    (%rax),%rax
  818b34:	48 8b 40 30          	mov    0x30(%rax),%rax
  818b38:	48 ba 78 74 b5 00 00 	movabs $0xb57478,%rdx
  818b3f:	00 00 00 
  818b42:	48 8b 12             	mov    (%rdx),%rdx
  818b45:	8b 52 38             	mov    0x38(%rdx),%edx
  818b48:	89 d2                	mov    %edx,%edx
  818b4a:	48 89 d7             	mov    %rdx,%rdi
  818b4d:	ff d0                	callq  *%rax
    thread_halt();
  818b4f:	48 b8 63 8d 81 00 00 	movabs $0x818d63,%rax
  818b56:	00 00 00 
  818b59:	ff d0                	callq  *%rax
}
  818b5b:	5d                   	pop    %rbp
  818b5c:	c3                   	retq   

0000000000818b5d <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint64_t), uint64_t arg) {
  818b5d:	55                   	push   %rbp
  818b5e:	48 89 e5             	mov    %rsp,%rbp
  818b61:	48 83 ec 30          	sub    $0x30,%rsp
  818b65:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818b69:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  818b6d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  818b71:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  818b75:	bf f0 00 00 00       	mov    $0xf0,%edi
  818b7a:	48 b8 c6 4a 80 00 00 	movabs $0x804ac6,%rax
  818b81:	00 00 00 
  818b84:	ff d0                	callq  *%rax
  818b86:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!tc)
  818b8a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818b8f:	75 0a                	jne    818b9b <thread_create+0x3e>
	return -E_NO_MEM;
  818b91:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818b96:	e9 4d 01 00 00       	jmpq   818ce8 <thread_create+0x18b>

    memset(tc, 0, sizeof(struct thread_context));
  818b9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b9f:	ba f0 00 00 00       	mov    $0xf0,%edx
  818ba4:	be 00 00 00 00       	mov    $0x0,%esi
  818ba9:	48 89 c7             	mov    %rax,%rdi
  818bac:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  818bb3:	00 00 00 
  818bb6:	ff d0                	callq  *%rax
    
    thread_set_name(tc, name);
  818bb8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  818bbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818bc0:	48 89 d6             	mov    %rdx,%rsi
  818bc3:	48 89 c7             	mov    %rax,%rdi
  818bc6:	48 b8 e6 8a 81 00 00 	movabs $0x818ae6,%rax
  818bcd:	00 00 00 
  818bd0:	ff d0                	callq  *%rax
    tc->tc_tid = alloc_tid();
  818bd2:	48 b8 80 8a 81 00 00 	movabs $0x818a80,%rax
  818bd9:	00 00 00 
  818bdc:	ff d0                	callq  *%rax
  818bde:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818be2:	89 02                	mov    %eax,(%rdx)

    tc->tc_stack_bottom = malloc(stack_size);
  818be4:	bf 00 10 00 00       	mov    $0x1000,%edi
  818be9:	48 b8 c6 4a 80 00 00 	movabs $0x804ac6,%rax
  818bf0:	00 00 00 
  818bf3:	ff d0                	callq  *%rax
  818bf5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818bf9:	48 89 42 08          	mov    %rax,0x8(%rdx)
    if (!tc->tc_stack_bottom) {
  818bfd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c01:	48 8b 40 08          	mov    0x8(%rax),%rax
  818c05:	48 85 c0             	test   %rax,%rax
  818c08:	75 1d                	jne    818c27 <thread_create+0xca>
	free(tc);
  818c0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c0e:	48 89 c7             	mov    %rax,%rdi
  818c11:	48 b8 44 4e 80 00 00 	movabs $0x804e44,%rax
  818c18:	00 00 00 
  818c1b:	ff d0                	callq  *%rax
	return -E_NO_MEM;
  818c1d:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818c22:	e9 c1 00 00 00       	jmpq   818ce8 <thread_create+0x18b>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
  818c27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c2b:	48 8b 40 08          	mov    0x8(%rax),%rax
  818c2f:	48 05 00 10 00 00    	add    $0x1000,%rax
  818c35:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    // Terminate stack unwinding
    stacktop = stacktop - 8;
  818c39:	48 83 6d f0 08       	subq   $0x8,-0x10(%rbp)
    memset(stacktop, 0, 8);
  818c3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818c42:	ba 08 00 00 00       	mov    $0x8,%edx
  818c47:	be 00 00 00 00       	mov    $0x0,%esi
  818c4c:	48 89 c7             	mov    %rax,%rdi
  818c4f:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  818c56:	00 00 00 
  818c59:	ff d0                	callq  *%rax
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  818c5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c5f:	48 83 c0 40          	add    $0x40,%rax
  818c63:	ba 70 00 00 00       	mov    $0x70,%edx
  818c68:	be 00 00 00 00       	mov    $0x0,%esi
  818c6d:	48 89 c7             	mov    %rax,%rdi
  818c70:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  818c77:	00 00 00 
  818c7a:	ff d0                	callq  *%rax
    tc->tc_jb.jb_rsp = (uint64_t)stacktop;
  818c7c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818c80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c84:	48 89 50 48          	mov    %rdx,0x48(%rax)
    tc->tc_jb.jb_rip = (uint64_t)&thread_entry;
  818c88:	48 ba 23 8b 81 00 00 	movabs $0x818b23,%rdx
  818c8f:	00 00 00 
  818c92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c96:	48 89 50 40          	mov    %rdx,0x40(%rax)
    tc->tc_entry = entry;
  818c9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c9e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  818ca2:	48 89 50 30          	mov    %rdx,0x30(%rax)
    tc->tc_arg = arg;
  818ca6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  818caa:	89 c2                	mov    %eax,%edx
  818cac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818cb0:	89 50 38             	mov    %edx,0x38(%rax)

    threadq_push(&thread_queue, tc);
  818cb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818cb7:	48 89 c6             	mov    %rax,%rsi
  818cba:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818cc1:	00 00 00 
  818cc4:	48 b8 9e 87 81 00 00 	movabs $0x81879e,%rax
  818ccb:	00 00 00 
  818cce:	ff d0                	callq  *%rax

    if (tid)
  818cd0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818cd5:	74 0c                	je     818ce3 <thread_create+0x186>
	*tid = tc->tc_tid;
  818cd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818cdb:	8b 10                	mov    (%rax),%edx
  818cdd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818ce1:	89 10                	mov    %edx,(%rax)
    return 0;
  818ce3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  818ce8:	c9                   	leaveq 
  818ce9:	c3                   	retq   

0000000000818cea <thread_clean>:

static void
thread_clean(struct thread_context *tc) {
  818cea:	55                   	push   %rbp
  818ceb:	48 89 e5             	mov    %rsp,%rbp
  818cee:	48 83 ec 20          	sub    $0x20,%rsp
  818cf2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tc) return;
  818cf6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818cfb:	75 02                	jne    818cff <thread_clean+0x15>
  818cfd:	eb 62                	jmp    818d61 <thread_clean+0x77>

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  818cff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  818d06:	eb 20                	jmp    818d28 <thread_clean+0x3e>
	tc->tc_onhalt[i](tc->tc_tid);
  818d08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818d0c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818d0f:	48 63 d2             	movslq %edx,%rdx
  818d12:	48 83 c2 18          	add    $0x18,%rdx
  818d16:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  818d1a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  818d1e:	8b 12                	mov    (%rdx),%edx
  818d20:	89 d7                	mov    %edx,%edi
  818d22:	ff d0                	callq  *%rax
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  818d24:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  818d28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818d2c:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  818d32:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  818d35:	7f d1                	jg     818d08 <thread_clean+0x1e>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  818d37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818d3b:	48 8b 40 08          	mov    0x8(%rax),%rax
  818d3f:	48 89 c7             	mov    %rax,%rdi
  818d42:	48 b8 44 4e 80 00 00 	movabs $0x804e44,%rax
  818d49:	00 00 00 
  818d4c:	ff d0                	callq  *%rax
    free(tc);
  818d4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818d52:	48 89 c7             	mov    %rax,%rdi
  818d55:	48 b8 44 4e 80 00 00 	movabs $0x804e44,%rax
  818d5c:	00 00 00 
  818d5f:	ff d0                	callq  *%rax
}
  818d61:	c9                   	leaveq 
  818d62:	c3                   	retq   

0000000000818d63 <thread_halt>:

void
thread_halt() {
  818d63:	55                   	push   %rbp
  818d64:	48 89 e5             	mov    %rsp,%rbp
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));
  818d67:	48 bf 90 74 b5 00 00 	movabs $0xb57490,%rdi
  818d6e:	00 00 00 
  818d71:	48 b8 03 88 81 00 00 	movabs $0x818803,%rax
  818d78:	00 00 00 
  818d7b:	ff d0                	callq  *%rax
  818d7d:	48 89 c7             	mov    %rax,%rdi
  818d80:	48 b8 ea 8c 81 00 00 	movabs $0x818cea,%rax
  818d87:	00 00 00 
  818d8a:	ff d0                	callq  *%rax

    threadq_push(&kill_queue, cur_tc);
  818d8c:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818d93:	00 00 00 
  818d96:	48 8b 00             	mov    (%rax),%rax
  818d99:	48 89 c6             	mov    %rax,%rsi
  818d9c:	48 bf 90 74 b5 00 00 	movabs $0xb57490,%rdi
  818da3:	00 00 00 
  818da6:	48 b8 9e 87 81 00 00 	movabs $0x81879e,%rax
  818dad:	00 00 00 
  818db0:	ff d0                	callq  *%rax
    cur_tc = NULL;
  818db2:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818db9:	00 00 00 
  818dbc:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    thread_yield();
  818dc3:	48 b8 dd 8d 81 00 00 	movabs $0x818ddd,%rax
  818dca:	00 00 00 
  818dcd:	ff d0                	callq  *%rax
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  818dcf:	48 b8 1d 0f 80 00 00 	movabs $0x800f1d,%rax
  818dd6:	00 00 00 
  818dd9:	ff d0                	callq  *%rax
}
  818ddb:	5d                   	pop    %rbp
  818ddc:	c3                   	retq   

0000000000818ddd <thread_yield>:

void
thread_yield(void) {
  818ddd:	55                   	push   %rbp
  818dde:	48 89 e5             	mov    %rsp,%rbp
  818de1:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *next_tc = threadq_pop(&thread_queue);
  818de5:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818dec:	00 00 00 
  818def:	48 b8 03 88 81 00 00 	movabs $0x818803,%rax
  818df6:	00 00 00 
  818df9:	ff d0                	callq  *%rax
  818dfb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (!next_tc)
  818dff:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818e04:	75 05                	jne    818e0b <thread_yield+0x2e>
	return;
  818e06:	e9 94 00 00 00       	jmpq   818e9f <thread_yield+0xc2>

    if (cur_tc) {
  818e0b:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818e12:	00 00 00 
  818e15:	48 8b 00             	mov    (%rax),%rax
  818e18:	48 85 c0             	test   %rax,%rax
  818e1b:	74 4c                	je     818e69 <thread_yield+0x8c>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  818e1d:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818e24:	00 00 00 
  818e27:	48 8b 00             	mov    (%rax),%rax
  818e2a:	48 83 c0 40          	add    $0x40,%rax
  818e2e:	48 89 c7             	mov    %rax,%rdi
  818e31:	48 b8 00 91 81 00 00 	movabs $0x819100,%rax
  818e38:	00 00 00 
  818e3b:	ff d0                	callq  *%rax
  818e3d:	85 c0                	test   %eax,%eax
  818e3f:	74 02                	je     818e43 <thread_yield+0x66>
	    return;
  818e41:	eb 5c                	jmp    818e9f <thread_yield+0xc2>
	threadq_push(&thread_queue, cur_tc);
  818e43:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818e4a:	00 00 00 
  818e4d:	48 8b 00             	mov    (%rax),%rax
  818e50:	48 89 c6             	mov    %rax,%rsi
  818e53:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818e5a:	00 00 00 
  818e5d:	48 b8 9e 87 81 00 00 	movabs $0x81879e,%rax
  818e64:	00 00 00 
  818e67:	ff d0                	callq  *%rax
    }

    cur_tc = next_tc;
  818e69:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818e70:	00 00 00 
  818e73:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818e77:	48 89 10             	mov    %rdx,(%rax)
    jos_longjmp(&cur_tc->tc_jb, 1);
  818e7a:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818e81:	00 00 00 
  818e84:	48 8b 00             	mov    (%rax),%rax
  818e87:	48 83 c0 40          	add    $0x40,%rax
  818e8b:	be 01 00 00 00       	mov    $0x1,%esi
  818e90:	48 89 c7             	mov    %rax,%rdi
  818e93:	48 b8 50 91 81 00 00 	movabs $0x819150,%rax
  818e9a:	00 00 00 
  818e9d:	ff d0                	callq  *%rax
}
  818e9f:	c9                   	leaveq 
  818ea0:	c3                   	retq   

0000000000818ea1 <print_jb>:

static void
print_jb(struct thread_context *tc) {
  818ea1:	55                   	push   %rbp
  818ea2:	48 89 e5             	mov    %rsp,%rbp
  818ea5:	48 83 ec 10          	sub    $0x10,%rsp
  818ea9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    cprintf("jump buffer for thread %s:\n", tc->tc_name);
  818ead:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818eb1:	48 83 c0 10          	add    $0x10,%rax
  818eb5:	48 89 c6             	mov    %rax,%rsi
  818eb8:	48 bf d3 2a 82 00 00 	movabs $0x822ad3,%rdi
  818ebf:	00 00 00 
  818ec2:	b8 00 00 00 00       	mov    $0x0,%eax
  818ec7:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  818ece:	00 00 00 
  818ed1:	ff d2                	callq  *%rdx
    cprintf("\trip: %x\n", tc->tc_jb.jb_rip);
  818ed3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ed7:	48 8b 40 40          	mov    0x40(%rax),%rax
  818edb:	48 89 c6             	mov    %rax,%rsi
  818ede:	48 bf ef 2a 82 00 00 	movabs $0x822aef,%rdi
  818ee5:	00 00 00 
  818ee8:	b8 00 00 00 00       	mov    $0x0,%eax
  818eed:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  818ef4:	00 00 00 
  818ef7:	ff d2                	callq  *%rdx
    cprintf("\trsp: %x\n", tc->tc_jb.jb_rsp);
  818ef9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818efd:	48 8b 40 48          	mov    0x48(%rax),%rax
  818f01:	48 89 c6             	mov    %rax,%rsi
  818f04:	48 bf f9 2a 82 00 00 	movabs $0x822af9,%rdi
  818f0b:	00 00 00 
  818f0e:	b8 00 00 00 00       	mov    $0x0,%eax
  818f13:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  818f1a:	00 00 00 
  818f1d:	ff d2                	callq  *%rdx
    cprintf("\trbp: %x\n", tc->tc_jb.jb_rbp);
  818f1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f23:	48 8b 40 50          	mov    0x50(%rax),%rax
  818f27:	48 89 c6             	mov    %rax,%rsi
  818f2a:	48 bf 03 2b 82 00 00 	movabs $0x822b03,%rdi
  818f31:	00 00 00 
  818f34:	b8 00 00 00 00       	mov    $0x0,%eax
  818f39:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  818f40:	00 00 00 
  818f43:	ff d2                	callq  *%rdx
    cprintf("\trbx: %x\n", tc->tc_jb.jb_rbx);
  818f45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f49:	48 8b 40 58          	mov    0x58(%rax),%rax
  818f4d:	48 89 c6             	mov    %rax,%rsi
  818f50:	48 bf 0d 2b 82 00 00 	movabs $0x822b0d,%rdi
  818f57:	00 00 00 
  818f5a:	b8 00 00 00 00       	mov    $0x0,%eax
  818f5f:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  818f66:	00 00 00 
  818f69:	ff d2                	callq  *%rdx
    cprintf("\trsi: %x\n", tc->tc_jb.jb_rsi);
  818f6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f6f:	48 8b 40 60          	mov    0x60(%rax),%rax
  818f73:	48 89 c6             	mov    %rax,%rsi
  818f76:	48 bf 17 2b 82 00 00 	movabs $0x822b17,%rdi
  818f7d:	00 00 00 
  818f80:	b8 00 00 00 00       	mov    $0x0,%eax
  818f85:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  818f8c:	00 00 00 
  818f8f:	ff d2                	callq  *%rdx
    cprintf("\trdi: %x\n", tc->tc_jb.jb_rdi);
  818f91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f95:	48 8b 40 68          	mov    0x68(%rax),%rax
  818f99:	48 89 c6             	mov    %rax,%rsi
  818f9c:	48 bf 21 2b 82 00 00 	movabs $0x822b21,%rdi
  818fa3:	00 00 00 
  818fa6:	b8 00 00 00 00       	mov    $0x0,%eax
  818fab:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  818fb2:	00 00 00 
  818fb5:	ff d2                	callq  *%rdx
    cprintf("\tr15: %x\n", tc->tc_jb.jb_r15);
  818fb7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fbb:	48 8b 40 70          	mov    0x70(%rax),%rax
  818fbf:	48 89 c6             	mov    %rax,%rsi
  818fc2:	48 bf 2b 2b 82 00 00 	movabs $0x822b2b,%rdi
  818fc9:	00 00 00 
  818fcc:	b8 00 00 00 00       	mov    $0x0,%eax
  818fd1:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  818fd8:	00 00 00 
  818fdb:	ff d2                	callq  *%rdx
    cprintf("\tr14: %x\n", tc->tc_jb.jb_r14);
  818fdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fe1:	48 8b 40 78          	mov    0x78(%rax),%rax
  818fe5:	48 89 c6             	mov    %rax,%rsi
  818fe8:	48 bf 35 2b 82 00 00 	movabs $0x822b35,%rdi
  818fef:	00 00 00 
  818ff2:	b8 00 00 00 00       	mov    $0x0,%eax
  818ff7:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  818ffe:	00 00 00 
  819001:	ff d2                	callq  *%rdx
    cprintf("\tr13: %x\n", tc->tc_jb.jb_r13);
  819003:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819007:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81900e:	48 89 c6             	mov    %rax,%rsi
  819011:	48 bf 3f 2b 82 00 00 	movabs $0x822b3f,%rdi
  819018:	00 00 00 
  81901b:	b8 00 00 00 00       	mov    $0x0,%eax
  819020:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  819027:	00 00 00 
  81902a:	ff d2                	callq  *%rdx
    cprintf("\tr12: %x\n", tc->tc_jb.jb_r12);
  81902c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819030:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  819037:	48 89 c6             	mov    %rax,%rsi
  81903a:	48 bf 49 2b 82 00 00 	movabs $0x822b49,%rdi
  819041:	00 00 00 
  819044:	b8 00 00 00 00       	mov    $0x0,%eax
  819049:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  819050:	00 00 00 
  819053:	ff d2                	callq  *%rdx
    cprintf("\tr11: %x\n", tc->tc_jb.jb_r11);
  819055:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819059:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  819060:	48 89 c6             	mov    %rax,%rsi
  819063:	48 bf 53 2b 82 00 00 	movabs $0x822b53,%rdi
  81906a:	00 00 00 
  81906d:	b8 00 00 00 00       	mov    $0x0,%eax
  819072:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  819079:	00 00 00 
  81907c:	ff d2                	callq  *%rdx
    cprintf("\tr10: %x\n", tc->tc_jb.jb_r10);
  81907e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819082:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  819089:	48 89 c6             	mov    %rax,%rsi
  81908c:	48 bf 5d 2b 82 00 00 	movabs $0x822b5d,%rdi
  819093:	00 00 00 
  819096:	b8 00 00 00 00       	mov    $0x0,%eax
  81909b:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  8190a2:	00 00 00 
  8190a5:	ff d2                	callq  *%rdx
    cprintf("\tr9: %x\n", tc->tc_jb.jb_r9);
  8190a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8190ab:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  8190b2:	48 89 c6             	mov    %rax,%rsi
  8190b5:	48 bf 67 2b 82 00 00 	movabs $0x822b67,%rdi
  8190bc:	00 00 00 
  8190bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8190c4:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  8190cb:	00 00 00 
  8190ce:	ff d2                	callq  *%rdx
    cprintf("\tr8: %x\n", tc->tc_jb.jb_r8);
  8190d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8190d4:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8190db:	48 89 c6             	mov    %rax,%rsi
  8190de:	48 bf 70 2b 82 00 00 	movabs $0x822b70,%rdi
  8190e5:	00 00 00 
  8190e8:	b8 00 00 00 00       	mov    $0x0,%eax
  8190ed:	48 ba 79 11 80 00 00 	movabs $0x801179,%rdx
  8190f4:	00 00 00 
  8190f7:	ff d2                	callq  *%rdx
}
  8190f9:	c9                   	leaveq 
  8190fa:	c3                   	retq   
  8190fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000819100 <jos_setjmp>:


ENTRY(jos_setjmp)
	//movq	4(%esp), %ecx	// jos_jmp_buf

	movq	%rdi, %rcx	// jos_jmp_buf
  819100:	48 89 f9             	mov    %rdi,%rcx
	movq	0(%rsp), %rdx	// %rip as pushed by call
  819103:	48 8b 14 24          	mov    (%rsp),%rdx
	movq	%rdx,  0(%rcx)
  819107:	48 89 11             	mov    %rdx,(%rcx)

	leaq	8(%rsp), %rdx	// where %esp will point when we return
  81910a:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	movq	%rdx,  8(%rcx)
  81910f:	48 89 51 08          	mov    %rdx,0x8(%rcx)

	movq	%rbp,  16(%rcx)
  819113:	48 89 69 10          	mov    %rbp,0x10(%rcx)
	movq	%rbx, 24(%rcx)
  819117:	48 89 59 18          	mov    %rbx,0x18(%rcx)
	movq	%rsi, 32(%rcx)
  81911b:	48 89 71 20          	mov    %rsi,0x20(%rcx)
	movq	%rdi, 40(%rcx)
  81911f:	48 89 79 28          	mov    %rdi,0x28(%rcx)
	movq	%r15, 48(%rcx)
  819123:	4c 89 79 30          	mov    %r15,0x30(%rcx)
	movq	%r14, 56(%rcx)
  819127:	4c 89 71 38          	mov    %r14,0x38(%rcx)
	movq	%r13, 64(%rcx)
  81912b:	4c 89 69 40          	mov    %r13,0x40(%rcx)
	movq	%r12, 72(%rcx)
  81912f:	4c 89 61 48          	mov    %r12,0x48(%rcx)
	movq	%r11, 80(%rcx)
  819133:	4c 89 59 50          	mov    %r11,0x50(%rcx)
	movq	%r10, 88(%rcx)
  819137:	4c 89 51 58          	mov    %r10,0x58(%rcx)
	movq	%r9, 96(%rcx)
  81913b:	4c 89 49 60          	mov    %r9,0x60(%rcx)
	movq	%r8, 104(%rcx)
  81913f:	4c 89 41 68          	mov    %r8,0x68(%rcx)

	movq	$0, %rax
  819143:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
	ret
  81914a:	c3                   	retq   
  81914b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000819150 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value
	movq     %rdi, %rax
  819150:	48 89 f8             	mov    %rdi,%rax
	movq	 %rsi, %rdx
  819153:	48 89 f2             	mov    %rsi,%rdx
	movq	 0(%rax), %rcx	// %rip
  819156:	48 8b 08             	mov    (%rax),%rcx
	movq	 8(%rax), %rsp
  819159:	48 8b 60 08          	mov    0x8(%rax),%rsp
	movq	 16(%rax), %rbp
  81915d:	48 8b 68 10          	mov    0x10(%rax),%rbp
	movq	24(%rax), %rbx
  819161:	48 8b 58 18          	mov    0x18(%rax),%rbx
	movq	32(%rax), %rsi
  819165:	48 8b 70 20          	mov    0x20(%rax),%rsi
	movq	40(%rax), %rdi
  819169:	48 8b 78 28          	mov    0x28(%rax),%rdi
	movq	48(%rax), %r15
  81916d:	4c 8b 78 30          	mov    0x30(%rax),%r15
	movq	56(%rax), %r14
  819171:	4c 8b 70 38          	mov    0x38(%rax),%r14
	movq	64(%rax), %r13
  819175:	4c 8b 68 40          	mov    0x40(%rax),%r13
	movq	72(%rax), %r12
  819179:	4c 8b 60 48          	mov    0x48(%rax),%r12
	movq	80(%rax), %r11
  81917d:	4c 8b 58 50          	mov    0x50(%rax),%r11
	movq	88(%rax), %r10
  819181:	4c 8b 50 58          	mov    0x58(%rax),%r10
	movq	96(%rax), %r9
  819185:	4c 8b 48 60          	mov    0x60(%rax),%r9
	movq	104(%rax), %r8
  819189:	4c 8b 40 68          	mov    0x68(%rax),%r8

	movq	%rdx, %rax
  81918d:	48 89 d0             	mov    %rdx,%rax
	jmp	*%rcx
  819190:	ff e1                	jmpq   *%rcx

0000000000819192 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  819192:	55                   	push   %rbp
  819193:	48 89 e5             	mov    %rsp,%rbp
  819196:	48 83 ec 20          	sub    $0x20,%rsp
  81919a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int err = errno;
  81919e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8191a5:	00 00 00 
  8191a8:	8b 00                	mov    (%rax),%eax
  8191aa:	89 45 fc             	mov    %eax,-0x4(%rbp)
	cprintf("%s: %s\n", s, e2s(err));
  8191ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8191b0:	89 c7                	mov    %eax,%edi
  8191b2:	48 b8 e5 91 81 00 00 	movabs $0x8191e5,%rax
  8191b9:	00 00 00 
  8191bc:	ff d0                	callq  *%rax
  8191be:	48 89 c2             	mov    %rax,%rdx
  8191c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8191c5:	48 89 c6             	mov    %rax,%rsi
  8191c8:	48 bf 5d 30 82 00 00 	movabs $0x82305d,%rdi
  8191cf:	00 00 00 
  8191d2:	b8 00 00 00 00       	mov    $0x0,%eax
  8191d7:	48 b9 79 11 80 00 00 	movabs $0x801179,%rcx
  8191de:	00 00 00 
  8191e1:	ff d1                	callq  *%rcx
}
  8191e3:	c9                   	leaveq 
  8191e4:	c3                   	retq   

00000000008191e5 <e2s>:

const char *
e2s(int err) {
  8191e5:	55                   	push   %rbp
  8191e6:	48 89 e5             	mov    %rsp,%rbp
  8191e9:	48 83 ec 04          	sub    $0x4,%rsp
  8191ed:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return sys_errlist[err];
  8191f0:	48 b8 00 82 82 00 00 	movabs $0x828200,%rax
  8191f7:	00 00 00 
  8191fa:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8191fd:	48 63 d2             	movslq %edx,%rdx
  819200:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
}
  819204:	c9                   	leaveq 
  819205:	c3                   	retq   

0000000000819206 <low_level_init>:
    envid_t envid;
};

static void
low_level_init(struct netif *netif)
{
  819206:	55                   	push   %rbp
  819207:	48 89 e5             	mov    %rsp,%rbp
  81920a:	48 83 ec 08          	sub    $0x8,%rsp
  81920e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    int r;

    netif->hwaddr_len = 6;
  819212:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819216:	c6 40 40 06          	movb   $0x6,0x40(%rax)
    netif->mtu = 1500;
  81921a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81921e:	66 c7 40 48 dc 05    	movw   $0x5dc,0x48(%rax)
    netif->flags = NETIF_FLAG_BROADCAST;
  819224:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819228:	c6 40 4a 02          	movb   $0x2,0x4a(%rax)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  81922c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819230:	c6 40 41 52          	movb   $0x52,0x41(%rax)
    netif->hwaddr[1] = 0x54;
  819234:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819238:	c6 40 42 54          	movb   $0x54,0x42(%rax)
    netif->hwaddr[2] = 0x00;
  81923c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819240:	c6 40 43 00          	movb   $0x0,0x43(%rax)
    netif->hwaddr[3] = 0x12;
  819244:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819248:	c6 40 44 12          	movb   $0x12,0x44(%rax)
    netif->hwaddr[4] = 0x34;
  81924c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819250:	c6 40 45 34          	movb   $0x34,0x45(%rax)
    netif->hwaddr[5] = 0x56;
  819254:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819258:	c6 40 46 56          	movb   $0x56,0x46(%rax)
}
  81925c:	c9                   	leaveq 
  81925d:	c3                   	retq   

000000000081925e <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  81925e:	55                   	push   %rbp
  81925f:	48 89 e5             	mov    %rsp,%rbp
  819262:	48 83 ec 40          	sub    $0x40,%rsp
  819266:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81926a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  81926e:	ba 07 00 00 00       	mov    $0x7,%edx
  819273:	be 00 00 00 10       	mov    $0x10000000,%esi
  819278:	bf 00 00 00 00       	mov    $0x0,%edi
  81927d:	48 b8 5d 26 80 00 00 	movabs $0x80265d,%rax
  819284:	00 00 00 
  819287:	ff d0                	callq  *%rax
  819289:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if (r < 0)
  81928c:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  819290:	79 2a                	jns    8192bc <low_level_output+0x5e>
	panic("jif: could not allocate page of memory");
  819292:	48 ba 68 30 82 00 00 	movabs $0x823068,%rdx
  819299:	00 00 00 
  81929c:	be 55 00 00 00       	mov    $0x55,%esi
  8192a1:	48 bf 8f 30 82 00 00 	movabs $0x82308f,%rdi
  8192a8:	00 00 00 
  8192ab:	b8 00 00 00 00       	mov    $0x0,%eax
  8192b0:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8192b7:	00 00 00 
  8192ba:	ff d1                	callq  *%rcx
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;
  8192bc:	48 c7 45 e0 00 00 00 	movq   $0x10000000,-0x20(%rbp)
  8192c3:	10 

    struct jif *jif;
    jif = netif->state;
  8192c4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8192c8:	48 8b 40 30          	mov    0x30(%rax),%rax
  8192cc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    char *txbuf = pkt->jp_data;
  8192d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8192d4:	48 83 c0 04          	add    $0x4,%rax
  8192d8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    int txsize = 0;
  8192dc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8192e3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8192e7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8192eb:	e9 a0 00 00 00       	jmpq   819390 <low_level_output+0x132>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  8192f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8192f4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8192f8:	0f b7 d0             	movzwl %ax,%edx
  8192fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8192fe:	01 d0                	add    %edx,%eax
  819300:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  819305:	7e 3e                	jle    819345 <low_level_output+0xe7>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  819307:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81930b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81930f:	0f b7 c0             	movzwl %ax,%eax
  819312:	8b 55 fc             	mov    -0x4(%rbp),%edx
  819315:	41 89 d0             	mov    %edx,%r8d
  819318:	89 c1                	mov    %eax,%ecx
  81931a:	48 ba a8 30 82 00 00 	movabs $0x8230a8,%rdx
  819321:	00 00 00 
  819324:	be 64 00 00 00       	mov    $0x64,%esi
  819329:	48 bf 8f 30 82 00 00 	movabs $0x82308f,%rdi
  819330:	00 00 00 
  819333:	b8 00 00 00 00       	mov    $0x0,%eax
  819338:	49 b9 40 0f 80 00 00 	movabs $0x800f40,%r9
  81933f:	00 00 00 
  819342:	41 ff d1             	callq  *%r9
	memcpy(&txbuf[txsize], q->payload, q->len);
  819345:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819349:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81934d:	0f b7 d0             	movzwl %ax,%edx
  819350:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819354:	48 8b 40 08          	mov    0x8(%rax),%rax
  819358:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  81935b:	48 63 f1             	movslq %ecx,%rsi
  81935e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  819362:	48 01 f1             	add    %rsi,%rcx
  819365:	48 89 c6             	mov    %rax,%rsi
  819368:	48 89 cf             	mov    %rcx,%rdi
  81936b:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  819372:	00 00 00 
  819375:	ff d0                	callq  *%rax
	txsize += q->len;
  819377:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81937b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81937f:	0f b7 c0             	movzwl %ax,%eax
  819382:	01 45 fc             	add    %eax,-0x4(%rbp)
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  819385:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819389:	48 8b 00             	mov    (%rax),%rax
  81938c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  819390:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819395:	0f 85 55 ff ff ff    	jne    8192f0 <low_level_output+0x92>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  81939b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81939f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8193a2:	89 10                	mov    %edx,(%rax)

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  8193a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8193a8:	8b 40 08             	mov    0x8(%rax),%eax
  8193ab:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8193af:	b9 07 00 00 00       	mov    $0x7,%ecx
  8193b4:	be 0b 00 00 00       	mov    $0xb,%esi
  8193b9:	89 c7                	mov    %eax,%edi
  8193bb:	48 b8 34 31 80 00 00 	movabs $0x803134,%rax
  8193c2:	00 00 00 
  8193c5:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void *)pkt);
  8193c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8193cb:	48 89 c6             	mov    %rax,%rsi
  8193ce:	bf 00 00 00 00       	mov    $0x0,%edi
  8193d3:	48 b8 08 27 80 00 00 	movabs $0x802708,%rax
  8193da:	00 00 00 
  8193dd:	ff d0                	callq  *%rax

    return ERR_OK;
  8193df:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8193e4:	c9                   	leaveq 
  8193e5:	c3                   	retq   

00000000008193e6 <low_level_input>:
 * packet from the interface into the pbuf.
 *
 */
static struct pbuf *
low_level_input(void *va)
{
  8193e6:	55                   	push   %rbp
  8193e7:	48 89 e5             	mov    %rsp,%rbp
  8193ea:	48 83 ec 50          	sub    $0x50,%rsp
  8193ee:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  8193f2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8193f6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    s16_t len = pkt->jp_len;
  8193fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8193fe:	8b 00                	mov    (%rax),%eax
  819400:	66 89 45 de          	mov    %ax,-0x22(%rbp)

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  819404:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
  819408:	0f b7 c0             	movzwl %ax,%eax
  81940b:	ba 03 00 00 00       	mov    $0x3,%edx
  819410:	89 c6                	mov    %eax,%esi
  819412:	bf 03 00 00 00       	mov    $0x3,%edi
  819417:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  81941e:	00 00 00 
  819421:	ff d0                	callq  *%rax
  819423:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == 0)
  819427:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81942c:	75 0a                	jne    819438 <low_level_input+0x52>
	return 0;
  81942e:	b8 00 00 00 00       	mov    $0x0,%eax
  819433:	e9 8a 00 00 00       	jmpq   8194c2 <low_level_input+0xdc>

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  819438:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81943c:	48 83 c0 04          	add    $0x4,%rax
  819440:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int copied = 0;
  819444:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  81944b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81944f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  819453:	eb 62                	jmp    8194b7 <low_level_input+0xd1>
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  819455:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819459:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81945d:	0f b7 c0             	movzwl %ax,%eax
  819460:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (bytes > (len - copied))
  819463:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  819467:	2b 45 fc             	sub    -0x4(%rbp),%eax
  81946a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  81946d:	7d 0a                	jge    819479 <low_level_input+0x93>
	    bytes = len - copied;
  81946f:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  819473:	2b 45 fc             	sub    -0x4(%rbp),%eax
  819476:	89 45 ec             	mov    %eax,-0x14(%rbp)
	memcpy(q->payload, rxbuf + copied, bytes);
  819479:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81947c:	48 63 d0             	movslq %eax,%rdx
  81947f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  819482:	48 63 c8             	movslq %eax,%rcx
  819485:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819489:	48 01 c1             	add    %rax,%rcx
  81948c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819490:	48 8b 40 08          	mov    0x8(%rax),%rax
  819494:	48 89 ce             	mov    %rcx,%rsi
  819497:	48 89 c7             	mov    %rax,%rdi
  81949a:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  8194a1:	00 00 00 
  8194a4:	ff d0                	callq  *%rax
	copied += bytes;
  8194a6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8194a9:	01 45 fc             	add    %eax,-0x4(%rbp)
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8194ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8194b0:	48 8b 00             	mov    (%rax),%rax
  8194b3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8194b7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8194bc:	75 97                	jne    819455 <low_level_input+0x6f>
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
	copied += bytes;
    }

    return p;
  8194be:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  8194c2:	c9                   	leaveq 
  8194c3:	c3                   	retq   

00000000008194c4 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  8194c4:	55                   	push   %rbp
  8194c5:	48 89 e5             	mov    %rsp,%rbp
  8194c8:	48 83 ec 20          	sub    $0x20,%rsp
  8194cc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8194d0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8194d4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  8194d8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8194dc:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8194e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8194e4:	48 89 ce             	mov    %rcx,%rsi
  8194e7:	48 89 c7             	mov    %rax,%rdi
  8194ea:	48 b8 24 67 81 00 00 	movabs $0x816724,%rax
  8194f1:	00 00 00 
  8194f4:	ff d0                	callq  *%rax
}
  8194f6:	c9                   	leaveq 
  8194f7:	c3                   	retq   

00000000008194f8 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  8194f8:	55                   	push   %rbp
  8194f9:	48 89 e5             	mov    %rsp,%rbp
  8194fc:	48 83 ec 30          	sub    $0x30,%rsp
  819500:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  819504:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  819508:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81950c:	48 8b 40 30          	mov    0x30(%rax),%rax
  819510:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);
  819514:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  819518:	48 89 c7             	mov    %rax,%rdi
  81951b:	48 b8 e6 93 81 00 00 	movabs $0x8193e6,%rax
  819522:	00 00 00 
  819525:	ff d0                	callq  *%rax
  819527:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  81952b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819530:	75 05                	jne    819537 <jif_input+0x3f>
  819532:	e9 ba 00 00 00       	jmpq   8195f1 <jif_input+0xf9>
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;
  819537:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81953b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81953f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    switch (htons(ethhdr->type)) {
  819543:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819547:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81954b:	0f b7 c0             	movzwl %ax,%eax
  81954e:	89 c7                	mov    %eax,%edi
  819550:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  819557:	00 00 00 
  81955a:	ff d0                	callq  *%rax
  81955c:	0f b7 c0             	movzwl %ax,%eax
  81955f:	3d 00 08 00 00       	cmp    $0x800,%eax
  819564:	74 09                	je     81956f <jif_input+0x77>
  819566:	3d 06 08 00 00       	cmp    $0x806,%eax
  81956b:	74 4e                	je     8195bb <jif_input+0xc3>
  81956d:	eb 6f                	jmp    8195de <jif_input+0xe6>
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  81956f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819573:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819577:	48 89 d6             	mov    %rdx,%rsi
  81957a:	48 89 c7             	mov    %rax,%rdi
  81957d:	48 b8 48 63 81 00 00 	movabs $0x816348,%rax
  819584:	00 00 00 
  819587:	ff d0                	callq  *%rax
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  819589:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81958d:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  819592:	48 89 c7             	mov    %rax,%rdi
  819595:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  81959c:	00 00 00 
  81959f:	ff d0                	callq  *%rax
	/* pass to network layer */
	netif->input(p, netif);
  8195a1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8195a5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8195a9:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8195ad:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8195b1:	48 89 ce             	mov    %rcx,%rsi
  8195b4:	48 89 d7             	mov    %rdx,%rdi
  8195b7:	ff d0                	callq  *%rax
	break;
  8195b9:	eb 36                	jmp    8195f1 <jif_input+0xf9>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  8195bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8195bf:	48 8b 08             	mov    (%rax),%rcx
  8195c2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8195c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8195ca:	48 89 ce             	mov    %rcx,%rsi
  8195cd:	48 89 c7             	mov    %rax,%rdi
  8195d0:	48 b8 de 63 81 00 00 	movabs $0x8163de,%rax
  8195d7:	00 00 00 
  8195da:	ff d0                	callq  *%rax
	break;
  8195dc:	eb 13                	jmp    8195f1 <jif_input+0xf9>

    default:
	pbuf_free(p);
  8195de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8195e2:	48 89 c7             	mov    %rax,%rdi
  8195e5:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8195ec:	00 00 00 
  8195ef:	ff d0                	callq  *%rax
    }
}
  8195f1:	c9                   	leaveq 
  8195f2:	c3                   	retq   

00000000008195f3 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  8195f3:	55                   	push   %rbp
  8195f4:	48 89 e5             	mov    %rsp,%rbp
  8195f7:	53                   	push   %rbx
  8195f8:	48 83 ec 38          	sub    $0x38,%rsp
  8195fc:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  819600:	bf 10 00 00 00       	mov    $0x10,%edi
  819605:	48 b8 65 c6 80 00 00 	movabs $0x80c665,%rax
  81960c:	00 00 00 
  81960f:	ff d0                	callq  *%rax
  819611:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    if (jif == NULL) {
  819615:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81961a:	75 0a                	jne    819626 <jif_init+0x33>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  81961c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  819621:	e9 ce 00 00 00       	jmpq   8196f4 <jif_init+0x101>
    }

    output_envid = (envid_t *)netif->state;
  819626:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81962a:	48 8b 40 30          	mov    0x30(%rax),%rax
  81962e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

    netif->state = jif;
  819632:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819636:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81963a:	48 89 50 30          	mov    %rdx,0x30(%rax)
    netif->output = jif_output;
  81963e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819642:	48 bb c4 94 81 00 00 	movabs $0x8194c4,%rbx
  819649:	00 00 00 
  81964c:	48 89 58 20          	mov    %rbx,0x20(%rax)
    netif->linkoutput = low_level_output;
  819650:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819654:	48 b9 5e 92 81 00 00 	movabs $0x81925e,%rcx
  81965b:	00 00 00 
  81965e:	48 89 48 28          	mov    %rcx,0x28(%rax)
    memcpy(&netif->name[0], "en", 2);
  819662:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819666:	48 83 c0 4b          	add    $0x4b,%rax
  81966a:	ba 02 00 00 00       	mov    $0x2,%edx
  81966f:	48 be d1 30 82 00 00 	movabs $0x8230d1,%rsi
  819676:	00 00 00 
  819679:	48 89 c7             	mov    %rax,%rdi
  81967c:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  819683:	00 00 00 
  819686:	ff d0                	callq  *%rax

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  819688:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81968c:	48 8d 50 41          	lea    0x41(%rax),%rdx
  819690:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819694:	48 89 10             	mov    %rdx,(%rax)
    jif->envid = *output_envid; 
  819697:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81969b:	8b 10                	mov    (%rax),%edx
  81969d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8196a1:	89 50 08             	mov    %edx,0x8(%rax)

    low_level_init(netif);
  8196a4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8196a8:	48 89 c7             	mov    %rax,%rdi
  8196ab:	48 b8 06 92 81 00 00 	movabs $0x819206,%rax
  8196b2:	00 00 00 
  8196b5:	ff d0                	callq  *%rax
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  8196b7:	48 bf d4 30 82 00 00 	movabs $0x8230d4,%rdi
  8196be:	00 00 00 
  8196c1:	48 b8 cf 28 81 00 00 	movabs $0x8128cf,%rax
  8196c8:	00 00 00 
  8196cb:	ff d0                	callq  *%rax
  8196cd:	89 45 dc             	mov    %eax,-0x24(%rbp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  8196d0:	48 8d 4d dc          	lea    -0x24(%rbp),%rcx
  8196d4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8196d8:	ba 00 00 00 00       	mov    $0x0,%edx
  8196dd:	48 89 ce             	mov    %rcx,%rsi
  8196e0:	48 89 c7             	mov    %rax,%rdi
  8196e3:	48 b8 b6 68 81 00 00 	movabs $0x8168b6,%rax
  8196ea:	00 00 00 
  8196ed:	ff d0                	callq  *%rax

    return ERR_OK;
  8196ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8196f4:	48 83 c4 38          	add    $0x38,%rsp
  8196f8:	5b                   	pop    %rbx
  8196f9:	5d                   	pop    %rbp
  8196fa:	c3                   	retq   

00000000008196fb <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  8196fb:	55                   	push   %rbp
  8196fc:	48 89 e5             	mov    %rsp,%rbp
  8196ff:	48 83 ec 40          	sub    $0x40,%rsp
  819703:	89 7d cc             	mov    %edi,-0x34(%rbp)
  819706:	89 f0                	mov    %esi,%eax
  819708:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  81970c:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  81970f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  819713:	8b 45 cc             	mov    -0x34(%rbp),%eax
  819716:	48 89 d6             	mov    %rdx,%rsi
  819719:	89 c7                	mov    %eax,%edi
  81971b:	48 b8 7d ad 81 00 00 	movabs $0x81ad7d,%rax
  819722:	00 00 00 
  819725:	ff d0                	callq  *%rax
  819727:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (conn != NULL ) {
  81972b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819730:	0f 84 62 01 00 00    	je     819898 <netconn_new_with_proto_and_callback+0x19d>
    msg.function = do_newconn;
  819736:	48 b8 34 ad 81 00 00 	movabs $0x81ad34,%rax
  81973d:	00 00 00 
  819740:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.msg.n.proto = proto;
  819744:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  819748:	88 45 e0             	mov    %al,-0x20(%rbp)
    msg.msg.conn = conn;
  81974b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81974f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    TCPIP_APIMSG(&msg);
  819753:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819757:	48 89 c7             	mov    %rax,%rdi
  81975a:	48 b8 a1 89 80 00 00 	movabs $0x8089a1,%rax
  819761:	00 00 00 
  819764:	ff d0                	callq  *%rax

    if (conn->err != ERR_OK) {
  819766:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81976a:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81976e:	84 c0                	test   %al,%al
  819770:	0f 84 22 01 00 00    	je     819898 <netconn_new_with_proto_and_callback+0x19d>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  819776:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81977a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81977e:	48 85 c0             	test   %rax,%rax
  819781:	74 2a                	je     8197ad <netconn_new_with_proto_and_callback+0xb2>
  819783:	48 ba e0 30 82 00 00 	movabs $0x8230e0,%rdx
  81978a:	00 00 00 
  81978d:	be 52 00 00 00       	mov    $0x52,%esi
  819792:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  819799:	00 00 00 
  81979c:	b8 00 00 00 00       	mov    $0x0,%eax
  8197a1:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8197a8:	00 00 00 
  8197ab:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  8197ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8197b1:	8b 40 14             	mov    0x14(%rax),%eax
  8197b4:	83 f8 ff             	cmp    $0xffffffff,%eax
  8197b7:	75 2a                	jne    8197e3 <netconn_new_with_proto_and_callback+0xe8>
  8197b9:	48 ba 18 31 82 00 00 	movabs $0x823118,%rdx
  8197c0:	00 00 00 
  8197c3:	be 53 00 00 00       	mov    $0x53,%esi
  8197c8:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  8197cf:	00 00 00 
  8197d2:	b8 00 00 00 00       	mov    $0x0,%eax
  8197d7:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8197de:	00 00 00 
  8197e1:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  8197e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8197e7:	8b 40 18             	mov    0x18(%rax),%eax
  8197ea:	83 f8 ff             	cmp    $0xffffffff,%eax
  8197ed:	75 2a                	jne    819819 <netconn_new_with_proto_and_callback+0x11e>
  8197ef:	48 ba 31 31 82 00 00 	movabs $0x823131,%rdx
  8197f6:	00 00 00 
  8197f9:	be 54 00 00 00       	mov    $0x54,%esi
  8197fe:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  819805:	00 00 00 
  819808:	b8 00 00 00 00       	mov    $0x0,%eax
  81980d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  819814:	00 00 00 
  819817:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  819819:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81981d:	8b 40 1c             	mov    0x1c(%rax),%eax
  819820:	83 f8 ff             	cmp    $0xffffffff,%eax
  819823:	74 2a                	je     81984f <netconn_new_with_proto_and_callback+0x154>
  819825:	48 ba 48 31 82 00 00 	movabs $0x823148,%rdx
  81982c:	00 00 00 
  81982f:	be 55 00 00 00       	mov    $0x55,%esi
  819834:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  81983b:	00 00 00 
  81983e:	b8 00 00 00 00       	mov    $0x0,%eax
  819843:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81984a:	00 00 00 
  81984d:	ff d1                	callq  *%rcx
      sys_sem_free(conn->op_completed);
  81984f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819853:	8b 40 14             	mov    0x14(%rax),%eax
  819856:	89 c7                	mov    %eax,%edi
  819858:	48 b8 99 7b 81 00 00 	movabs $0x817b99,%rax
  81985f:	00 00 00 
  819862:	ff d0                	callq  *%rax
      sys_mbox_free(conn->recvmbox);
  819864:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819868:	8b 40 18             	mov    0x18(%rax),%eax
  81986b:	89 c7                	mov    %eax,%edi
  81986d:	48 b8 84 75 81 00 00 	movabs $0x817584,%rax
  819874:	00 00 00 
  819877:	ff d0                	callq  *%rax
      memp_free(MEMP_NETCONN, conn);
  819879:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81987d:	48 89 c6             	mov    %rax,%rsi
  819880:	bf 07 00 00 00       	mov    $0x7,%edi
  819885:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81988c:	00 00 00 
  81988f:	ff d0                	callq  *%rax
      return NULL;
  819891:	b8 00 00 00 00       	mov    $0x0,%eax
  819896:	eb 04                	jmp    81989c <netconn_new_with_proto_and_callback+0x1a1>
    }
  }
  return conn;
  819898:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81989c:	c9                   	leaveq 
  81989d:	c3                   	retq   

000000000081989e <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  81989e:	55                   	push   %rbp
  81989f:	48 89 e5             	mov    %rsp,%rbp
  8198a2:	48 83 ec 40          	sub    $0x40,%rsp
  8198a6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  8198aa:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8198af:	75 07                	jne    8198b8 <netconn_delete+0x1a>
    return ERR_OK;
  8198b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8198b6:	eb 4d                	jmp    819905 <netconn_delete+0x67>
  }

  msg.function = do_delconn;
  8198b8:	48 b8 47 b3 81 00 00 	movabs $0x81b347,%rax
  8198bf:	00 00 00 
  8198c2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  8198c6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8198ca:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  8198ce:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8198d2:	48 89 c7             	mov    %rax,%rdi
  8198d5:	48 b8 a1 89 80 00 00 	movabs $0x8089a1,%rax
  8198dc:	00 00 00 
  8198df:	ff d0                	callq  *%rax

  conn->pcb.tcp = NULL;
  8198e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8198e5:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8198ec:	00 
  netconn_free(conn);
  8198ed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8198f1:	48 89 c7             	mov    %rax,%rdi
  8198f4:	48 b8 b1 ae 81 00 00 	movabs $0x81aeb1,%rax
  8198fb:	00 00 00 
  8198fe:	ff d0                	callq  *%rax

  return ERR_OK;
  819900:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819905:	c9                   	leaveq 
  819906:	c3                   	retq   

0000000000819907 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  819907:	55                   	push   %rbp
  819908:	48 89 e5             	mov    %rsp,%rbp
  81990b:	48 83 ec 10          	sub    $0x10,%rsp
  81990f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  819913:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819918:	75 2a                	jne    819944 <netconn_type+0x3d>
  81991a:	48 ba 69 31 82 00 00 	movabs $0x823169,%rdx
  819921:	00 00 00 
  819924:	be 84 00 00 00       	mov    $0x84,%esi
  819929:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  819930:	00 00 00 
  819933:	b8 00 00 00 00       	mov    $0x0,%eax
  819938:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81993f:	00 00 00 
  819942:	ff d1                	callq  *%rcx
  return conn->type;
  819944:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819948:	8b 00                	mov    (%rax),%eax
}
  81994a:	c9                   	leaveq 
  81994b:	c3                   	retq   

000000000081994c <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  81994c:	55                   	push   %rbp
  81994d:	48 89 e5             	mov    %rsp,%rbp
  819950:	48 83 ec 50          	sub    $0x50,%rsp
  819954:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819958:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81995c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  819960:	89 c8                	mov    %ecx,%eax
  819962:	88 45 b4             	mov    %al,-0x4c(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  819965:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81996a:	75 2a                	jne    819996 <netconn_getaddr+0x4a>
  81996c:	48 ba 84 31 82 00 00 	movabs $0x823184,%rdx
  819973:	00 00 00 
  819976:	be 98 00 00 00       	mov    $0x98,%esi
  81997b:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  819982:	00 00 00 
  819985:	b8 00 00 00 00       	mov    $0x0,%eax
  81998a:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  819991:	00 00 00 
  819994:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  819996:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  81999b:	75 2a                	jne    8199c7 <netconn_getaddr+0x7b>
  81999d:	48 ba a2 31 82 00 00 	movabs $0x8231a2,%rdx
  8199a4:	00 00 00 
  8199a7:	be 99 00 00 00       	mov    $0x99,%esi
  8199ac:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  8199b3:	00 00 00 
  8199b6:	b8 00 00 00 00       	mov    $0x0,%eax
  8199bb:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8199c2:	00 00 00 
  8199c5:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  8199c7:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8199cc:	75 2a                	jne    8199f8 <netconn_getaddr+0xac>
  8199ce:	48 ba c0 31 82 00 00 	movabs $0x8231c0,%rdx
  8199d5:	00 00 00 
  8199d8:	be 9a 00 00 00       	mov    $0x9a,%esi
  8199dd:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  8199e4:	00 00 00 
  8199e7:	b8 00 00 00 00       	mov    $0x0,%eax
  8199ec:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8199f3:	00 00 00 
  8199f6:	ff d1                	callq  *%rcx

  msg.function = do_getaddr;
  8199f8:	48 b8 ef be 81 00 00 	movabs $0x81beef,%rax
  8199ff:	00 00 00 
  819a02:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819a06:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819a0a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.ad.ipaddr = addr;
  819a0e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819a12:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.ad.port = port;
  819a16:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819a1a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  msg.msg.msg.ad.local = local;
  819a1e:	0f b6 45 b4          	movzbl -0x4c(%rbp),%eax
  819a22:	88 45 f0             	mov    %al,-0x10(%rbp)
  TCPIP_APIMSG(&msg);
  819a25:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819a29:	48 89 c7             	mov    %rax,%rdi
  819a2c:	48 b8 a1 89 80 00 00 	movabs $0x8089a1,%rax
  819a33:	00 00 00 
  819a36:	ff d0                	callq  *%rax

  return conn->err;
  819a38:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819a3c:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819a40:	c9                   	leaveq 
  819a41:	c3                   	retq   

0000000000819a42 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819a42:	55                   	push   %rbp
  819a43:	48 89 e5             	mov    %rsp,%rbp
  819a46:	48 83 ec 50          	sub    $0x50,%rsp
  819a4a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819a4e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819a52:	89 d0                	mov    %edx,%eax
  819a54:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  819a58:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819a5d:	75 2a                	jne    819a89 <netconn_bind+0x47>
  819a5f:	48 ba de 31 82 00 00 	movabs $0x8231de,%rdx
  819a66:	00 00 00 
  819a69:	be b5 00 00 00       	mov    $0xb5,%esi
  819a6e:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  819a75:	00 00 00 
  819a78:	b8 00 00 00 00       	mov    $0x0,%eax
  819a7d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  819a84:	00 00 00 
  819a87:	ff d1                	callq  *%rcx

  msg.function = do_bind;
  819a89:	48 b8 85 b4 81 00 00 	movabs $0x81b485,%rax
  819a90:	00 00 00 
  819a93:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819a97:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819a9b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  819a9f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819aa3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  819aa7:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  819aab:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  TCPIP_APIMSG(&msg);
  819aaf:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819ab3:	48 89 c7             	mov    %rax,%rdi
  819ab6:	48 b8 a1 89 80 00 00 	movabs $0x8089a1,%rax
  819abd:	00 00 00 
  819ac0:	ff d0                	callq  *%rax
  return conn->err;
  819ac2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819ac6:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819aca:	c9                   	leaveq 
  819acb:	c3                   	retq   

0000000000819acc <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819acc:	55                   	push   %rbp
  819acd:	48 89 e5             	mov    %rsp,%rbp
  819ad0:	48 83 ec 50          	sub    $0x50,%rsp
  819ad4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819ad8:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819adc:	89 d0                	mov    %edx,%eax
  819ade:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  819ae2:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819ae7:	75 2a                	jne    819b13 <netconn_connect+0x47>
  819ae9:	48 ba f9 31 82 00 00 	movabs $0x8231f9,%rdx
  819af0:	00 00 00 
  819af3:	be cc 00 00 00       	mov    $0xcc,%esi
  819af8:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  819aff:	00 00 00 
  819b02:	b8 00 00 00 00       	mov    $0x0,%eax
  819b07:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  819b0e:	00 00 00 
  819b11:	ff d1                	callq  *%rcx

  msg.function = do_connect;
  819b13:	48 b8 30 b6 81 00 00 	movabs $0x81b630,%rax
  819b1a:	00 00 00 
  819b1d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819b21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819b25:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  819b29:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819b2d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  819b31:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  819b35:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  819b39:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819b3d:	48 89 c7             	mov    %rax,%rdi
  819b40:	48 b8 a1 89 80 00 00 	movabs $0x8089a1,%rax
  819b47:	00 00 00 
  819b4a:	ff d0                	callq  *%rax
  return conn->err;
  819b4c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819b50:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819b54:	c9                   	leaveq 
  819b55:	c3                   	retq   

0000000000819b56 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  819b56:	55                   	push   %rbp
  819b57:	48 89 e5             	mov    %rsp,%rbp
  819b5a:	48 83 ec 40          	sub    $0x40,%rsp
  819b5e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  819b62:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819b67:	75 2a                	jne    819b93 <netconn_disconnect+0x3d>
  819b69:	48 ba 18 32 82 00 00 	movabs $0x823218,%rdx
  819b70:	00 00 00 
  819b73:	be e2 00 00 00       	mov    $0xe2,%esi
  819b78:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  819b7f:	00 00 00 
  819b82:	b8 00 00 00 00       	mov    $0x0,%eax
  819b87:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  819b8e:	00 00 00 
  819b91:	ff d1                	callq  *%rcx

  msg.function = do_disconnect;
  819b93:	48 b8 9d b7 81 00 00 	movabs $0x81b79d,%rax
  819b9a:	00 00 00 
  819b9d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819ba1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819ba5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  TCPIP_APIMSG(&msg);
  819ba9:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819bad:	48 89 c7             	mov    %rax,%rdi
  819bb0:	48 b8 a1 89 80 00 00 	movabs $0x8089a1,%rax
  819bb7:	00 00 00 
  819bba:	ff d0                	callq  *%rax
  return conn->err;
  819bbc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819bc0:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819bc4:	c9                   	leaveq 
  819bc5:	c3                   	retq   

0000000000819bc6 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  819bc6:	55                   	push   %rbp
  819bc7:	48 89 e5             	mov    %rsp,%rbp
  819bca:	48 83 ec 40          	sub    $0x40,%rsp
  819bce:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819bd2:	89 f0                	mov    %esi,%eax
  819bd4:	88 45 c4             	mov    %al,-0x3c(%rbp)
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  819bd7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819bdc:	75 2a                	jne    819c08 <netconn_listen_with_backlog+0x42>
  819bde:	48 ba 39 32 82 00 00 	movabs $0x823239,%rdx
  819be5:	00 00 00 
  819be8:	be fa 00 00 00       	mov    $0xfa,%esi
  819bed:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  819bf4:	00 00 00 
  819bf7:	b8 00 00 00 00       	mov    $0x0,%eax
  819bfc:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  819c03:	00 00 00 
  819c06:	ff d1                	callq  *%rcx

  msg.function = do_listen;
  819c08:	48 b8 f0 b7 81 00 00 	movabs $0x81b7f0,%rax
  819c0f:	00 00 00 
  819c12:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819c16:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819c1a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  819c1e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819c22:	48 89 c7             	mov    %rax,%rdi
  819c25:	48 b8 a1 89 80 00 00 	movabs $0x8089a1,%rax
  819c2c:	00 00 00 
  819c2f:	ff d0                	callq  *%rax
  return conn->err;
  819c31:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819c35:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819c39:	c9                   	leaveq 
  819c3a:	c3                   	retq   

0000000000819c3b <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  819c3b:	55                   	push   %rbp
  819c3c:	48 89 e5             	mov    %rsp,%rbp
  819c3f:	48 83 ec 20          	sub    $0x20,%rsp
  819c43:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  819c47:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  819c4c:	75 2a                	jne    819c78 <netconn_accept+0x3d>
  819c4e:	48 ba 56 32 82 00 00 	movabs $0x823256,%rdx
  819c55:	00 00 00 
  819c58:	be 10 01 00 00       	mov    $0x110,%esi
  819c5d:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  819c64:	00 00 00 
  819c67:	b8 00 00 00 00       	mov    $0x0,%eax
  819c6c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  819c73:	00 00 00 
  819c76:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  819c78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819c7c:	8b 40 1c             	mov    0x1c(%rax),%eax
  819c7f:	83 f8 ff             	cmp    $0xffffffff,%eax
  819c82:	75 2a                	jne    819cae <netconn_accept+0x73>
  819c84:	48 ba 78 32 82 00 00 	movabs $0x823278,%rdx
  819c8b:	00 00 00 
  819c8e:	be 11 01 00 00       	mov    $0x111,%esi
  819c93:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  819c9a:	00 00 00 
  819c9d:	b8 00 00 00 00       	mov    $0x0,%eax
  819ca2:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  819ca9:	00 00 00 
  819cac:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  819cae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819cb2:	8b 40 1c             	mov    0x1c(%rax),%eax
  819cb5:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  819cb9:	ba 00 00 00 00       	mov    $0x0,%edx
  819cbe:	48 89 ce             	mov    %rcx,%rsi
  819cc1:	89 c7                	mov    %eax,%edi
  819cc3:	48 b8 42 80 81 00 00 	movabs $0x818042,%rax
  819cca:	00 00 00 
  819ccd:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  819ccf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819cd3:	48 8b 40 38          	mov    0x38(%rax),%rax
  819cd7:	48 85 c0             	test   %rax,%rax
  819cda:	74 1b                	je     819cf7 <netconn_accept+0xbc>
  819cdc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819ce0:	48 8b 40 38          	mov    0x38(%rax),%rax
  819ce4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  819ce8:	ba 00 00 00 00       	mov    $0x0,%edx
  819ced:	be 01 00 00 00       	mov    $0x1,%esi
  819cf2:	48 89 cf             	mov    %rcx,%rdi
  819cf5:	ff d0                	callq  *%rax
      TCPIP_APIMSG(&msg);
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
  819cf7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  819cfb:	c9                   	leaveq 
  819cfc:	c3                   	retq   

0000000000819cfd <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  819cfd:	55                   	push   %rbp
  819cfe:	48 89 e5             	mov    %rsp,%rbp
  819d01:	48 83 ec 50          	sub    $0x50,%rsp
  819d05:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct api_msg msg;
  struct netbuf *buf = NULL;
  819d09:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  819d10:	00 
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  819d11:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  819d16:	75 2a                	jne    819d42 <netconn_recv+0x45>
  819d18:	48 ba 9b 32 82 00 00 	movabs $0x82329b,%rdx
  819d1f:	00 00 00 
  819d22:	be 3a 01 00 00       	mov    $0x13a,%esi
  819d27:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  819d2e:	00 00 00 
  819d31:	b8 00 00 00 00       	mov    $0x0,%eax
  819d36:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  819d3d:	00 00 00 
  819d40:	ff d1                	callq  *%rcx

  if (conn->recvmbox == SYS_MBOX_NULL) {
  819d42:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d46:	8b 40 18             	mov    0x18(%rax),%eax
  819d49:	83 f8 ff             	cmp    $0xffffffff,%eax
  819d4c:	75 12                	jne    819d60 <netconn_recv+0x63>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  819d4e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d52:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
    return NULL;
  819d56:	b8 00 00 00 00       	mov    $0x0,%eax
  819d5b:	e9 21 02 00 00       	jmpq   819f81 <netconn_recv+0x284>
  }

  if (ERR_IS_FATAL(conn->err)) {
  819d60:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d64:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  819d68:	3c fc                	cmp    $0xfc,%al
  819d6a:	7d 0a                	jge    819d76 <netconn_recv+0x79>
    return NULL;
  819d6c:	b8 00 00 00 00       	mov    $0x0,%eax
  819d71:	e9 0b 02 00 00       	jmpq   819f81 <netconn_recv+0x284>
  }

  if (conn->type == NETCONN_TCP) {
  819d76:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d7a:	8b 00                	mov    (%rax),%eax
  819d7c:	83 f8 10             	cmp    $0x10,%eax
  819d7f:	0f 85 80 01 00 00    	jne    819f05 <netconn_recv+0x208>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  819d85:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d89:	8b 40 04             	mov    0x4(%rax),%eax
  819d8c:	83 f8 02             	cmp    $0x2,%eax
  819d8f:	75 12                	jne    819da3 <netconn_recv+0xa6>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  819d91:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d95:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      return NULL;
  819d99:	b8 00 00 00 00       	mov    $0x0,%eax
  819d9e:	e9 de 01 00 00       	jmpq   819f81 <netconn_recv+0x284>
    }

    buf = memp_malloc(MEMP_NETBUF);
  819da3:	bf 06 00 00 00       	mov    $0x6,%edi
  819da8:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  819daf:	00 00 00 
  819db2:	ff d0                	callq  *%rax
  819db4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    if (buf == NULL) {
  819db8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819dbc:	48 85 c0             	test   %rax,%rax
  819dbf:	75 12                	jne    819dd3 <netconn_recv+0xd6>
      conn->err = ERR_MEM;
  819dc1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819dc5:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
      return NULL;
  819dc9:	b8 00 00 00 00       	mov    $0x0,%eax
  819dce:	e9 ae 01 00 00       	jmpq   819f81 <netconn_recv+0x284>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  819dd3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819dd7:	8b 40 18             	mov    0x18(%rax),%eax
  819dda:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  819dde:	ba 00 00 00 00       	mov    $0x0,%edx
  819de3:	48 89 ce             	mov    %rcx,%rsi
  819de6:	89 c7                	mov    %eax,%edi
  819de8:	48 b8 42 80 81 00 00 	movabs $0x818042,%rax
  819def:	00 00 00 
  819df2:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  819df4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819df8:	48 85 c0             	test   %rax,%rax
  819dfb:	74 24                	je     819e21 <netconn_recv+0x124>
      len = p->tot_len;
  819dfd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819e01:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819e05:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
      SYS_ARCH_DEC(conn->recv_avail, len);
  819e09:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819e0d:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  819e11:	66 2b 45 fe          	sub    -0x2(%rbp),%ax
  819e15:	89 c2                	mov    %eax,%edx
  819e17:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819e1b:	66 89 50 24          	mov    %dx,0x24(%rax)
  819e1f:	eb 06                	jmp    819e27 <netconn_recv+0x12a>
    } else {
      len = 0;
  819e21:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  819e27:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819e2b:	48 8b 40 38          	mov    0x38(%rax),%rax
  819e2f:	48 85 c0             	test   %rax,%rax
  819e32:	74 1a                	je     819e4e <netconn_recv+0x151>
  819e34:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819e38:	48 8b 40 38          	mov    0x38(%rax),%rax
  819e3c:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  819e40:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  819e44:	be 01 00 00 00       	mov    $0x1,%esi
  819e49:	48 89 cf             	mov    %rcx,%rdi
  819e4c:	ff d0                	callq  *%rax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  819e4e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819e52:	48 85 c0             	test   %rax,%rax
  819e55:	75 36                	jne    819e8d <netconn_recv+0x190>
      memp_free(MEMP_NETBUF, buf);
  819e57:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e5b:	48 89 c6             	mov    %rax,%rsi
  819e5e:	bf 06 00 00 00       	mov    $0x6,%edi
  819e63:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  819e6a:	00 00 00 
  819e6d:	ff d0                	callq  *%rax
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  819e6f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819e73:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  819e77:	84 c0                	test   %al,%al
  819e79:	75 08                	jne    819e83 <netconn_recv+0x186>
        conn->err = ERR_CLSD;
  819e7b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819e7f:	c6 40 10 f9          	movb   $0xf9,0x10(%rax)
      }
      return NULL;
  819e83:	b8 00 00 00 00       	mov    $0x0,%eax
  819e88:	e9 f4 00 00 00       	jmpq   819f81 <netconn_recv+0x284>
    }

    buf->p = p;
  819e8d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e91:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  819e95:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  819e98:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e9c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  819ea0:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->port = 0;
  819ea4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819ea8:	66 c7 40 18 00 00    	movw   $0x0,0x18(%rax)
    buf->addr = NULL;
  819eae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819eb2:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  819eb9:	00 

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  819eba:	48 b8 29 bb 81 00 00 	movabs $0x81bb29,%rax
  819ec1:	00 00 00 
  819ec4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.conn = conn;
  819ec8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819ecc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    if (buf != NULL) {
  819ed0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819ed4:	48 85 c0             	test   %rax,%rax
  819ed7:	74 11                	je     819eea <netconn_recv+0x1ed>
      msg.msg.msg.r.len = buf->p->tot_len;
  819ed9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819edd:	48 8b 00             	mov    (%rax),%rax
  819ee0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819ee4:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
  819ee8:	eb 06                	jmp    819ef0 <netconn_recv+0x1f3>
    } else {
      msg.msg.msg.r.len = 1;
  819eea:	66 c7 45 e0 01 00    	movw   $0x1,-0x20(%rbp)
    }
    TCPIP_APIMSG(&msg);
  819ef0:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819ef4:	48 89 c7             	mov    %rax,%rdi
  819ef7:	48 b8 a1 89 80 00 00 	movabs $0x8089a1,%rax
  819efe:	00 00 00 
  819f01:	ff d0                	callq  *%rax
  819f03:	eb 78                	jmp    819f7d <netconn_recv+0x280>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  819f05:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819f09:	8b 40 18             	mov    0x18(%rax),%eax
  819f0c:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  819f10:	ba 00 00 00 00       	mov    $0x0,%edx
  819f15:	48 89 ce             	mov    %rcx,%rsi
  819f18:	89 c7                	mov    %eax,%edi
  819f1a:	48 b8 42 80 81 00 00 	movabs $0x818042,%rax
  819f21:	00 00 00 
  819f24:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  819f26:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819f2a:	48 85 c0             	test   %rax,%rax
  819f2d:	74 4e                	je     819f7d <netconn_recv+0x280>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  819f2f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819f33:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  819f37:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819f3b:	48 8b 00             	mov    (%rax),%rax
  819f3e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819f42:	29 c2                	sub    %eax,%edx
  819f44:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819f48:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  819f4c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819f50:	48 8b 40 38          	mov    0x38(%rax),%rax
  819f54:	48 85 c0             	test   %rax,%rax
  819f57:	74 24                	je     819f7d <netconn_recv+0x280>
  819f59:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819f5d:	48 8b 40 38          	mov    0x38(%rax),%rax
  819f61:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  819f65:	48 8b 12             	mov    (%rdx),%rdx
  819f68:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  819f6c:	0f b7 d2             	movzwl %dx,%edx
  819f6f:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  819f73:	be 01 00 00 00       	mov    $0x1,%esi
  819f78:	48 89 cf             	mov    %rcx,%rdi
  819f7b:	ff d0                	callq  *%rax
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  819f7d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  819f81:	c9                   	leaveq 
  819f82:	c3                   	retq   

0000000000819f83 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  819f83:	55                   	push   %rbp
  819f84:	48 89 e5             	mov    %rsp,%rbp
  819f87:	48 83 ec 20          	sub    $0x20,%rsp
  819f8b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  819f8f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  819f93:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  819f97:	89 c8                	mov    %ecx,%eax
  819f99:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  if (buf != NULL) {
  819f9d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819fa2:	74 34                	je     819fd8 <netconn_sendto+0x55>
    buf->addr = addr;
  819fa4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819fa8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  819fac:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  819fb0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819fb4:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  819fb8:	66 89 50 18          	mov    %dx,0x18(%rax)
    return netconn_send(conn, buf);
  819fbc:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819fc0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819fc4:	48 89 d6             	mov    %rdx,%rsi
  819fc7:	48 89 c7             	mov    %rax,%rdi
  819fca:	48 b8 df 9f 81 00 00 	movabs $0x819fdf,%rax
  819fd1:	00 00 00 
  819fd4:	ff d0                	callq  *%rax
  819fd6:	eb 05                	jmp    819fdd <netconn_sendto+0x5a>
  }
  return ERR_VAL;
  819fd8:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  819fdd:	c9                   	leaveq 
  819fde:	c3                   	retq   

0000000000819fdf <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  819fdf:	55                   	push   %rbp
  819fe0:	48 89 e5             	mov    %rsp,%rbp
  819fe3:	48 83 ec 40          	sub    $0x40,%rsp
  819fe7:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819feb:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  819fef:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819ff4:	75 2a                	jne    81a020 <netconn_send+0x41>
  819ff6:	48 ba b6 32 82 00 00 	movabs $0x8232b6,%rdx
  819ffd:	00 00 00 
  81a000:	be b9 01 00 00       	mov    $0x1b9,%esi
  81a005:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  81a00c:	00 00 00 
  81a00f:	b8 00 00 00 00       	mov    $0x0,%eax
  81a014:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a01b:	00 00 00 
  81a01e:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  81a020:	48 b8 9a b9 81 00 00 	movabs $0x81b99a,%rax
  81a027:	00 00 00 
  81a02a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a02e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a032:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.b = buf;
  81a036:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a03a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  TCPIP_APIMSG(&msg);
  81a03e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a042:	48 89 c7             	mov    %rax,%rdi
  81a045:	48 b8 a1 89 80 00 00 	movabs $0x8089a1,%rax
  81a04c:	00 00 00 
  81a04f:	ff d0                	callq  *%rax
  return conn->err;
  81a051:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a055:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a059:	c9                   	leaveq 
  81a05a:	c3                   	retq   

000000000081a05b <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  81a05b:	55                   	push   %rbp
  81a05c:	48 89 e5             	mov    %rsp,%rbp
  81a05f:	48 83 ec 50          	sub    $0x50,%rsp
  81a063:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81a067:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81a06b:	89 55 bc             	mov    %edx,-0x44(%rbp)
  81a06e:	89 c8                	mov    %ecx,%eax
  81a070:	88 45 b8             	mov    %al,-0x48(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a073:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a078:	75 2a                	jne    81a0a4 <netconn_write+0x49>
  81a07a:	48 ba d1 32 82 00 00 	movabs $0x8232d1,%rdx
  81a081:	00 00 00 
  81a084:	be d3 01 00 00       	mov    $0x1d3,%esi
  81a089:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  81a090:	00 00 00 
  81a093:	b8 00 00 00 00       	mov    $0x0,%eax
  81a098:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a09f:	00 00 00 
  81a0a2:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  81a0a4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0a8:	8b 00                	mov    (%rax),%eax
  81a0aa:	83 f8 10             	cmp    $0x10,%eax
  81a0ad:	74 2a                	je     81a0d9 <netconn_write+0x7e>
  81a0af:	48 ba f0 32 82 00 00 	movabs $0x8232f0,%rdx
  81a0b6:	00 00 00 
  81a0b9:	be d4 01 00 00       	mov    $0x1d4,%esi
  81a0be:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  81a0c5:	00 00 00 
  81a0c8:	b8 00 00 00 00       	mov    $0x0,%eax
  81a0cd:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a0d4:	00 00 00 
  81a0d7:	ff d1                	callq  *%rcx

  msg.function = do_write;
  81a0d9:	48 b8 4e be 81 00 00 	movabs $0x81be4e,%rax
  81a0e0:	00 00 00 
  81a0e3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a0e7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0eb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.w.dataptr = dataptr;
  81a0ef:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a0f3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.w.apiflags = apiflags;
  81a0f7:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
  81a0fb:	88 45 ec             	mov    %al,-0x14(%rbp)
  msg.msg.msg.w.len = size;
  81a0fe:	8b 45 bc             	mov    -0x44(%rbp),%eax
  81a101:	89 45 e8             	mov    %eax,-0x18(%rbp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  81a104:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a108:	48 89 c7             	mov    %rax,%rdi
  81a10b:	48 b8 a1 89 80 00 00 	movabs $0x8089a1,%rax
  81a112:	00 00 00 
  81a115:	ff d0                	callq  *%rax
  return conn->err;
  81a117:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a11b:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a11f:	c9                   	leaveq 
  81a120:	c3                   	retq   

000000000081a121 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  81a121:	55                   	push   %rbp
  81a122:	48 89 e5             	mov    %rsp,%rbp
  81a125:	48 83 ec 40          	sub    $0x40,%rsp
  81a129:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a12d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a132:	75 2a                	jne    81a15e <netconn_close+0x3d>
  81a134:	48 ba 12 33 82 00 00 	movabs $0x823312,%rdx
  81a13b:	00 00 00 
  81a13e:	be ed 01 00 00       	mov    $0x1ed,%esi
  81a143:	48 bf 01 31 82 00 00 	movabs $0x823101,%rdi
  81a14a:	00 00 00 
  81a14d:	b8 00 00 00 00       	mov    $0x0,%eax
  81a152:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a159:	00 00 00 
  81a15c:	ff d1                	callq  *%rcx

  msg.function = do_close;
  81a15e:	48 b8 73 c0 81 00 00 	movabs $0x81c073,%rax
  81a165:	00 00 00 
  81a168:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a16c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a170:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  81a174:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a178:	48 89 c7             	mov    %rax,%rdi
  81a17b:	48 b8 a1 89 80 00 00 	movabs $0x8089a1,%rax
  81a182:	00 00 00 
  81a185:	ff d0                	callq  *%rax
  return conn->err;
  81a187:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a18b:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a18f:	c9                   	leaveq 
  81a190:	c3                   	retq   

000000000081a191 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  81a191:	55                   	push   %rbp
  81a192:	48 89 e5             	mov    %rsp,%rbp
  81a195:	48 83 ec 40          	sub    $0x40,%rsp
  81a199:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81a19d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81a1a1:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81a1a5:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  81a1a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a1ad:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  81a1b1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a1b6:	0f 84 74 01 00 00    	je     81a330 <recv_raw+0x19f>
  81a1bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a1c0:	8b 40 18             	mov    0x18(%rax),%eax
  81a1c3:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a1c6:	0f 84 64 01 00 00    	je     81a330 <recv_raw+0x19f>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  81a1cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a1d0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a1d4:	0f b7 c0             	movzwl %ax,%eax
  81a1d7:	ba 00 00 00 00       	mov    $0x0,%edx
  81a1dc:	89 c6                	mov    %eax,%esi
  81a1de:	bf 03 00 00 00       	mov    $0x3,%edi
  81a1e3:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  81a1ea:	00 00 00 
  81a1ed:	ff d0                	callq  *%rax
  81a1ef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if(q != NULL) {
  81a1f3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a1f8:	74 39                	je     81a233 <recv_raw+0xa2>
      if (pbuf_copy(q, p) != ERR_OK) {
  81a1fa:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81a1fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a202:	48 89 d6             	mov    %rdx,%rsi
  81a205:	48 89 c7             	mov    %rax,%rdi
  81a208:	48 b8 8e de 80 00 00 	movabs $0x80de8e,%rax
  81a20f:	00 00 00 
  81a212:	ff d0                	callq  *%rax
  81a214:	84 c0                	test   %al,%al
  81a216:	74 1b                	je     81a233 <recv_raw+0xa2>
        pbuf_free(q);
  81a218:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a21c:	48 89 c7             	mov    %rax,%rdi
  81a21f:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81a226:	00 00 00 
  81a229:	ff d0                	callq  *%rax
        q = NULL;
  81a22b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  81a232:	00 
      }
    }

    if(q != NULL) {
  81a233:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a238:	0f 84 f2 00 00 00    	je     81a330 <recv_raw+0x19f>
      buf = memp_malloc(MEMP_NETBUF);
  81a23e:	bf 06 00 00 00       	mov    $0x6,%edi
  81a243:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  81a24a:	00 00 00 
  81a24d:	ff d0                	callq  *%rax
  81a24f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      if (buf == NULL) {
  81a253:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a258:	75 1d                	jne    81a277 <recv_raw+0xe6>
        pbuf_free(q);
  81a25a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a25e:	48 89 c7             	mov    %rax,%rdi
  81a261:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81a268:	00 00 00 
  81a26b:	ff d0                	callq  *%rax
        return 0;
  81a26d:	b8 00 00 00 00       	mov    $0x0,%eax
  81a272:	e9 be 00 00 00       	jmpq   81a335 <recv_raw+0x1a4>
      }

      buf->p = q;
  81a277:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a27b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a27f:	48 89 10             	mov    %rdx,(%rax)
      buf->ptr = q;
  81a282:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a286:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a28a:	48 89 50 08          	mov    %rdx,0x8(%rax)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  81a28e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a292:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a296:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  81a29a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a29e:	48 89 50 10          	mov    %rdx,0x10(%rax)
      buf->port = pcb->protocol;
  81a2a2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81a2a6:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81a2aa:	0f b6 d0             	movzbl %al,%edx
  81a2ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a2b1:	66 89 50 18          	mov    %dx,0x18(%rax)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  81a2b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a2b9:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a2bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a2c1:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a2c5:	01 c2                	add    %eax,%edx
  81a2c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a2cb:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  81a2cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a2d3:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a2d7:	48 85 c0             	test   %rax,%rax
  81a2da:	74 21                	je     81a2fd <recv_raw+0x16c>
  81a2dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a2e0:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a2e4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a2e8:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a2ec:	0f b7 d2             	movzwl %dx,%edx
  81a2ef:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81a2f3:	be 00 00 00 00       	mov    $0x0,%esi
  81a2f8:	48 89 cf             	mov    %rcx,%rdi
  81a2fb:	ff d0                	callq  *%rax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a2fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a301:	8b 40 18             	mov    0x18(%rax),%eax
  81a304:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a308:	48 89 d6             	mov    %rdx,%rsi
  81a30b:	89 c7                	mov    %eax,%edi
  81a30d:	48 b8 35 78 81 00 00 	movabs $0x817835,%rax
  81a314:	00 00 00 
  81a317:	ff d0                	callq  *%rax
  81a319:	84 c0                	test   %al,%al
  81a31b:	74 13                	je     81a330 <recv_raw+0x19f>
        netbuf_delete(buf);
  81a31d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a321:	48 89 c7             	mov    %rax,%rdi
  81a324:	48 b8 84 8b 80 00 00 	movabs $0x808b84,%rax
  81a32b:	00 00 00 
  81a32e:	ff d0                	callq  *%rax
      }
    }
  }

  return 0; /* do not eat the packet */
  81a330:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a335:	c9                   	leaveq 
  81a336:	c3                   	retq   

000000000081a337 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  81a337:	55                   	push   %rbp
  81a338:	48 89 e5             	mov    %rsp,%rbp
  81a33b:	48 83 ec 40          	sub    $0x40,%rsp
  81a33f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a343:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a347:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a34b:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  81a34f:	44 89 c0             	mov    %r8d,%eax
  81a352:	66 89 45 cc          	mov    %ax,-0x34(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  81a356:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a35b:	75 2a                	jne    81a387 <recv_udp+0x50>
  81a35d:	48 ba 30 33 82 00 00 	movabs $0x823330,%rdx
  81a364:	00 00 00 
  81a367:	be 8e 00 00 00       	mov    $0x8e,%esi
  81a36c:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81a373:	00 00 00 
  81a376:	b8 00 00 00 00       	mov    $0x0,%eax
  81a37b:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a382:	00 00 00 
  81a385:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  81a387:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a38c:	75 2a                	jne    81a3b8 <recv_udp+0x81>
  81a38e:	48 ba 70 33 82 00 00 	movabs $0x823370,%rdx
  81a395:	00 00 00 
  81a398:	be 8f 00 00 00       	mov    $0x8f,%esi
  81a39d:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81a3a4:	00 00 00 
  81a3a7:	b8 00 00 00 00       	mov    $0x0,%eax
  81a3ac:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a3b3:	00 00 00 
  81a3b6:	ff d1                	callq  *%rcx
  conn = arg;
  81a3b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a3bc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  81a3c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a3c4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a3c8:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81a3cc:	74 2a                	je     81a3f8 <recv_udp+0xc1>
  81a3ce:	48 ba 8f 33 82 00 00 	movabs $0x82338f,%rdx
  81a3d5:	00 00 00 
  81a3d8:	be 91 00 00 00       	mov    $0x91,%esi
  81a3dd:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81a3e4:	00 00 00 
  81a3e7:	b8 00 00 00 00       	mov    $0x0,%eax
  81a3ec:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a3f3:	00 00 00 
  81a3f6:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81a3f8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a3fd:	74 0c                	je     81a40b <recv_udp+0xd4>
  81a3ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a403:	8b 40 18             	mov    0x18(%rax),%eax
  81a406:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a409:	75 18                	jne    81a423 <recv_udp+0xec>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  81a40b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a40f:	48 89 c7             	mov    %rax,%rdi
  81a412:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81a419:	00 00 00 
  81a41c:	ff d0                	callq  *%rax
    return;
  81a41e:	e9 df 00 00 00       	jmpq   81a502 <recv_udp+0x1cb>
  }

  buf = memp_malloc(MEMP_NETBUF);
  81a423:	bf 06 00 00 00       	mov    $0x6,%edi
  81a428:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  81a42f:	00 00 00 
  81a432:	ff d0                	callq  *%rax
  81a434:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (buf == NULL) {
  81a438:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a43d:	75 18                	jne    81a457 <recv_udp+0x120>
    pbuf_free(p);
  81a43f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a443:	48 89 c7             	mov    %rax,%rdi
  81a446:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81a44d:	00 00 00 
  81a450:	ff d0                	callq  *%rax
    return;
  81a452:	e9 ab 00 00 00       	jmpq   81a502 <recv_udp+0x1cb>
  } else {
    buf->p = p;
  81a457:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a45b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a45f:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  81a462:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a466:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a46a:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->addr = addr;
  81a46e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a472:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81a476:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  81a47a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a47e:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
  81a482:	66 89 50 18          	mov    %dx,0x18(%rax)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  81a486:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a48a:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a48e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a492:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a496:	01 c2                	add    %eax,%edx
  81a498:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a49c:	66 89 50 24          	mov    %dx,0x24(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  81a4a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a4a4:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a4a8:	48 85 c0             	test   %rax,%rax
  81a4ab:	74 21                	je     81a4ce <recv_udp+0x197>
  81a4ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a4b1:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a4b5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a4b9:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a4bd:	0f b7 d2             	movzwl %dx,%edx
  81a4c0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81a4c4:	be 00 00 00 00       	mov    $0x0,%esi
  81a4c9:	48 89 cf             	mov    %rcx,%rdi
  81a4cc:	ff d0                	callq  *%rax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a4ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a4d2:	8b 40 18             	mov    0x18(%rax),%eax
  81a4d5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a4d9:	48 89 d6             	mov    %rdx,%rsi
  81a4dc:	89 c7                	mov    %eax,%edi
  81a4de:	48 b8 35 78 81 00 00 	movabs $0x817835,%rax
  81a4e5:	00 00 00 
  81a4e8:	ff d0                	callq  *%rax
  81a4ea:	84 c0                	test   %al,%al
  81a4ec:	74 14                	je     81a502 <recv_udp+0x1cb>
    netbuf_delete(buf);
  81a4ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a4f2:	48 89 c7             	mov    %rax,%rdi
  81a4f5:	48 b8 84 8b 80 00 00 	movabs $0x808b84,%rax
  81a4fc:	00 00 00 
  81a4ff:	ff d0                	callq  *%rax
    return;
  81a501:	90                   	nop
  }
}
  81a502:	c9                   	leaveq 
  81a503:	c3                   	retq   

000000000081a504 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  81a504:	55                   	push   %rbp
  81a505:	48 89 e5             	mov    %rsp,%rbp
  81a508:	48 83 ec 30          	sub    $0x30,%rsp
  81a50c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a510:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a514:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a518:	89 c8                	mov    %ecx,%eax
  81a51a:	88 45 d4             	mov    %al,-0x2c(%rbp)
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  81a51d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a522:	75 2a                	jne    81a54e <recv_tcp+0x4a>
  81a524:	48 ba b0 33 82 00 00 	movabs $0x8233b0,%rdx
  81a52b:	00 00 00 
  81a52e:	be c1 00 00 00       	mov    $0xc1,%esi
  81a533:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81a53a:	00 00 00 
  81a53d:	b8 00 00 00 00       	mov    $0x0,%eax
  81a542:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a549:	00 00 00 
  81a54c:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  81a54e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a553:	75 2a                	jne    81a57f <recv_tcp+0x7b>
  81a555:	48 ba d8 33 82 00 00 	movabs $0x8233d8,%rdx
  81a55c:	00 00 00 
  81a55f:	be c2 00 00 00       	mov    $0xc2,%esi
  81a564:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81a56b:	00 00 00 
  81a56e:	b8 00 00 00 00       	mov    $0x0,%eax
  81a573:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a57a:	00 00 00 
  81a57d:	ff d1                	callq  *%rcx
  conn = arg;
  81a57f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a583:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  81a587:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a58b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a58f:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81a593:	74 2a                	je     81a5bf <recv_tcp+0xbb>
  81a595:	48 ba f7 33 82 00 00 	movabs $0x8233f7,%rdx
  81a59c:	00 00 00 
  81a59f:	be c4 00 00 00       	mov    $0xc4,%esi
  81a5a4:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81a5ab:	00 00 00 
  81a5ae:	b8 00 00 00 00       	mov    $0x0,%eax
  81a5b3:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a5ba:	00 00 00 
  81a5bd:	ff d1                	callq  *%rcx

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81a5bf:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a5c4:	74 0c                	je     81a5d2 <recv_tcp+0xce>
  81a5c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a5ca:	8b 40 18             	mov    0x18(%rax),%eax
  81a5cd:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a5d0:	75 0a                	jne    81a5dc <recv_tcp+0xd8>
    return ERR_VAL;
  81a5d2:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81a5d7:	e9 8f 00 00 00       	jmpq   81a66b <recv_tcp+0x167>
  }

  conn->err = err;
  81a5dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a5e0:	0f b6 55 d4          	movzbl -0x2c(%rbp),%edx
  81a5e4:	88 50 10             	mov    %dl,0x10(%rax)
  if (p != NULL) {
  81a5e7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81a5ec:	74 24                	je     81a612 <recv_tcp+0x10e>
    len = p->tot_len;
  81a5ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a5f2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a5f6:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    SYS_ARCH_INC(conn->recv_avail, len);
  81a5fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a5fe:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a602:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81a606:	01 c2                	add    %eax,%edx
  81a608:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a60c:	66 89 50 24          	mov    %dx,0x24(%rax)
  81a610:	eb 06                	jmp    81a618 <recv_tcp+0x114>
  } else {
    len = 0;
  81a612:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  81a618:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a61c:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a620:	48 85 c0             	test   %rax,%rax
  81a623:	74 1a                	je     81a63f <recv_tcp+0x13b>
  81a625:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a629:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a62d:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81a631:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81a635:	be 00 00 00 00       	mov    $0x0,%esi
  81a63a:	48 89 cf             	mov    %rcx,%rdi
  81a63d:	ff d0                	callq  *%rax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  81a63f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a643:	8b 40 18             	mov    0x18(%rax),%eax
  81a646:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a64a:	48 89 d6             	mov    %rdx,%rsi
  81a64d:	89 c7                	mov    %eax,%edi
  81a64f:	48 b8 35 78 81 00 00 	movabs $0x817835,%rax
  81a656:	00 00 00 
  81a659:	ff d0                	callq  *%rax
  81a65b:	84 c0                	test   %al,%al
  81a65d:	74 07                	je     81a666 <recv_tcp+0x162>
    return ERR_MEM;
  81a65f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81a664:	eb 05                	jmp    81a66b <recv_tcp+0x167>
  }

  return ERR_OK;
  81a666:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a66b:	c9                   	leaveq 
  81a66c:	c3                   	retq   

000000000081a66d <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  81a66d:	55                   	push   %rbp
  81a66e:	48 89 e5             	mov    %rsp,%rbp
  81a671:	48 83 ec 20          	sub    $0x20,%rsp
  81a675:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a679:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn = arg;
  81a67d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a681:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81a685:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a68a:	75 2a                	jne    81a6b6 <poll_tcp+0x49>
  81a68c:	48 ba 15 34 82 00 00 	movabs $0x823415,%rdx
  81a693:	00 00 00 
  81a696:	be eb 00 00 00       	mov    $0xeb,%esi
  81a69b:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81a6a2:	00 00 00 
  81a6a5:	b8 00 00 00 00       	mov    $0x0,%eax
  81a6aa:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a6b1:	00 00 00 
  81a6b4:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81a6b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6ba:	8b 40 04             	mov    0x4(%rax),%eax
  81a6bd:	83 f8 01             	cmp    $0x1,%eax
  81a6c0:	75 15                	jne    81a6d7 <poll_tcp+0x6a>
    do_writemore(conn);
  81a6c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6c6:	48 89 c7             	mov    %rax,%rdi
  81a6c9:	48 b8 a3 bb 81 00 00 	movabs $0x81bba3,%rax
  81a6d0:	00 00 00 
  81a6d3:	ff d0                	callq  *%rax
  81a6d5:	eb 1f                	jmp    81a6f6 <poll_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
  81a6d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6db:	8b 40 04             	mov    0x4(%rax),%eax
  81a6de:	83 f8 04             	cmp    $0x4,%eax
  81a6e1:	75 13                	jne    81a6f6 <poll_tcp+0x89>
    do_close_internal(conn);
  81a6e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6e7:	48 89 c7             	mov    %rax,%rdi
  81a6ea:	48 b8 1b b0 81 00 00 	movabs $0x81b01b,%rax
  81a6f1:	00 00 00 
  81a6f4:	ff d0                	callq  *%rax
  }

  return ERR_OK;
  81a6f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a6fb:	c9                   	leaveq 
  81a6fc:	c3                   	retq   

000000000081a6fd <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  81a6fd:	55                   	push   %rbp
  81a6fe:	48 89 e5             	mov    %rsp,%rbp
  81a701:	48 83 ec 30          	sub    $0x30,%rsp
  81a705:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a709:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a70d:	89 d0                	mov    %edx,%eax
  81a70f:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct netconn *conn = arg;
  81a713:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a717:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81a71b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a720:	75 2a                	jne    81a74c <sent_tcp+0x4f>
  81a722:	48 ba 15 34 82 00 00 	movabs $0x823415,%rdx
  81a729:	00 00 00 
  81a72c:	be 03 01 00 00       	mov    $0x103,%esi
  81a731:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81a738:	00 00 00 
  81a73b:	b8 00 00 00 00       	mov    $0x0,%eax
  81a740:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a747:	00 00 00 
  81a74a:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81a74c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a750:	8b 40 04             	mov    0x4(%rax),%eax
  81a753:	83 f8 01             	cmp    $0x1,%eax
  81a756:	75 4c                	jne    81a7a4 <sent_tcp+0xa7>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  81a758:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a75c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a760:	48 85 c0             	test   %rax,%rax
  81a763:	75 2a                	jne    81a78f <sent_tcp+0x92>
  81a765:	48 ba 22 34 82 00 00 	movabs $0x823422,%rdx
  81a76c:	00 00 00 
  81a76f:	be 06 01 00 00       	mov    $0x106,%esi
  81a774:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81a77b:	00 00 00 
  81a77e:	b8 00 00 00 00       	mov    $0x0,%eax
  81a783:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a78a:	00 00 00 
  81a78d:	ff d1                	callq  *%rcx
    do_writemore(conn);
  81a78f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a793:	48 89 c7             	mov    %rax,%rdi
  81a796:	48 b8 a3 bb 81 00 00 	movabs $0x81bba3,%rax
  81a79d:	00 00 00 
  81a7a0:	ff d0                	callq  *%rax
  81a7a2:	eb 1f                	jmp    81a7c3 <sent_tcp+0xc6>
  } else if (conn->state == NETCONN_CLOSE) {
  81a7a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7a8:	8b 40 04             	mov    0x4(%rax),%eax
  81a7ab:	83 f8 04             	cmp    $0x4,%eax
  81a7ae:	75 13                	jne    81a7c3 <sent_tcp+0xc6>
    do_close_internal(conn);
  81a7b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7b4:	48 89 c7             	mov    %rax,%rdi
  81a7b7:	48 b8 1b b0 81 00 00 	movabs $0x81b01b,%rax
  81a7be:	00 00 00 
  81a7c1:	ff d0                	callq  *%rax
  }

  if (conn) {
  81a7c3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a7c8:	74 46                	je     81a810 <sent_tcp+0x113>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  81a7ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7ce:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a7d2:	48 85 c0             	test   %rax,%rax
  81a7d5:	74 39                	je     81a810 <sent_tcp+0x113>
  81a7d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7db:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a7df:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81a7e3:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81a7e7:	76 27                	jbe    81a810 <sent_tcp+0x113>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  81a7e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7ed:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a7f1:	48 85 c0             	test   %rax,%rax
  81a7f4:	74 1a                	je     81a810 <sent_tcp+0x113>
  81a7f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7fa:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a7fe:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  81a802:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81a806:	be 02 00 00 00       	mov    $0x2,%esi
  81a80b:	48 89 cf             	mov    %rcx,%rdi
  81a80e:	ff d0                	callq  *%rax
    }
  }
  
  return ERR_OK;
  81a810:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a815:	c9                   	leaveq 
  81a816:	c3                   	retq   

000000000081a817 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  81a817:	55                   	push   %rbp
  81a818:	48 89 e5             	mov    %rsp,%rbp
  81a81b:	48 83 ec 20          	sub    $0x20,%rsp
  81a81f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a823:	89 f0                	mov    %esi,%eax
  81a825:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct netconn *conn;

  conn = arg;
  81a828:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a82c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81a830:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a835:	75 2a                	jne    81a861 <err_tcp+0x4a>
  81a837:	48 ba 15 34 82 00 00 	movabs $0x823415,%rdx
  81a83e:	00 00 00 
  81a841:	be 22 01 00 00       	mov    $0x122,%esi
  81a846:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81a84d:	00 00 00 
  81a850:	b8 00 00 00 00       	mov    $0x0,%eax
  81a855:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81a85c:	00 00 00 
  81a85f:	ff d1                	callq  *%rcx

  conn->pcb.tcp = NULL;
  81a861:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a865:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81a86c:	00 

  conn->err = err;
  81a86d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a871:	0f b6 55 e4          	movzbl -0x1c(%rbp),%edx
  81a875:	88 50 10             	mov    %dl,0x10(%rax)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81a878:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a87c:	8b 40 18             	mov    0x18(%rax),%eax
  81a87f:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a882:	74 42                	je     81a8c6 <err_tcp+0xaf>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81a884:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a888:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a88c:	48 85 c0             	test   %rax,%rax
  81a88f:	74 1b                	je     81a8ac <err_tcp+0x95>
  81a891:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a895:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a899:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81a89d:	ba 00 00 00 00       	mov    $0x0,%edx
  81a8a2:	be 00 00 00 00       	mov    $0x0,%esi
  81a8a7:	48 89 cf             	mov    %rcx,%rdi
  81a8aa:	ff d0                	callq  *%rax
    sys_mbox_post(conn->recvmbox, NULL);
  81a8ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8b0:	8b 40 18             	mov    0x18(%rax),%eax
  81a8b3:	be 00 00 00 00       	mov    $0x0,%esi
  81a8b8:	89 c7                	mov    %eax,%edi
  81a8ba:	48 b8 d3 77 81 00 00 	movabs $0x8177d3,%rax
  81a8c1:	00 00 00 
  81a8c4:	ff d0                	callq  *%rax
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  81a8c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8ca:	8b 40 14             	mov    0x14(%rax),%eax
  81a8cd:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a8d0:	74 2c                	je     81a8fe <err_tcp+0xe7>
  81a8d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8d6:	8b 40 04             	mov    0x4(%rax),%eax
  81a8d9:	83 f8 03             	cmp    $0x3,%eax
  81a8dc:	75 20                	jne    81a8fe <err_tcp+0xe7>
    conn->state = NETCONN_NONE;
  81a8de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8e2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    sys_sem_signal(conn->op_completed);
  81a8e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8ed:	8b 40 14             	mov    0x14(%rax),%eax
  81a8f0:	89 c7                	mov    %eax,%edi
  81a8f2:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81a8f9:	00 00 00 
  81a8fc:	ff d0                	callq  *%rax
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81a8fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a902:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a905:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a908:	74 42                	je     81a94c <err_tcp+0x135>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81a90a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a90e:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a912:	48 85 c0             	test   %rax,%rax
  81a915:	74 1b                	je     81a932 <err_tcp+0x11b>
  81a917:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a91b:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a91f:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81a923:	ba 00 00 00 00       	mov    $0x0,%edx
  81a928:	be 00 00 00 00       	mov    $0x0,%esi
  81a92d:	48 89 cf             	mov    %rcx,%rdi
  81a930:	ff d0                	callq  *%rax
    sys_mbox_post(conn->acceptmbox, NULL);
  81a932:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a936:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a939:	be 00 00 00 00       	mov    $0x0,%esi
  81a93e:	89 c7                	mov    %eax,%edi
  81a940:	48 b8 d3 77 81 00 00 	movabs $0x8177d3,%rax
  81a947:	00 00 00 
  81a94a:	ff d0                	callq  *%rax
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  81a94c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a950:	8b 40 04             	mov    0x4(%rax),%eax
  81a953:	83 f8 01             	cmp    $0x1,%eax
  81a956:	74 0c                	je     81a964 <err_tcp+0x14d>
  81a958:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a95c:	8b 40 04             	mov    0x4(%rax),%eax
  81a95f:	83 f8 04             	cmp    $0x4,%eax
  81a962:	75 20                	jne    81a984 <err_tcp+0x16d>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  81a964:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a968:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  81a96f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a973:	8b 40 14             	mov    0x14(%rax),%eax
  81a976:	89 c7                	mov    %eax,%edi
  81a978:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81a97f:	00 00 00 
  81a982:	ff d0                	callq  *%rax
  }
}
  81a984:	c9                   	leaveq 
  81a985:	c3                   	retq   

000000000081a986 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  81a986:	55                   	push   %rbp
  81a987:	48 89 e5             	mov    %rsp,%rbp
  81a98a:	48 83 ec 20          	sub    $0x20,%rsp
  81a98e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  81a992:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a996:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a99a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  tcp_arg(pcb, conn);
  81a99e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a9a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9a6:	48 89 d6             	mov    %rdx,%rsi
  81a9a9:	48 89 c7             	mov    %rax,%rdi
  81a9ac:	48 b8 a6 05 81 00 00 	movabs $0x8105a6,%rax
  81a9b3:	00 00 00 
  81a9b6:	ff d0                	callq  *%rax
  tcp_recv(pcb, recv_tcp);
  81a9b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9bc:	48 be 04 a5 81 00 00 	movabs $0x81a504,%rsi
  81a9c3:	00 00 00 
  81a9c6:	48 89 c7             	mov    %rax,%rdi
  81a9c9:	48 b8 c4 05 81 00 00 	movabs $0x8105c4,%rax
  81a9d0:	00 00 00 
  81a9d3:	ff d0                	callq  *%rax
  tcp_sent(pcb, sent_tcp);
  81a9d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9d9:	48 be fd a6 81 00 00 	movabs $0x81a6fd,%rsi
  81a9e0:	00 00 00 
  81a9e3:	48 89 c7             	mov    %rax,%rdi
  81a9e6:	48 b8 e5 05 81 00 00 	movabs $0x8105e5,%rax
  81a9ed:	00 00 00 
  81a9f0:	ff d0                	callq  *%rax
  tcp_poll(pcb, poll_tcp, 4);
  81a9f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9f6:	ba 04 00 00 00       	mov    $0x4,%edx
  81a9fb:	48 be 6d a6 81 00 00 	movabs $0x81a66d,%rsi
  81aa02:	00 00 00 
  81aa05:	48 89 c7             	mov    %rax,%rdi
  81aa08:	48 b8 45 06 81 00 00 	movabs $0x810645,%rax
  81aa0f:	00 00 00 
  81aa12:	ff d0                	callq  *%rax
  tcp_err(pcb, err_tcp);
  81aa14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa18:	48 be 17 a8 81 00 00 	movabs $0x81a817,%rsi
  81aa1f:	00 00 00 
  81aa22:	48 89 c7             	mov    %rax,%rdi
  81aa25:	48 b8 06 06 81 00 00 	movabs $0x810606,%rax
  81aa2c:	00 00 00 
  81aa2f:	ff d0                	callq  *%rax
}
  81aa31:	c9                   	leaveq 
  81aa32:	c3                   	retq   

000000000081aa33 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  81aa33:	55                   	push   %rbp
  81aa34:	48 89 e5             	mov    %rsp,%rbp
  81aa37:	48 83 ec 30          	sub    $0x30,%rsp
  81aa3b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81aa3f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81aa43:	89 d0                	mov    %edx,%eax
  81aa45:	88 45 dc             	mov    %al,-0x24(%rbp)
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  81aa48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa4c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  81aa50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa54:	8b 40 1c             	mov    0x1c(%rax),%eax
  81aa57:	83 f8 ff             	cmp    $0xffffffff,%eax
  81aa5a:	75 2a                	jne    81aa86 <accept_function+0x53>
  81aa5c:	48 ba 38 34 82 00 00 	movabs $0x823438,%rdx
  81aa63:	00 00 00 
  81aa66:	be 65 01 00 00       	mov    $0x165,%esi
  81aa6b:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81aa72:	00 00 00 
  81aa75:	b8 00 00 00 00       	mov    $0x0,%eax
  81aa7a:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81aa81:	00 00 00 
  81aa84:	ff d1                	callq  *%rcx
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  81aa86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa8a:	48 8b 50 38          	mov    0x38(%rax),%rdx
  81aa8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa92:	8b 00                	mov    (%rax),%eax
  81aa94:	48 89 d6             	mov    %rdx,%rsi
  81aa97:	89 c7                	mov    %eax,%edi
  81aa99:	48 b8 7d ad 81 00 00 	movabs $0x81ad7d,%rax
  81aaa0:	00 00 00 
  81aaa3:	ff d0                	callq  *%rax
  81aaa5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (newconn == NULL) {
  81aaa9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81aaae:	75 0a                	jne    81aaba <accept_function+0x87>
    return ERR_MEM;
  81aab0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81aab5:	e9 9d 00 00 00       	jmpq   81ab57 <accept_function+0x124>
  }
  newconn->pcb.tcp = newpcb;
  81aaba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aabe:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81aac2:	48 89 50 08          	mov    %rdx,0x8(%rax)
  setup_tcp(newconn);
  81aac6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aaca:	48 89 c7             	mov    %rax,%rdi
  81aacd:	48 b8 86 a9 81 00 00 	movabs $0x81a986,%rax
  81aad4:	00 00 00 
  81aad7:	ff d0                	callq  *%rax
  newconn->err = err;
  81aad9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aadd:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81aae1:	88 50 10             	mov    %dl,0x10(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81aae4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aae8:	48 8b 40 38          	mov    0x38(%rax),%rax
  81aaec:	48 85 c0             	test   %rax,%rax
  81aaef:	74 1b                	je     81ab0c <accept_function+0xd9>
  81aaf1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aaf5:	48 8b 40 38          	mov    0x38(%rax),%rax
  81aaf9:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81aafd:	ba 00 00 00 00       	mov    $0x0,%edx
  81ab02:	be 00 00 00 00       	mov    $0x0,%esi
  81ab07:	48 89 cf             	mov    %rcx,%rdi
  81ab0a:	ff d0                	callq  *%rax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  81ab0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab10:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ab13:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81ab17:	48 89 d6             	mov    %rdx,%rsi
  81ab1a:	89 c7                	mov    %eax,%edi
  81ab1c:	48 b8 35 78 81 00 00 	movabs $0x817835,%rax
  81ab23:	00 00 00 
  81ab26:	ff d0                	callq  *%rax
  81ab28:	84 c0                	test   %al,%al
  81ab2a:	74 26                	je     81ab52 <accept_function+0x11f>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  81ab2c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ab30:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81ab37:	00 
    netconn_free(newconn);
  81ab38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ab3c:	48 89 c7             	mov    %rax,%rdi
  81ab3f:	48 b8 b1 ae 81 00 00 	movabs $0x81aeb1,%rax
  81ab46:	00 00 00 
  81ab49:	ff d0                	callq  *%rax
    return ERR_MEM;
  81ab4b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81ab50:	eb 05                	jmp    81ab57 <accept_function+0x124>
  }
  return ERR_OK;
  81ab52:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81ab57:	c9                   	leaveq 
  81ab58:	c3                   	retq   

000000000081ab59 <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
  81ab59:	55                   	push   %rbp
  81ab5a:	48 89 e5             	mov    %rsp,%rbp
  81ab5d:	53                   	push   %rbx
  81ab5e:	48 83 ec 18          	sub    $0x18,%rsp
  81ab62:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   msg->conn->err = ERR_OK;
  81ab66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab6a:	48 8b 00             	mov    (%rax),%rax
  81ab6d:	c6 40 10 00          	movb   $0x0,0x10(%rax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  81ab71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab75:	48 8b 00             	mov    (%rax),%rax
  81ab78:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ab7c:	48 85 c0             	test   %rax,%rax
  81ab7f:	74 2a                	je     81abab <pcb_new+0x52>
  81ab81:	48 ba 68 34 82 00 00 	movabs $0x823468,%rdx
  81ab88:	00 00 00 
  81ab8b:	be 8a 01 00 00       	mov    $0x18a,%esi
  81ab90:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81ab97:	00 00 00 
  81ab9a:	b8 00 00 00 00       	mov    $0x0,%eax
  81ab9f:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81aba6:	00 00 00 
  81aba9:	ff d1                	callq  *%rcx

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  81abab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81abaf:	48 8b 00             	mov    (%rax),%rax
  81abb2:	8b 00                	mov    (%rax),%eax
  81abb4:	25 f0 00 00 00       	and    $0xf0,%eax
  81abb9:	83 f8 20             	cmp    $0x20,%eax
  81abbc:	0f 84 87 00 00 00    	je     81ac49 <pcb_new+0xf0>
  81abc2:	83 f8 40             	cmp    $0x40,%eax
  81abc5:	74 0e                	je     81abd5 <pcb_new+0x7c>
  81abc7:	83 f8 10             	cmp    $0x10,%eax
  81abca:	0f 84 fa 00 00 00    	je     81acca <pcb_new+0x171>
  81abd0:	e9 41 01 00 00       	jmpq   81ad16 <pcb_new+0x1bd>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  81abd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81abd9:	48 8b 18             	mov    (%rax),%rbx
  81abdc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81abe0:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81abe4:	0f b6 c0             	movzbl %al,%eax
  81abe7:	89 c7                	mov    %eax,%edi
  81abe9:	48 b8 2f fe 81 00 00 	movabs $0x81fe2f,%rax
  81abf0:	00 00 00 
  81abf3:	ff d0                	callq  *%rax
  81abf5:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.raw == NULL) {
  81abf9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81abfd:	48 8b 00             	mov    (%rax),%rax
  81ac00:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ac04:	48 85 c0             	test   %rax,%rax
  81ac07:	75 10                	jne    81ac19 <pcb_new+0xc0>
       msg->conn->err = ERR_MEM;
  81ac09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac0d:	48 8b 00             	mov    (%rax),%rax
  81ac10:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81ac14:	e9 09 01 00 00       	jmpq   81ad22 <pcb_new+0x1c9>
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  81ac19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac1d:	48 8b 10             	mov    (%rax),%rdx
  81ac20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac24:	48 8b 00             	mov    (%rax),%rax
  81ac27:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ac2b:	48 be 91 a1 81 00 00 	movabs $0x81a191,%rsi
  81ac32:	00 00 00 
  81ac35:	48 89 c7             	mov    %rax,%rdi
  81ac38:	48 b8 7f fb 81 00 00 	movabs $0x81fb7f,%rax
  81ac3f:	00 00 00 
  81ac42:	ff d0                	callq  *%rax
     break;
  81ac44:	e9 d9 00 00 00       	jmpq   81ad22 <pcb_new+0x1c9>
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  81ac49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac4d:	48 8b 18             	mov    (%rax),%rbx
  81ac50:	48 b8 15 56 81 00 00 	movabs $0x815615,%rax
  81ac57:	00 00 00 
  81ac5a:	ff d0                	callq  *%rax
  81ac5c:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.udp == NULL) {
  81ac60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac64:	48 8b 00             	mov    (%rax),%rax
  81ac67:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ac6b:	48 85 c0             	test   %rax,%rax
  81ac6e:	75 10                	jne    81ac80 <pcb_new+0x127>
       msg->conn->err = ERR_MEM;
  81ac70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac74:	48 8b 00             	mov    (%rax),%rax
  81ac77:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81ac7b:	e9 a2 00 00 00       	jmpq   81ad22 <pcb_new+0x1c9>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  81ac80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac84:	48 8b 00             	mov    (%rax),%rax
  81ac87:	8b 00                	mov    (%rax),%eax
  81ac89:	83 f8 22             	cmp    $0x22,%eax
  81ac8c:	75 0f                	jne    81ac9d <pcb_new+0x144>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  81ac8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac92:	48 8b 00             	mov    (%rax),%rax
  81ac95:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ac99:	c6 40 18 01          	movb   $0x1,0x18(%rax)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  81ac9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aca1:	48 8b 10             	mov    (%rax),%rdx
  81aca4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aca8:	48 8b 00             	mov    (%rax),%rax
  81acab:	48 8b 40 08          	mov    0x8(%rax),%rax
  81acaf:	48 be 37 a3 81 00 00 	movabs $0x81a337,%rsi
  81acb6:	00 00 00 
  81acb9:	48 89 c7             	mov    %rax,%rdi
  81acbc:	48 b8 3d 55 81 00 00 	movabs $0x81553d,%rax
  81acc3:	00 00 00 
  81acc6:	ff d0                	callq  *%rax
     break;
  81acc8:	eb 58                	jmp    81ad22 <pcb_new+0x1c9>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  81acca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81acce:	48 8b 18             	mov    (%rax),%rbx
  81acd1:	48 b8 8f 05 81 00 00 	movabs $0x81058f,%rax
  81acd8:	00 00 00 
  81acdb:	ff d0                	callq  *%rax
  81acdd:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.tcp == NULL) {
  81ace1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ace5:	48 8b 00             	mov    (%rax),%rax
  81ace8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81acec:	48 85 c0             	test   %rax,%rax
  81acef:	75 0d                	jne    81acfe <pcb_new+0x1a5>
       msg->conn->err = ERR_MEM;
  81acf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81acf5:	48 8b 00             	mov    (%rax),%rax
  81acf8:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81acfc:	eb 24                	jmp    81ad22 <pcb_new+0x1c9>
     }
     setup_tcp(msg->conn);
  81acfe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad02:	48 8b 00             	mov    (%rax),%rax
  81ad05:	48 89 c7             	mov    %rax,%rdi
  81ad08:	48 b8 86 a9 81 00 00 	movabs $0x81a986,%rax
  81ad0f:	00 00 00 
  81ad12:	ff d0                	callq  *%rax
     break;
  81ad14:	eb 0c                	jmp    81ad22 <pcb_new+0x1c9>
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  81ad16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad1a:	48 8b 00             	mov    (%rax),%rax
  81ad1d:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
     break;
  81ad21:	90                   	nop
   }

  return msg->conn->err;
  81ad22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad26:	48 8b 00             	mov    (%rax),%rax
  81ad29:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81ad2d:	48 83 c4 18          	add    $0x18,%rsp
  81ad31:	5b                   	pop    %rbx
  81ad32:	5d                   	pop    %rbp
  81ad33:	c3                   	retq   

000000000081ad34 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  81ad34:	55                   	push   %rbp
  81ad35:	48 89 e5             	mov    %rsp,%rbp
  81ad38:	48 83 ec 10          	sub    $0x10,%rsp
  81ad3c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   if(msg->conn->pcb.tcp == NULL) {
  81ad40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad44:	48 8b 00             	mov    (%rax),%rax
  81ad47:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ad4b:	48 85 c0             	test   %rax,%rax
  81ad4e:	75 13                	jne    81ad63 <do_newconn+0x2f>
     pcb_new(msg);
  81ad50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad54:	48 89 c7             	mov    %rax,%rdi
  81ad57:	48 b8 59 ab 81 00 00 	movabs $0x81ab59,%rax
  81ad5e:	00 00 00 
  81ad61:	ff d0                	callq  *%rax
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  81ad63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad67:	48 8b 00             	mov    (%rax),%rax
  81ad6a:	8b 40 14             	mov    0x14(%rax),%eax
  81ad6d:	89 c7                	mov    %eax,%edi
  81ad6f:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81ad76:	00 00 00 
  81ad79:	ff d0                	callq  *%rax
}
  81ad7b:	c9                   	leaveq 
  81ad7c:	c3                   	retq   

000000000081ad7d <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  81ad7d:	55                   	push   %rbp
  81ad7e:	48 89 e5             	mov    %rsp,%rbp
  81ad81:	48 83 ec 20          	sub    $0x20,%rsp
  81ad85:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81ad88:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  81ad8c:	bf 07 00 00 00       	mov    $0x7,%edi
  81ad91:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  81ad98:	00 00 00 
  81ad9b:	ff d0                	callq  *%rax
  81ad9d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (conn == NULL) {
  81ada1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ada6:	75 0a                	jne    81adb2 <netconn_alloc+0x35>
    return NULL;
  81ada8:	b8 00 00 00 00       	mov    $0x0,%eax
  81adad:	e9 fd 00 00 00       	jmpq   81aeaf <netconn_alloc+0x132>
  }

  conn->err = ERR_OK;
  81adb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adb6:	c6 40 10 00          	movb   $0x0,0x10(%rax)
  conn->type = t;
  81adba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adbe:	8b 55 ec             	mov    -0x14(%rbp),%edx
  81adc1:	89 10                	mov    %edx,(%rax)
  conn->pcb.tcp = NULL;
  81adc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adc7:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81adce:	00 

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
  81adcf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  81add6:	bf 00 00 00 00       	mov    $0x0,%edi
  81addb:	48 b8 9b 7a 81 00 00 	movabs $0x817a9b,%rax
  81ade2:	00 00 00 
  81ade5:	ff d0                	callq  *%rax
  81ade7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81adeb:	89 42 14             	mov    %eax,0x14(%rdx)
  81adee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adf2:	8b 40 14             	mov    0x14(%rax),%eax
  81adf5:	83 f8 ff             	cmp    $0xffffffff,%eax
  81adf8:	75 22                	jne    81ae1c <netconn_alloc+0x9f>
    memp_free(MEMP_NETCONN, conn);
  81adfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adfe:	48 89 c6             	mov    %rax,%rsi
  81ae01:	bf 07 00 00 00       	mov    $0x7,%edi
  81ae06:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81ae0d:	00 00 00 
  81ae10:	ff d0                	callq  *%rax
    return NULL;
  81ae12:	b8 00 00 00 00       	mov    $0x0,%eax
  81ae17:	e9 93 00 00 00       	jmpq   81aeaf <netconn_alloc+0x132>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  81ae1c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81ae1f:	89 c7                	mov    %eax,%edi
  81ae21:	48 b8 a4 73 81 00 00 	movabs $0x8173a4,%rax
  81ae28:	00 00 00 
  81ae2b:	ff d0                	callq  *%rax
  81ae2d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81ae31:	89 42 18             	mov    %eax,0x18(%rdx)
  81ae34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae38:	8b 40 18             	mov    0x18(%rax),%eax
  81ae3b:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ae3e:	75 34                	jne    81ae74 <netconn_alloc+0xf7>
    sys_sem_free(conn->op_completed);
  81ae40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae44:	8b 40 14             	mov    0x14(%rax),%eax
  81ae47:	89 c7                	mov    %eax,%edi
  81ae49:	48 b8 99 7b 81 00 00 	movabs $0x817b99,%rax
  81ae50:	00 00 00 
  81ae53:	ff d0                	callq  *%rax
    memp_free(MEMP_NETCONN, conn);
  81ae55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae59:	48 89 c6             	mov    %rax,%rsi
  81ae5c:	bf 07 00 00 00       	mov    $0x7,%edi
  81ae61:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81ae68:	00 00 00 
  81ae6b:	ff d0                	callq  *%rax
    return NULL;
  81ae6d:	b8 00 00 00 00       	mov    $0x0,%eax
  81ae72:	eb 3b                	jmp    81aeaf <netconn_alloc+0x132>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  81ae74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae78:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  conn->state        = NETCONN_NONE;
  81ae7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae83:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  81ae8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae8e:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%rax)
  conn->callback     = callback;
  81ae95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae99:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81ae9d:	48 89 50 38          	mov    %rdx,0x38(%rax)
  conn->recv_avail   = 0;
  81aea1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aea5:	66 c7 40 24 00 00    	movw   $0x0,0x24(%rax)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  81aeab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81aeaf:	c9                   	leaveq 
  81aeb0:	c3                   	retq   

000000000081aeb1 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  81aeb1:	55                   	push   %rbp
  81aeb2:	48 89 e5             	mov    %rsp,%rbp
  81aeb5:	48 83 ec 20          	sub    $0x20,%rsp
  81aeb9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  81aebd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aec1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aec5:	48 85 c0             	test   %rax,%rax
  81aec8:	74 2a                	je     81aef4 <netconn_free+0x43>
  81aeca:	48 ba 88 34 82 00 00 	movabs $0x823488,%rdx
  81aed1:	00 00 00 
  81aed4:	be 26 02 00 00       	mov    $0x226,%esi
  81aed9:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81aee0:	00 00 00 
  81aee3:	b8 00 00 00 00       	mov    $0x0,%eax
  81aee8:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81aeef:	00 00 00 
  81aef2:	ff d1                	callq  *%rcx

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81aef4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aef8:	8b 40 18             	mov    0x18(%rax),%eax
  81aefb:	83 f8 ff             	cmp    $0xffffffff,%eax
  81aefe:	74 7f                	je     81af7f <netconn_free+0xce>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81af00:	eb 3c                	jmp    81af3e <netconn_free+0x8d>
      if (conn->type == NETCONN_TCP) {
  81af02:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af06:	8b 00                	mov    (%rax),%eax
  81af08:	83 f8 10             	cmp    $0x10,%eax
  81af0b:	75 1e                	jne    81af2b <netconn_free+0x7a>
        if(mem != NULL) {
  81af0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af11:	48 85 c0             	test   %rax,%rax
  81af14:	74 28                	je     81af3e <netconn_free+0x8d>
          pbuf_free((struct pbuf *)mem);
  81af16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af1a:	48 89 c7             	mov    %rax,%rdi
  81af1d:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81af24:	00 00 00 
  81af27:	ff d0                	callq  *%rax
  81af29:	eb 13                	jmp    81af3e <netconn_free+0x8d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  81af2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af2f:	48 89 c7             	mov    %rax,%rdi
  81af32:	48 b8 84 8b 80 00 00 	movabs $0x808b84,%rax
  81af39:	00 00 00 
  81af3c:	ff d0                	callq  *%rax
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81af3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af42:	8b 40 18             	mov    0x18(%rax),%eax
  81af45:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81af49:	48 89 d6             	mov    %rdx,%rsi
  81af4c:	89 c7                	mov    %eax,%edi
  81af4e:	48 b8 ba 82 81 00 00 	movabs $0x8182ba,%rax
  81af55:	00 00 00 
  81af58:	ff d0                	callq  *%rax
  81af5a:	83 f8 ff             	cmp    $0xffffffff,%eax
  81af5d:	75 a3                	jne    81af02 <netconn_free+0x51>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  81af5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af63:	8b 40 18             	mov    0x18(%rax),%eax
  81af66:	89 c7                	mov    %eax,%edi
  81af68:	48 b8 84 75 81 00 00 	movabs $0x817584,%rax
  81af6f:	00 00 00 
  81af72:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  81af74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af78:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81af7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af83:	8b 40 1c             	mov    0x1c(%rax),%eax
  81af86:	83 f8 ff             	cmp    $0xffffffff,%eax
  81af89:	74 56                	je     81afe1 <netconn_free+0x130>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81af8b:	eb 13                	jmp    81afa0 <netconn_free+0xef>
      netconn_delete((struct netconn *)mem);
  81af8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af91:	48 89 c7             	mov    %rax,%rdi
  81af94:	48 b8 9e 98 81 00 00 	movabs $0x81989e,%rax
  81af9b:	00 00 00 
  81af9e:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81afa0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afa4:	8b 40 1c             	mov    0x1c(%rax),%eax
  81afa7:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81afab:	48 89 d6             	mov    %rdx,%rsi
  81afae:	89 c7                	mov    %eax,%edi
  81afb0:	48 b8 ba 82 81 00 00 	movabs $0x8182ba,%rax
  81afb7:	00 00 00 
  81afba:	ff d0                	callq  *%rax
  81afbc:	83 f8 ff             	cmp    $0xffffffff,%eax
  81afbf:	75 cc                	jne    81af8d <netconn_free+0xdc>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  81afc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afc5:	8b 40 1c             	mov    0x1c(%rax),%eax
  81afc8:	89 c7                	mov    %eax,%edi
  81afca:	48 b8 84 75 81 00 00 	movabs $0x817584,%rax
  81afd1:	00 00 00 
  81afd4:	ff d0                	callq  *%rax
    conn->acceptmbox = SYS_MBOX_NULL;
  81afd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afda:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  }

  sys_sem_free(conn->op_completed);
  81afe1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afe5:	8b 40 14             	mov    0x14(%rax),%eax
  81afe8:	89 c7                	mov    %eax,%edi
  81afea:	48 b8 99 7b 81 00 00 	movabs $0x817b99,%rax
  81aff1:	00 00 00 
  81aff4:	ff d0                	callq  *%rax
  conn->op_completed = SYS_SEM_NULL;
  81aff6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81affa:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%rax)

  memp_free(MEMP_NETCONN, conn);
  81b001:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b005:	48 89 c6             	mov    %rax,%rsi
  81b008:	bf 07 00 00 00       	mov    $0x7,%edi
  81b00d:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81b014:	00 00 00 
  81b017:	ff d0                	callq  *%rax
}
  81b019:	c9                   	leaveq 
  81b01a:	c3                   	retq   

000000000081b01b <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  81b01b:	55                   	push   %rbp
  81b01c:	48 89 e5             	mov    %rsp,%rbp
  81b01f:	48 83 ec 20          	sub    $0x20,%rsp
  81b023:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  81b027:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81b02c:	75 2a                	jne    81b058 <do_close_internal+0x3d>
  81b02e:	48 ba b6 34 82 00 00 	movabs $0x8234b6,%rdx
  81b035:	00 00 00 
  81b038:	be 53 02 00 00       	mov    $0x253,%esi
  81b03d:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81b044:	00 00 00 
  81b047:	b8 00 00 00 00       	mov    $0x0,%eax
  81b04c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81b053:	00 00 00 
  81b056:	ff d1                	callq  *%rcx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  81b058:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b05c:	8b 00                	mov    (%rax),%eax
  81b05e:	83 f8 10             	cmp    $0x10,%eax
  81b061:	74 2a                	je     81b08d <do_close_internal+0x72>
  81b063:	48 ba c3 34 82 00 00 	movabs $0x8234c3,%rdx
  81b06a:	00 00 00 
  81b06d:	be 54 02 00 00       	mov    $0x254,%esi
  81b072:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81b079:	00 00 00 
  81b07c:	b8 00 00 00 00       	mov    $0x0,%eax
  81b081:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81b088:	00 00 00 
  81b08b:	ff d1                	callq  *%rcx
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  81b08d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b091:	8b 40 04             	mov    0x4(%rax),%eax
  81b094:	83 f8 04             	cmp    $0x4,%eax
  81b097:	74 2a                	je     81b0c3 <do_close_internal+0xa8>
  81b099:	48 ba e8 34 82 00 00 	movabs $0x8234e8,%rdx
  81b0a0:	00 00 00 
  81b0a3:	be 55 02 00 00       	mov    $0x255,%esi
  81b0a8:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81b0af:	00 00 00 
  81b0b2:	b8 00 00 00 00       	mov    $0x0,%eax
  81b0b7:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81b0be:	00 00 00 
  81b0c1:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  81b0c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0c7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b0cb:	48 85 c0             	test   %rax,%rax
  81b0ce:	75 2a                	jne    81b0fa <do_close_internal+0xdf>
  81b0d0:	48 ba 0c 35 82 00 00 	movabs $0x82350c,%rdx
  81b0d7:	00 00 00 
  81b0da:	be 56 02 00 00       	mov    $0x256,%esi
  81b0df:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81b0e6:	00 00 00 
  81b0e9:	b8 00 00 00 00       	mov    $0x0,%eax
  81b0ee:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81b0f5:	00 00 00 
  81b0f8:	ff d1                	callq  *%rcx

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  81b0fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0fe:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b102:	be 00 00 00 00       	mov    $0x0,%esi
  81b107:	48 89 c7             	mov    %rax,%rdi
  81b10a:	48 b8 a6 05 81 00 00 	movabs $0x8105a6,%rax
  81b111:	00 00 00 
  81b114:	ff d0                	callq  *%rax
  if (conn->pcb.tcp->state == LISTEN) {
  81b116:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b11a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b11e:	8b 40 18             	mov    0x18(%rax),%eax
  81b121:	83 f8 01             	cmp    $0x1,%eax
  81b124:	75 21                	jne    81b147 <do_close_internal+0x12c>
    tcp_accept(conn->pcb.tcp, NULL);
  81b126:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b12a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b12e:	be 00 00 00 00       	mov    $0x0,%esi
  81b133:	48 89 c7             	mov    %rax,%rdi
  81b136:	48 b8 27 06 81 00 00 	movabs $0x810627,%rax
  81b13d:	00 00 00 
  81b140:	ff d0                	callq  *%rax
  81b142:	e9 91 00 00 00       	jmpq   81b1d8 <do_close_internal+0x1bd>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  81b147:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b14b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b14f:	be 00 00 00 00       	mov    $0x0,%esi
  81b154:	48 89 c7             	mov    %rax,%rdi
  81b157:	48 b8 c4 05 81 00 00 	movabs $0x8105c4,%rax
  81b15e:	00 00 00 
  81b161:	ff d0                	callq  *%rax
    tcp_accept(conn->pcb.tcp, NULL);
  81b163:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b167:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b16b:	be 00 00 00 00       	mov    $0x0,%esi
  81b170:	48 89 c7             	mov    %rax,%rdi
  81b173:	48 b8 27 06 81 00 00 	movabs $0x810627,%rax
  81b17a:	00 00 00 
  81b17d:	ff d0                	callq  *%rax
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  81b17f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b183:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b187:	be 00 00 00 00       	mov    $0x0,%esi
  81b18c:	48 89 c7             	mov    %rax,%rdi
  81b18f:	48 b8 e5 05 81 00 00 	movabs $0x8105e5,%rax
  81b196:	00 00 00 
  81b199:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, NULL, 4);
  81b19b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b19f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b1a3:	ba 04 00 00 00       	mov    $0x4,%edx
  81b1a8:	be 00 00 00 00       	mov    $0x0,%esi
  81b1ad:	48 89 c7             	mov    %rax,%rdi
  81b1b0:	48 b8 45 06 81 00 00 	movabs $0x810645,%rax
  81b1b7:	00 00 00 
  81b1ba:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, NULL);
  81b1bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b1c4:	be 00 00 00 00       	mov    $0x0,%esi
  81b1c9:	48 89 c7             	mov    %rax,%rdi
  81b1cc:	48 b8 06 06 81 00 00 	movabs $0x810606,%rax
  81b1d3:	00 00 00 
  81b1d6:	ff d0                	callq  *%rax
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  81b1d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1dc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b1e0:	48 89 c7             	mov    %rax,%rdi
  81b1e3:	48 b8 48 e9 80 00 00 	movabs $0x80e948,%rax
  81b1ea:	00 00 00 
  81b1ed:	ff d0                	callq  *%rax
  81b1ef:	88 45 ff             	mov    %al,-0x1(%rbp)
  if (err == ERR_OK) {
  81b1f2:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81b1f6:	0f 85 89 00 00 00    	jne    81b285 <do_close_internal+0x26a>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  81b1fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b200:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  81b207:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b20b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81b212:	00 
    conn->err = ERR_OK;
  81b213:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b217:	c6 40 10 00          	movb   $0x0,0x10(%rax)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81b21b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b21f:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b223:	48 85 c0             	test   %rax,%rax
  81b226:	74 1b                	je     81b243 <do_close_internal+0x228>
  81b228:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b22c:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b230:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81b234:	ba 00 00 00 00       	mov    $0x0,%edx
  81b239:	be 00 00 00 00       	mov    $0x0,%esi
  81b23e:	48 89 cf             	mov    %rcx,%rdi
  81b241:	ff d0                	callq  *%rax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  81b243:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b247:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b24b:	48 85 c0             	test   %rax,%rax
  81b24e:	74 1b                	je     81b26b <do_close_internal+0x250>
  81b250:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b254:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b258:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81b25c:	ba 00 00 00 00       	mov    $0x0,%edx
  81b261:	be 02 00 00 00       	mov    $0x2,%esi
  81b266:	48 89 cf             	mov    %rcx,%rdi
  81b269:	ff d0                	callq  *%rax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  81b26b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b26f:	8b 40 14             	mov    0x14(%rax),%eax
  81b272:	89 c7                	mov    %eax,%edi
  81b274:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81b27b:	00 00 00 
  81b27e:	ff d0                	callq  *%rax
  81b280:	e9 c0 00 00 00       	jmpq   81b345 <do_close_internal+0x32a>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  81b285:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b289:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b28d:	8b 40 18             	mov    0x18(%rax),%eax
  81b290:	83 f8 01             	cmp    $0x1,%eax
  81b293:	75 2a                	jne    81b2bf <do_close_internal+0x2a4>
  81b295:	48 ba 20 35 82 00 00 	movabs $0x823520,%rdx
  81b29c:	00 00 00 
  81b29f:	be 75 02 00 00       	mov    $0x275,%esi
  81b2a4:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81b2ab:	00 00 00 
  81b2ae:	b8 00 00 00 00       	mov    $0x0,%eax
  81b2b3:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81b2ba:	00 00 00 
  81b2bd:	ff d1                	callq  *%rcx
    tcp_sent(conn->pcb.tcp, sent_tcp);
  81b2bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2c3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b2c7:	48 be fd a6 81 00 00 	movabs $0x81a6fd,%rsi
  81b2ce:	00 00 00 
  81b2d1:	48 89 c7             	mov    %rax,%rdi
  81b2d4:	48 b8 e5 05 81 00 00 	movabs $0x8105e5,%rax
  81b2db:	00 00 00 
  81b2de:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  81b2e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2e4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b2e8:	ba 04 00 00 00       	mov    $0x4,%edx
  81b2ed:	48 be 6d a6 81 00 00 	movabs $0x81a66d,%rsi
  81b2f4:	00 00 00 
  81b2f7:	48 89 c7             	mov    %rax,%rdi
  81b2fa:	48 b8 45 06 81 00 00 	movabs $0x810645,%rax
  81b301:	00 00 00 
  81b304:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, err_tcp);
  81b306:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b30a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b30e:	48 be 17 a8 81 00 00 	movabs $0x81a817,%rsi
  81b315:	00 00 00 
  81b318:	48 89 c7             	mov    %rax,%rdi
  81b31b:	48 b8 06 06 81 00 00 	movabs $0x810606,%rax
  81b322:	00 00 00 
  81b325:	ff d0                	callq  *%rax
    tcp_arg(conn->pcb.tcp, conn);
  81b327:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b32b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b32f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81b333:	48 89 d6             	mov    %rdx,%rsi
  81b336:	48 89 c7             	mov    %rax,%rdi
  81b339:	48 b8 a6 05 81 00 00 	movabs $0x8105a6,%rax
  81b340:	00 00 00 
  81b343:	ff d0                	callq  *%rax
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  81b345:	c9                   	leaveq 
  81b346:	c3                   	retq   

000000000081b347 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  81b347:	55                   	push   %rbp
  81b348:	48 89 e5             	mov    %rsp,%rbp
  81b34b:	48 83 ec 10          	sub    $0x10,%rsp
  81b34f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.tcp != NULL) {
  81b353:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b357:	48 8b 00             	mov    (%rax),%rax
  81b35a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b35e:	48 85 c0             	test   %rax,%rax
  81b361:	0f 84 93 00 00 00    	je     81b3fa <do_delconn+0xb3>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b367:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b36b:	48 8b 00             	mov    (%rax),%rax
  81b36e:	8b 00                	mov    (%rax),%eax
  81b370:	25 f0 00 00 00       	and    $0xf0,%eax
  81b375:	83 f8 20             	cmp    $0x20,%eax
  81b378:	74 28                	je     81b3a2 <do_delconn+0x5b>
  81b37a:	83 f8 40             	cmp    $0x40,%eax
  81b37d:	74 07                	je     81b386 <do_delconn+0x3f>
  81b37f:	83 f8 10             	cmp    $0x10,%eax
  81b382:	74 4d                	je     81b3d1 <do_delconn+0x8a>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
#endif /* LWIP_TCP */
    default:
      break;
  81b384:	eb 74                	jmp    81b3fa <do_delconn+0xb3>
{
  if (msg->conn->pcb.tcp != NULL) {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  81b386:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b38a:	48 8b 00             	mov    (%rax),%rax
  81b38d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b391:	48 89 c7             	mov    %rax,%rdi
  81b394:	48 b8 85 fd 81 00 00 	movabs $0x81fd85,%rax
  81b39b:	00 00 00 
  81b39e:	ff d0                	callq  *%rax
      break;
  81b3a0:	eb 58                	jmp    81b3fa <do_delconn+0xb3>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  81b3a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b3a6:	48 8b 00             	mov    (%rax),%rax
  81b3a9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b3ad:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81b3b4:	00 
      udp_remove(msg->conn->pcb.udp);
  81b3b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b3b9:	48 8b 00             	mov    (%rax),%rax
  81b3bc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b3c0:	48 89 c7             	mov    %rax,%rdi
  81b3c3:	48 b8 6b 55 81 00 00 	movabs $0x81556b,%rax
  81b3ca:	00 00 00 
  81b3cd:	ff d0                	callq  *%rax
      break;
  81b3cf:	eb 29                	jmp    81b3fa <do_delconn+0xb3>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  81b3d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b3d5:	48 8b 00             	mov    (%rax),%rax
  81b3d8:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81b3df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b3e3:	48 8b 00             	mov    (%rax),%rax
  81b3e6:	48 89 c7             	mov    %rax,%rdi
  81b3e9:	48 b8 1b b0 81 00 00 	movabs $0x81b01b,%rax
  81b3f0:	00 00 00 
  81b3f3:	ff d0                	callq  *%rax
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  81b3f5:	e9 89 00 00 00       	jmpq   81b483 <do_delconn+0x13c>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  81b3fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b3fe:	48 8b 00             	mov    (%rax),%rax
  81b401:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b405:	48 85 c0             	test   %rax,%rax
  81b408:	74 21                	je     81b42b <do_delconn+0xe4>
  81b40a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b40e:	48 8b 00             	mov    (%rax),%rax
  81b411:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b415:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b419:	48 8b 0a             	mov    (%rdx),%rcx
  81b41c:	ba 00 00 00 00       	mov    $0x0,%edx
  81b421:	be 00 00 00 00       	mov    $0x0,%esi
  81b426:	48 89 cf             	mov    %rcx,%rdi
  81b429:	ff d0                	callq  *%rax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  81b42b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b42f:	48 8b 00             	mov    (%rax),%rax
  81b432:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b436:	48 85 c0             	test   %rax,%rax
  81b439:	74 21                	je     81b45c <do_delconn+0x115>
  81b43b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b43f:	48 8b 00             	mov    (%rax),%rax
  81b442:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b446:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b44a:	48 8b 0a             	mov    (%rdx),%rcx
  81b44d:	ba 00 00 00 00       	mov    $0x0,%edx
  81b452:	be 02 00 00 00       	mov    $0x2,%esi
  81b457:	48 89 cf             	mov    %rcx,%rdi
  81b45a:	ff d0                	callq  *%rax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  81b45c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b460:	48 8b 00             	mov    (%rax),%rax
  81b463:	8b 40 14             	mov    0x14(%rax),%eax
  81b466:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b469:	74 18                	je     81b483 <do_delconn+0x13c>
    sys_sem_signal(msg->conn->op_completed);
  81b46b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b46f:	48 8b 00             	mov    (%rax),%rax
  81b472:	8b 40 14             	mov    0x14(%rax),%eax
  81b475:	89 c7                	mov    %eax,%edi
  81b477:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81b47e:	00 00 00 
  81b481:	ff d0                	callq  *%rax
  }
}
  81b483:	c9                   	leaveq 
  81b484:	c3                   	retq   

000000000081b485 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  81b485:	55                   	push   %rbp
  81b486:	48 89 e5             	mov    %rsp,%rbp
  81b489:	53                   	push   %rbx
  81b48a:	48 83 ec 18          	sub    $0x18,%rsp
  81b48e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b492:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b496:	48 8b 00             	mov    (%rax),%rax
  81b499:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b49d:	3c fc                	cmp    $0xfc,%al
  81b49f:	0f 8c eb 00 00 00    	jl     81b590 <do_bind+0x10b>
    if (msg->conn->pcb.tcp != NULL) {
  81b4a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4a9:	48 8b 00             	mov    (%rax),%rax
  81b4ac:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b4b0:	48 85 c0             	test   %rax,%rax
  81b4b3:	0f 84 cc 00 00 00    	je     81b585 <do_bind+0x100>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b4b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4bd:	48 8b 00             	mov    (%rax),%rax
  81b4c0:	8b 00                	mov    (%rax),%eax
  81b4c2:	25 f0 00 00 00       	and    $0xf0,%eax
  81b4c7:	83 f8 20             	cmp    $0x20,%eax
  81b4ca:	74 40                	je     81b50c <do_bind+0x87>
  81b4cc:	83 f8 40             	cmp    $0x40,%eax
  81b4cf:	74 0a                	je     81b4db <do_bind+0x56>
  81b4d1:	83 f8 10             	cmp    $0x10,%eax
  81b4d4:	74 72                	je     81b548 <do_bind+0xc3>
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_TCP */
      default:
        break;
  81b4d6:	e9 a8 00 00 00       	jmpq   81b583 <do_bind+0xfe>
  if (!ERR_IS_FATAL(msg->conn->err)) {
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81b4db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4df:	48 8b 18             	mov    (%rax),%rbx
  81b4e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4e6:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b4ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4ee:	48 8b 00             	mov    (%rax),%rax
  81b4f1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b4f5:	48 89 d6             	mov    %rdx,%rsi
  81b4f8:	48 89 c7             	mov    %rax,%rdi
  81b4fb:	48 b8 1c fb 81 00 00 	movabs $0x81fb1c,%rax
  81b502:	00 00 00 
  81b505:	ff d0                	callq  *%rax
  81b507:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b50a:	eb 77                	jmp    81b583 <do_bind+0xfe>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b50c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b510:	48 8b 18             	mov    (%rax),%rbx
  81b513:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b517:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b51b:	0f b7 d0             	movzwl %ax,%edx
  81b51e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b522:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b526:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b52a:	48 8b 00             	mov    (%rax),%rax
  81b52d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b531:	48 89 ce             	mov    %rcx,%rsi
  81b534:	48 89 c7             	mov    %rax,%rdi
  81b537:	48 b8 b9 52 81 00 00 	movabs $0x8152b9,%rax
  81b53e:	00 00 00 
  81b541:	ff d0                	callq  *%rax
  81b543:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b546:	eb 3b                	jmp    81b583 <do_bind+0xfe>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b548:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b54c:	48 8b 18             	mov    (%rax),%rbx
  81b54f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b553:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b557:	0f b7 d0             	movzwl %ax,%edx
  81b55a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b55e:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b562:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b566:	48 8b 00             	mov    (%rax),%rax
  81b569:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b56d:	48 89 ce             	mov    %rcx,%rsi
  81b570:	48 89 c7             	mov    %rax,%rdi
  81b573:	48 b8 97 ed 80 00 00 	movabs $0x80ed97,%rax
  81b57a:	00 00 00 
  81b57d:	ff d0                	callq  *%rax
  81b57f:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b582:	90                   	nop
  81b583:	eb 0b                	jmp    81b590 <do_bind+0x10b>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  81b585:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b589:	48 8b 00             	mov    (%rax),%rax
  81b58c:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81b590:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b594:	48 8b 00             	mov    (%rax),%rax
  81b597:	8b 40 14             	mov    0x14(%rax),%eax
  81b59a:	89 c7                	mov    %eax,%edi
  81b59c:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81b5a3:	00 00 00 
  81b5a6:	ff d0                	callq  *%rax
}
  81b5a8:	48 83 c4 18          	add    $0x18,%rsp
  81b5ac:	5b                   	pop    %rbx
  81b5ad:	5d                   	pop    %rbp
  81b5ae:	c3                   	retq   

000000000081b5af <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  81b5af:	55                   	push   %rbp
  81b5b0:	48 89 e5             	mov    %rsp,%rbp
  81b5b3:	48 83 ec 30          	sub    $0x30,%rsp
  81b5b7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81b5bb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81b5bf:	89 d0                	mov    %edx,%eax
  81b5c1:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  81b5c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5c8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (conn == NULL) {
  81b5cc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81b5d1:	75 07                	jne    81b5da <do_connected+0x2b>
    return ERR_VAL;
  81b5d3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81b5d8:	eb 54                	jmp    81b62e <do_connected+0x7f>
  }

  conn->err = err;
  81b5da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b5de:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81b5e2:	88 50 10             	mov    %dl,0x10(%rax)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  81b5e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b5e9:	8b 00                	mov    (%rax),%eax
  81b5eb:	83 f8 10             	cmp    $0x10,%eax
  81b5ee:	75 19                	jne    81b609 <do_connected+0x5a>
  81b5f0:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  81b5f4:	75 13                	jne    81b609 <do_connected+0x5a>
    setup_tcp(conn);
  81b5f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b5fa:	48 89 c7             	mov    %rax,%rdi
  81b5fd:	48 b8 86 a9 81 00 00 	movabs $0x81a986,%rax
  81b604:	00 00 00 
  81b607:	ff d0                	callq  *%rax
  }
  conn->state = NETCONN_NONE;
  81b609:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b60d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  sys_sem_signal(conn->op_completed);
  81b614:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b618:	8b 40 14             	mov    0x14(%rax),%eax
  81b61b:	89 c7                	mov    %eax,%edi
  81b61d:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81b624:	00 00 00 
  81b627:	ff d0                	callq  *%rax
  return ERR_OK;
  81b629:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81b62e:	c9                   	leaveq 
  81b62f:	c3                   	retq   

000000000081b630 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  81b630:	55                   	push   %rbp
  81b631:	48 89 e5             	mov    %rsp,%rbp
  81b634:	53                   	push   %rbx
  81b635:	48 83 ec 18          	sub    $0x18,%rsp
  81b639:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (msg->conn->pcb.tcp == NULL) {
  81b63d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b641:	48 8b 00             	mov    (%rax),%rax
  81b644:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b648:	48 85 c0             	test   %rax,%rax
  81b64b:	75 1d                	jne    81b66a <do_connect+0x3a>
    sys_sem_signal(msg->conn->op_completed);
  81b64d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b651:	48 8b 00             	mov    (%rax),%rax
  81b654:	8b 40 14             	mov    0x14(%rax),%eax
  81b657:	89 c7                	mov    %eax,%edi
  81b659:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81b660:	00 00 00 
  81b663:	ff d0                	callq  *%rax
    return;
  81b665:	e9 2c 01 00 00       	jmpq   81b796 <do_connect+0x166>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b66a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b66e:	48 8b 00             	mov    (%rax),%rax
  81b671:	8b 00                	mov    (%rax),%eax
  81b673:	25 f0 00 00 00       	and    $0xf0,%eax
  81b678:	83 f8 20             	cmp    $0x20,%eax
  81b67b:	74 5f                	je     81b6dc <do_connect+0xac>
  81b67d:	83 f8 40             	cmp    $0x40,%eax
  81b680:	74 0e                	je     81b690 <do_connect+0x60>
  81b682:	83 f8 10             	cmp    $0x10,%eax
  81b685:	0f 84 a5 00 00 00    	je     81b730 <do_connect+0x100>
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
#endif /* LWIP_TCP */
  default:
    break;
  81b68b:	e9 06 01 00 00       	jmpq   81b796 <do_connect+0x166>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81b690:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b694:	48 8b 18             	mov    (%rax),%rbx
  81b697:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b69b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b69f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6a3:	48 8b 00             	mov    (%rax),%rax
  81b6a6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b6aa:	48 89 d6             	mov    %rdx,%rsi
  81b6ad:	48 89 c7             	mov    %rax,%rdi
  81b6b0:	48 b8 4d fb 81 00 00 	movabs $0x81fb4d,%rax
  81b6b7:	00 00 00 
  81b6ba:	ff d0                	callq  *%rax
  81b6bc:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81b6bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6c3:	48 8b 00             	mov    (%rax),%rax
  81b6c6:	8b 40 14             	mov    0x14(%rax),%eax
  81b6c9:	89 c7                	mov    %eax,%edi
  81b6cb:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81b6d2:	00 00 00 
  81b6d5:	ff d0                	callq  *%rax
    break;
  81b6d7:	e9 ba 00 00 00       	jmpq   81b796 <do_connect+0x166>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b6dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6e0:	48 8b 18             	mov    (%rax),%rbx
  81b6e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6e7:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b6eb:	0f b7 d0             	movzwl %ax,%edx
  81b6ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6f2:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b6f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6fa:	48 8b 00             	mov    (%rax),%rax
  81b6fd:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b701:	48 89 ce             	mov    %rcx,%rsi
  81b704:	48 89 c7             	mov    %rax,%rdi
  81b707:	48 b8 05 54 81 00 00 	movabs $0x815405,%rax
  81b70e:	00 00 00 
  81b711:	ff d0                	callq  *%rax
  81b713:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81b716:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b71a:	48 8b 00             	mov    (%rax),%rax
  81b71d:	8b 40 14             	mov    0x14(%rax),%eax
  81b720:	89 c7                	mov    %eax,%edi
  81b722:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81b729:	00 00 00 
  81b72c:	ff d0                	callq  *%rax
    break;
  81b72e:	eb 66                	jmp    81b796 <do_connect+0x166>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  81b730:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b734:	48 8b 00             	mov    (%rax),%rax
  81b737:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%rax)
    setup_tcp(msg->conn);
  81b73e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b742:	48 8b 00             	mov    (%rax),%rax
  81b745:	48 89 c7             	mov    %rax,%rdi
  81b748:	48 b8 86 a9 81 00 00 	movabs $0x81a986,%rax
  81b74f:	00 00 00 
  81b752:	ff d0                	callq  *%rax
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  81b754:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b758:	48 8b 18             	mov    (%rax),%rbx
  81b75b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b75f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b763:	0f b7 d0             	movzwl %ax,%edx
  81b766:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b76a:	48 8b 70 08          	mov    0x8(%rax),%rsi
  81b76e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b772:	48 8b 00             	mov    (%rax),%rax
  81b775:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b779:	48 b9 af b5 81 00 00 	movabs $0x81b5af,%rcx
  81b780:	00 00 00 
  81b783:	48 89 c7             	mov    %rax,%rdi
  81b786:	48 b8 d1 f4 80 00 00 	movabs $0x80f4d1,%rax
  81b78d:	00 00 00 
  81b790:	ff d0                	callq  *%rax
  81b792:	88 43 10             	mov    %al,0x10(%rbx)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  81b795:	90                   	nop
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  81b796:	48 83 c4 18          	add    $0x18,%rsp
  81b79a:	5b                   	pop    %rbx
  81b79b:	5d                   	pop    %rbp
  81b79c:	c3                   	retq   

000000000081b79d <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  81b79d:	55                   	push   %rbp
  81b79e:	48 89 e5             	mov    %rsp,%rbp
  81b7a1:	48 83 ec 10          	sub    $0x10,%rsp
  81b7a5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  81b7a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b7ad:	48 8b 00             	mov    (%rax),%rax
  81b7b0:	8b 00                	mov    (%rax),%eax
  81b7b2:	25 f0 00 00 00       	and    $0xf0,%eax
  81b7b7:	83 f8 20             	cmp    $0x20,%eax
  81b7ba:	75 1a                	jne    81b7d6 <do_disconnect+0x39>
    udp_disconnect(msg->conn->pcb.udp);
  81b7bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b7c0:	48 8b 00             	mov    (%rax),%rax
  81b7c3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7c7:	48 89 c7             	mov    %rax,%rdi
  81b7ca:	48 b8 fe 54 81 00 00 	movabs $0x8154fe,%rax
  81b7d1:	00 00 00 
  81b7d4:	ff d0                	callq  *%rax
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  81b7d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b7da:	48 8b 00             	mov    (%rax),%rax
  81b7dd:	8b 40 14             	mov    0x14(%rax),%eax
  81b7e0:	89 c7                	mov    %eax,%edi
  81b7e2:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81b7e9:	00 00 00 
  81b7ec:	ff d0                	callq  *%rax
}
  81b7ee:	c9                   	leaveq 
  81b7ef:	c3                   	retq   

000000000081b7f0 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  81b7f0:	55                   	push   %rbp
  81b7f1:	48 89 e5             	mov    %rsp,%rbp
  81b7f4:	53                   	push   %rbx
  81b7f5:	48 83 ec 28          	sub    $0x28,%rsp
  81b7f9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b7fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b801:	48 8b 00             	mov    (%rax),%rax
  81b804:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b808:	3c fc                	cmp    $0xfc,%al
  81b80a:	0f 8c 6b 01 00 00    	jl     81b97b <do_listen+0x18b>
    if (msg->conn->pcb.tcp != NULL) {
  81b810:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b814:	48 8b 00             	mov    (%rax),%rax
  81b817:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b81b:	48 85 c0             	test   %rax,%rax
  81b81e:	0f 84 57 01 00 00    	je     81b97b <do_listen+0x18b>
      if (msg->conn->type == NETCONN_TCP) {
  81b824:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b828:	48 8b 00             	mov    (%rax),%rax
  81b82b:	8b 00                	mov    (%rax),%eax
  81b82d:	83 f8 10             	cmp    $0x10,%eax
  81b830:	0f 85 45 01 00 00    	jne    81b97b <do_listen+0x18b>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  81b836:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b83a:	48 8b 00             	mov    (%rax),%rax
  81b83d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b841:	8b 40 18             	mov    0x18(%rax),%eax
  81b844:	85 c0                	test   %eax,%eax
  81b846:	0f 85 24 01 00 00    	jne    81b970 <do_listen+0x180>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  81b84c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b850:	48 8b 00             	mov    (%rax),%rax
  81b853:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b857:	be ff 00 00 00       	mov    $0xff,%esi
  81b85c:	48 89 c7             	mov    %rax,%rdi
  81b85f:	48 b8 18 f0 80 00 00 	movabs $0x80f018,%rax
  81b866:	00 00 00 
  81b869:	ff d0                	callq  *%rax
  81b86b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  81b86f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81b874:	75 10                	jne    81b886 <do_listen+0x96>
            msg->conn->err = ERR_MEM;
  81b876:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b87a:	48 8b 00             	mov    (%rax),%rax
  81b87d:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
  81b881:	e9 e8 00 00 00       	jmpq   81b96e <do_listen+0x17e>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  81b886:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b88a:	48 8b 00             	mov    (%rax),%rax
  81b88d:	8b 40 18             	mov    0x18(%rax),%eax
  81b890:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b893:	74 26                	je     81b8bb <do_listen+0xcb>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  81b895:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b899:	48 8b 00             	mov    (%rax),%rax
  81b89c:	8b 40 18             	mov    0x18(%rax),%eax
  81b89f:	89 c7                	mov    %eax,%edi
  81b8a1:	48 b8 84 75 81 00 00 	movabs $0x817584,%rax
  81b8a8:	00 00 00 
  81b8ab:	ff d0                	callq  *%rax
              msg->conn->recvmbox = SYS_MBOX_NULL;
  81b8ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b8b1:	48 8b 00             	mov    (%rax),%rax
  81b8b4:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  81b8bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b8bf:	48 8b 00             	mov    (%rax),%rax
  81b8c2:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b8c5:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b8c8:	75 2e                	jne    81b8f8 <do_listen+0x108>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  81b8ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b8ce:	48 8b 18             	mov    (%rax),%rbx
  81b8d1:	bf 00 00 00 00       	mov    $0x0,%edi
  81b8d6:	48 b8 a4 73 81 00 00 	movabs $0x8173a4,%rax
  81b8dd:	00 00 00 
  81b8e0:	ff d0                	callq  *%rax
  81b8e2:	89 43 1c             	mov    %eax,0x1c(%rbx)
  81b8e5:	8b 43 1c             	mov    0x1c(%rbx),%eax
  81b8e8:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b8eb:	75 0b                	jne    81b8f8 <do_listen+0x108>
                msg->conn->err = ERR_MEM;
  81b8ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b8f1:	48 8b 00             	mov    (%rax),%rax
  81b8f4:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  81b8f8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b8fc:	48 8b 00             	mov    (%rax),%rax
  81b8ff:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b903:	84 c0                	test   %al,%al
  81b905:	75 67                	jne    81b96e <do_listen+0x17e>
              msg->conn->state = NETCONN_LISTEN;
  81b907:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b90b:	48 8b 00             	mov    (%rax),%rax
  81b90e:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
              msg->conn->pcb.tcp = lpcb;
  81b915:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b919:	48 8b 00             	mov    (%rax),%rax
  81b91c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81b920:	48 89 50 08          	mov    %rdx,0x8(%rax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  81b924:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b928:	48 8b 10             	mov    (%rax),%rdx
  81b92b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b92f:	48 8b 00             	mov    (%rax),%rax
  81b932:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b936:	48 89 d6             	mov    %rdx,%rsi
  81b939:	48 89 c7             	mov    %rax,%rdi
  81b93c:	48 b8 a6 05 81 00 00 	movabs $0x8105a6,%rax
  81b943:	00 00 00 
  81b946:	ff d0                	callq  *%rax
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  81b948:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b94c:	48 8b 00             	mov    (%rax),%rax
  81b94f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b953:	48 be 33 aa 81 00 00 	movabs $0x81aa33,%rsi
  81b95a:	00 00 00 
  81b95d:	48 89 c7             	mov    %rax,%rdi
  81b960:	48 b8 27 06 81 00 00 	movabs $0x810627,%rax
  81b967:	00 00 00 
  81b96a:	ff d0                	callq  *%rax
  81b96c:	eb 0d                	jmp    81b97b <do_listen+0x18b>
  81b96e:	eb 0b                	jmp    81b97b <do_listen+0x18b>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  81b970:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b974:	48 8b 00             	mov    (%rax),%rax
  81b977:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81b97b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b97f:	48 8b 00             	mov    (%rax),%rax
  81b982:	8b 40 14             	mov    0x14(%rax),%eax
  81b985:	89 c7                	mov    %eax,%edi
  81b987:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81b98e:	00 00 00 
  81b991:	ff d0                	callq  *%rax
}
  81b993:	48 83 c4 28          	add    $0x28,%rsp
  81b997:	5b                   	pop    %rbx
  81b998:	5d                   	pop    %rbp
  81b999:	c3                   	retq   

000000000081b99a <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  81b99a:	55                   	push   %rbp
  81b99b:	48 89 e5             	mov    %rsp,%rbp
  81b99e:	53                   	push   %rbx
  81b99f:	48 83 ec 18          	sub    $0x18,%rsp
  81b9a3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b9a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9ab:	48 8b 00             	mov    (%rax),%rax
  81b9ae:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b9b2:	3c fc                	cmp    $0xfc,%al
  81b9b4:	0f 8c 50 01 00 00    	jl     81bb0a <do_send+0x170>
    if (msg->conn->pcb.tcp != NULL) {
  81b9ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9be:	48 8b 00             	mov    (%rax),%rax
  81b9c1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b9c5:	48 85 c0             	test   %rax,%rax
  81b9c8:	0f 84 3c 01 00 00    	je     81bb0a <do_send+0x170>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b9ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9d2:	48 8b 00             	mov    (%rax),%rax
  81b9d5:	8b 00                	mov    (%rax),%eax
  81b9d7:	25 f0 00 00 00       	and    $0xf0,%eax
  81b9dc:	83 f8 20             	cmp    $0x20,%eax
  81b9df:	0f 84 95 00 00 00    	je     81ba7a <do_send+0xe0>
  81b9e5:	83 f8 40             	cmp    $0x40,%eax
  81b9e8:	74 05                	je     81b9ef <do_send+0x55>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
#endif /* LWIP_UDP */
      default:
        break;
  81b9ea:	e9 1b 01 00 00       	jmpq   81bb0a <do_send+0x170>
  if (!ERR_IS_FATAL(msg->conn->err)) {
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  81b9ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9f3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b9f7:	48 8b 40 10          	mov    0x10(%rax),%rax
  81b9fb:	48 85 c0             	test   %rax,%rax
  81b9fe:	75 37                	jne    81ba37 <do_send+0x9d>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  81ba00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba04:	48 8b 18             	mov    (%rax),%rbx
  81ba07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba0b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba0f:	48 8b 10             	mov    (%rax),%rdx
  81ba12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba16:	48 8b 00             	mov    (%rax),%rax
  81ba19:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba1d:	48 89 d6             	mov    %rdx,%rsi
  81ba20:	48 89 c7             	mov    %rax,%rdi
  81ba23:	48 b8 51 fd 81 00 00 	movabs $0x81fd51,%rax
  81ba2a:	00 00 00 
  81ba2d:	ff d0                	callq  *%rax
  81ba2f:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
        }
        break;
  81ba32:	e9 d3 00 00 00       	jmpq   81bb0a <do_send+0x170>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  81ba37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba3b:	48 8b 18             	mov    (%rax),%rbx
  81ba3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba42:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba46:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81ba4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba4e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba52:	48 8b 08             	mov    (%rax),%rcx
  81ba55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba59:	48 8b 00             	mov    (%rax),%rax
  81ba5c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba60:	48 89 ce             	mov    %rcx,%rsi
  81ba63:	48 89 c7             	mov    %rax,%rdi
  81ba66:	48 b8 ad fb 81 00 00 	movabs $0x81fbad,%rax
  81ba6d:	00 00 00 
  81ba70:	ff d0                	callq  *%rax
  81ba72:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81ba75:	e9 90 00 00 00       	jmpq   81bb0a <do_send+0x170>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  81ba7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba7e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba82:	48 8b 40 10          	mov    0x10(%rax),%rax
  81ba86:	48 85 c0             	test   %rax,%rax
  81ba89:	75 34                	jne    81babf <do_send+0x125>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  81ba8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba8f:	48 8b 18             	mov    (%rax),%rbx
  81ba92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba96:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba9a:	48 8b 10             	mov    (%rax),%rdx
  81ba9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81baa1:	48 8b 00             	mov    (%rax),%rax
  81baa4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81baa8:	48 89 d6             	mov    %rdx,%rsi
  81baab:	48 89 c7             	mov    %rax,%rdi
  81baae:	48 b8 60 4f 81 00 00 	movabs $0x814f60,%rax
  81bab5:	00 00 00 
  81bab8:	ff d0                	callq  *%rax
  81baba:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
  81babd:	eb 4a                	jmp    81bb09 <do_send+0x16f>
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  81babf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bac3:	48 8b 18             	mov    (%rax),%rbx
  81bac6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81baca:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bace:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81bad2:	0f b7 c8             	movzwl %ax,%ecx
  81bad5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bad9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81badd:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81bae1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bae5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bae9:	48 8b 30             	mov    (%rax),%rsi
  81baec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81baf0:	48 8b 00             	mov    (%rax),%rax
  81baf3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81baf7:	48 89 c7             	mov    %rax,%rdi
  81bafa:	48 b8 a1 4f 81 00 00 	movabs $0x814fa1,%rax
  81bb01:	00 00 00 
  81bb04:	ff d0                	callq  *%rax
  81bb06:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81bb09:	90                   	nop
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81bb0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb0e:	48 8b 00             	mov    (%rax),%rax
  81bb11:	8b 40 14             	mov    0x14(%rax),%eax
  81bb14:	89 c7                	mov    %eax,%edi
  81bb16:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81bb1d:	00 00 00 
  81bb20:	ff d0                	callq  *%rax
}
  81bb22:	48 83 c4 18          	add    $0x18,%rsp
  81bb26:	5b                   	pop    %rbx
  81bb27:	5d                   	pop    %rbp
  81bb28:	c3                   	retq   

000000000081bb29 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  81bb29:	55                   	push   %rbp
  81bb2a:	48 89 e5             	mov    %rsp,%rbp
  81bb2d:	48 83 ec 10          	sub    $0x10,%rsp
  81bb31:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81bb35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bb39:	48 8b 00             	mov    (%rax),%rax
  81bb3c:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bb40:	3c fc                	cmp    $0xfc,%al
  81bb42:	7c 45                	jl     81bb89 <do_recv+0x60>
    if (msg->conn->pcb.tcp != NULL) {
  81bb44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bb48:	48 8b 00             	mov    (%rax),%rax
  81bb4b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb4f:	48 85 c0             	test   %rax,%rax
  81bb52:	74 35                	je     81bb89 <do_recv+0x60>
      if (msg->conn->type == NETCONN_TCP) {
  81bb54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bb58:	48 8b 00             	mov    (%rax),%rax
  81bb5b:	8b 00                	mov    (%rax),%eax
  81bb5d:	83 f8 10             	cmp    $0x10,%eax
  81bb60:	75 27                	jne    81bb89 <do_recv+0x60>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  81bb62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bb66:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81bb6a:	0f b7 d0             	movzwl %ax,%edx
  81bb6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bb71:	48 8b 00             	mov    (%rax),%rax
  81bb74:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb78:	89 d6                	mov    %edx,%esi
  81bb7a:	48 89 c7             	mov    %rax,%rdi
  81bb7d:	48 b8 61 f2 80 00 00 	movabs $0x80f261,%rax
  81bb84:	00 00 00 
  81bb87:	ff d0                	callq  *%rax
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81bb89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bb8d:	48 8b 00             	mov    (%rax),%rax
  81bb90:	8b 40 14             	mov    0x14(%rax),%eax
  81bb93:	89 c7                	mov    %eax,%edi
  81bb95:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81bb9c:	00 00 00 
  81bb9f:	ff d0                	callq  *%rax
}
  81bba1:	c9                   	leaveq 
  81bba2:	c3                   	retq   

000000000081bba3 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  81bba3:	55                   	push   %rbp
  81bba4:	48 89 e5             	mov    %rsp,%rbp
  81bba7:	48 83 ec 30          	sub    $0x30,%rsp
  81bbab:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  81bbaf:	c6 45 fd 00          	movb   $0x0,-0x3(%rbp)

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  81bbb3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbb7:	8b 40 04             	mov    0x4(%rax),%eax
  81bbba:	83 f8 01             	cmp    $0x1,%eax
  81bbbd:	74 2a                	je     81bbe9 <do_writemore+0x46>
  81bbbf:	48 ba 43 35 82 00 00 	movabs $0x823543,%rdx
  81bbc6:	00 00 00 
  81bbc9:	be b8 03 00 00       	mov    $0x3b8,%esi
  81bbce:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81bbd5:	00 00 00 
  81bbd8:	b8 00 00 00 00       	mov    $0x0,%eax
  81bbdd:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81bbe4:	00 00 00 
  81bbe7:	ff d1                	callq  *%rcx

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  81bbe9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbed:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bbf1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81bbf5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbf9:	8b 40 30             	mov    0x30(%rax),%eax
  81bbfc:	48 98                	cltq   
  81bbfe:	48 01 d0             	add    %rdx,%rax
  81bc01:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  81bc05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc09:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bc0d:	8b 50 10             	mov    0x10(%rax),%edx
  81bc10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc14:	8b 40 30             	mov    0x30(%rax),%eax
  81bc17:	29 c2                	sub    %eax,%edx
  81bc19:	89 d0                	mov    %edx,%eax
  81bc1b:	3d ff ff 00 00       	cmp    $0xffff,%eax
  81bc20:	7e 08                	jle    81bc2a <do_writemore+0x87>
    len = 0xffff;
  81bc22:	66 c7 45 fe ff ff    	movw   $0xffff,-0x2(%rbp)
  81bc28:	eb 1c                	jmp    81bc46 <do_writemore+0xa3>
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  81bc2a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc2e:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bc32:	8b 40 10             	mov    0x10(%rax),%eax
  81bc35:	89 c2                	mov    %eax,%edx
  81bc37:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc3b:	8b 40 30             	mov    0x30(%rax),%eax
  81bc3e:	29 c2                	sub    %eax,%edx
  81bc40:	89 d0                	mov    %edx,%eax
  81bc42:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  81bc46:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc4a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc4e:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81bc52:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if (available < len) {
  81bc56:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81bc5a:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  81bc5e:	73 08                	jae    81bc68 <do_writemore+0xc5>
    /* don't try to write more than sendbuf */
    len = available;
  81bc60:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81bc64:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  81bc68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc6c:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bc70:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  81bc74:	0f b6 c8             	movzbl %al,%ecx
  81bc77:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81bc7b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc7f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc83:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  81bc87:	48 89 c7             	mov    %rax,%rdi
  81bc8a:	48 b8 c2 2d 81 00 00 	movabs $0x812dc2,%rax
  81bc91:	00 00 00 
  81bc94:	ff d0                	callq  *%rax
  81bc96:	88 45 ed             	mov    %al,-0x13(%rbp)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  81bc99:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc9d:	8b 50 30             	mov    0x30(%rax),%edx
  81bca0:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81bca4:	01 c2                	add    %eax,%edx
  81bca6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bcaa:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bcae:	8b 40 10             	mov    0x10(%rax),%eax
  81bcb1:	39 c2                	cmp    %eax,%edx
  81bcb3:	7e 2a                	jle    81bcdf <do_writemore+0x13c>
  81bcb5:	48 ba 60 35 82 00 00 	movabs $0x823560,%rdx
  81bcbc:	00 00 00 
  81bcbf:	be cd 03 00 00       	mov    $0x3cd,%esi
  81bcc4:	48 bf 52 33 82 00 00 	movabs $0x823352,%rdi
  81bccb:	00 00 00 
  81bcce:	b8 00 00 00 00       	mov    $0x0,%eax
  81bcd3:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81bcda:	00 00 00 
  81bcdd:	ff d1                	callq  *%rcx
  if (err == ERR_OK) {
  81bcdf:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81bce3:	0f 85 07 01 00 00    	jne    81bdf0 <do_writemore+0x24d>
    conn->write_offset += len;
  81bce9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bced:	8b 50 30             	mov    0x30(%rax),%edx
  81bcf0:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81bcf4:	01 c2                	add    %eax,%edx
  81bcf6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bcfa:	89 50 30             	mov    %edx,0x30(%rax)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  81bcfd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd01:	8b 50 30             	mov    0x30(%rax),%edx
  81bd04:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd08:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bd0c:	8b 40 10             	mov    0x10(%rax),%eax
  81bd0f:	39 c2                	cmp    %eax,%edx
  81bd11:	75 1b                	jne    81bd2e <do_writemore+0x18b>
      /* everything was written */
      write_finished = 1;
  81bd13:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
      conn->write_msg = NULL;
  81bd17:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd1b:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81bd22:	00 
      conn->write_offset = 0;
  81bd23:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd27:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  81bd2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd32:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd36:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81bd3d:	48 85 c0             	test   %rax,%rax
  81bd40:	74 41                	je     81bd83 <do_writemore+0x1e0>
  81bd42:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd46:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd4a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81bd4e:	0f b6 c0             	movzbl %al,%eax
  81bd51:	83 e0 40             	and    $0x40,%eax
  81bd54:	85 c0                	test   %eax,%eax
  81bd56:	75 2b                	jne    81bd83 <do_writemore+0x1e0>
  81bd58:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd5c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd60:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81bd67:	48 85 c0             	test   %rax,%rax
  81bd6a:	74 30                	je     81bd9c <do_writemore+0x1f9>
  81bd6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd70:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd74:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81bd7b:	48 8b 00             	mov    (%rax),%rax
  81bd7e:	48 85 c0             	test   %rax,%rax
  81bd81:	74 19                	je     81bd9c <do_writemore+0x1f9>
  81bd83:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd87:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd8b:	48 89 c7             	mov    %rax,%rdi
  81bd8e:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81bd95:	00 00 00 
  81bd98:	ff d0                	callq  *%rax
  81bd9a:	eb 05                	jmp    81bda1 <do_writemore+0x1fe>
  81bd9c:	b8 00 00 00 00       	mov    $0x0,%eax
  81bda1:	88 45 ed             	mov    %al,-0x13(%rbp)
    conn->err = err;
  81bda4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bda8:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81bdac:	88 50 10             	mov    %dl,0x10(%rax)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  81bdaf:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81bdb3:	75 6c                	jne    81be21 <do_writemore+0x27e>
  81bdb5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bdb9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bdbd:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81bdc1:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81bdc5:	77 5a                	ja     81be21 <do_writemore+0x27e>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  81bdc7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bdcb:	48 8b 40 38          	mov    0x38(%rax),%rax
  81bdcf:	48 85 c0             	test   %rax,%rax
  81bdd2:	74 4d                	je     81be21 <do_writemore+0x27e>
  81bdd4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bdd8:	48 8b 40 38          	mov    0x38(%rax),%rax
  81bddc:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81bde0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  81bde4:	be 03 00 00 00       	mov    $0x3,%esi
  81bde9:	48 89 cf             	mov    %rcx,%rdi
  81bdec:	ff d0                	callq  *%rax
  81bdee:	eb 31                	jmp    81be21 <do_writemore+0x27e>
    }
  } else if (err == ERR_MEM) {
  81bdf0:	80 7d ed ff          	cmpb   $0xff,-0x13(%rbp)
  81bdf4:	75 1c                	jne    81be12 <do_writemore+0x26f>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  81bdf6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bdfa:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bdfe:	48 89 c7             	mov    %rax,%rdi
  81be01:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81be08:	00 00 00 
  81be0b:	ff d0                	callq  *%rax
  81be0d:	88 45 ed             	mov    %al,-0x13(%rbp)
  81be10:	eb 0f                	jmp    81be21 <do_writemore+0x27e>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  81be12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be16:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81be1a:	88 50 10             	mov    %dl,0x10(%rax)
    write_finished = 1;
  81be1d:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
  }

  if (write_finished) {
  81be21:	80 7d fd 00          	cmpb   $0x0,-0x3(%rbp)
  81be25:	74 20                	je     81be47 <do_writemore+0x2a4>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  81be27:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be2b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  81be32:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be36:	8b 40 14             	mov    0x14(%rax),%eax
  81be39:	89 c7                	mov    %eax,%edi
  81be3b:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81be42:	00 00 00 
  81be45:	ff d0                	callq  *%rax
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
  81be47:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81be4c:	c9                   	leaveq 
  81be4d:	c3                   	retq   

000000000081be4e <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  81be4e:	55                   	push   %rbp
  81be4f:	48 89 e5             	mov    %rsp,%rbp
  81be52:	48 83 ec 10          	sub    $0x10,%rsp
  81be56:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81be5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be5e:	48 8b 00             	mov    (%rax),%rax
  81be61:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81be65:	3c fc                	cmp    $0xfc,%al
  81be67:	7c 6c                	jl     81bed5 <do_write+0x87>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81be69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be6d:	48 8b 00             	mov    (%rax),%rax
  81be70:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be74:	48 85 c0             	test   %rax,%rax
  81be77:	74 51                	je     81beca <do_write+0x7c>
  81be79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be7d:	48 8b 00             	mov    (%rax),%rax
  81be80:	8b 00                	mov    (%rax),%eax
  81be82:	83 f8 10             	cmp    $0x10,%eax
  81be85:	75 43                	jne    81beca <do_write+0x7c>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  81be87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be8b:	48 8b 00             	mov    (%rax),%rax
  81be8e:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  81be95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be99:	48 8b 00             	mov    (%rax),%rax
  81be9c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bea0:	48 89 50 28          	mov    %rdx,0x28(%rax)
      msg->conn->write_offset = 0;
  81bea4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bea8:	48 8b 00             	mov    (%rax),%rax
  81beab:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  81beb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81beb6:	48 8b 00             	mov    (%rax),%rax
  81beb9:	48 89 c7             	mov    %rax,%rdi
  81bebc:	48 b8 a3 bb 81 00 00 	movabs $0x81bba3,%rax
  81bec3:	00 00 00 
  81bec6:	ff d0                	callq  *%rax
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  81bec8:	eb 23                	jmp    81beed <do_write+0x9f>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  81beca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bece:	48 8b 00             	mov    (%rax),%rax
  81bed1:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81bed5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bed9:	48 8b 00             	mov    (%rax),%rax
  81bedc:	8b 40 14             	mov    0x14(%rax),%eax
  81bedf:	89 c7                	mov    %eax,%edi
  81bee1:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81bee8:	00 00 00 
  81beeb:	ff d0                	callq  *%rax
}
  81beed:	c9                   	leaveq 
  81beee:	c3                   	retq   

000000000081beef <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  81beef:	55                   	push   %rbp
  81bef0:	48 89 e5             	mov    %rsp,%rbp
  81bef3:	48 83 ec 10          	sub    $0x10,%rsp
  81bef7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.ip != NULL) {
  81befb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81beff:	48 8b 00             	mov    (%rax),%rax
  81bf02:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf06:	48 85 c0             	test   %rax,%rax
  81bf09:	0f 84 3f 01 00 00    	je     81c04e <do_getaddr+0x15f>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  81bf0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf13:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf17:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bf1b:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81bf1f:	84 d2                	test   %dl,%dl
  81bf21:	74 11                	je     81bf34 <do_getaddr+0x45>
  81bf23:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bf27:	48 8b 12             	mov    (%rdx),%rdx
  81bf2a:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81bf2e:	8b 12                	mov    (%rdx),%edx
  81bf30:	89 10                	mov    %edx,(%rax)
  81bf32:	eb 10                	jmp    81bf44 <do_getaddr+0x55>
  81bf34:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bf38:	48 8b 12             	mov    (%rdx),%rdx
  81bf3b:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81bf3f:	8b 52 04             	mov    0x4(%rdx),%edx
  81bf42:	89 10                	mov    %edx,(%rax)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81bf44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf48:	48 8b 00             	mov    (%rax),%rax
  81bf4b:	8b 00                	mov    (%rax),%eax
  81bf4d:	25 f0 00 00 00       	and    $0xf0,%eax
  81bf52:	83 f8 20             	cmp    $0x20,%eax
  81bf55:	74 51                	je     81bfa8 <do_getaddr+0xb9>
  81bf57:	83 f8 40             	cmp    $0x40,%eax
  81bf5a:	74 0e                	je     81bf6a <do_getaddr+0x7b>
  81bf5c:	83 f8 10             	cmp    $0x10,%eax
  81bf5f:	0f 84 af 00 00 00    	je     81c014 <do_getaddr+0x125>
  81bf65:	e9 ef 00 00 00       	jmpq   81c059 <do_getaddr+0x16a>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  81bf6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf6e:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81bf72:	84 c0                	test   %al,%al
  81bf74:	74 22                	je     81bf98 <do_getaddr+0xa9>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  81bf76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf7a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bf7e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bf82:	48 8b 12             	mov    (%rdx),%rdx
  81bf85:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81bf89:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81bf8d:	0f b6 d2             	movzbl %dl,%edx
  81bf90:	66 89 10             	mov    %dx,(%rax)
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
      }
      break;
  81bf93:	e9 b4 00 00 00       	jmpq   81c04c <do_getaddr+0x15d>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  81bf98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf9c:	48 8b 00             	mov    (%rax),%rax
  81bf9f:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      }
      break;
  81bfa3:	e9 a4 00 00 00       	jmpq   81c04c <do_getaddr+0x15d>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  81bfa8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bfac:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81bfb0:	84 c0                	test   %al,%al
  81bfb2:	74 1c                	je     81bfd0 <do_getaddr+0xe1>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  81bfb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bfb8:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bfbc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bfc0:	48 8b 12             	mov    (%rdx),%rdx
  81bfc3:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81bfc7:	0f b7 52 1a          	movzwl 0x1a(%rdx),%edx
  81bfcb:	66 89 10             	mov    %dx,(%rax)
  81bfce:	eb 42                	jmp    81c012 <do_getaddr+0x123>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  81bfd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bfd4:	48 8b 00             	mov    (%rax),%rax
  81bfd7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bfdb:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81bfdf:	0f b6 c0             	movzbl %al,%eax
  81bfe2:	83 e0 04             	and    $0x4,%eax
  81bfe5:	85 c0                	test   %eax,%eax
  81bfe7:	75 0d                	jne    81bff6 <do_getaddr+0x107>
          msg->conn->err = ERR_CONN;
  81bfe9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bfed:	48 8b 00             	mov    (%rax),%rax
  81bff0:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
  81bff4:	eb 1c                	jmp    81c012 <do_getaddr+0x123>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  81bff6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bffa:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bffe:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c002:	48 8b 12             	mov    (%rdx),%rdx
  81c005:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c009:	0f b7 52 1c          	movzwl 0x1c(%rdx),%edx
  81c00d:	66 89 10             	mov    %dx,(%rax)
        }
      }
      break;
  81c010:	eb 3a                	jmp    81c04c <do_getaddr+0x15d>
  81c012:	eb 38                	jmp    81c04c <do_getaddr+0x15d>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  81c014:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c018:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c01c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c020:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c024:	84 c0                	test   %al,%al
  81c026:	74 11                	je     81c039 <do_getaddr+0x14a>
  81c028:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c02c:	48 8b 00             	mov    (%rax),%rax
  81c02f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c033:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  81c037:	eb 0f                	jmp    81c048 <do_getaddr+0x159>
  81c039:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c03d:	48 8b 00             	mov    (%rax),%rax
  81c040:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c044:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  81c048:	66 89 02             	mov    %ax,(%rdx)
      break;
  81c04b:	90                   	nop
  81c04c:	eb 0b                	jmp    81c059 <do_getaddr+0x16a>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  81c04e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c052:	48 8b 00             	mov    (%rax),%rax
  81c055:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
  }
  TCPIP_APIMSG_ACK(msg);
  81c059:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c05d:	48 8b 00             	mov    (%rax),%rax
  81c060:	8b 40 14             	mov    0x14(%rax),%eax
  81c063:	89 c7                	mov    %eax,%edi
  81c065:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81c06c:	00 00 00 
  81c06f:	ff d0                	callq  *%rax
}
  81c071:	c9                   	leaveq 
  81c072:	c3                   	retq   

000000000081c073 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  81c073:	55                   	push   %rbp
  81c074:	48 89 e5             	mov    %rsp,%rbp
  81c077:	48 83 ec 10          	sub    $0x10,%rsp
  81c07b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81c07f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c083:	48 8b 00             	mov    (%rax),%rax
  81c086:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c08a:	48 85 c0             	test   %rax,%rax
  81c08d:	74 34                	je     81c0c3 <do_close+0x50>
  81c08f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c093:	48 8b 00             	mov    (%rax),%rax
  81c096:	8b 00                	mov    (%rax),%eax
  81c098:	83 f8 10             	cmp    $0x10,%eax
  81c09b:	75 26                	jne    81c0c3 <do_close+0x50>
      msg->conn->state = NETCONN_CLOSE;
  81c09d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c0a1:	48 8b 00             	mov    (%rax),%rax
  81c0a4:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81c0ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c0af:	48 8b 00             	mov    (%rax),%rax
  81c0b2:	48 89 c7             	mov    %rax,%rdi
  81c0b5:	48 b8 1b b0 81 00 00 	movabs $0x81b01b,%rax
  81c0bc:	00 00 00 
  81c0bf:	ff d0                	callq  *%rax
  81c0c1:	eb 23                	jmp    81c0e6 <do_close+0x73>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  81c0c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c0c7:	48 8b 00             	mov    (%rax),%rax
  81c0ca:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    TCPIP_APIMSG_ACK(msg);
  81c0ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c0d2:	48 8b 00             	mov    (%rax),%rax
  81c0d5:	8b 40 14             	mov    0x14(%rax),%eax
  81c0d8:	89 c7                	mov    %eax,%edi
  81c0da:	48 b8 1b 7d 81 00 00 	movabs $0x817d1b,%rax
  81c0e1:	00 00 00 
  81c0e4:	ff d0                	callq  *%rax
  }
}
  81c0e6:	c9                   	leaveq 
  81c0e7:	c3                   	retq   

000000000081c0e8 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  81c0e8:	55                   	push   %rbp
  81c0e9:	48 89 e5             	mov    %rsp,%rbp
  81c0ec:	53                   	push   %rbx
  81c0ed:	48 83 ec 38          	sub    $0x38,%rsp
  81c0f1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81c0f5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  81c0f9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c0fd:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81c101:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c108:	00 00 00 
  81c10b:	48 89 10             	mov    %rdx,(%rax)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  81c10e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c112:	48 8b 58 08          	mov    0x8(%rax),%rbx
  81c116:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c11d:	00 00 00 
  81c120:	48 8b 00             	mov    (%rax),%rax
  81c123:	0f b7 00             	movzwl (%rax),%eax
  81c126:	0f b7 c0             	movzwl %ax,%eax
  81c129:	89 c7                	mov    %eax,%edi
  81c12b:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81c132:	00 00 00 
  81c135:	ff d0                	callq  *%rax
  81c137:	66 c1 e8 08          	shr    $0x8,%ax
  81c13b:	0f b7 c0             	movzwl %ax,%eax
  81c13e:	83 e0 0f             	and    $0xf,%eax
  81c141:	c1 e0 02             	shl    $0x2,%eax
  81c144:	48 98                	cltq   
  81c146:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  81c14a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c151:	00 00 00 
  81c154:	48 89 10             	mov    %rdx,(%rax)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  81c157:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c15e:	00 00 00 
  81c161:	48 8b 00             	mov    (%rax),%rax
  81c164:	0f b7 00             	movzwl (%rax),%eax
  81c167:	0f b7 c0             	movzwl %ax,%eax
  81c16a:	89 c7                	mov    %eax,%edi
  81c16c:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81c173:	00 00 00 
  81c176:	ff d0                	callq  *%rax
  81c178:	66 c1 e8 08          	shr    $0x8,%ax
  81c17c:	83 e0 0f             	and    $0xf,%eax
  81c17f:	c1 e0 02             	shl    $0x2,%eax
  81c182:	f7 d8                	neg    %eax
  81c184:	0f bf d0             	movswl %ax,%edx
  81c187:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c18b:	89 d6                	mov    %edx,%esi
  81c18d:	48 89 c7             	mov    %rax,%rdi
  81c190:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  81c197:	00 00 00 
  81c19a:	ff d0                	callq  *%rax
  81c19c:	84 c0                	test   %al,%al
  81c19e:	75 0e                	jne    81c1ae <tcp_input+0xc6>
  81c1a0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c1a4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81c1a8:	66 83 f8 13          	cmp    $0x13,%ax
  81c1ac:	77 18                	ja     81c1c6 <tcp_input+0xde>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c1ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c1b2:	48 89 c7             	mov    %rax,%rdi
  81c1b5:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81c1bc:	00 00 00 
  81c1bf:	ff d0                	callq  *%rax
    return;
  81c1c1:	e9 eb 0b 00 00       	jmpq   81cdb1 <tcp_input+0xcc9>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81c1c6:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c1cd:	00 00 00 
  81c1d0:	48 8b 00             	mov    (%rax),%rax
  81c1d3:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c1d7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81c1db:	48 89 c6             	mov    %rax,%rsi
  81c1de:	48 89 d7             	mov    %rdx,%rdi
  81c1e1:	48 b8 10 0a 81 00 00 	movabs $0x810a10,%rax
  81c1e8:	00 00 00 
  81c1eb:	ff d0                	callq  *%rax
  81c1ed:	84 c0                	test   %al,%al
  81c1ef:	75 38                	jne    81c229 <tcp_input+0x141>
      ip_addr_ismulticast(&(iphdr->dest))) {
  81c1f1:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c1f8:	00 00 00 
  81c1fb:	48 8b 00             	mov    (%rax),%rax
  81c1fe:	8b 58 10             	mov    0x10(%rax),%ebx
  81c201:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81c206:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  81c20d:	00 00 00 
  81c210:	ff d0                	callq  *%rax
  81c212:	21 c3                	and    %eax,%ebx
  81c214:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81c219:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  81c220:	00 00 00 
  81c223:	ff d0                	callq  *%rax
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81c225:	39 c3                	cmp    %eax,%ebx
  81c227:	75 18                	jne    81c241 <tcp_input+0x159>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c229:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c22d:	48 89 c7             	mov    %rax,%rdi
  81c230:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81c237:	00 00 00 
  81c23a:	ff d0                	callq  *%rax
    return;
  81c23c:	e9 70 0b 00 00       	jmpq   81cdb1 <tcp_input+0xcc9>

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
  81c241:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c245:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81c249:	0f b7 c8             	movzwl %ax,%ecx
      (struct ip_addr *)&(iphdr->dest),
  81c24c:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c253:	00 00 00 
  81c256:	48 8b 00             	mov    (%rax),%rax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81c259:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c25d:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c264:	00 00 00 
  81c267:	48 8b 00             	mov    (%rax),%rax
  81c26a:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  81c26e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c272:	41 89 c8             	mov    %ecx,%r8d
  81c275:	b9 06 00 00 00       	mov    $0x6,%ecx
  81c27a:	48 89 c7             	mov    %rax,%rdi
  81c27d:	48 b8 9a 24 81 00 00 	movabs $0x81249a,%rax
  81c284:	00 00 00 
  81c287:	ff d0                	callq  *%rax
  81c289:	66 85 c0             	test   %ax,%ax
  81c28c:	74 18                	je     81c2a6 <tcp_input+0x1be>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c28e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c292:	48 89 c7             	mov    %rax,%rdi
  81c295:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81c29c:	00 00 00 
  81c29f:	ff d0                	callq  *%rax
    return;
  81c2a1:	e9 0b 0b 00 00       	jmpq   81cdb1 <tcp_input+0xcc9>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  81c2a6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c2ad:	00 00 00 
  81c2b0:	48 8b 00             	mov    (%rax),%rax
  81c2b3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c2b7:	0f b7 c0             	movzwl %ax,%eax
  81c2ba:	89 c7                	mov    %eax,%edi
  81c2bc:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81c2c3:	00 00 00 
  81c2c6:	ff d0                	callq  *%rax
  81c2c8:	66 c1 e8 0c          	shr    $0xc,%ax
  81c2cc:	88 45 d6             	mov    %al,-0x2a(%rbp)
  if(pbuf_header(p, -(hdrlen * 4))){
  81c2cf:	0f b6 55 d6          	movzbl -0x2a(%rbp),%edx
  81c2d3:	b8 00 00 00 00       	mov    $0x0,%eax
  81c2d8:	29 d0                	sub    %edx,%eax
  81c2da:	c1 e0 02             	shl    $0x2,%eax
  81c2dd:	0f bf d0             	movswl %ax,%edx
  81c2e0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c2e4:	89 d6                	mov    %edx,%esi
  81c2e6:	48 89 c7             	mov    %rax,%rdi
  81c2e9:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  81c2f0:	00 00 00 
  81c2f3:	ff d0                	callq  *%rax
  81c2f5:	84 c0                	test   %al,%al
  81c2f7:	74 18                	je     81c311 <tcp_input+0x229>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c2f9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c2fd:	48 89 c7             	mov    %rax,%rdi
  81c300:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81c307:	00 00 00 
  81c30a:	ff d0                	callq  *%rax
    return;
  81c30c:	e9 a0 0a 00 00       	jmpq   81cdb1 <tcp_input+0xcc9>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  81c311:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c318:	00 00 00 
  81c31b:	48 8b 18             	mov    (%rax),%rbx
  81c31e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c325:	00 00 00 
  81c328:	48 8b 00             	mov    (%rax),%rax
  81c32b:	0f b7 00             	movzwl (%rax),%eax
  81c32e:	0f b7 c0             	movzwl %ax,%eax
  81c331:	89 c7                	mov    %eax,%edi
  81c333:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81c33a:	00 00 00 
  81c33d:	ff d0                	callq  *%rax
  81c33f:	66 89 03             	mov    %ax,(%rbx)
  tcphdr->dest = ntohs(tcphdr->dest);
  81c342:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c349:	00 00 00 
  81c34c:	48 8b 18             	mov    (%rax),%rbx
  81c34f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c356:	00 00 00 
  81c359:	48 8b 00             	mov    (%rax),%rax
  81c35c:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  81c360:	0f b7 c0             	movzwl %ax,%eax
  81c363:	89 c7                	mov    %eax,%edi
  81c365:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81c36c:	00 00 00 
  81c36f:	ff d0                	callq  *%rax
  81c371:	66 89 43 02          	mov    %ax,0x2(%rbx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  81c375:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c37c:	00 00 00 
  81c37f:	48 8b 18             	mov    (%rax),%rbx
  81c382:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c389:	00 00 00 
  81c38c:	48 8b 00             	mov    (%rax),%rax
  81c38f:	8b 40 04             	mov    0x4(%rax),%eax
  81c392:	89 c7                	mov    %eax,%edi
  81c394:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  81c39b:	00 00 00 
  81c39e:	ff d0                	callq  *%rax
  81c3a0:	89 43 04             	mov    %eax,0x4(%rbx)
  81c3a3:	8b 53 04             	mov    0x4(%rbx),%edx
  81c3a6:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81c3ad:	00 00 00 
  81c3b0:	89 10                	mov    %edx,(%rax)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  81c3b2:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c3b9:	00 00 00 
  81c3bc:	48 8b 18             	mov    (%rax),%rbx
  81c3bf:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c3c6:	00 00 00 
  81c3c9:	48 8b 00             	mov    (%rax),%rax
  81c3cc:	8b 40 08             	mov    0x8(%rax),%eax
  81c3cf:	89 c7                	mov    %eax,%edi
  81c3d1:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  81c3d8:	00 00 00 
  81c3db:	ff d0                	callq  *%rax
  81c3dd:	89 43 08             	mov    %eax,0x8(%rbx)
  81c3e0:	8b 53 08             	mov    0x8(%rbx),%edx
  81c3e3:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81c3ea:	00 00 00 
  81c3ed:	89 10                	mov    %edx,(%rax)
  tcphdr->wnd = ntohs(tcphdr->wnd);
  81c3ef:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c3f6:	00 00 00 
  81c3f9:	48 8b 18             	mov    (%rax),%rbx
  81c3fc:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c403:	00 00 00 
  81c406:	48 8b 00             	mov    (%rax),%rax
  81c409:	0f b7 40 0e          	movzwl 0xe(%rax),%eax
  81c40d:	0f b7 c0             	movzwl %ax,%eax
  81c410:	89 c7                	mov    %eax,%edi
  81c412:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81c419:	00 00 00 
  81c41c:	ff d0                	callq  *%rax
  81c41e:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  81c422:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c429:	00 00 00 
  81c42c:	48 8b 00             	mov    (%rax),%rax
  81c42f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c433:	0f b7 c0             	movzwl %ax,%eax
  81c436:	89 c7                	mov    %eax,%edi
  81c438:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81c43f:	00 00 00 
  81c442:	ff d0                	callq  *%rax
  81c444:	83 e0 3f             	and    $0x3f,%eax
  81c447:	89 c2                	mov    %eax,%edx
  81c449:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c450:	00 00 00 
  81c453:	88 10                	mov    %dl,(%rax)
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  81c455:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c459:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81c45d:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c464:	00 00 00 
  81c467:	0f b6 00             	movzbl (%rax),%eax
  81c46a:	0f b6 c0             	movzbl %al,%eax
  81c46d:	83 e0 01             	and    $0x1,%eax
  81c470:	85 c0                	test   %eax,%eax
  81c472:	75 17                	jne    81c48b <tcp_input+0x3a3>
  81c474:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c47b:	00 00 00 
  81c47e:	0f b6 00             	movzbl (%rax),%eax
  81c481:	0f b6 c0             	movzbl %al,%eax
  81c484:	83 e0 02             	and    $0x2,%eax
  81c487:	85 c0                	test   %eax,%eax
  81c489:	74 07                	je     81c492 <tcp_input+0x3aa>
  81c48b:	b8 01 00 00 00       	mov    $0x1,%eax
  81c490:	eb 05                	jmp    81c497 <tcp_input+0x3af>
  81c492:	b8 00 00 00 00       	mov    $0x0,%eax
  81c497:	01 c2                	add    %eax,%edx
  81c499:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81c4a0:	00 00 00 
  81c4a3:	66 89 10             	mov    %dx,(%rax)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  81c4a6:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81c4ad:	00 

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81c4ae:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c4b5:	00 00 00 
  81c4b8:	48 8b 00             	mov    (%rax),%rax
  81c4bb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c4bf:	e9 e4 01 00 00       	jmpq   81c6a8 <tcp_input+0x5c0>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  81c4c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c4c8:	8b 40 18             	mov    0x18(%rax),%eax
  81c4cb:	85 c0                	test   %eax,%eax
  81c4cd:	75 2a                	jne    81c4f9 <tcp_input+0x411>
  81c4cf:	48 ba 80 35 82 00 00 	movabs $0x823580,%rdx
  81c4d6:	00 00 00 
  81c4d9:	be b5 00 00 00       	mov    $0xb5,%esi
  81c4de:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81c4e5:	00 00 00 
  81c4e8:	b8 00 00 00 00       	mov    $0x0,%eax
  81c4ed:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81c4f4:	00 00 00 
  81c4f7:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81c4f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c4fd:	8b 40 18             	mov    0x18(%rax),%eax
  81c500:	83 f8 0a             	cmp    $0xa,%eax
  81c503:	75 2a                	jne    81c52f <tcp_input+0x447>
  81c505:	48 ba c0 35 82 00 00 	movabs $0x8235c0,%rdx
  81c50c:	00 00 00 
  81c50f:	be b6 00 00 00       	mov    $0xb6,%esi
  81c514:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81c51b:	00 00 00 
  81c51e:	b8 00 00 00 00       	mov    $0x0,%eax
  81c523:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81c52a:	00 00 00 
  81c52d:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  81c52f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c533:	8b 40 18             	mov    0x18(%rax),%eax
  81c536:	83 f8 01             	cmp    $0x1,%eax
  81c539:	75 2a                	jne    81c565 <tcp_input+0x47d>
  81c53b:	48 ba f0 35 82 00 00 	movabs $0x8235f0,%rdx
  81c542:	00 00 00 
  81c545:	be b7 00 00 00       	mov    $0xb7,%esi
  81c54a:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81c551:	00 00 00 
  81c554:	b8 00 00 00 00       	mov    $0x0,%eax
  81c559:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81c560:	00 00 00 
  81c563:	ff d1                	callq  *%rcx
    if (pcb->remote_port == tcphdr->src &&
  81c565:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c569:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81c56d:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c574:	00 00 00 
  81c577:	48 8b 00             	mov    (%rax),%rax
  81c57a:	0f b7 00             	movzwl (%rax),%eax
  81c57d:	66 39 c2             	cmp    %ax,%dx
  81c580:	0f 85 0e 01 00 00    	jne    81c694 <tcp_input+0x5ac>
       pcb->local_port == tcphdr->dest &&
  81c586:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c58a:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c58e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c595:	00 00 00 
  81c598:	48 8b 00             	mov    (%rax),%rax
  81c59b:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  81c59f:	66 39 c2             	cmp    %ax,%dx
  81c5a2:	0f 85 ec 00 00 00    	jne    81c694 <tcp_input+0x5ac>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c5a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c5ac:	8b 50 04             	mov    0x4(%rax),%edx
  81c5af:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c5b6:	00 00 00 
  81c5b9:	48 8b 00             	mov    (%rax),%rax
  81c5bc:	8b 40 0c             	mov    0xc(%rax),%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
  81c5bf:	39 c2                	cmp    %eax,%edx
  81c5c1:	0f 85 cd 00 00 00    	jne    81c694 <tcp_input+0x5ac>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81c5c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c5cb:	8b 10                	mov    (%rax),%edx
  81c5cd:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c5d4:	00 00 00 
  81c5d7:	48 8b 00             	mov    (%rax),%rax
  81c5da:	8b 40 10             	mov    0x10(%rax),%eax
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c5dd:	39 c2                	cmp    %eax,%edx
  81c5df:	0f 85 af 00 00 00    	jne    81c694 <tcp_input+0x5ac>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  81c5e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c5e9:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c5ed:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81c5f1:	75 2a                	jne    81c61d <tcp_input+0x535>
  81c5f3:	48 ba 18 36 82 00 00 	movabs $0x823618,%rdx
  81c5fa:	00 00 00 
  81c5fd:	be c0 00 00 00       	mov    $0xc0,%esi
  81c602:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81c609:	00 00 00 
  81c60c:	b8 00 00 00 00       	mov    $0x0,%eax
  81c611:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81c618:	00 00 00 
  81c61b:	ff d1                	callq  *%rcx
      if (prev != NULL) {
  81c61d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81c622:	74 36                	je     81c65a <tcp_input+0x572>
        prev->next = pcb->next;
  81c624:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c628:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c62c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81c630:	48 89 50 10          	mov    %rdx,0x10(%rax)
        pcb->next = tcp_active_pcbs;
  81c634:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c63b:	00 00 00 
  81c63e:	48 8b 10             	mov    (%rax),%rdx
  81c641:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c645:	48 89 50 10          	mov    %rdx,0x10(%rax)
        tcp_active_pcbs = pcb;
  81c649:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c650:	00 00 00 
  81c653:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c657:	48 89 10             	mov    %rdx,(%rax)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  81c65a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c65e:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c662:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81c666:	75 2a                	jne    81c692 <tcp_input+0x5aa>
  81c668:	48 ba 48 36 82 00 00 	movabs $0x823648,%rdx
  81c66f:	00 00 00 
  81c672:	be c6 00 00 00       	mov    $0xc6,%esi
  81c677:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81c67e:	00 00 00 
  81c681:	b8 00 00 00 00       	mov    $0x0,%eax
  81c686:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81c68d:	00 00 00 
  81c690:	ff d1                	callq  *%rcx
      break;
  81c692:	eb 1f                	jmp    81c6b3 <tcp_input+0x5cb>
    }
    prev = pcb;
  81c694:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c698:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81c69c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c6a0:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c6a4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c6a8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c6ad:	0f 85 11 fe ff ff    	jne    81c4c4 <tcp_input+0x3dc>
      break;
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  81c6b3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c6b8:	0f 85 f2 01 00 00    	jne    81c8b0 <tcp_input+0x7c8>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81c6be:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81c6c5:	00 00 00 
  81c6c8:	48 8b 00             	mov    (%rax),%rax
  81c6cb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c6cf:	e9 dd 00 00 00       	jmpq   81c7b1 <tcp_input+0x6c9>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  81c6d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c6d8:	8b 40 18             	mov    0x18(%rax),%eax
  81c6db:	83 f8 0a             	cmp    $0xa,%eax
  81c6de:	74 2a                	je     81c70a <tcp_input+0x622>
  81c6e0:	48 ba 78 36 82 00 00 	movabs $0x823678,%rdx
  81c6e7:	00 00 00 
  81c6ea:	be d0 00 00 00       	mov    $0xd0,%esi
  81c6ef:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81c6f6:	00 00 00 
  81c6f9:	b8 00 00 00 00       	mov    $0x0,%eax
  81c6fe:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81c705:	00 00 00 
  81c708:	ff d1                	callq  *%rcx
      if (pcb->remote_port == tcphdr->src &&
  81c70a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c70e:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81c712:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c719:	00 00 00 
  81c71c:	48 8b 00             	mov    (%rax),%rax
  81c71f:	0f b7 00             	movzwl (%rax),%eax
  81c722:	66 39 c2             	cmp    %ax,%dx
  81c725:	75 7e                	jne    81c7a5 <tcp_input+0x6bd>
         pcb->local_port == tcphdr->dest &&
  81c727:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c72b:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c72f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c736:	00 00 00 
  81c739:	48 8b 00             	mov    (%rax),%rax
  81c73c:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  81c740:	66 39 c2             	cmp    %ax,%dx
  81c743:	75 60                	jne    81c7a5 <tcp_input+0x6bd>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c745:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c749:	8b 50 04             	mov    0x4(%rax),%edx
  81c74c:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c753:	00 00 00 
  81c756:	48 8b 00             	mov    (%rax),%rax
  81c759:	8b 40 0c             	mov    0xc(%rax),%eax
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
  81c75c:	39 c2                	cmp    %eax,%edx
  81c75e:	75 45                	jne    81c7a5 <tcp_input+0x6bd>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81c760:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c764:	8b 10                	mov    (%rax),%edx
  81c766:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c76d:	00 00 00 
  81c770:	48 8b 00             	mov    (%rax),%rax
  81c773:	8b 40 10             	mov    0x10(%rax),%eax
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c776:	39 c2                	cmp    %eax,%edx
  81c778:	75 2b                	jne    81c7a5 <tcp_input+0x6bd>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
  81c77a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c77e:	48 89 c7             	mov    %rax,%rdi
  81c781:	48 b8 b7 d0 81 00 00 	movabs $0x81d0b7,%rax
  81c788:	00 00 00 
  81c78b:	ff d0                	callq  *%rax
        pbuf_free(p);
  81c78d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c791:	48 89 c7             	mov    %rax,%rdi
  81c794:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81c79b:	00 00 00 
  81c79e:	ff d0                	callq  *%rax
        return;
  81c7a0:	e9 0c 06 00 00       	jmpq   81cdb1 <tcp_input+0xcc9>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81c7a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c7a9:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c7ad:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c7b1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c7b6:	0f 85 18 ff ff ff    	jne    81c6d4 <tcp_input+0x5ec>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  81c7bc:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81c7c3:	00 
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81c7c4:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81c7cb:	00 00 00 
  81c7ce:	48 8b 00             	mov    (%rax),%rax
  81c7d1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81c7d5:	e9 cb 00 00 00       	jmpq   81c8a5 <tcp_input+0x7bd>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81c7da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c7de:	48 85 c0             	test   %rax,%rax
  81c7e1:	74 28                	je     81c80b <tcp_input+0x723>
  81c7e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c7e7:	8b 00                	mov    (%rax),%eax
  81c7e9:	85 c0                	test   %eax,%eax
  81c7eb:	74 1e                	je     81c80b <tcp_input+0x723>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81c7ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c7f1:	8b 10                	mov    (%rax),%edx
  81c7f3:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c7fa:	00 00 00 
  81c7fd:	48 8b 00             	mov    (%rax),%rax
  81c800:	8b 40 10             	mov    0x10(%rax),%eax

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81c803:	39 c2                	cmp    %eax,%edx
  81c805:	0f 85 86 00 00 00    	jne    81c891 <tcp_input+0x7a9>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
  81c80b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c80f:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c813:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c81a:	00 00 00 
  81c81d:	48 8b 00             	mov    (%rax),%rax
  81c820:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81c824:	66 39 c2             	cmp    %ax,%dx
  81c827:	75 68                	jne    81c891 <tcp_input+0x7a9>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  81c829:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81c82e:	74 36                	je     81c866 <tcp_input+0x77e>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  81c830:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c834:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c838:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81c83c:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  81c840:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81c847:	00 00 00 
  81c84a:	48 8b 10             	mov    (%rax),%rdx
  81c84d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c851:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  81c855:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81c85c:	00 00 00 
  81c85f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81c863:	48 89 10             	mov    %rdx,(%rax)
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
  81c866:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c86a:	48 89 c7             	mov    %rax,%rdi
  81c86d:	48 b8 b8 cd 81 00 00 	movabs $0x81cdb8,%rax
  81c874:	00 00 00 
  81c877:	ff d0                	callq  *%rax
        pbuf_free(p);
  81c879:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c87d:	48 89 c7             	mov    %rax,%rdi
  81c880:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81c887:	00 00 00 
  81c88a:	ff d0                	callq  *%rax
        return;
  81c88c:	e9 20 05 00 00       	jmpq   81cdb1 <tcp_input+0xcc9>
      }
      prev = (struct tcp_pcb *)lpcb;
  81c891:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c895:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81c899:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c89d:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c8a1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81c8a5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81c8aa:	0f 85 2a ff ff ff    	jne    81c7da <tcp_input+0x6f2>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  81c8b0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c8b5:	0f 84 2b 04 00 00    	je     81cce6 <tcp_input+0xbfe>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  81c8bb:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81c8c2:	00 00 00 
  81c8c5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    inseg.len = p->tot_len;
  81c8cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c8d0:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81c8d4:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81c8db:	00 00 00 
  81c8de:	66 89 50 18          	mov    %dx,0x18(%rax)
    inseg.dataptr = p->payload;
  81c8e2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c8e6:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81c8ea:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81c8f1:	00 00 00 
  81c8f4:	48 89 50 10          	mov    %rdx,0x10(%rax)
    inseg.p = p;
  81c8f8:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81c8ff:	00 00 00 
  81c902:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81c906:	48 89 50 08          	mov    %rdx,0x8(%rax)
    inseg.tcphdr = tcphdr;
  81c90a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c911:	00 00 00 
  81c914:	48 8b 10             	mov    (%rax),%rdx
  81c917:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81c91e:	00 00 00 
  81c921:	48 89 50 20          	mov    %rdx,0x20(%rax)

    recv_data = NULL;
  81c925:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81c92c:	00 00 00 
  81c92f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    recv_flags = 0;
  81c936:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81c93d:	00 00 00 
  81c940:	c6 00 00             	movb   $0x0,(%rax)

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  81c943:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c947:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81c94e:	48 85 c0             	test   %rax,%rax
  81c951:	0f 84 9b 00 00 00    	je     81c9f2 <tcp_input+0x90a>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81c957:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c95b:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81c962:	48 85 c0             	test   %rax,%rax
  81c965:	74 2e                	je     81c995 <tcp_input+0x8ad>
  81c967:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c96b:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81c972:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c976:	48 8b 92 98 00 00 00 	mov    0x98(%rdx),%rdx
  81c97d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81c981:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81c985:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81c989:	b9 00 00 00 00       	mov    $0x0,%ecx
  81c98e:	ff d0                	callq  *%rax
  81c990:	88 45 d7             	mov    %al,-0x29(%rbp)
  81c993:	eb 2e                	jmp    81c9c3 <tcp_input+0x8db>
  81c995:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81c999:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c99d:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81c9a4:	48 85 c0             	test   %rax,%rax
  81c9a7:	74 1a                	je     81c9c3 <tcp_input+0x8db>
  81c9a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9ad:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81c9b4:	48 89 c7             	mov    %rax,%rdi
  81c9b7:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81c9be:	00 00 00 
  81c9c1:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  81c9c3:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81c9c7:	75 11                	jne    81c9da <tcp_input+0x8f2>
        pcb->refused_data = NULL;
  81c9c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9cd:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  81c9d4:	00 00 00 00 
  81c9d8:	eb 18                	jmp    81c9f2 <tcp_input+0x90a>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  81c9da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c9de:	48 89 c7             	mov    %rax,%rdi
  81c9e1:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81c9e8:	00 00 00 
  81c9eb:	ff d0                	callq  *%rax
        return;
  81c9ed:	e9 bf 03 00 00       	jmpq   81cdb1 <tcp_input+0xcc9>
      }
    }

    tcp_input_pcb = pcb;
  81c9f2:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81c9f9:	00 00 00 
  81c9fc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81ca00:	48 89 10             	mov    %rdx,(%rax)
    err = tcp_process(pcb);
  81ca03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca07:	48 89 c7             	mov    %rax,%rdi
  81ca0a:	48 b8 63 d1 81 00 00 	movabs $0x81d163,%rax
  81ca11:	00 00 00 
  81ca14:	ff d0                	callq  *%rax
  81ca16:	88 45 d7             	mov    %al,-0x29(%rbp)
    tcp_input_pcb = NULL;
  81ca19:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81ca20:	00 00 00 
  81ca23:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
  81ca2a:	80 7d d7 fb          	cmpb   $0xfb,-0x29(%rbp)
  81ca2e:	0f 84 67 02 00 00    	je     81cc9b <tcp_input+0xbb3>
      if (recv_flags & TF_RESET) {
  81ca34:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81ca3b:	00 00 00 
  81ca3e:	0f b6 00             	movzbl (%rax),%eax
  81ca41:	0f b6 c0             	movzbl %al,%eax
  81ca44:	83 e0 08             	and    $0x8,%eax
  81ca47:	85 c0                	test   %eax,%eax
  81ca49:	74 67                	je     81cab2 <tcp_input+0x9ca>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  81ca4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca4f:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81ca56:	48 85 c0             	test   %rax,%rax
  81ca59:	74 1d                	je     81ca78 <tcp_input+0x990>
  81ca5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca5f:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81ca66:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81ca6a:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  81ca6e:	be fa ff ff ff       	mov    $0xfffffffa,%esi
  81ca73:	48 89 d7             	mov    %rdx,%rdi
  81ca76:	ff d0                	callq  *%rax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81ca78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca7c:	48 89 c6             	mov    %rax,%rsi
  81ca7f:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81ca86:	00 00 00 
  81ca89:	48 b8 78 07 81 00 00 	movabs $0x810778,%rax
  81ca90:	00 00 00 
  81ca93:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81ca95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca99:	48 89 c6             	mov    %rax,%rsi
  81ca9c:	bf 02 00 00 00       	mov    $0x2,%edi
  81caa1:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81caa8:	00 00 00 
  81caab:	ff d0                	callq  *%rax
  81caad:	e9 e9 01 00 00       	jmpq   81cc9b <tcp_input+0xbb3>
      } else if (recv_flags & TF_CLOSED) {
  81cab2:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cab9:	00 00 00 
  81cabc:	0f b6 00             	movzbl (%rax),%eax
  81cabf:	0f b6 c0             	movzbl %al,%eax
  81cac2:	83 e0 10             	and    $0x10,%eax
  81cac5:	85 c0                	test   %eax,%eax
  81cac7:	74 3a                	je     81cb03 <tcp_input+0xa1b>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81cac9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cacd:	48 89 c6             	mov    %rax,%rsi
  81cad0:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81cad7:	00 00 00 
  81cada:	48 b8 78 07 81 00 00 	movabs $0x810778,%rax
  81cae1:	00 00 00 
  81cae4:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81cae6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81caea:	48 89 c6             	mov    %rax,%rsi
  81caed:	bf 02 00 00 00       	mov    $0x2,%edi
  81caf2:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81caf9:	00 00 00 
  81cafc:	ff d0                	callq  *%rax
  81cafe:	e9 98 01 00 00       	jmpq   81cc9b <tcp_input+0xbb3>
      } else {
        err = ERR_OK;
  81cb03:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  81cb07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb0b:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81cb0f:	66 85 c0             	test   %ax,%ax
  81cb12:	74 3a                	je     81cb4e <tcp_input+0xa66>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  81cb14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb18:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81cb1f:	48 85 c0             	test   %rax,%rax
  81cb22:	74 2a                	je     81cb4e <tcp_input+0xa66>
  81cb24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb28:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81cb2f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cb33:	0f b7 52 78          	movzwl 0x78(%rdx),%edx
  81cb37:	0f b7 d2             	movzwl %dx,%edx
  81cb3a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81cb3e:	48 8b 49 20          	mov    0x20(%rcx),%rcx
  81cb42:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81cb46:	48 89 cf             	mov    %rcx,%rdi
  81cb49:	ff d0                	callq  *%rax
  81cb4b:	88 45 d7             	mov    %al,-0x29(%rbp)
        }
      
        if (recv_data != NULL) {
  81cb4e:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cb55:	00 00 00 
  81cb58:	48 8b 00             	mov    (%rax),%rax
  81cb5b:	48 85 c0             	test   %rax,%rax
  81cb5e:	0f 84 cb 00 00 00    	je     81cc2f <tcp_input+0xb47>
          if(flags & TCP_PSH) {
  81cb64:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81cb6b:	00 00 00 
  81cb6e:	0f b6 00             	movzbl (%rax),%eax
  81cb71:	0f b6 c0             	movzbl %al,%eax
  81cb74:	83 e0 08             	and    $0x8,%eax
  81cb77:	85 c0                	test   %eax,%eax
  81cb79:	74 24                	je     81cb9f <tcp_input+0xab7>
            recv_data->flags |= PBUF_FLAG_PUSH;
  81cb7b:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cb82:	00 00 00 
  81cb85:	48 8b 00             	mov    (%rax),%rax
  81cb88:	48 ba e8 74 b5 00 00 	movabs $0xb574e8,%rdx
  81cb8f:	00 00 00 
  81cb92:	48 8b 12             	mov    (%rdx),%rdx
  81cb95:	0f b6 52 15          	movzbl 0x15(%rdx),%edx
  81cb99:	83 ca 01             	or     $0x1,%edx
  81cb9c:	88 50 15             	mov    %dl,0x15(%rax)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81cb9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cba3:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cbaa:	48 85 c0             	test   %rax,%rax
  81cbad:	74 30                	je     81cbdf <tcp_input+0xaf7>
  81cbaf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbb3:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cbba:	48 ba e8 74 b5 00 00 	movabs $0xb574e8,%rdx
  81cbc1:	00 00 00 
  81cbc4:	48 8b 12             	mov    (%rdx),%rdx
  81cbc7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81cbcb:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81cbcf:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81cbd3:	b9 00 00 00 00       	mov    $0x0,%ecx
  81cbd8:	ff d0                	callq  *%rax
  81cbda:	88 45 d7             	mov    %al,-0x29(%rbp)
  81cbdd:	eb 32                	jmp    81cc11 <tcp_input+0xb29>
  81cbdf:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81cbe3:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cbea:	00 00 00 
  81cbed:	48 8b 00             	mov    (%rax),%rax
  81cbf0:	48 85 c0             	test   %rax,%rax
  81cbf3:	74 1c                	je     81cc11 <tcp_input+0xb29>
  81cbf5:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cbfc:	00 00 00 
  81cbff:	48 8b 00             	mov    (%rax),%rax
  81cc02:	48 89 c7             	mov    %rax,%rdi
  81cc05:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81cc0c:	00 00 00 
  81cc0f:	ff d0                	callq  *%rax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  81cc11:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81cc15:	74 18                	je     81cc2f <tcp_input+0xb47>
            pcb->refused_data = recv_data;
  81cc17:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cc1e:	00 00 00 
  81cc21:	48 8b 10             	mov    (%rax),%rdx
  81cc24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc28:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  81cc2f:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cc36:	00 00 00 
  81cc39:	0f b6 00             	movzbl (%rax),%eax
  81cc3c:	0f b6 c0             	movzbl %al,%eax
  81cc3f:	83 e0 20             	and    $0x20,%eax
  81cc42:	85 c0                	test   %eax,%eax
  81cc44:	74 3c                	je     81cc82 <tcp_input+0xb9a>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81cc46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc4a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cc51:	48 85 c0             	test   %rax,%rax
  81cc54:	74 28                	je     81cc7e <tcp_input+0xb96>
  81cc56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc5a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cc61:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cc65:	48 8b 7a 20          	mov    0x20(%rdx),%rdi
  81cc69:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81cc6d:	b9 00 00 00 00       	mov    $0x0,%ecx
  81cc72:	ba 00 00 00 00       	mov    $0x0,%edx
  81cc77:	ff d0                	callq  *%rax
  81cc79:	88 45 d7             	mov    %al,-0x29(%rbp)
  81cc7c:	eb 04                	jmp    81cc82 <tcp_input+0xb9a>
  81cc7e:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  81cc82:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81cc86:	75 13                	jne    81cc9b <tcp_input+0xbb3>
          tcp_output(pcb);
  81cc88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc8c:	48 89 c7             	mov    %rax,%rdi
  81cc8f:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81cc96:	00 00 00 
  81cc99:	ff d0                	callq  *%rax
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81cc9b:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cca2:	00 00 00 
  81cca5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81cca9:	48 85 c0             	test   %rax,%rax
  81ccac:	0f 84 ff 00 00 00    	je     81cdb1 <tcp_input+0xcc9>
    {
      pbuf_free(inseg.p);
  81ccb2:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ccb9:	00 00 00 
  81ccbc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ccc0:	48 89 c7             	mov    %rax,%rdi
  81ccc3:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81ccca:	00 00 00 
  81cccd:	ff d0                	callq  *%rax
      inseg.p = NULL;
  81cccf:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ccd6:	00 00 00 
  81ccd9:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81cce0:	00 
  81cce1:	e9 cb 00 00 00       	jmpq   81cdb1 <tcp_input+0xcc9>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  81cce6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cced:	00 00 00 
  81ccf0:	48 8b 00             	mov    (%rax),%rax
  81ccf3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ccf7:	0f b7 c0             	movzwl %ax,%eax
  81ccfa:	89 c7                	mov    %eax,%edi
  81ccfc:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81cd03:	00 00 00 
  81cd06:	ff d0                	callq  *%rax
  81cd08:	0f b7 c0             	movzwl %ax,%eax
  81cd0b:	83 e0 04             	and    $0x4,%eax
  81cd0e:	85 c0                	test   %eax,%eax
  81cd10:	0f 85 88 00 00 00    	jne    81cd9e <tcp_input+0xcb6>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81cd16:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cd1d:	00 00 00 
  81cd20:	48 8b 00             	mov    (%rax),%rax
  81cd23:	0f b7 00             	movzwl (%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cd26:	44 0f b7 c0          	movzwl %ax,%r8d
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81cd2a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cd31:	00 00 00 
  81cd34:	48 8b 00             	mov    (%rax),%rax
  81cd37:	0f b7 40 02          	movzwl 0x2(%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cd3b:	0f b7 f8             	movzwl %ax,%edi
        &(iphdr->dest), &(iphdr->src),
  81cd3e:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cd45:	00 00 00 
  81cd48:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cd4b:	48 8d 48 0c          	lea    0xc(%rax),%rcx
        &(iphdr->dest), &(iphdr->src),
  81cd4f:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cd56:	00 00 00 
  81cd59:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cd5c:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81cd60:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81cd67:	00 00 00 
  81cd6a:	0f b7 00             	movzwl (%rax),%eax
  81cd6d:	0f b7 f0             	movzwl %ax,%esi
  81cd70:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81cd77:	00 00 00 
  81cd7a:	8b 00                	mov    (%rax),%eax
  81cd7c:	01 c6                	add    %eax,%esi
  81cd7e:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81cd85:	00 00 00 
  81cd88:	8b 00                	mov    (%rax),%eax
  81cd8a:	45 89 c1             	mov    %r8d,%r9d
  81cd8d:	41 89 f8             	mov    %edi,%r8d
  81cd90:	89 c7                	mov    %eax,%edi
  81cd92:	48 b8 17 42 81 00 00 	movabs $0x814217,%rax
  81cd99:	00 00 00 
  81cd9c:	ff d0                	callq  *%rax
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  81cd9e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cda2:	48 89 c7             	mov    %rax,%rdi
  81cda5:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81cdac:	00 00 00 
  81cdaf:	ff d0                	callq  *%rax
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  81cdb1:	48 83 c4 38          	add    $0x38,%rsp
  81cdb5:	5b                   	pop    %rbx
  81cdb6:	5d                   	pop    %rbp
  81cdb7:	c3                   	retq   

000000000081cdb8 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  81cdb8:	55                   	push   %rbp
  81cdb9:	48 89 e5             	mov    %rsp,%rbp
  81cdbc:	48 83 ec 20          	sub    $0x20,%rsp
  81cdc0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  81cdc4:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81cdcb:	00 00 00 
  81cdce:	0f b6 00             	movzbl (%rax),%eax
  81cdd1:	0f b6 c0             	movzbl %al,%eax
  81cdd4:	83 e0 10             	and    $0x10,%eax
  81cdd7:	85 c0                	test   %eax,%eax
  81cdd9:	0f 84 90 00 00 00    	je     81ce6f <tcp_listen_input+0xb7>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81cddf:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cde6:	00 00 00 
  81cde9:	48 8b 00             	mov    (%rax),%rax
  81cdec:	0f b7 00             	movzwl (%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81cdef:	44 0f b7 c0          	movzwl %ax,%r8d
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81cdf3:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cdfa:	00 00 00 
  81cdfd:	48 8b 00             	mov    (%rax),%rax
  81ce00:	0f b7 40 02          	movzwl 0x2(%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81ce04:	0f b7 f8             	movzwl %ax,%edi
      &(iphdr->dest), &(iphdr->src),
  81ce07:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81ce0e:	00 00 00 
  81ce11:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81ce14:	48 8d 48 0c          	lea    0xc(%rax),%rcx
      &(iphdr->dest), &(iphdr->src),
  81ce18:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81ce1f:	00 00 00 
  81ce22:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81ce25:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81ce29:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ce30:	00 00 00 
  81ce33:	0f b7 00             	movzwl (%rax),%eax
  81ce36:	0f b7 f0             	movzwl %ax,%esi
  81ce39:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ce40:	00 00 00 
  81ce43:	8b 00                	mov    (%rax),%eax
  81ce45:	01 c6                	add    %eax,%esi
  81ce47:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81ce4e:	00 00 00 
  81ce51:	8b 00                	mov    (%rax),%eax
  81ce53:	83 c0 01             	add    $0x1,%eax
  81ce56:	45 89 c1             	mov    %r8d,%r9d
  81ce59:	41 89 f8             	mov    %edi,%r8d
  81ce5c:	89 c7                	mov    %eax,%edi
  81ce5e:	48 b8 17 42 81 00 00 	movabs $0x814217,%rax
  81ce65:	00 00 00 
  81ce68:	ff d0                	callq  *%rax
  81ce6a:	e9 41 02 00 00       	jmpq   81d0b0 <tcp_listen_input+0x2f8>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  81ce6f:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81ce76:	00 00 00 
  81ce79:	0f b6 00             	movzbl (%rax),%eax
  81ce7c:	0f b6 c0             	movzbl %al,%eax
  81ce7f:	83 e0 02             	and    $0x2,%eax
  81ce82:	85 c0                	test   %eax,%eax
  81ce84:	0f 84 26 02 00 00    	je     81d0b0 <tcp_listen_input+0x2f8>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  81ce8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce8e:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81ce92:	0f b6 c0             	movzbl %al,%eax
  81ce95:	89 c7                	mov    %eax,%edi
  81ce97:	48 b8 e3 03 81 00 00 	movabs $0x8103e3,%rax
  81ce9e:	00 00 00 
  81cea1:	ff d0                	callq  *%rax
  81cea3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  81cea7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ceac:	75 0a                	jne    81ceb8 <tcp_listen_input+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
  81ceae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81ceb3:	e9 fd 01 00 00       	jmpq   81d0b5 <tcp_listen_input+0x2fd>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  81ceb8:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cebf:	00 00 00 
  81cec2:	48 8b 00             	mov    (%rax),%rax
  81cec5:	48 83 c0 10          	add    $0x10,%rax
  81cec9:	48 85 c0             	test   %rax,%rax
  81cecc:	74 12                	je     81cee0 <tcp_listen_input+0x128>
  81cece:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81ced5:	00 00 00 
  81ced8:	48 8b 00             	mov    (%rax),%rax
  81cedb:	8b 40 10             	mov    0x10(%rax),%eax
  81cede:	eb 05                	jmp    81cee5 <tcp_listen_input+0x12d>
  81cee0:	b8 00 00 00 00       	mov    $0x0,%eax
  81cee5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81cee9:	89 02                	mov    %eax,(%rdx)
    npcb->local_port = pcb->local_port;
  81ceeb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ceef:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81cef3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cef7:	66 89 50 28          	mov    %dx,0x28(%rax)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  81cefb:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cf02:	00 00 00 
  81cf05:	48 8b 00             	mov    (%rax),%rax
  81cf08:	48 83 c0 0c          	add    $0xc,%rax
  81cf0c:	48 85 c0             	test   %rax,%rax
  81cf0f:	74 12                	je     81cf23 <tcp_listen_input+0x16b>
  81cf11:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cf18:	00 00 00 
  81cf1b:	48 8b 00             	mov    (%rax),%rax
  81cf1e:	8b 40 0c             	mov    0xc(%rax),%eax
  81cf21:	eb 05                	jmp    81cf28 <tcp_listen_input+0x170>
  81cf23:	b8 00 00 00 00       	mov    $0x0,%eax
  81cf28:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81cf2c:	89 42 04             	mov    %eax,0x4(%rdx)
    npcb->remote_port = tcphdr->src;
  81cf2f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cf36:	00 00 00 
  81cf39:	48 8b 00             	mov    (%rax),%rax
  81cf3c:	0f b7 10             	movzwl (%rax),%edx
  81cf3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf43:	66 89 50 2a          	mov    %dx,0x2a(%rax)
    npcb->state = SYN_RCVD;
  81cf47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf4b:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%rax)
    npcb->rcv_nxt = seqno + 1;
  81cf52:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81cf59:	00 00 00 
  81cf5c:	8b 00                	mov    (%rax),%eax
  81cf5e:	8d 50 01             	lea    0x1(%rax),%edx
  81cf61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf65:	89 50 30             	mov    %edx,0x30(%rax)
    npcb->snd_wnd = tcphdr->wnd;
  81cf68:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cf6f:	00 00 00 
  81cf72:	48 8b 00             	mov    (%rax),%rax
  81cf75:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81cf79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf7d:	66 89 50 68          	mov    %dx,0x68(%rax)
    npcb->ssthresh = npcb->snd_wnd;
  81cf81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf85:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  81cf89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf8d:	66 89 50 5c          	mov    %dx,0x5c(%rax)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  81cf91:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81cf98:	00 00 00 
  81cf9b:	8b 00                	mov    (%rax),%eax
  81cf9d:	8d 50 ff             	lea    -0x1(%rax),%edx
  81cfa0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cfa4:	89 50 6c             	mov    %edx,0x6c(%rax)
    npcb->callback_arg = pcb->callback_arg;
  81cfa7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cfab:	48 8b 50 20          	mov    0x20(%rax),%rdx
  81cfaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cfb3:	48 89 50 20          	mov    %rdx,0x20(%rax)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  81cfb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cfbb:	48 8b 50 30          	mov    0x30(%rax),%rdx
  81cfbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cfc3:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  81cfca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cfce:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81cfd2:	66 25 99 01          	and    $0x199,%ax
  81cfd6:	89 c2                	mov    %eax,%edx
  81cfd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cfdc:	66 89 50 08          	mov    %dx,0x8(%rax)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  81cfe0:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81cfe7:	00 00 00 
  81cfea:	48 8b 10             	mov    (%rax),%rdx
  81cfed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cff1:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81cff5:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81cffc:	00 00 00 
  81cfff:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d003:	48 89 10             	mov    %rdx,(%rax)
  81d006:	48 b8 c0 83 80 00 00 	movabs $0x8083c0,%rax
  81d00d:	00 00 00 
  81d010:	ff d0                	callq  *%rax

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  81d012:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d016:	48 89 c7             	mov    %rax,%rdi
  81d019:	48 b8 99 f8 81 00 00 	movabs $0x81f899,%rax
  81d020:	00 00 00 
  81d023:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  81d025:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d029:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81d02d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d031:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d035:	0f b7 c0             	movzwl %ax,%eax
  81d038:	48 89 d6             	mov    %rdx,%rsi
  81d03b:	89 c7                	mov    %eax,%edi
  81d03d:	48 b8 ad 09 81 00 00 	movabs $0x8109ad,%rax
  81d044:	00 00 00 
  81d047:	ff d0                	callq  *%rax
  81d049:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d04d:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  81d051:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  81d056:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  81d05d:	00 00 00 
  81d060:	ff d0                	callq  *%rax
  81d062:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  81d065:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  81d069:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d06d:	c7 04 24 04 00 00 00 	movl   $0x4,(%rsp)
  81d074:	49 89 d1             	mov    %rdx,%r9
  81d077:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  81d07d:	b9 12 00 00 00       	mov    $0x12,%ecx
  81d082:	ba 00 00 00 00       	mov    $0x0,%edx
  81d087:	be 00 00 00 00       	mov    $0x0,%esi
  81d08c:	48 89 c7             	mov    %rax,%rdi
  81d08f:	48 b8 56 2e 81 00 00 	movabs $0x812e56,%rax
  81d096:	00 00 00 
  81d099:	ff d0                	callq  *%rax
    return tcp_output(npcb);
  81d09b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d09f:	48 89 c7             	mov    %rax,%rdi
  81d0a2:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81d0a9:	00 00 00 
  81d0ac:	ff d0                	callq  *%rax
  81d0ae:	eb 05                	jmp    81d0b5 <tcp_listen_input+0x2fd>
  }
  return ERR_OK;
  81d0b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81d0b5:	c9                   	leaveq 
  81d0b6:	c3                   	retq   

000000000081d0b7 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  81d0b7:	55                   	push   %rbp
  81d0b8:	48 89 e5             	mov    %rsp,%rbp
  81d0bb:	48 83 ec 10          	sub    $0x10,%rsp
  81d0bf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  81d0c3:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d0ca:	00 00 00 
  81d0cd:	0f b7 00             	movzwl (%rax),%eax
  81d0d0:	0f b7 d0             	movzwl %ax,%edx
  81d0d3:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d0da:	00 00 00 
  81d0dd:	8b 00                	mov    (%rax),%eax
  81d0df:	01 c2                	add    %eax,%edx
  81d0e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d0e5:	8b 40 30             	mov    0x30(%rax),%eax
  81d0e8:	29 c2                	sub    %eax,%edx
  81d0ea:	89 d0                	mov    %edx,%eax
  81d0ec:	85 c0                	test   %eax,%eax
  81d0ee:	7e 25                	jle    81d115 <tcp_timewait_input+0x5e>
    pcb->rcv_nxt = seqno + tcplen;
  81d0f0:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d0f7:	00 00 00 
  81d0fa:	0f b7 00             	movzwl (%rax),%eax
  81d0fd:	0f b7 d0             	movzwl %ax,%edx
  81d100:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d107:	00 00 00 
  81d10a:	8b 00                	mov    (%rax),%eax
  81d10c:	01 c2                	add    %eax,%edx
  81d10e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d112:	89 50 30             	mov    %edx,0x30(%rax)
  }
  if (tcplen > 0) {
  81d115:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d11c:	00 00 00 
  81d11f:	0f b7 00             	movzwl (%rax),%eax
  81d122:	66 85 c0             	test   %ax,%ax
  81d125:	74 27                	je     81d14e <tcp_timewait_input+0x97>
    tcp_ack_now(pcb);
  81d127:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d12b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d12f:	83 c8 02             	or     $0x2,%eax
  81d132:	89 c2                	mov    %eax,%edx
  81d134:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d138:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d13b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d13f:	48 89 c7             	mov    %rax,%rdi
  81d142:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81d149:	00 00 00 
  81d14c:	ff d0                	callq  *%rax
  }
  return tcp_output(pcb);
  81d14e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d152:	48 89 c7             	mov    %rax,%rdi
  81d155:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81d15c:	00 00 00 
  81d15f:	ff d0                	callq  *%rax
}
  81d161:	c9                   	leaveq 
  81d162:	c3                   	retq   

000000000081d163 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  81d163:	55                   	push   %rbp
  81d164:	48 89 e5             	mov    %rsp,%rbp
  81d167:	48 83 ec 30          	sub    $0x30,%rsp
  81d16b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  81d16f:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  err_t err;
  u8_t accepted_inseq;

  err = ERR_OK;
  81d173:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  81d177:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d17e:	00 00 00 
  81d181:	0f b6 00             	movzbl (%rax),%eax
  81d184:	0f b6 c0             	movzbl %al,%eax
  81d187:	83 e0 04             	and    $0x4,%eax
  81d18a:	85 c0                	test   %eax,%eax
  81d18c:	0f 84 e0 00 00 00    	je     81d272 <tcp_process+0x10f>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  81d192:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d196:	8b 40 18             	mov    0x18(%rax),%eax
  81d199:	83 f8 02             	cmp    $0x2,%eax
  81d19c:	75 1d                	jne    81d1bb <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
  81d19e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1a2:	8b 50 60             	mov    0x60(%rax),%edx
  81d1a5:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d1ac:	00 00 00 
  81d1af:	8b 00                	mov    (%rax),%eax
  81d1b1:	39 c2                	cmp    %eax,%edx
  81d1b3:	75 4d                	jne    81d202 <tcp_process+0x9f>
        acceptable = 1;
  81d1b5:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  81d1b9:	eb 47                	jmp    81d202 <tcp_process+0x9f>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81d1bb:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d1c2:	00 00 00 
  81d1c5:	8b 10                	mov    (%rax),%edx
  81d1c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1cb:	8b 40 30             	mov    0x30(%rax),%eax
  81d1ce:	29 c2                	sub    %eax,%edx
  81d1d0:	89 d0                	mov    %edx,%eax
  81d1d2:	85 c0                	test   %eax,%eax
  81d1d4:	78 2c                	js     81d202 <tcp_process+0x9f>
  81d1d6:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d1dd:	00 00 00 
  81d1e0:	8b 10                	mov    (%rax),%edx
  81d1e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1e6:	8b 48 30             	mov    0x30(%rax),%ecx
  81d1e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1ed:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81d1f1:	0f b7 c0             	movzwl %ax,%eax
  81d1f4:	01 c8                	add    %ecx,%eax
  81d1f6:	29 c2                	sub    %eax,%edx
  81d1f8:	89 d0                	mov    %edx,%eax
  81d1fa:	85 c0                	test   %eax,%eax
  81d1fc:	7f 04                	jg     81d202 <tcp_process+0x9f>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
  81d1fe:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
      }
    }

    if (acceptable) {
  81d202:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81d206:	74 60                	je     81d268 <tcp_process+0x105>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  81d208:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d20c:	8b 40 18             	mov    0x18(%rax),%eax
  81d20f:	85 c0                	test   %eax,%eax
  81d211:	75 2a                	jne    81d23d <tcp_process+0xda>
  81d213:	48 ba a8 36 82 00 00 	movabs $0x8236a8,%rdx
  81d21a:	00 00 00 
  81d21d:	be 09 02 00 00       	mov    $0x209,%esi
  81d222:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81d229:	00 00 00 
  81d22c:	b8 00 00 00 00       	mov    $0x0,%eax
  81d231:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81d238:	00 00 00 
  81d23b:	ff d1                	callq  *%rcx
      recv_flags = TF_RESET;
  81d23d:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81d244:	00 00 00 
  81d247:	c6 00 08             	movb   $0x8,(%rax)
      pcb->flags &= ~TF_ACK_DELAY;
  81d24a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d24e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d252:	83 e0 fe             	and    $0xfffffffe,%eax
  81d255:	89 c2                	mov    %eax,%edx
  81d257:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d25b:	88 50 2c             	mov    %dl,0x2c(%rax)
      return ERR_RST;
  81d25e:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  81d263:	e9 c7 0b 00 00       	jmpq   81de2f <tcp_process+0xccc>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
  81d268:	b8 00 00 00 00       	mov    $0x0,%eax
  81d26d:	e9 bd 0b 00 00       	jmpq   81de2f <tcp_process+0xccc>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  81d272:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81d279:	00 00 00 
  81d27c:	8b 10                	mov    (%rax),%edx
  81d27e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d282:	89 50 38             	mov    %edx,0x38(%rax)
  pcb->keep_cnt_sent = 0;
  81d285:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d289:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  81d290:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d294:	8b 40 18             	mov    0x18(%rax),%eax
  81d297:	83 f8 09             	cmp    $0x9,%eax
  81d29a:	0f 87 89 0b 00 00    	ja     81de29 <tcp_process+0xcc6>
  81d2a0:	89 c0                	mov    %eax,%eax
  81d2a2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  81d2a9:	00 
  81d2aa:	48 b8 f8 36 82 00 00 	movabs $0x8236f8,%rax
  81d2b1:	00 00 00 
  81d2b4:	48 01 d0             	add    %rdx,%rax
  81d2b7:	48 8b 00             	mov    (%rax),%rax
  81d2ba:	ff e0                	jmpq   *%rax
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  81d2bc:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d2c3:	00 00 00 
  81d2c6:	0f b6 00             	movzbl (%rax),%eax
  81d2c9:	0f b6 c0             	movzbl %al,%eax
  81d2cc:	83 e0 10             	and    $0x10,%eax
  81d2cf:	85 c0                	test   %eax,%eax
  81d2d1:	0f 84 58 02 00 00    	je     81d52f <tcp_process+0x3cc>
  81d2d7:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d2de:	00 00 00 
  81d2e1:	0f b6 00             	movzbl (%rax),%eax
  81d2e4:	0f b6 c0             	movzbl %al,%eax
  81d2e7:	83 e0 02             	and    $0x2,%eax
  81d2ea:	85 c0                	test   %eax,%eax
  81d2ec:	0f 84 3d 02 00 00    	je     81d52f <tcp_process+0x3cc>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  81d2f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d2f6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d2fd:	48 8b 40 20          	mov    0x20(%rax),%rax
  81d301:	8b 40 04             	mov    0x4(%rax),%eax
  81d304:	89 c7                	mov    %eax,%edi
  81d306:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  81d30d:	00 00 00 
  81d310:	ff d0                	callq  *%rax
  81d312:	8d 50 01             	lea    0x1(%rax),%edx
  81d315:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d31c:	00 00 00 
  81d31f:	8b 00                	mov    (%rax),%eax
  81d321:	39 c2                	cmp    %eax,%edx
  81d323:	0f 85 06 02 00 00    	jne    81d52f <tcp_process+0x3cc>
      pcb->snd_buf++;
  81d329:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d32d:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81d331:	8d 50 01             	lea    0x1(%rax),%edx
  81d334:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d338:	66 89 50 7a          	mov    %dx,0x7a(%rax)
      pcb->rcv_nxt = seqno + 1;
  81d33c:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d343:	00 00 00 
  81d346:	8b 00                	mov    (%rax),%eax
  81d348:	8d 50 01             	lea    0x1(%rax),%edx
  81d34b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d34f:	89 50 30             	mov    %edx,0x30(%rax)
      pcb->lastack = ackno;
  81d352:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d359:	00 00 00 
  81d35c:	8b 10                	mov    (%rax),%edx
  81d35e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d362:	89 50 54             	mov    %edx,0x54(%rax)
      pcb->snd_wnd = tcphdr->wnd;
  81d365:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d36c:	00 00 00 
  81d36f:	48 8b 00             	mov    (%rax),%rax
  81d372:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d376:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d37a:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  81d37e:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d385:	00 00 00 
  81d388:	8b 00                	mov    (%rax),%eax
  81d38a:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d38d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d391:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->state = ESTABLISHED;
  81d394:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d398:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  81d39f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3a3:	48 89 c7             	mov    %rax,%rdi
  81d3a6:	48 b8 99 f8 81 00 00 	movabs $0x81f899,%rax
  81d3ad:	00 00 00 
  81d3b0:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  81d3b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3b6:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81d3ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3be:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d3c2:	0f b7 c0             	movzwl %ax,%eax
  81d3c5:	48 89 d6             	mov    %rdx,%rsi
  81d3c8:	89 c7                	mov    %eax,%edi
  81d3ca:	48 b8 ad 09 81 00 00 	movabs $0x8109ad,%rax
  81d3d1:	00 00 00 
  81d3d4:	ff d0                	callq  *%rax
  81d3d6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d3da:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  81d3de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3e2:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81d3e6:	89 d0                	mov    %edx,%eax
  81d3e8:	c1 e0 02             	shl    $0x2,%eax
  81d3eb:	01 d0                	add    %edx,%eax
  81d3ed:	01 c0                	add    %eax,%eax
  81d3ef:	89 c2                	mov    %eax,%edx
  81d3f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3f5:	66 89 50 5c          	mov    %dx,0x5c(%rax)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81d3f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3fd:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d401:	66 83 f8 01          	cmp    $0x1,%ax
  81d405:	75 0c                	jne    81d413 <tcp_process+0x2b0>
  81d407:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d40b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d40f:	01 c0                	add    %eax,%eax
  81d411:	eb 08                	jmp    81d41b <tcp_process+0x2b8>
  81d413:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d417:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d41b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d41f:	66 89 42 5a          	mov    %ax,0x5a(%rdx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  81d423:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d427:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d42b:	66 85 c0             	test   %ax,%ax
  81d42e:	75 2a                	jne    81d45a <tcp_process+0x2f7>
  81d430:	48 ba c8 36 82 00 00 	movabs $0x8236c8,%rdx
  81d437:	00 00 00 
  81d43a:	be 35 02 00 00       	mov    $0x235,%esi
  81d43f:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81d446:	00 00 00 
  81d449:	b8 00 00 00 00       	mov    $0x0,%eax
  81d44e:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81d455:	00 00 00 
  81d458:	ff d1                	callq  *%rcx
      --pcb->snd_queuelen;
  81d45a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d45e:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d462:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d465:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d469:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  81d46d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d471:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d478:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb->unacked = rseg->next;
  81d47c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d480:	48 8b 10             	mov    (%rax),%rdx
  81d483:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d487:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81d48e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d492:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d499:	48 85 c0             	test   %rax,%rax
  81d49c:	75 0c                	jne    81d4aa <tcp_process+0x347>
        pcb->rtime = -1;
  81d49e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4a2:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81d4a8:	eb 12                	jmp    81d4bc <tcp_process+0x359>
      else {
        pcb->rtime = 0;
  81d4aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4ae:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)
        pcb->nrtx = 0;
  81d4b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4b8:	c6 40 52 00          	movb   $0x0,0x52(%rax)
      }

      tcp_seg_free(rseg);
  81d4bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d4c0:	48 89 c7             	mov    %rax,%rdi
  81d4c3:	48 b8 4b 01 81 00 00 	movabs $0x81014b,%rax
  81d4ca:	00 00 00 
  81d4cd:	ff d0                	callq  *%rax

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  81d4cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4d3:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81d4da:	48 85 c0             	test   %rax,%rax
  81d4dd:	74 24                	je     81d503 <tcp_process+0x3a0>
  81d4df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4e3:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81d4ea:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d4ee:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  81d4f2:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  81d4f6:	ba 00 00 00 00       	mov    $0x0,%edx
  81d4fb:	48 89 cf             	mov    %rcx,%rdi
  81d4fe:	ff d0                	callq  *%rax
  81d500:	88 45 fe             	mov    %al,-0x2(%rbp)
      tcp_ack_now(pcb);
  81d503:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d507:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d50b:	83 c8 02             	or     $0x2,%eax
  81d50e:	89 c2                	mov    %eax,%edx
  81d510:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d514:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d517:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d51b:	48 89 c7             	mov    %rax,%rdi
  81d51e:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81d525:	00 00 00 
  81d528:	ff d0                	callq  *%rax
  81d52a:	e9 a8 00 00 00       	jmpq   81d5d7 <tcp_process+0x474>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  81d52f:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d536:	00 00 00 
  81d539:	0f b6 00             	movzbl (%rax),%eax
  81d53c:	0f b6 c0             	movzbl %al,%eax
  81d53f:	83 e0 10             	and    $0x10,%eax
  81d542:	85 c0                	test   %eax,%eax
  81d544:	0f 84 8d 00 00 00    	je     81d5d7 <tcp_process+0x474>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81d54a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d551:	00 00 00 
  81d554:	48 8b 00             	mov    (%rax),%rax
  81d557:	0f b7 00             	movzwl (%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d55a:	44 0f b7 c0          	movzwl %ax,%r8d
        tcphdr->dest, tcphdr->src);
  81d55e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d565:	00 00 00 
  81d568:	48 8b 00             	mov    (%rax),%rax
  81d56b:	0f b7 40 02          	movzwl 0x2(%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d56f:	0f b7 f8             	movzwl %ax,%edi
  81d572:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d579:	00 00 00 
  81d57c:	48 8b 00             	mov    (%rax),%rax
  81d57f:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81d583:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d58a:	00 00 00 
  81d58d:	48 8b 00             	mov    (%rax),%rax
  81d590:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d594:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d59b:	00 00 00 
  81d59e:	0f b7 00             	movzwl (%rax),%eax
  81d5a1:	0f b7 f0             	movzwl %ax,%esi
  81d5a4:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d5ab:	00 00 00 
  81d5ae:	8b 00                	mov    (%rax),%eax
  81d5b0:	01 c6                	add    %eax,%esi
  81d5b2:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d5b9:	00 00 00 
  81d5bc:	8b 00                	mov    (%rax),%eax
  81d5be:	45 89 c1             	mov    %r8d,%r9d
  81d5c1:	41 89 f8             	mov    %edi,%r8d
  81d5c4:	89 c7                	mov    %eax,%edi
  81d5c6:	48 b8 17 42 81 00 00 	movabs $0x814217,%rax
  81d5cd:	00 00 00 
  81d5d0:	ff d0                	callq  *%rax
        tcphdr->dest, tcphdr->src);
    }
    break;
  81d5d2:	e9 53 08 00 00       	jmpq   81de2a <tcp_process+0xcc7>
  81d5d7:	e9 4e 08 00 00       	jmpq   81de2a <tcp_process+0xcc7>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81d5dc:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d5e3:	00 00 00 
  81d5e6:	0f b6 00             	movzbl (%rax),%eax
  81d5e9:	0f b6 c0             	movzbl %al,%eax
  81d5ec:	83 e0 10             	and    $0x10,%eax
  81d5ef:	85 c0                	test   %eax,%eax
  81d5f1:	0f 84 23 02 00 00    	je     81d81a <tcp_process+0x6b7>
       !(flags & TCP_RST)) {
  81d5f7:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d5fe:	00 00 00 
  81d601:	0f b6 00             	movzbl (%rax),%eax
  81d604:	0f b6 c0             	movzbl %al,%eax
  81d607:	83 e0 04             	and    $0x4,%eax
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81d60a:	85 c0                	test   %eax,%eax
  81d60c:	0f 85 08 02 00 00    	jne    81d81a <tcp_process+0x6b7>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81d612:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d619:	00 00 00 
  81d61c:	8b 10                	mov    (%rax),%edx
  81d61e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d622:	8b 40 54             	mov    0x54(%rax),%eax
  81d625:	29 c2                	sub    %eax,%edx
  81d627:	89 d0                	mov    %edx,%eax
  81d629:	83 e8 01             	sub    $0x1,%eax
  81d62c:	85 c0                	test   %eax,%eax
  81d62e:	0f 88 59 01 00 00    	js     81d78d <tcp_process+0x62a>
  81d634:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d63b:	00 00 00 
  81d63e:	8b 10                	mov    (%rax),%edx
  81d640:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d644:	8b 40 60             	mov    0x60(%rax),%eax
  81d647:	29 c2                	sub    %eax,%edx
  81d649:	89 d0                	mov    %edx,%eax
  81d64b:	85 c0                	test   %eax,%eax
  81d64d:	0f 8f 3a 01 00 00    	jg     81d78d <tcp_process+0x62a>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  81d653:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d657:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  81d65e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d662:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d669:	48 85 c0             	test   %rax,%rax
  81d66c:	75 2a                	jne    81d698 <tcp_process+0x535>
  81d66e:	48 ba de 36 82 00 00 	movabs $0x8236de,%rdx
  81d675:	00 00 00 
  81d678:	be 5b 02 00 00       	mov    $0x25b,%esi
  81d67d:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81d684:	00 00 00 
  81d687:	b8 00 00 00 00       	mov    $0x0,%eax
  81d68c:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81d693:	00 00 00 
  81d696:	ff d1                	callq  *%rcx
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  81d698:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d69c:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d6a3:	48 85 c0             	test   %rax,%rax
  81d6a6:	74 24                	je     81d6cc <tcp_process+0x569>
  81d6a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6ac:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d6b3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d6b7:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  81d6bb:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  81d6bf:	ba 00 00 00 00       	mov    $0x0,%edx
  81d6c4:	48 89 cf             	mov    %rcx,%rdi
  81d6c7:	ff d0                	callq  *%rax
  81d6c9:	88 45 fe             	mov    %al,-0x2(%rbp)
        if (err != ERR_OK) {
  81d6cc:	80 7d fe 00          	cmpb   $0x0,-0x2(%rbp)
  81d6d0:	74 1d                	je     81d6ef <tcp_process+0x58c>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  81d6d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6d6:	48 89 c7             	mov    %rax,%rdi
  81d6d9:	48 b8 ce eb 80 00 00 	movabs $0x80ebce,%rax
  81d6e0:	00 00 00 
  81d6e3:	ff d0                	callq  *%rax
          return ERR_ABRT;
  81d6e5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  81d6ea:	e9 40 07 00 00       	jmpq   81de2f <tcp_process+0xccc>
        }
        old_cwnd = pcb->cwnd;
  81d6ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6f3:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d6f7:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  81d6fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6ff:	48 89 c7             	mov    %rax,%rdi
  81d702:	48 b8 31 de 81 00 00 	movabs $0x81de31,%rax
  81d709:	00 00 00 
  81d70c:	ff d0                	callq  *%rax
  81d70e:	88 45 ed             	mov    %al,-0x13(%rbp)

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81d711:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  81d716:	75 0c                	jne    81d724 <tcp_process+0x5c1>
  81d718:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d71c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d720:	01 c0                	add    %eax,%eax
  81d722:	eb 08                	jmp    81d72c <tcp_process+0x5c9>
  81d724:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d728:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d72c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d730:	66 89 42 5a          	mov    %ax,0x5a(%rdx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  81d734:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d73b:	00 00 00 
  81d73e:	0f b6 00             	movzbl (%rax),%eax
  81d741:	0f b6 c0             	movzbl %al,%eax
  81d744:	83 e0 01             	and    $0x1,%eax
  81d747:	85 c0                	test   %eax,%eax
  81d749:	74 3d                	je     81d788 <tcp_process+0x625>
  81d74b:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81d74f:	74 37                	je     81d788 <tcp_process+0x625>
          tcp_ack_now(pcb);
  81d751:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d755:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d759:	83 c8 02             	or     $0x2,%eax
  81d75c:	89 c2                	mov    %eax,%edx
  81d75e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d762:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d765:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d769:	48 89 c7             	mov    %rax,%rdi
  81d76c:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81d773:	00 00 00 
  81d776:	ff d0                	callq  *%rax
          pcb->state = CLOSE_WAIT;
  81d778:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d77c:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81d783:	e9 92 00 00 00       	jmpq   81d81a <tcp_process+0x6b7>
  81d788:	e9 8d 00 00 00       	jmpq   81d81a <tcp_process+0x6b7>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  81d78d:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d794:	00 00 00 
  81d797:	48 8b 00             	mov    (%rax),%rax
  81d79a:	0f b7 00             	movzwl (%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d79d:	44 0f b7 c0          	movzwl %ax,%r8d
                tcphdr->dest, tcphdr->src);
  81d7a1:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d7a8:	00 00 00 
  81d7ab:	48 8b 00             	mov    (%rax),%rax
  81d7ae:	0f b7 40 02          	movzwl 0x2(%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d7b2:	0f b7 f8             	movzwl %ax,%edi
  81d7b5:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d7bc:	00 00 00 
  81d7bf:	48 8b 00             	mov    (%rax),%rax
  81d7c2:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81d7c6:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d7cd:	00 00 00 
  81d7d0:	48 8b 00             	mov    (%rax),%rax
  81d7d3:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d7d7:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d7de:	00 00 00 
  81d7e1:	0f b7 00             	movzwl (%rax),%eax
  81d7e4:	0f b7 f0             	movzwl %ax,%esi
  81d7e7:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d7ee:	00 00 00 
  81d7f1:	8b 00                	mov    (%rax),%eax
  81d7f3:	01 c6                	add    %eax,%esi
  81d7f5:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d7fc:	00 00 00 
  81d7ff:	8b 00                	mov    (%rax),%eax
  81d801:	45 89 c1             	mov    %r8d,%r9d
  81d804:	41 89 f8             	mov    %edi,%r8d
  81d807:	89 c7                	mov    %eax,%edi
  81d809:	48 b8 17 42 81 00 00 	movabs $0x814217,%rax
  81d810:	00 00 00 
  81d813:	ff d0                	callq  *%rax
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81d815:	e9 10 06 00 00       	jmpq   81de2a <tcp_process+0xcc7>
  81d81a:	e9 0b 06 00 00       	jmpq   81de2a <tcp_process+0xcc7>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  81d81f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d823:	48 89 c7             	mov    %rax,%rdi
  81d826:	48 b8 31 de 81 00 00 	movabs $0x81de31,%rax
  81d82d:	00 00 00 
  81d830:	ff d0                	callq  *%rax
  81d832:	88 45 ed             	mov    %al,-0x13(%rbp)
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  81d835:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d83c:	00 00 00 
  81d83f:	0f b6 00             	movzbl (%rax),%eax
  81d842:	0f b6 c0             	movzbl %al,%eax
  81d845:	83 e0 01             	and    $0x1,%eax
  81d848:	85 c0                	test   %eax,%eax
  81d84a:	74 3d                	je     81d889 <tcp_process+0x726>
  81d84c:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81d850:	74 37                	je     81d889 <tcp_process+0x726>
      tcp_ack_now(pcb);
  81d852:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d856:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d85a:	83 c8 02             	or     $0x2,%eax
  81d85d:	89 c2                	mov    %eax,%edx
  81d85f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d863:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d866:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d86a:	48 89 c7             	mov    %rax,%rdi
  81d86d:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81d874:	00 00 00 
  81d877:	ff d0                	callq  *%rax
      pcb->state = CLOSE_WAIT;
  81d879:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d87d:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    }
    break;
  81d884:	e9 a1 05 00 00       	jmpq   81de2a <tcp_process+0xcc7>
  81d889:	e9 9c 05 00 00       	jmpq   81de2a <tcp_process+0xcc7>
  case FIN_WAIT_1:
    tcp_receive(pcb);
  81d88e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d892:	48 89 c7             	mov    %rax,%rdi
  81d895:	48 b8 31 de 81 00 00 	movabs $0x81de31,%rax
  81d89c:	00 00 00 
  81d89f:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81d8a1:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d8a8:	00 00 00 
  81d8ab:	0f b6 00             	movzbl (%rax),%eax
  81d8ae:	0f b6 c0             	movzbl %al,%eax
  81d8b1:	83 e0 01             	and    $0x1,%eax
  81d8b4:	85 c0                	test   %eax,%eax
  81d8b6:	0f 84 b9 01 00 00    	je     81da75 <tcp_process+0x912>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81d8bc:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d8c3:	00 00 00 
  81d8c6:	0f b6 00             	movzbl (%rax),%eax
  81d8c9:	0f b6 c0             	movzbl %al,%eax
  81d8cc:	83 e0 10             	and    $0x10,%eax
  81d8cf:	85 c0                	test   %eax,%eax
  81d8d1:	0f 84 6a 01 00 00    	je     81da41 <tcp_process+0x8de>
  81d8d7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d8db:	8b 50 60             	mov    0x60(%rax),%edx
  81d8de:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d8e5:	00 00 00 
  81d8e8:	8b 00                	mov    (%rax),%eax
  81d8ea:	39 c2                	cmp    %eax,%edx
  81d8ec:	0f 85 4f 01 00 00    	jne    81da41 <tcp_process+0x8de>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  81d8f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d8f6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d8fa:	83 c8 02             	or     $0x2,%eax
  81d8fd:	89 c2                	mov    %eax,%edx
  81d8ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d903:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d906:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d90a:	48 89 c7             	mov    %rax,%rdi
  81d90d:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81d914:	00 00 00 
  81d917:	ff d0                	callq  *%rax
        tcp_pcb_purge(pcb);
  81d919:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d91d:	48 89 c7             	mov    %rax,%rdi
  81d920:	48 b8 76 06 81 00 00 	movabs $0x810676,%rax
  81d927:	00 00 00 
  81d92a:	ff d0                	callq  *%rax
        TCP_RMV(&tcp_active_pcbs, pcb);
  81d92c:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d933:	00 00 00 
  81d936:	48 8b 00             	mov    (%rax),%rax
  81d939:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81d93d:	75 23                	jne    81d962 <tcp_process+0x7ff>
  81d93f:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d946:	00 00 00 
  81d949:	48 8b 00             	mov    (%rax),%rax
  81d94c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d950:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d957:	00 00 00 
  81d95a:	48 89 10             	mov    %rdx,(%rax)
  81d95d:	e9 94 00 00 00       	jmpq   81d9f6 <tcp_process+0x893>
  81d962:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d969:	00 00 00 
  81d96c:	48 8b 10             	mov    (%rax),%rdx
  81d96f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d976:	00 00 00 
  81d979:	48 89 10             	mov    %rdx,(%rax)
  81d97c:	eb 66                	jmp    81d9e4 <tcp_process+0x881>
  81d97e:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d985:	00 00 00 
  81d988:	48 8b 00             	mov    (%rax),%rax
  81d98b:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d98f:	48 85 c0             	test   %rax,%rax
  81d992:	74 32                	je     81d9c6 <tcp_process+0x863>
  81d994:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d99b:	00 00 00 
  81d99e:	48 8b 00             	mov    (%rax),%rax
  81d9a1:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d9a5:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81d9a9:	75 1b                	jne    81d9c6 <tcp_process+0x863>
  81d9ab:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d9b2:	00 00 00 
  81d9b5:	48 8b 00             	mov    (%rax),%rax
  81d9b8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d9bc:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81d9c0:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d9c4:	eb 30                	jmp    81d9f6 <tcp_process+0x893>
  81d9c6:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d9cd:	00 00 00 
  81d9d0:	48 8b 00             	mov    (%rax),%rax
  81d9d3:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d9d7:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d9de:	00 00 00 
  81d9e1:	48 89 10             	mov    %rdx,(%rax)
  81d9e4:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d9eb:	00 00 00 
  81d9ee:	48 8b 00             	mov    (%rax),%rax
  81d9f1:	48 85 c0             	test   %rax,%rax
  81d9f4:	75 88                	jne    81d97e <tcp_process+0x81b>
  81d9f6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d9fa:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81da01:	00 
        pcb->state = TIME_WAIT;
  81da02:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da06:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
        TCP_REG(&tcp_tw_pcbs, pcb);
  81da0d:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81da14:	00 00 00 
  81da17:	48 8b 10             	mov    (%rax),%rdx
  81da1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da1e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81da22:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81da29:	00 00 00 
  81da2c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81da30:	48 89 10             	mov    %rdx,(%rax)
  81da33:	48 b8 c0 83 80 00 00 	movabs $0x8083c0,%rax
  81da3a:	00 00 00 
  81da3d:	ff d0                	callq  *%rax
  81da3f:	eb 72                	jmp    81dab3 <tcp_process+0x950>
      } else {
        tcp_ack_now(pcb);
  81da41:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da45:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81da49:	83 c8 02             	or     $0x2,%eax
  81da4c:	89 c2                	mov    %eax,%edx
  81da4e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da52:	88 50 2c             	mov    %dl,0x2c(%rax)
  81da55:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da59:	48 89 c7             	mov    %rax,%rdi
  81da5c:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81da63:	00 00 00 
  81da66:	ff d0                	callq  *%rax
        pcb->state = CLOSING;
  81da68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da6c:	c7 40 18 08 00 00 00 	movl   $0x8,0x18(%rax)
  81da73:	eb 3e                	jmp    81dab3 <tcp_process+0x950>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81da75:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81da7c:	00 00 00 
  81da7f:	0f b6 00             	movzbl (%rax),%eax
  81da82:	0f b6 c0             	movzbl %al,%eax
  81da85:	83 e0 10             	and    $0x10,%eax
  81da88:	85 c0                	test   %eax,%eax
  81da8a:	74 27                	je     81dab3 <tcp_process+0x950>
  81da8c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da90:	8b 50 60             	mov    0x60(%rax),%edx
  81da93:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81da9a:	00 00 00 
  81da9d:	8b 00                	mov    (%rax),%eax
  81da9f:	39 c2                	cmp    %eax,%edx
  81daa1:	75 10                	jne    81dab3 <tcp_process+0x950>
      pcb->state = FIN_WAIT_2;
  81daa3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81daa7:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%rax)
    }
    break;
  81daae:	e9 77 03 00 00       	jmpq   81de2a <tcp_process+0xcc7>
  81dab3:	e9 72 03 00 00       	jmpq   81de2a <tcp_process+0xcc7>
  case FIN_WAIT_2:
    tcp_receive(pcb);
  81dab8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dabc:	48 89 c7             	mov    %rax,%rdi
  81dabf:	48 b8 31 de 81 00 00 	movabs $0x81de31,%rax
  81dac6:	00 00 00 
  81dac9:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81dacb:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dad2:	00 00 00 
  81dad5:	0f b6 00             	movzbl (%rax),%eax
  81dad8:	0f b6 c0             	movzbl %al,%eax
  81dadb:	83 e0 01             	and    $0x1,%eax
  81dade:	85 c0                	test   %eax,%eax
  81dae0:	0f 84 52 01 00 00    	je     81dc38 <tcp_process+0xad5>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81dae6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81daea:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81daee:	83 c8 02             	or     $0x2,%eax
  81daf1:	89 c2                	mov    %eax,%edx
  81daf3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81daf7:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dafa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dafe:	48 89 c7             	mov    %rax,%rdi
  81db01:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81db08:	00 00 00 
  81db0b:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81db0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db11:	48 89 c7             	mov    %rax,%rdi
  81db14:	48 b8 76 06 81 00 00 	movabs $0x810676,%rax
  81db1b:	00 00 00 
  81db1e:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81db20:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81db27:	00 00 00 
  81db2a:	48 8b 00             	mov    (%rax),%rax
  81db2d:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81db31:	75 23                	jne    81db56 <tcp_process+0x9f3>
  81db33:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81db3a:	00 00 00 
  81db3d:	48 8b 00             	mov    (%rax),%rax
  81db40:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81db44:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81db4b:	00 00 00 
  81db4e:	48 89 10             	mov    %rdx,(%rax)
  81db51:	e9 94 00 00 00       	jmpq   81dbea <tcp_process+0xa87>
  81db56:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81db5d:	00 00 00 
  81db60:	48 8b 10             	mov    (%rax),%rdx
  81db63:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81db6a:	00 00 00 
  81db6d:	48 89 10             	mov    %rdx,(%rax)
  81db70:	eb 66                	jmp    81dbd8 <tcp_process+0xa75>
  81db72:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81db79:	00 00 00 
  81db7c:	48 8b 00             	mov    (%rax),%rax
  81db7f:	48 8b 40 10          	mov    0x10(%rax),%rax
  81db83:	48 85 c0             	test   %rax,%rax
  81db86:	74 32                	je     81dbba <tcp_process+0xa57>
  81db88:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81db8f:	00 00 00 
  81db92:	48 8b 00             	mov    (%rax),%rax
  81db95:	48 8b 40 10          	mov    0x10(%rax),%rax
  81db99:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81db9d:	75 1b                	jne    81dbba <tcp_process+0xa57>
  81db9f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dba6:	00 00 00 
  81dba9:	48 8b 00             	mov    (%rax),%rax
  81dbac:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81dbb0:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81dbb4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81dbb8:	eb 30                	jmp    81dbea <tcp_process+0xa87>
  81dbba:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dbc1:	00 00 00 
  81dbc4:	48 8b 00             	mov    (%rax),%rax
  81dbc7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dbcb:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dbd2:	00 00 00 
  81dbd5:	48 89 10             	mov    %rdx,(%rax)
  81dbd8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dbdf:	00 00 00 
  81dbe2:	48 8b 00             	mov    (%rax),%rax
  81dbe5:	48 85 c0             	test   %rax,%rax
  81dbe8:	75 88                	jne    81db72 <tcp_process+0xa0f>
  81dbea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dbee:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81dbf5:	00 
      pcb->state = TIME_WAIT;
  81dbf6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dbfa:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81dc01:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81dc08:	00 00 00 
  81dc0b:	48 8b 10             	mov    (%rax),%rdx
  81dc0e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc12:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81dc16:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81dc1d:	00 00 00 
  81dc20:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81dc24:	48 89 10             	mov    %rdx,(%rax)
  81dc27:	48 b8 c0 83 80 00 00 	movabs $0x8083c0,%rax
  81dc2e:	00 00 00 
  81dc31:	ff d0                	callq  *%rax
    }
    break;
  81dc33:	e9 f2 01 00 00       	jmpq   81de2a <tcp_process+0xcc7>
  81dc38:	e9 ed 01 00 00       	jmpq   81de2a <tcp_process+0xcc7>
  case CLOSING:
    tcp_receive(pcb);
  81dc3d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc41:	48 89 c7             	mov    %rax,%rdi
  81dc44:	48 b8 31 de 81 00 00 	movabs $0x81de31,%rax
  81dc4b:	00 00 00 
  81dc4e:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81dc50:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dc57:	00 00 00 
  81dc5a:	0f b6 00             	movzbl (%rax),%eax
  81dc5d:	0f b6 c0             	movzbl %al,%eax
  81dc60:	83 e0 10             	and    $0x10,%eax
  81dc63:	85 c0                	test   %eax,%eax
  81dc65:	0f 84 6a 01 00 00    	je     81ddd5 <tcp_process+0xc72>
  81dc6b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc6f:	8b 50 60             	mov    0x60(%rax),%edx
  81dc72:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dc79:	00 00 00 
  81dc7c:	8b 00                	mov    (%rax),%eax
  81dc7e:	39 c2                	cmp    %eax,%edx
  81dc80:	0f 85 4f 01 00 00    	jne    81ddd5 <tcp_process+0xc72>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81dc86:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc8a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dc8e:	83 c8 02             	or     $0x2,%eax
  81dc91:	89 c2                	mov    %eax,%edx
  81dc93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc97:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dc9a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc9e:	48 89 c7             	mov    %rax,%rdi
  81dca1:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81dca8:	00 00 00 
  81dcab:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81dcad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dcb1:	48 89 c7             	mov    %rax,%rdi
  81dcb4:	48 b8 76 06 81 00 00 	movabs $0x810676,%rax
  81dcbb:	00 00 00 
  81dcbe:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81dcc0:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dcc7:	00 00 00 
  81dcca:	48 8b 00             	mov    (%rax),%rax
  81dccd:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81dcd1:	75 23                	jne    81dcf6 <tcp_process+0xb93>
  81dcd3:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dcda:	00 00 00 
  81dcdd:	48 8b 00             	mov    (%rax),%rax
  81dce0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dce4:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dceb:	00 00 00 
  81dcee:	48 89 10             	mov    %rdx,(%rax)
  81dcf1:	e9 94 00 00 00       	jmpq   81dd8a <tcp_process+0xc27>
  81dcf6:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dcfd:	00 00 00 
  81dd00:	48 8b 10             	mov    (%rax),%rdx
  81dd03:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dd0a:	00 00 00 
  81dd0d:	48 89 10             	mov    %rdx,(%rax)
  81dd10:	eb 66                	jmp    81dd78 <tcp_process+0xc15>
  81dd12:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dd19:	00 00 00 
  81dd1c:	48 8b 00             	mov    (%rax),%rax
  81dd1f:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dd23:	48 85 c0             	test   %rax,%rax
  81dd26:	74 32                	je     81dd5a <tcp_process+0xbf7>
  81dd28:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dd2f:	00 00 00 
  81dd32:	48 8b 00             	mov    (%rax),%rax
  81dd35:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dd39:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81dd3d:	75 1b                	jne    81dd5a <tcp_process+0xbf7>
  81dd3f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dd46:	00 00 00 
  81dd49:	48 8b 00             	mov    (%rax),%rax
  81dd4c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81dd50:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81dd54:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81dd58:	eb 30                	jmp    81dd8a <tcp_process+0xc27>
  81dd5a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dd61:	00 00 00 
  81dd64:	48 8b 00             	mov    (%rax),%rax
  81dd67:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dd6b:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dd72:	00 00 00 
  81dd75:	48 89 10             	mov    %rdx,(%rax)
  81dd78:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dd7f:	00 00 00 
  81dd82:	48 8b 00             	mov    (%rax),%rax
  81dd85:	48 85 c0             	test   %rax,%rax
  81dd88:	75 88                	jne    81dd12 <tcp_process+0xbaf>
  81dd8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd8e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81dd95:	00 
      pcb->state = TIME_WAIT;
  81dd96:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd9a:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81dda1:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81dda8:	00 00 00 
  81ddab:	48 8b 10             	mov    (%rax),%rdx
  81ddae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ddb2:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81ddb6:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81ddbd:	00 00 00 
  81ddc0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81ddc4:	48 89 10             	mov    %rdx,(%rax)
  81ddc7:	48 b8 c0 83 80 00 00 	movabs $0x8083c0,%rax
  81ddce:	00 00 00 
  81ddd1:	ff d0                	callq  *%rax
    }
    break;
  81ddd3:	eb 55                	jmp    81de2a <tcp_process+0xcc7>
  81ddd5:	eb 53                	jmp    81de2a <tcp_process+0xcc7>
  case LAST_ACK:
    tcp_receive(pcb);
  81ddd7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dddb:	48 89 c7             	mov    %rax,%rdi
  81ddde:	48 b8 31 de 81 00 00 	movabs $0x81de31,%rax
  81dde5:	00 00 00 
  81dde8:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81ddea:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81ddf1:	00 00 00 
  81ddf4:	0f b6 00             	movzbl (%rax),%eax
  81ddf7:	0f b6 c0             	movzbl %al,%eax
  81ddfa:	83 e0 10             	and    $0x10,%eax
  81ddfd:	85 c0                	test   %eax,%eax
  81ddff:	74 26                	je     81de27 <tcp_process+0xcc4>
  81de01:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81de05:	8b 50 60             	mov    0x60(%rax),%edx
  81de08:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81de0f:	00 00 00 
  81de12:	8b 00                	mov    (%rax),%eax
  81de14:	39 c2                	cmp    %eax,%edx
  81de16:	75 0f                	jne    81de27 <tcp_process+0xcc4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  81de18:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81de1f:	00 00 00 
  81de22:	c6 00 10             	movb   $0x10,(%rax)
    }
    break;
  81de25:	eb 03                	jmp    81de2a <tcp_process+0xcc7>
  81de27:	eb 01                	jmp    81de2a <tcp_process+0xcc7>
  default:
    break;
  81de29:	90                   	nop
  }
  return ERR_OK;
  81de2a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81de2f:	c9                   	leaveq 
  81de30:	c3                   	retq   

000000000081de31 <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  81de31:	55                   	push   %rbp
  81de32:	48 89 e5             	mov    %rsp,%rbp
  81de35:	41 55                	push   %r13
  81de37:	41 54                	push   %r12
  81de39:	53                   	push   %rbx
  81de3a:	48 83 ec 58          	sub    $0x58,%rsp
  81de3e:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  81de42:	c6 45 c1 00          	movb   $0x0,-0x3f(%rbp)

  if (flags & TCP_ACK) {
  81de46:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81de4d:	00 00 00 
  81de50:	0f b6 00             	movzbl (%rax),%eax
  81de53:	0f b6 c0             	movzbl %al,%eax
  81de56:	83 e0 10             	and    $0x10,%eax
  81de59:	85 c0                	test   %eax,%eax
  81de5b:	0f 84 80 09 00 00    	je     81e7e1 <tcp_receive+0x9b0>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  81de61:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de65:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81de69:	0f b7 d0             	movzwl %ax,%edx
  81de6c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de70:	8b 40 6c             	mov    0x6c(%rax),%eax
  81de73:	01 d0                	add    %edx,%eax
  81de75:	89 45 bc             	mov    %eax,-0x44(%rbp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81de78:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de7c:	8b 50 6c             	mov    0x6c(%rax),%edx
  81de7f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81de86:	00 00 00 
  81de89:	8b 00                	mov    (%rax),%eax
  81de8b:	29 c2                	sub    %eax,%edx
  81de8d:	89 d0                	mov    %edx,%eax
  81de8f:	85 c0                	test   %eax,%eax
  81de91:	78 6b                	js     81defe <tcp_receive+0xcd>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81de93:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de97:	8b 50 6c             	mov    0x6c(%rax),%edx
  81de9a:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81dea1:	00 00 00 
  81dea4:	8b 00                	mov    (%rax),%eax

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81dea6:	39 c2                	cmp    %eax,%edx
  81dea8:	75 1b                	jne    81dec5 <tcp_receive+0x94>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81deaa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81deae:	8b 50 70             	mov    0x70(%rax),%edx
  81deb1:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81deb8:	00 00 00 
  81debb:	8b 00                	mov    (%rax),%eax
  81debd:	29 c2                	sub    %eax,%edx
  81debf:	89 d0                	mov    %edx,%eax
  81dec1:	85 c0                	test   %eax,%eax
  81dec3:	78 39                	js     81defe <tcp_receive+0xcd>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81dec5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dec9:	8b 50 70             	mov    0x70(%rax),%edx
  81decc:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81ded3:	00 00 00 
  81ded6:	8b 00                	mov    (%rax),%eax
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81ded8:	39 c2                	cmp    %eax,%edx
  81deda:	0f 85 84 00 00 00    	jne    81df64 <tcp_receive+0x133>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81dee0:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81dee7:	00 00 00 
  81deea:	48 8b 00             	mov    (%rax),%rax
  81deed:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81def1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81def5:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81def9:	66 39 c2             	cmp    %ax,%dx
  81defc:	76 66                	jbe    81df64 <tcp_receive+0x133>
      pcb->snd_wnd = tcphdr->wnd;
  81defe:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81df05:	00 00 00 
  81df08:	48 8b 00             	mov    (%rax),%rax
  81df0b:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81df0f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df13:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno;
  81df17:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81df1e:	00 00 00 
  81df21:	8b 10                	mov    (%rax),%edx
  81df23:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df27:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->snd_wl2 = ackno;
  81df2a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81df31:	00 00 00 
  81df34:	8b 10                	mov    (%rax),%edx
  81df36:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df3a:	89 50 70             	mov    %edx,0x70(%rax)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  81df3d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df41:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81df45:	66 85 c0             	test   %ax,%ax
  81df48:	74 1a                	je     81df64 <tcp_receive+0x133>
  81df4a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df4e:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  81df55:	84 c0                	test   %al,%al
  81df57:	74 0b                	je     81df64 <tcp_receive+0x133>
          pcb->persist_backoff = 0;
  81df59:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df5d:	c6 80 d8 00 00 00 00 	movb   $0x0,0xd8(%rax)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  81df64:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df68:	8b 50 54             	mov    0x54(%rax),%edx
  81df6b:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81df72:	00 00 00 
  81df75:	8b 00                	mov    (%rax),%eax
  81df77:	39 c2                	cmp    %eax,%edx
  81df79:	0f 85 72 01 00 00    	jne    81e0f1 <tcp_receive+0x2c0>
      pcb->acked = 0;
  81df7f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df83:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  81df89:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df8d:	8b 50 6c             	mov    0x6c(%rax),%edx
  81df90:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df94:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81df98:	0f b7 c0             	movzwl %ax,%eax
  81df9b:	01 d0                	add    %edx,%eax
  81df9d:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  81dfa0:	0f 85 15 05 00 00    	jne    81e4bb <tcp_receive+0x68a>
        ++pcb->dupacks;
  81dfa6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfaa:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81dfae:	8d 50 01             	lea    0x1(%rax),%edx
  81dfb1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfb5:	88 50 58             	mov    %dl,0x58(%rax)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  81dfb8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfbc:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81dfc0:	3c 02                	cmp    $0x2,%al
  81dfc2:	0f 86 f3 04 00 00    	jbe    81e4bb <tcp_receive+0x68a>
  81dfc8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfcc:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81dfd3:	48 85 c0             	test   %rax,%rax
  81dfd6:	0f 84 df 04 00 00    	je     81e4bb <tcp_receive+0x68a>
          if (!(pcb->flags & TF_INFR)) {
  81dfdc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfe0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dfe4:	0f b6 c0             	movzbl %al,%eax
  81dfe7:	83 e0 04             	and    $0x4,%eax
  81dfea:	85 c0                	test   %eax,%eax
  81dfec:	0f 85 bd 00 00 00    	jne    81e0af <tcp_receive+0x27e>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  81dff2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dff6:	48 89 c7             	mov    %rax,%rdi
  81dff9:	48 b8 fa 44 81 00 00 	movabs $0x8144fa,%rax
  81e000:	00 00 00 
  81e003:	ff d0                	callq  *%rax
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  81e005:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e009:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e00d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e011:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e015:	66 39 c2             	cmp    %ax,%dx
  81e018:	76 17                	jbe    81e031 <tcp_receive+0x200>
              pcb->ssthresh = pcb->snd_wnd / 2;
  81e01a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e01e:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e022:	66 d1 e8             	shr    %ax
  81e025:	89 c2                	mov    %eax,%edx
  81e027:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e02b:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  81e02f:	eb 15                	jmp    81e046 <tcp_receive+0x215>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  81e031:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e035:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e039:	66 d1 e8             	shr    %ax
  81e03c:	89 c2                	mov    %eax,%edx
  81e03e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e042:	66 89 50 5c          	mov    %dx,0x5c(%rax)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  81e046:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e04a:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81e04e:	0f b7 d0             	movzwl %ax,%edx
  81e051:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e055:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e059:	0f b7 c0             	movzwl %ax,%eax
  81e05c:	01 c0                	add    %eax,%eax
  81e05e:	39 c2                	cmp    %eax,%edx
  81e060:	7d 13                	jge    81e075 <tcp_receive+0x244>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  81e062:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e066:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e06a:	8d 14 00             	lea    (%rax,%rax,1),%edx
  81e06d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e071:	66 89 50 5c          	mov    %dx,0x5c(%rax)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  81e075:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e079:	0f b7 48 5c          	movzwl 0x5c(%rax),%ecx
  81e07d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e081:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81e085:	89 d0                	mov    %edx,%eax
  81e087:	01 c0                	add    %eax,%eax
  81e089:	01 d0                	add    %edx,%eax
  81e08b:	8d 14 01             	lea    (%rcx,%rax,1),%edx
  81e08e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e092:	66 89 50 5a          	mov    %dx,0x5a(%rax)
            pcb->flags |= TF_INFR;
  81e096:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e09a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e09e:	83 c8 04             	or     $0x4,%eax
  81e0a1:	89 c2                	mov    %eax,%edx
  81e0a3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0a7:	88 50 2c             	mov    %dl,0x2c(%rax)
  81e0aa:	e9 0c 04 00 00       	jmpq   81e4bb <tcp_receive+0x68a>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81e0af:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0b3:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e0b7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0bb:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e0bf:	01 c2                	add    %eax,%edx
  81e0c1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0c5:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e0c9:	66 39 c2             	cmp    %ax,%dx
  81e0cc:	0f 86 e9 03 00 00    	jbe    81e4bb <tcp_receive+0x68a>
              pcb->cwnd += pcb->mss;
  81e0d2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0d6:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e0da:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0de:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e0e2:	01 c2                	add    %eax,%edx
  81e0e4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0e8:	66 89 50 5a          	mov    %dx,0x5a(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e0ec:	e9 17 05 00 00       	jmpq   81e608 <tcp_receive+0x7d7>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  81e0f1:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e0f8:	00 00 00 
  81e0fb:	8b 10                	mov    (%rax),%edx
  81e0fd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e101:	8b 40 54             	mov    0x54(%rax),%eax
  81e104:	29 c2                	sub    %eax,%edx
  81e106:	89 d0                	mov    %edx,%eax
  81e108:	83 e8 01             	sub    $0x1,%eax
  81e10b:	85 c0                	test   %eax,%eax
  81e10d:	0f 88 99 03 00 00    	js     81e4ac <tcp_receive+0x67b>
  81e113:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e11a:	00 00 00 
  81e11d:	8b 10                	mov    (%rax),%edx
  81e11f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e123:	8b 40 64             	mov    0x64(%rax),%eax
  81e126:	29 c2                	sub    %eax,%edx
  81e128:	89 d0                	mov    %edx,%eax
  81e12a:	85 c0                	test   %eax,%eax
  81e12c:	0f 8f 7a 03 00 00    	jg     81e4ac <tcp_receive+0x67b>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  81e132:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e136:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e13a:	0f b6 c0             	movzbl %al,%eax
  81e13d:	83 e0 04             	and    $0x4,%eax
  81e140:	85 c0                	test   %eax,%eax
  81e142:	74 24                	je     81e168 <tcp_receive+0x337>
        pcb->flags &= ~TF_INFR;
  81e144:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e148:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e14c:	83 e0 fb             	and    $0xfffffffb,%eax
  81e14f:	89 c2                	mov    %eax,%edx
  81e151:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e155:	88 50 2c             	mov    %dl,0x2c(%rax)
        pcb->cwnd = pcb->ssthresh;
  81e158:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e15c:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  81e160:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e164:	66 89 50 5a          	mov    %dx,0x5a(%rax)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  81e168:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e16c:	c6 40 52 00          	movb   $0x0,0x52(%rax)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81e170:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e174:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e178:	66 c1 f8 03          	sar    $0x3,%ax
  81e17c:	89 c2                	mov    %eax,%edx
  81e17e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e182:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e186:	01 d0                	add    %edx,%eax
  81e188:	89 c2                	mov    %eax,%edx
  81e18a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e18e:	66 89 50 50          	mov    %dx,0x50(%rax)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  81e192:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e199:	00 00 00 
  81e19c:	8b 00                	mov    (%rax),%eax
  81e19e:	89 c2                	mov    %eax,%edx
  81e1a0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1a4:	8b 40 54             	mov    0x54(%rax),%eax
  81e1a7:	29 c2                	sub    %eax,%edx
  81e1a9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1ad:	66 89 50 78          	mov    %dx,0x78(%rax)

      pcb->snd_buf += pcb->acked;
  81e1b1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1b5:	0f b7 50 7a          	movzwl 0x7a(%rax),%edx
  81e1b9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1bd:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81e1c1:	01 c2                	add    %eax,%edx
  81e1c3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1c7:	66 89 50 7a          	mov    %dx,0x7a(%rax)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  81e1cb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1cf:	c6 40 58 00          	movb   $0x0,0x58(%rax)
      pcb->lastack = ackno;
  81e1d3:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e1da:	00 00 00 
  81e1dd:	8b 10                	mov    (%rax),%edx
  81e1df:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1e3:	89 50 54             	mov    %edx,0x54(%rax)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  81e1e6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1ea:	8b 40 18             	mov    0x18(%rax),%eax
  81e1ed:	83 f8 03             	cmp    $0x3,%eax
  81e1f0:	0f 86 a1 00 00 00    	jbe    81e297 <tcp_receive+0x466>
        if (pcb->cwnd < pcb->ssthresh) {
  81e1f6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1fa:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e1fe:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e202:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81e206:	66 39 c2             	cmp    %ax,%dx
  81e209:	73 3b                	jae    81e246 <tcp_receive+0x415>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81e20b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e20f:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e213:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e217:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e21b:	01 c2                	add    %eax,%edx
  81e21d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e221:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e225:	66 39 c2             	cmp    %ax,%dx
  81e228:	76 6d                	jbe    81e297 <tcp_receive+0x466>
            pcb->cwnd += pcb->mss;
  81e22a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e22e:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e232:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e236:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e23a:	01 c2                	add    %eax,%edx
  81e23c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e240:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81e244:	eb 51                	jmp    81e297 <tcp_receive+0x466>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  81e246:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e24a:	0f b7 48 5a          	movzwl 0x5a(%rax),%ecx
  81e24e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e252:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e256:	0f b7 d0             	movzwl %ax,%edx
  81e259:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e25d:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e261:	0f b7 c0             	movzwl %ax,%eax
  81e264:	0f af c2             	imul   %edx,%eax
  81e267:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e26b:	0f b7 52 5a          	movzwl 0x5a(%rdx),%edx
  81e26f:	0f b7 f2             	movzwl %dx,%esi
  81e272:	99                   	cltd   
  81e273:	f7 fe                	idiv   %esi
  81e275:	01 c8                	add    %ecx,%eax
  81e277:	66 89 45 ba          	mov    %ax,-0x46(%rbp)
          if (new_cwnd > pcb->cwnd) {
  81e27b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e27f:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e283:	66 3b 45 ba          	cmp    -0x46(%rbp),%ax
  81e287:	73 0e                	jae    81e297 <tcp_receive+0x466>
            pcb->cwnd = new_cwnd;
  81e289:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e28d:	0f b7 55 ba          	movzwl -0x46(%rbp),%edx
  81e291:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81e295:	eb 00                	jmp    81e297 <tcp_receive+0x466>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e297:	e9 11 01 00 00       	jmpq   81e3ad <tcp_receive+0x57c>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  81e29c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2a0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e2a7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        pcb->unacked = pcb->unacked->next;
  81e2ab:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2af:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e2b6:	48 8b 10             	mov    (%rax),%rdx
  81e2b9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2bd:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e2c4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2c8:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e2cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e2d0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e2d4:	48 89 c7             	mov    %rax,%rdi
  81e2d7:	48 b8 c4 db 80 00 00 	movabs $0x80dbc4,%rax
  81e2de:	00 00 00 
  81e2e1:	ff d0                	callq  *%rax
  81e2e3:	0f b6 c0             	movzbl %al,%eax
  81e2e6:	66 39 c3             	cmp    %ax,%bx
  81e2e9:	73 2a                	jae    81e315 <tcp_receive+0x4e4>
  81e2eb:	48 ba 48 37 82 00 00 	movabs $0x823748,%rdx
  81e2f2:	00 00 00 
  81e2f5:	be 55 03 00 00       	mov    $0x355,%esi
  81e2fa:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81e301:	00 00 00 
  81e304:	b8 00 00 00 00       	mov    $0x0,%eax
  81e309:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81e310:	00 00 00 
  81e313:	ff d1                	callq  *%rcx
        pcb->snd_queuelen -= pbuf_clen(next->p);
  81e315:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e319:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e31d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e321:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e325:	48 89 c7             	mov    %rax,%rdi
  81e328:	48 b8 c4 db 80 00 00 	movabs $0x80dbc4,%rax
  81e32f:	00 00 00 
  81e332:	ff d0                	callq  *%rax
  81e334:	0f b6 c0             	movzbl %al,%eax
  81e337:	29 c3                	sub    %eax,%ebx
  81e339:	89 da                	mov    %ebx,%edx
  81e33b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e33f:	66 89 50 7c          	mov    %dx,0x7c(%rax)
        tcp_seg_free(next);
  81e343:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e347:	48 89 c7             	mov    %rax,%rdi
  81e34a:	48 b8 4b 01 81 00 00 	movabs $0x81014b,%rax
  81e351:	00 00 00 
  81e354:	ff d0                	callq  *%rax

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  81e356:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e35a:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81e35e:	66 85 c0             	test   %ax,%ax
  81e361:	74 4a                	je     81e3ad <tcp_receive+0x57c>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  81e363:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e367:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e36e:	48 85 c0             	test   %rax,%rax
  81e371:	75 3a                	jne    81e3ad <tcp_receive+0x57c>
  81e373:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e377:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e37e:	48 85 c0             	test   %rax,%rax
  81e381:	75 2a                	jne    81e3ad <tcp_receive+0x57c>
  81e383:	48 ba 70 37 82 00 00 	movabs $0x823770,%rdx
  81e38a:	00 00 00 
  81e38d:	be 5c 03 00 00       	mov    $0x35c,%esi
  81e392:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81e399:	00 00 00 
  81e39c:	b8 00 00 00 00       	mov    $0x0,%eax
  81e3a1:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81e3a8:	00 00 00 
  81e3ab:	ff d1                	callq  *%rcx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e3ad:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3b1:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e3b8:	48 85 c0             	test   %rax,%rax
  81e3bb:	0f 84 bb 00 00 00    	je     81e47c <tcp_receive+0x64b>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  81e3c1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3c5:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e3cc:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e3d0:	8b 40 04             	mov    0x4(%rax),%eax
  81e3d3:	89 c7                	mov    %eax,%edi
  81e3d5:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  81e3dc:	00 00 00 
  81e3df:	ff d0                	callq  *%rax
  81e3e1:	89 c3                	mov    %eax,%ebx
  81e3e3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3e7:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e3ee:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e3f2:	44 0f b7 e0          	movzwl %ax,%r12d
  81e3f6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3fa:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e401:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e405:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e409:	0f b7 c0             	movzwl %ax,%eax
  81e40c:	89 c7                	mov    %eax,%edi
  81e40e:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81e415:	00 00 00 
  81e418:	ff d0                	callq  *%rax
  81e41a:	0f b7 c0             	movzwl %ax,%eax
  81e41d:	83 e0 01             	and    $0x1,%eax
  81e420:	85 c0                	test   %eax,%eax
  81e422:	75 2e                	jne    81e452 <tcp_receive+0x621>
  81e424:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e428:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e42f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e433:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e437:	0f b7 c0             	movzwl %ax,%eax
  81e43a:	89 c7                	mov    %eax,%edi
  81e43c:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81e443:	00 00 00 
  81e446:	ff d0                	callq  *%rax
  81e448:	0f b7 c0             	movzwl %ax,%eax
  81e44b:	83 e0 02             	and    $0x2,%eax
  81e44e:	85 c0                	test   %eax,%eax
  81e450:	74 07                	je     81e459 <tcp_receive+0x628>
  81e452:	b8 01 00 00 00       	mov    $0x1,%eax
  81e457:	eb 05                	jmp    81e45e <tcp_receive+0x62d>
  81e459:	b8 00 00 00 00       	mov    $0x0,%eax
  81e45e:	44 01 e0             	add    %r12d,%eax
  81e461:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81e464:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e46b:	00 00 00 
  81e46e:	8b 00                	mov    (%rax),%eax
  81e470:	29 c2                	sub    %eax,%edx
  81e472:	89 d0                	mov    %edx,%eax
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e474:	85 c0                	test   %eax,%eax
  81e476:	0f 8e 20 fe ff ff    	jle    81e29c <tcp_receive+0x46b>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81e47c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e480:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e487:	48 85 c0             	test   %rax,%rax
  81e48a:	75 0c                	jne    81e498 <tcp_receive+0x667>
        pcb->rtime = -1;
  81e48c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e490:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81e496:	eb 0a                	jmp    81e4a2 <tcp_receive+0x671>
      else
        pcb->rtime = 0;
  81e498:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e49c:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

      pcb->polltmr = 0;
  81e4a2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4a6:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
  81e4aa:	eb 0f                	jmp    81e4bb <tcp_receive+0x68a>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  81e4ac:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4b0:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e4b6:	e9 4d 01 00 00       	jmpq   81e608 <tcp_receive+0x7d7>
  81e4bb:	e9 48 01 00 00       	jmpq   81e608 <tcp_receive+0x7d7>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  81e4c0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4c4:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e4cb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      pcb->unsent = pcb->unsent->next;
  81e4cf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4d3:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e4da:	48 8b 10             	mov    (%rax),%rdx
  81e4dd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4e1:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e4e8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4ec:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e4f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e4f4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e4f8:	48 89 c7             	mov    %rax,%rdi
  81e4fb:	48 b8 c4 db 80 00 00 	movabs $0x80dbc4,%rax
  81e502:	00 00 00 
  81e505:	ff d0                	callq  *%rax
  81e507:	0f b6 c0             	movzbl %al,%eax
  81e50a:	66 39 c3             	cmp    %ax,%bx
  81e50d:	73 2a                	jae    81e539 <tcp_receive+0x708>
  81e50f:	48 ba 48 37 82 00 00 	movabs $0x823748,%rdx
  81e516:	00 00 00 
  81e519:	be 7f 03 00 00       	mov    $0x37f,%esi
  81e51e:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81e525:	00 00 00 
  81e528:	b8 00 00 00 00       	mov    $0x0,%eax
  81e52d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81e534:	00 00 00 
  81e537:	ff d1                	callq  *%rcx
      pcb->snd_queuelen -= pbuf_clen(next->p);
  81e539:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e53d:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e541:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e545:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e549:	48 89 c7             	mov    %rax,%rdi
  81e54c:	48 b8 c4 db 80 00 00 	movabs $0x80dbc4,%rax
  81e553:	00 00 00 
  81e556:	ff d0                	callq  *%rax
  81e558:	0f b6 c0             	movzbl %al,%eax
  81e55b:	29 c3                	sub    %eax,%ebx
  81e55d:	89 da                	mov    %ebx,%edx
  81e55f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e563:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      tcp_seg_free(next);
  81e567:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e56b:	48 89 c7             	mov    %rax,%rdi
  81e56e:	48 b8 4b 01 81 00 00 	movabs $0x81014b,%rax
  81e575:	00 00 00 
  81e578:	ff d0                	callq  *%rax
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  81e57a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e57e:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81e582:	66 85 c0             	test   %ax,%ax
  81e585:	74 4a                	je     81e5d1 <tcp_receive+0x7a0>
        LWIP_ASSERT("tcp_receive: valid queue length",
  81e587:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e58b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e592:	48 85 c0             	test   %rax,%rax
  81e595:	75 3a                	jne    81e5d1 <tcp_receive+0x7a0>
  81e597:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e59b:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e5a2:	48 85 c0             	test   %rax,%rax
  81e5a5:	75 2a                	jne    81e5d1 <tcp_receive+0x7a0>
  81e5a7:	48 ba 70 37 82 00 00 	movabs $0x823770,%rdx
  81e5ae:	00 00 00 
  81e5b1:	be 85 03 00 00       	mov    $0x385,%esi
  81e5b6:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81e5bd:	00 00 00 
  81e5c0:	b8 00 00 00 00       	mov    $0x0,%eax
  81e5c5:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81e5cc:	00 00 00 
  81e5cf:	ff d1                	callq  *%rcx
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  81e5d1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5d5:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e5dc:	48 85 c0             	test   %rax,%rax
  81e5df:	74 27                	je     81e608 <tcp_receive+0x7d7>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  81e5e1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5e5:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e5ec:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e5f0:	8b 40 04             	mov    0x4(%rax),%eax
  81e5f3:	89 c7                	mov    %eax,%edi
  81e5f5:	48 b8 23 2d 81 00 00 	movabs $0x812d23,%rax
  81e5fc:	00 00 00 
  81e5ff:	ff d0                	callq  *%rax
  81e601:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e605:	89 42 60             	mov    %eax,0x60(%rdx)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e608:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e60c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e613:	48 85 c0             	test   %rax,%rax
  81e616:	0f 84 d8 00 00 00    	je     81e6f4 <tcp_receive+0x8c3>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81e61c:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e623:	00 00 00 
  81e626:	44 8b 20             	mov    (%rax),%r12d
  81e629:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e62d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e634:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e638:	8b 40 04             	mov    0x4(%rax),%eax
  81e63b:	89 c7                	mov    %eax,%edi
  81e63d:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  81e644:	00 00 00 
  81e647:	ff d0                	callq  *%rax
  81e649:	89 c3                	mov    %eax,%ebx
  81e64b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e64f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e656:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e65a:	44 0f b7 e8          	movzwl %ax,%r13d
  81e65e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e662:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e669:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e66d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e671:	0f b7 c0             	movzwl %ax,%eax
  81e674:	89 c7                	mov    %eax,%edi
  81e676:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81e67d:	00 00 00 
  81e680:	ff d0                	callq  *%rax
  81e682:	0f b7 c0             	movzwl %ax,%eax
  81e685:	83 e0 01             	and    $0x1,%eax
  81e688:	85 c0                	test   %eax,%eax
  81e68a:	75 2e                	jne    81e6ba <tcp_receive+0x889>
  81e68c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e690:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e697:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e69b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e69f:	0f b7 c0             	movzwl %ax,%eax
  81e6a2:	89 c7                	mov    %eax,%edi
  81e6a4:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81e6ab:	00 00 00 
  81e6ae:	ff d0                	callq  *%rax
  81e6b0:	0f b7 c0             	movzwl %ax,%eax
  81e6b3:	83 e0 02             	and    $0x2,%eax
  81e6b6:	85 c0                	test   %eax,%eax
  81e6b8:	74 07                	je     81e6c1 <tcp_receive+0x890>
  81e6ba:	b8 01 00 00 00       	mov    $0x1,%eax
  81e6bf:	eb 05                	jmp    81e6c6 <tcp_receive+0x895>
  81e6c1:	b8 00 00 00 00       	mov    $0x0,%eax
  81e6c6:	44 01 e8             	add    %r13d,%eax
  81e6c9:	01 d8                	add    %ebx,%eax
  81e6cb:	41 29 c4             	sub    %eax,%r12d
  81e6ce:	44 89 e0             	mov    %r12d,%eax
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e6d1:	85 c0                	test   %eax,%eax
  81e6d3:	78 1f                	js     81e6f4 <tcp_receive+0x8c3>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81e6d5:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e6dc:	00 00 00 
  81e6df:	8b 10                	mov    (%rax),%edx
  81e6e1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6e5:	8b 40 64             	mov    0x64(%rax),%eax
  81e6e8:	29 c2                	sub    %eax,%edx
  81e6ea:	89 d0                	mov    %edx,%eax
  81e6ec:	85 c0                	test   %eax,%eax
  81e6ee:	0f 8e cc fd ff ff    	jle    81e4c0 <tcp_receive+0x68f>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  81e6f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6f8:	8b 40 44             	mov    0x44(%rax),%eax
  81e6fb:	85 c0                	test   %eax,%eax
  81e6fd:	0f 84 de 00 00 00    	je     81e7e1 <tcp_receive+0x9b0>
  81e703:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e707:	8b 50 48             	mov    0x48(%rax),%edx
  81e70a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e711:	00 00 00 
  81e714:	8b 00                	mov    (%rax),%eax
  81e716:	29 c2                	sub    %eax,%edx
  81e718:	89 d0                	mov    %edx,%eax
  81e71a:	85 c0                	test   %eax,%eax
  81e71c:	0f 89 bf 00 00 00    	jns    81e7e1 <tcp_receive+0x9b0>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  81e722:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81e729:	00 00 00 
  81e72c:	8b 00                	mov    (%rax),%eax
  81e72e:	89 c2                	mov    %eax,%edx
  81e730:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e734:	8b 40 44             	mov    0x44(%rax),%eax
  81e737:	29 c2                	sub    %eax,%edx
  81e739:	89 d0                	mov    %edx,%eax
  81e73b:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  81e73f:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81e743:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e747:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e74b:	66 c1 f8 03          	sar    $0x3,%ax
  81e74f:	29 c2                	sub    %eax,%edx
  81e751:	89 d0                	mov    %edx,%eax
  81e753:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sa += m;
  81e757:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e75b:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e75f:	89 c2                	mov    %eax,%edx
  81e761:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81e765:	01 d0                	add    %edx,%eax
  81e767:	89 c2                	mov    %eax,%edx
  81e769:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e76d:	66 89 50 4c          	mov    %dx,0x4c(%rax)
      if (m < 0) {
  81e771:	66 83 7d c2 00       	cmpw   $0x0,-0x3e(%rbp)
  81e776:	79 0a                	jns    81e782 <tcp_receive+0x951>
        m = -m;
  81e778:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81e77c:	f7 d8                	neg    %eax
  81e77e:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      }
      m = m - (pcb->sv >> 2);
  81e782:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81e786:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e78a:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e78e:	66 c1 f8 02          	sar    $0x2,%ax
  81e792:	29 c2                	sub    %eax,%edx
  81e794:	89 d0                	mov    %edx,%eax
  81e796:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sv += m;
  81e79a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e79e:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e7a2:	89 c2                	mov    %eax,%edx
  81e7a4:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81e7a8:	01 d0                	add    %edx,%eax
  81e7aa:	89 c2                	mov    %eax,%edx
  81e7ac:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7b0:	66 89 50 4e          	mov    %dx,0x4e(%rax)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81e7b4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7b8:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e7bc:	66 c1 f8 03          	sar    $0x3,%ax
  81e7c0:	89 c2                	mov    %eax,%edx
  81e7c2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7c6:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e7ca:	01 d0                	add    %edx,%eax
  81e7cc:	89 c2                	mov    %eax,%edx
  81e7ce:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7d2:	66 89 50 50          	mov    %dx,0x50(%rax)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  81e7d6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7da:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  81e7e1:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81e7e8:	00 00 00 
  81e7eb:	0f b7 00             	movzwl (%rax),%eax
  81e7ee:	66 85 c0             	test   %ax,%ax
  81e7f1:	0f 84 26 10 00 00    	je     81f81d <tcp_receive+0x19ec>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  81e7f7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7fb:	8b 50 30             	mov    0x30(%rax),%edx
  81e7fe:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e805:	00 00 00 
  81e808:	8b 00                	mov    (%rax),%eax
  81e80a:	29 c2                	sub    %eax,%edx
  81e80c:	89 d0                	mov    %edx,%eax
  81e80e:	83 e8 01             	sub    $0x1,%eax
  81e811:	85 c0                	test   %eax,%eax
  81e813:	0f 88 af 02 00 00    	js     81eac8 <tcp_receive+0xc97>
  81e819:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e81d:	8b 50 30             	mov    0x30(%rax),%edx
  81e820:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81e827:	00 00 00 
  81e82a:	0f b7 00             	movzwl (%rax),%eax
  81e82d:	0f b7 c8             	movzwl %ax,%ecx
  81e830:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e837:	00 00 00 
  81e83a:	8b 00                	mov    (%rax),%eax
  81e83c:	01 c8                	add    %ecx,%eax
  81e83e:	29 c2                	sub    %eax,%edx
  81e840:	89 d0                	mov    %edx,%eax
  81e842:	83 c0 01             	add    $0x1,%eax
  81e845:	85 c0                	test   %eax,%eax
  81e847:	0f 8f 7b 02 00 00    	jg     81eac8 <tcp_receive+0xc97>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  81e84d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e851:	8b 50 30             	mov    0x30(%rax),%edx
  81e854:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e85b:	00 00 00 
  81e85e:	8b 00                	mov    (%rax),%eax
  81e860:	29 c2                	sub    %eax,%edx
  81e862:	89 d0                	mov    %edx,%eax
  81e864:	89 45 c4             	mov    %eax,-0x3c(%rbp)
      p = inseg.p;
  81e867:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e86e:	00 00 00 
  81e871:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e875:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  81e879:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e880:	00 00 00 
  81e883:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e887:	48 85 c0             	test   %rax,%rax
  81e88a:	75 2a                	jne    81e8b6 <tcp_receive+0xa85>
  81e88c:	48 ba 90 37 82 00 00 	movabs $0x823790,%rdx
  81e893:	00 00 00 
  81e896:	be e5 03 00 00       	mov    $0x3e5,%esi
  81e89b:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81e8a2:	00 00 00 
  81e8a5:	b8 00 00 00 00       	mov    $0x0,%eax
  81e8aa:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81e8b1:	00 00 00 
  81e8b4:	ff d1                	callq  *%rcx
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  81e8b6:	81 7d c4 fe 7f 00 00 	cmpl   $0x7ffe,-0x3c(%rbp)
  81e8bd:	7e 2a                	jle    81e8e9 <tcp_receive+0xab8>
  81e8bf:	48 ba a0 37 82 00 00 	movabs $0x8237a0,%rdx
  81e8c6:	00 00 00 
  81e8c9:	be e6 03 00 00       	mov    $0x3e6,%esi
  81e8ce:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81e8d5:	00 00 00 
  81e8d8:	b8 00 00 00 00       	mov    $0x0,%eax
  81e8dd:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81e8e4:	00 00 00 
  81e8e7:	ff d1                	callq  *%rcx
      if (inseg.p->len < off) {
  81e8e9:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e8f0:	00 00 00 
  81e8f3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e8f7:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81e8fb:	0f b7 c0             	movzwl %ax,%eax
  81e8fe:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81e901:	0f 8d ed 00 00 00    	jge    81e9f4 <tcp_receive+0xbc3>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  81e907:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e90e:	00 00 00 
  81e911:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e915:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81e919:	0f b7 c0             	movzwl %ax,%eax
  81e91c:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81e91f:	7d 2a                	jge    81e94b <tcp_receive+0xb1a>
  81e921:	48 ba af 37 82 00 00 	movabs $0x8237af,%rdx
  81e928:	00 00 00 
  81e92b:	be e8 03 00 00       	mov    $0x3e8,%esi
  81e930:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81e937:	00 00 00 
  81e93a:	b8 00 00 00 00       	mov    $0x0,%eax
  81e93f:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81e946:	00 00 00 
  81e949:	ff d1                	callq  *%rcx
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  81e94b:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e952:	00 00 00 
  81e955:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e959:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81e95d:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81e960:	29 c2                	sub    %eax,%edx
  81e962:	89 d0                	mov    %edx,%eax
  81e964:	66 89 45 b8          	mov    %ax,-0x48(%rbp)
        while (p->len < off) {
  81e968:	eb 2f                	jmp    81e999 <tcp_receive+0xb68>
          off -= p->len;
  81e96a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e96e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81e972:	0f b7 c0             	movzwl %ax,%eax
  81e975:	29 45 c4             	sub    %eax,-0x3c(%rbp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  81e978:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e97c:	0f b7 55 b8          	movzwl -0x48(%rbp),%edx
  81e980:	66 89 50 10          	mov    %dx,0x10(%rax)
          p->len = 0;
  81e984:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e988:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
          p = p->next;
  81e98e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e992:	48 8b 00             	mov    (%rax),%rax
  81e995:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  81e999:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e99d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81e9a1:	0f b7 c0             	movzwl %ax,%eax
  81e9a4:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81e9a7:	7c c1                	jl     81e96a <tcp_receive+0xb39>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  81e9a9:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81e9ac:	f7 d8                	neg    %eax
  81e9ae:	0f bf d0             	movswl %ax,%edx
  81e9b1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e9b5:	89 d6                	mov    %edx,%esi
  81e9b7:	48 89 c7             	mov    %rax,%rdi
  81e9ba:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  81e9c1:	00 00 00 
  81e9c4:	ff d0                	callq  *%rax
  81e9c6:	84 c0                	test   %al,%al
  81e9c8:	74 7f                	je     81ea49 <tcp_receive+0xc18>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81e9ca:	48 ba bf 37 82 00 00 	movabs $0x8237bf,%rdx
  81e9d1:	00 00 00 
  81e9d4:	be f5 03 00 00       	mov    $0x3f5,%esi
  81e9d9:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81e9e0:	00 00 00 
  81e9e3:	b8 00 00 00 00       	mov    $0x0,%eax
  81e9e8:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81e9ef:	00 00 00 
  81e9f2:	ff d1                	callq  *%rcx
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  81e9f4:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81e9f7:	f7 d8                	neg    %eax
  81e9f9:	0f bf d0             	movswl %ax,%edx
  81e9fc:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ea03:	00 00 00 
  81ea06:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ea0a:	89 d6                	mov    %edx,%esi
  81ea0c:	48 89 c7             	mov    %rax,%rdi
  81ea0f:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  81ea16:	00 00 00 
  81ea19:	ff d0                	callq  *%rax
  81ea1b:	84 c0                	test   %al,%al
  81ea1d:	74 2a                	je     81ea49 <tcp_receive+0xc18>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81ea1f:	48 ba bf 37 82 00 00 	movabs $0x8237bf,%rdx
  81ea26:	00 00 00 
  81ea29:	be fa 03 00 00       	mov    $0x3fa,%esi
  81ea2e:	48 bf a7 35 82 00 00 	movabs $0x8235a7,%rdi
  81ea35:	00 00 00 
  81ea38:	b8 00 00 00 00       	mov    $0x0,%eax
  81ea3d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81ea44:	00 00 00 
  81ea47:	ff d1                	callq  *%rcx
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  81ea49:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ea4d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ea51:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ea58:	00 00 00 
  81ea5b:	48 89 50 10          	mov    %rdx,0x10(%rax)
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  81ea5f:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ea66:	00 00 00 
  81ea69:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81ea6d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ea74:	00 00 00 
  81ea77:	8b 00                	mov    (%rax),%eax
  81ea79:	89 c1                	mov    %eax,%ecx
  81ea7b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea7f:	8b 40 30             	mov    0x30(%rax),%eax
  81ea82:	29 c1                	sub    %eax,%ecx
  81ea84:	89 c8                	mov    %ecx,%eax
  81ea86:	01 c2                	add    %eax,%edx
  81ea88:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ea8f:	00 00 00 
  81ea92:	66 89 50 18          	mov    %dx,0x18(%rax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  81ea96:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ea9d:	00 00 00 
  81eaa0:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eaa4:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81eaa8:	8b 4a 30             	mov    0x30(%rdx),%ecx
  81eaab:	48 ba d8 74 b5 00 00 	movabs $0xb574d8,%rdx
  81eab2:	00 00 00 
  81eab5:	89 0a                	mov    %ecx,(%rdx)
  81eab7:	48 ba d8 74 b5 00 00 	movabs $0xb574d8,%rdx
  81eabe:	00 00 00 
  81eac1:	8b 12                	mov    (%rdx),%edx
  81eac3:	89 50 04             	mov    %edx,0x4(%rax)
  81eac6:	eb 42                	jmp    81eb0a <tcp_receive+0xcd9>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  81eac8:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81eacf:	00 00 00 
  81ead2:	8b 10                	mov    (%rax),%edx
  81ead4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ead8:	8b 40 30             	mov    0x30(%rax),%eax
  81eadb:	29 c2                	sub    %eax,%edx
  81eadd:	89 d0                	mov    %edx,%eax
  81eadf:	85 c0                	test   %eax,%eax
  81eae1:	79 27                	jns    81eb0a <tcp_receive+0xcd9>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  81eae3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eae7:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81eaeb:	83 c8 02             	or     $0x2,%eax
  81eaee:	89 c2                	mov    %eax,%edx
  81eaf0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eaf4:	88 50 2c             	mov    %dl,0x2c(%rax)
  81eaf7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eafb:	48 89 c7             	mov    %rax,%rdi
  81eafe:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81eb05:	00 00 00 
  81eb08:	ff d0                	callq  *%rax
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81eb0a:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81eb11:	00 00 00 
  81eb14:	8b 10                	mov    (%rax),%edx
  81eb16:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb1a:	8b 40 30             	mov    0x30(%rax),%eax
  81eb1d:	29 c2                	sub    %eax,%edx
  81eb1f:	89 d0                	mov    %edx,%eax
  81eb21:	85 c0                	test   %eax,%eax
  81eb23:	0f 88 c9 0c 00 00    	js     81f7f2 <tcp_receive+0x19c1>
  81eb29:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81eb30:	00 00 00 
  81eb33:	8b 10                	mov    (%rax),%edx
  81eb35:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb39:	8b 48 30             	mov    0x30(%rax),%ecx
  81eb3c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb40:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81eb44:	0f b7 c0             	movzwl %ax,%eax
  81eb47:	01 c8                	add    %ecx,%eax
  81eb49:	29 c2                	sub    %eax,%edx
  81eb4b:	89 d0                	mov    %edx,%eax
  81eb4d:	83 c0 01             	add    $0x1,%eax
  81eb50:	85 c0                	test   %eax,%eax
  81eb52:	0f 8f 9a 0c 00 00    	jg     81f7f2 <tcp_receive+0x19c1>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81eb58:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb5c:	8b 50 30             	mov    0x30(%rax),%edx
  81eb5f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81eb66:	00 00 00 
  81eb69:	8b 00                	mov    (%rax),%eax
  81eb6b:	39 c2                	cmp    %eax,%edx
  81eb6d:	0f 85 42 07 00 00    	jne    81f2b5 <tcp_receive+0x1484>
        accepted_inseq = 1; 
  81eb73:	c6 45 c1 01          	movb   $0x1,-0x3f(%rbp)
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81eb77:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb7b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eb82:	48 85 c0             	test   %rax,%rax
  81eb85:	0f 84 4c 01 00 00    	je     81ecd7 <tcp_receive+0xea6>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  81eb8b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb8f:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eb96:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eb9a:	8b 50 04             	mov    0x4(%rax),%edx
  81eb9d:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81eba4:	00 00 00 
  81eba7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ebab:	0f b7 c8             	movzwl %ax,%ecx
  81ebae:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ebb5:	00 00 00 
  81ebb8:	8b 00                	mov    (%rax),%eax
  81ebba:	01 c8                	add    %ecx,%eax
  81ebbc:	29 c2                	sub    %eax,%edx
  81ebbe:	89 d0                	mov    %edx,%eax
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81ebc0:	85 c0                	test   %eax,%eax
  81ebc2:	0f 8f 0f 01 00 00    	jg     81ecd7 <tcp_receive+0xea6>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  81ebc8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ebcc:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ebd3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ebd7:	66 85 c0             	test   %ax,%ax
  81ebda:	74 65                	je     81ec41 <tcp_receive+0xe10>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  81ebdc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ebe0:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ebe7:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ebeb:	8b 40 04             	mov    0x4(%rax),%eax
  81ebee:	89 c2                	mov    %eax,%edx
  81ebf0:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ebf7:	00 00 00 
  81ebfa:	8b 00                	mov    (%rax),%eax
  81ebfc:	29 c2                	sub    %eax,%edx
  81ebfe:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec05:	00 00 00 
  81ec08:	66 89 50 18          	mov    %dx,0x18(%rax)
            pbuf_realloc(inseg.p, inseg.len);
  81ec0c:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec13:	00 00 00 
  81ec16:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ec1a:	0f b7 d0             	movzwl %ax,%edx
  81ec1d:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec24:	00 00 00 
  81ec27:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ec2b:	89 d6                	mov    %edx,%esi
  81ec2d:	48 89 c7             	mov    %rax,%rdi
  81ec30:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  81ec37:	00 00 00 
  81ec3a:	ff d0                	callq  *%rax
  81ec3c:	e9 96 00 00 00       	jmpq   81ecd7 <tcp_receive+0xea6>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81ec41:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec48:	00 00 00 
  81ec4b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ec4f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ec53:	0f b7 c0             	movzwl %ax,%eax
  81ec56:	89 c7                	mov    %eax,%edi
  81ec58:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81ec5f:	00 00 00 
  81ec62:	ff d0                	callq  *%rax
  81ec64:	0f b7 d8             	movzwl %ax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  81ec67:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec6b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ec72:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ec76:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ec7a:	0f b7 c0             	movzwl %ax,%eax
  81ec7d:	89 c7                	mov    %eax,%edi
  81ec7f:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81ec86:	00 00 00 
  81ec89:	ff d0                	callq  *%rax
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81ec8b:	0f b7 c0             	movzwl %ax,%eax
  81ec8e:	31 d8                	xor    %ebx,%eax
  81ec90:	83 e0 03             	and    $0x3,%eax
  81ec93:	85 c0                	test   %eax,%eax
  81ec95:	75 40                	jne    81ecd7 <tcp_receive+0xea6>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  81ec97:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec9b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eca2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
              pcb->ooseq = pcb->ooseq->next;
  81eca6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ecaa:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ecb1:	48 8b 10             	mov    (%rax),%rdx
  81ecb4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ecb8:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  81ecbf:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  81ecc3:	48 89 c6             	mov    %rax,%rsi
  81ecc6:	bf 04 00 00 00       	mov    $0x4,%edi
  81eccb:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81ecd2:	00 00 00 
  81ecd5:	ff d0                	callq  *%rax
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  81ecd7:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ecde:	00 00 00 
  81ece1:	0f b7 58 18          	movzwl 0x18(%rax),%ebx
  81ece5:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ecec:	00 00 00 
  81ecef:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ecf3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ecf7:	0f b7 c0             	movzwl %ax,%eax
  81ecfa:	89 c7                	mov    %eax,%edi
  81ecfc:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81ed03:	00 00 00 
  81ed06:	ff d0                	callq  *%rax
  81ed08:	0f b7 c0             	movzwl %ax,%eax
  81ed0b:	83 e0 01             	and    $0x1,%eax
  81ed0e:	85 c0                	test   %eax,%eax
  81ed10:	75 2d                	jne    81ed3f <tcp_receive+0xf0e>
  81ed12:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ed19:	00 00 00 
  81ed1c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ed20:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ed24:	0f b7 c0             	movzwl %ax,%eax
  81ed27:	89 c7                	mov    %eax,%edi
  81ed29:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81ed30:	00 00 00 
  81ed33:	ff d0                	callq  *%rax
  81ed35:	0f b7 c0             	movzwl %ax,%eax
  81ed38:	83 e0 02             	and    $0x2,%eax
  81ed3b:	85 c0                	test   %eax,%eax
  81ed3d:	74 07                	je     81ed46 <tcp_receive+0xf15>
  81ed3f:	b8 01 00 00 00       	mov    $0x1,%eax
  81ed44:	eb 05                	jmp    81ed4b <tcp_receive+0xf1a>
  81ed46:	b8 00 00 00 00       	mov    $0x0,%eax
  81ed4b:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81ed4e:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ed55:	00 00 00 
  81ed58:	66 89 10             	mov    %dx,(%rax)

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  81ed5b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed5f:	8b 40 18             	mov    0x18(%rax),%eax
  81ed62:	83 f8 07             	cmp    $0x7,%eax
  81ed65:	74 20                	je     81ed87 <tcp_receive+0xf56>
          pcb->rcv_nxt += tcplen;
  81ed67:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed6b:	8b 50 30             	mov    0x30(%rax),%edx
  81ed6e:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ed75:	00 00 00 
  81ed78:	0f b7 00             	movzwl (%rax),%eax
  81ed7b:	0f b7 c0             	movzwl %ax,%eax
  81ed7e:	01 c2                	add    %eax,%edx
  81ed80:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed84:	89 50 30             	mov    %edx,0x30(%rax)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  81ed87:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed8b:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81ed8f:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ed96:	00 00 00 
  81ed99:	0f b7 00             	movzwl (%rax),%eax
  81ed9c:	66 39 c2             	cmp    %ax,%dx
  81ed9f:	73 0c                	jae    81edad <tcp_receive+0xf7c>
          pcb->rcv_wnd = 0;
  81eda1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eda5:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81edab:	eb 1f                	jmp    81edcc <tcp_receive+0xf9b>
        } else {
          pcb->rcv_wnd -= tcplen;
  81edad:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81edb1:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81edb5:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81edbc:	00 00 00 
  81edbf:	0f b7 00             	movzwl (%rax),%eax
  81edc2:	29 c2                	sub    %eax,%edx
  81edc4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81edc8:	66 89 50 34          	mov    %dx,0x34(%rax)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  81edcc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81edd0:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81edd4:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81eddb:	00 00 00 
  81edde:	0f b7 00             	movzwl (%rax),%eax
  81ede1:	66 39 c2             	cmp    %ax,%dx
  81ede4:	73 0c                	jae    81edf2 <tcp_receive+0xfc1>
          pcb->rcv_ann_wnd = 0;
  81ede6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81edea:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81edf0:	eb 1f                	jmp    81ee11 <tcp_receive+0xfe0>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  81edf2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81edf6:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81edfa:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ee01:	00 00 00 
  81ee04:	0f b7 00             	movzwl (%rax),%eax
  81ee07:	29 c2                	sub    %eax,%edx
  81ee09:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee0d:	66 89 50 36          	mov    %dx,0x36(%rax)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  81ee11:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ee18:	00 00 00 
  81ee1b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ee1f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ee23:	66 85 c0             	test   %ax,%ax
  81ee26:	74 2d                	je     81ee55 <tcp_receive+0x1024>
          recv_data = inseg.p;
  81ee28:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ee2f:	00 00 00 
  81ee32:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ee36:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81ee3d:	00 00 00 
  81ee40:	48 89 10             	mov    %rdx,(%rax)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  81ee43:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ee4a:	00 00 00 
  81ee4d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81ee54:	00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  81ee55:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ee5c:	00 00 00 
  81ee5f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ee63:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ee67:	0f b7 c0             	movzwl %ax,%eax
  81ee6a:	89 c7                	mov    %eax,%edi
  81ee6c:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81ee73:	00 00 00 
  81ee76:	ff d0                	callq  *%rax
  81ee78:	0f b7 c0             	movzwl %ax,%eax
  81ee7b:	83 e0 01             	and    $0x1,%eax
  81ee7e:	85 c0                	test   %eax,%eax
  81ee80:	74 12                	je     81ee94 <tcp_receive+0x1063>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81ee82:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81ee89:	00 00 00 
  81ee8c:	c6 00 20             	movb   $0x20,(%rax)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81ee8f:	e9 85 03 00 00       	jmpq   81f219 <tcp_receive+0x13e8>
  81ee94:	e9 80 03 00 00       	jmpq   81f219 <tcp_receive+0x13e8>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
  81ee99:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee9d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eea4:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
          seqno = pcb->ooseq->tcphdr->seqno;
  81eea8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eeac:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eeb3:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eeb7:	8b 50 04             	mov    0x4(%rax),%edx
  81eeba:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81eec1:	00 00 00 
  81eec4:	89 10                	mov    %edx,(%rax)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  81eec6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eeca:	8b 58 30             	mov    0x30(%rax),%ebx
  81eecd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81eed1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81eed5:	44 0f b7 e0          	movzwl %ax,%r12d
  81eed9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81eedd:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eee1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81eee5:	0f b7 c0             	movzwl %ax,%eax
  81eee8:	89 c7                	mov    %eax,%edi
  81eeea:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81eef1:	00 00 00 
  81eef4:	ff d0                	callq  *%rax
  81eef6:	0f b7 c0             	movzwl %ax,%eax
  81eef9:	83 e0 01             	and    $0x1,%eax
  81eefc:	85 c0                	test   %eax,%eax
  81eefe:	75 27                	jne    81ef27 <tcp_receive+0x10f6>
  81ef00:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef04:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef08:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ef0c:	0f b7 c0             	movzwl %ax,%eax
  81ef0f:	89 c7                	mov    %eax,%edi
  81ef11:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81ef18:	00 00 00 
  81ef1b:	ff d0                	callq  *%rax
  81ef1d:	0f b7 c0             	movzwl %ax,%eax
  81ef20:	83 e0 02             	and    $0x2,%eax
  81ef23:	85 c0                	test   %eax,%eax
  81ef25:	74 07                	je     81ef2e <tcp_receive+0x10fd>
  81ef27:	b8 01 00 00 00       	mov    $0x1,%eax
  81ef2c:	eb 05                	jmp    81ef33 <tcp_receive+0x1102>
  81ef2e:	b8 00 00 00 00       	mov    $0x0,%eax
  81ef33:	44 01 e0             	add    %r12d,%eax
  81ef36:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81ef39:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef3d:	89 50 30             	mov    %edx,0x30(%rax)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  81ef40:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef44:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81ef48:	0f b7 d8             	movzwl %ax,%ebx
  81ef4b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef4f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ef53:	44 0f b7 e0          	movzwl %ax,%r12d
  81ef57:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef5b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef5f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ef63:	0f b7 c0             	movzwl %ax,%eax
  81ef66:	89 c7                	mov    %eax,%edi
  81ef68:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81ef6f:	00 00 00 
  81ef72:	ff d0                	callq  *%rax
  81ef74:	0f b7 c0             	movzwl %ax,%eax
  81ef77:	83 e0 01             	and    $0x1,%eax
  81ef7a:	85 c0                	test   %eax,%eax
  81ef7c:	75 27                	jne    81efa5 <tcp_receive+0x1174>
  81ef7e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef82:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef86:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ef8a:	0f b7 c0             	movzwl %ax,%eax
  81ef8d:	89 c7                	mov    %eax,%edi
  81ef8f:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81ef96:	00 00 00 
  81ef99:	ff d0                	callq  *%rax
  81ef9b:	0f b7 c0             	movzwl %ax,%eax
  81ef9e:	83 e0 02             	and    $0x2,%eax
  81efa1:	85 c0                	test   %eax,%eax
  81efa3:	74 07                	je     81efac <tcp_receive+0x117b>
  81efa5:	b8 01 00 00 00       	mov    $0x1,%eax
  81efaa:	eb 05                	jmp    81efb1 <tcp_receive+0x1180>
  81efac:	b8 00 00 00 00       	mov    $0x0,%eax
  81efb1:	44 01 e0             	add    %r12d,%eax
  81efb4:	39 c3                	cmp    %eax,%ebx
  81efb6:	7d 0c                	jge    81efc4 <tcp_receive+0x1193>
            pcb->rcv_wnd = 0;
  81efb8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efbc:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81efc2:	eb 7a                	jmp    81f03e <tcp_receive+0x120d>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  81efc4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efc8:	0f b7 58 34          	movzwl 0x34(%rax),%ebx
  81efcc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81efd0:	44 0f b7 60 18       	movzwl 0x18(%rax),%r12d
  81efd5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81efd9:	48 8b 40 20          	mov    0x20(%rax),%rax
  81efdd:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81efe1:	0f b7 c0             	movzwl %ax,%eax
  81efe4:	89 c7                	mov    %eax,%edi
  81efe6:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81efed:	00 00 00 
  81eff0:	ff d0                	callq  *%rax
  81eff2:	0f b7 c0             	movzwl %ax,%eax
  81eff5:	83 e0 01             	and    $0x1,%eax
  81eff8:	85 c0                	test   %eax,%eax
  81effa:	75 27                	jne    81f023 <tcp_receive+0x11f2>
  81effc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f000:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f004:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f008:	0f b7 c0             	movzwl %ax,%eax
  81f00b:	89 c7                	mov    %eax,%edi
  81f00d:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81f014:	00 00 00 
  81f017:	ff d0                	callq  *%rax
  81f019:	0f b7 c0             	movzwl %ax,%eax
  81f01c:	83 e0 02             	and    $0x2,%eax
  81f01f:	85 c0                	test   %eax,%eax
  81f021:	74 07                	je     81f02a <tcp_receive+0x11f9>
  81f023:	b8 01 00 00 00       	mov    $0x1,%eax
  81f028:	eb 05                	jmp    81f02f <tcp_receive+0x11fe>
  81f02a:	b8 00 00 00 00       	mov    $0x0,%eax
  81f02f:	44 01 e0             	add    %r12d,%eax
  81f032:	29 c3                	sub    %eax,%ebx
  81f034:	89 da                	mov    %ebx,%edx
  81f036:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f03a:	66 89 50 34          	mov    %dx,0x34(%rax)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  81f03e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f042:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81f046:	0f b7 d8             	movzwl %ax,%ebx
  81f049:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f04d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f051:	44 0f b7 e0          	movzwl %ax,%r12d
  81f055:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f059:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f05d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f061:	0f b7 c0             	movzwl %ax,%eax
  81f064:	89 c7                	mov    %eax,%edi
  81f066:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81f06d:	00 00 00 
  81f070:	ff d0                	callq  *%rax
  81f072:	0f b7 c0             	movzwl %ax,%eax
  81f075:	83 e0 01             	and    $0x1,%eax
  81f078:	85 c0                	test   %eax,%eax
  81f07a:	75 27                	jne    81f0a3 <tcp_receive+0x1272>
  81f07c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f080:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f084:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f088:	0f b7 c0             	movzwl %ax,%eax
  81f08b:	89 c7                	mov    %eax,%edi
  81f08d:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81f094:	00 00 00 
  81f097:	ff d0                	callq  *%rax
  81f099:	0f b7 c0             	movzwl %ax,%eax
  81f09c:	83 e0 02             	and    $0x2,%eax
  81f09f:	85 c0                	test   %eax,%eax
  81f0a1:	74 07                	je     81f0aa <tcp_receive+0x1279>
  81f0a3:	b8 01 00 00 00       	mov    $0x1,%eax
  81f0a8:	eb 05                	jmp    81f0af <tcp_receive+0x127e>
  81f0aa:	b8 00 00 00 00       	mov    $0x0,%eax
  81f0af:	44 01 e0             	add    %r12d,%eax
  81f0b2:	39 c3                	cmp    %eax,%ebx
  81f0b4:	7d 0c                	jge    81f0c2 <tcp_receive+0x1291>
            pcb->rcv_ann_wnd = 0;
  81f0b6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0ba:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81f0c0:	eb 7a                	jmp    81f13c <tcp_receive+0x130b>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  81f0c2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0c6:	0f b7 58 36          	movzwl 0x36(%rax),%ebx
  81f0ca:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f0ce:	44 0f b7 60 18       	movzwl 0x18(%rax),%r12d
  81f0d3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f0d7:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f0db:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f0df:	0f b7 c0             	movzwl %ax,%eax
  81f0e2:	89 c7                	mov    %eax,%edi
  81f0e4:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81f0eb:	00 00 00 
  81f0ee:	ff d0                	callq  *%rax
  81f0f0:	0f b7 c0             	movzwl %ax,%eax
  81f0f3:	83 e0 01             	and    $0x1,%eax
  81f0f6:	85 c0                	test   %eax,%eax
  81f0f8:	75 27                	jne    81f121 <tcp_receive+0x12f0>
  81f0fa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f0fe:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f102:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f106:	0f b7 c0             	movzwl %ax,%eax
  81f109:	89 c7                	mov    %eax,%edi
  81f10b:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81f112:	00 00 00 
  81f115:	ff d0                	callq  *%rax
  81f117:	0f b7 c0             	movzwl %ax,%eax
  81f11a:	83 e0 02             	and    $0x2,%eax
  81f11d:	85 c0                	test   %eax,%eax
  81f11f:	74 07                	je     81f128 <tcp_receive+0x12f7>
  81f121:	b8 01 00 00 00       	mov    $0x1,%eax
  81f126:	eb 05                	jmp    81f12d <tcp_receive+0x12fc>
  81f128:	b8 00 00 00 00       	mov    $0x0,%eax
  81f12d:	44 01 e0             	add    %r12d,%eax
  81f130:	29 c3                	sub    %eax,%ebx
  81f132:	89 da                	mov    %ebx,%edx
  81f134:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f138:	66 89 50 36          	mov    %dx,0x36(%rax)
          }

          if (cseg->p->tot_len > 0) {
  81f13c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f140:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f144:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f148:	66 85 c0             	test   %ax,%ax
  81f14b:	74 5c                	je     81f1a9 <tcp_receive+0x1378>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  81f14d:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f154:	00 00 00 
  81f157:	48 8b 00             	mov    (%rax),%rax
  81f15a:	48 85 c0             	test   %rax,%rax
  81f15d:	74 29                	je     81f188 <tcp_receive+0x1357>
              pbuf_cat(recv_data, cseg->p);
  81f15f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f163:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f167:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f16e:	00 00 00 
  81f171:	48 8b 00             	mov    (%rax),%rax
  81f174:	48 89 d6             	mov    %rdx,%rsi
  81f177:	48 89 c7             	mov    %rax,%rdi
  81f17a:	48 b8 1a dc 80 00 00 	movabs $0x80dc1a,%rax
  81f181:	00 00 00 
  81f184:	ff d0                	callq  *%rax
  81f186:	eb 15                	jmp    81f19d <tcp_receive+0x136c>
            } else {
              recv_data = cseg->p;
  81f188:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f18c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f190:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f197:	00 00 00 
  81f19a:	48 89 10             	mov    %rdx,(%rax)
            }
            cseg->p = NULL;
  81f19d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f1a1:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81f1a8:	00 
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  81f1a9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f1ad:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f1b1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f1b5:	0f b7 c0             	movzwl %ax,%eax
  81f1b8:	89 c7                	mov    %eax,%edi
  81f1ba:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81f1c1:	00 00 00 
  81f1c4:	ff d0                	callq  *%rax
  81f1c6:	0f b7 c0             	movzwl %ax,%eax
  81f1c9:	83 e0 01             	and    $0x1,%eax
  81f1cc:	85 c0                	test   %eax,%eax
  81f1ce:	74 24                	je     81f1f4 <tcp_receive+0x13c3>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81f1d0:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81f1d7:	00 00 00 
  81f1da:	c6 00 20             	movb   $0x20,(%rax)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  81f1dd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1e1:	8b 40 18             	mov    0x18(%rax),%eax
  81f1e4:	83 f8 04             	cmp    $0x4,%eax
  81f1e7:	75 0b                	jne    81f1f4 <tcp_receive+0x13c3>
              pcb->state = CLOSE_WAIT;
  81f1e9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1ed:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
            } 
          }


          pcb->ooseq = cseg->next;
  81f1f4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f1f8:	48 8b 10             	mov    (%rax),%rdx
  81f1fb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1ff:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
          tcp_seg_free(cseg);
  81f206:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f20a:	48 89 c7             	mov    %rax,%rdi
  81f20d:	48 b8 4b 01 81 00 00 	movabs $0x81014b,%rax
  81f214:	00 00 00 
  81f217:	ff d0                	callq  *%rax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f219:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f21d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f224:	48 85 c0             	test   %rax,%rax
  81f227:	74 21                	je     81f24a <tcp_receive+0x1419>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  81f229:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f22d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f234:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f238:	8b 50 04             	mov    0x4(%rax),%edx
  81f23b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f23f:	8b 40 30             	mov    0x30(%rax),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f242:	39 c2                	cmp    %eax,%edx
  81f244:	0f 84 4f fc ff ff    	je     81ee99 <tcp_receive+0x1068>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  81f24a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f24e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f252:	0f b6 c0             	movzbl %al,%eax
  81f255:	83 e0 01             	and    $0x1,%eax
  81f258:	85 c0                	test   %eax,%eax
  81f25a:	74 40                	je     81f29c <tcp_receive+0x146b>
  81f25c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f260:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f264:	83 e0 fe             	and    $0xfffffffe,%eax
  81f267:	89 c2                	mov    %eax,%edx
  81f269:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f26d:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f270:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f274:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f278:	83 c8 02             	or     $0x2,%eax
  81f27b:	89 c2                	mov    %eax,%edx
  81f27d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f281:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f284:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f288:	48 89 c7             	mov    %rax,%rdi
  81f28b:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81f292:	00 00 00 
  81f295:	ff d0                	callq  *%rax
  81f297:	e9 54 05 00 00       	jmpq   81f7f0 <tcp_receive+0x19bf>
  81f29c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2a0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f2a4:	83 c8 01             	or     $0x1,%eax
  81f2a7:	89 c2                	mov    %eax,%edx
  81f2a9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2ad:	88 50 2c             	mov    %dl,0x2c(%rax)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f2b0:	e9 66 05 00 00       	jmpq   81f81b <tcp_receive+0x19ea>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  81f2b5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2b9:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f2bd:	83 c8 02             	or     $0x2,%eax
  81f2c0:	89 c2                	mov    %eax,%edx
  81f2c2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2c6:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f2c9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2cd:	48 89 c7             	mov    %rax,%rdi
  81f2d0:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81f2d7:	00 00 00 
  81f2da:	ff d0                	callq  *%rax
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  81f2dc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2e0:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f2e7:	48 85 c0             	test   %rax,%rax
  81f2ea:	75 26                	jne    81f312 <tcp_receive+0x14e1>
          pcb->ooseq = tcp_seg_copy(&inseg);
  81f2ec:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f2f3:	00 00 00 
  81f2f6:	48 b8 c5 01 81 00 00 	movabs $0x8101c5,%rax
  81f2fd:	00 00 00 
  81f300:	ff d0                	callq  *%rax
  81f302:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81f306:	48 89 82 90 00 00 00 	mov    %rax,0x90(%rdx)
  81f30d:	e9 de 04 00 00       	jmpq   81f7f0 <tcp_receive+0x19bf>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
  81f312:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  81f319:	00 
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81f31a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f31e:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f325:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81f329:	e9 b7 04 00 00       	jmpq   81f7e5 <tcp_receive+0x19b4>
            if (seqno == next->tcphdr->seqno) {
  81f32e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f332:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f336:	8b 50 04             	mov    0x4(%rax),%edx
  81f339:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f340:	00 00 00 
  81f343:	8b 00                	mov    (%rax),%eax
  81f345:	39 c2                	cmp    %eax,%edx
  81f347:	0f 85 25 01 00 00    	jne    81f472 <tcp_receive+0x1641>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  81f34d:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f354:	00 00 00 
  81f357:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81f35b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f35f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f363:	66 39 c2             	cmp    %ax,%dx
  81f366:	0f 86 01 01 00 00    	jbe    81f46d <tcp_receive+0x163c>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  81f36c:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f373:	00 00 00 
  81f376:	48 b8 c5 01 81 00 00 	movabs $0x8101c5,%rax
  81f37d:	00 00 00 
  81f380:	ff d0                	callq  *%rax
  81f382:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81f386:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f38b:	0f 84 d7 00 00 00    	je     81f468 <tcp_receive+0x1637>
                  cseg->next = next->next;
  81f391:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f395:	48 8b 10             	mov    (%rax),%rdx
  81f398:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f39c:	48 89 10             	mov    %rdx,(%rax)
                  if (prev != NULL) {
  81f39f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f3a4:	74 0d                	je     81f3b3 <tcp_receive+0x1582>
                    prev->next = cseg;
  81f3a6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f3aa:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f3ae:	48 89 10             	mov    %rdx,(%rax)
  81f3b1:	eb 0f                	jmp    81f3c2 <tcp_receive+0x1591>
                  } else {
                    pcb->ooseq = cseg;
  81f3b3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f3b7:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f3bb:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  tcp_seg_free(next);
  81f3c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f3c6:	48 89 c7             	mov    %rax,%rdi
  81f3c9:	48 b8 4b 01 81 00 00 	movabs $0x81014b,%rax
  81f3d0:	00 00 00 
  81f3d3:	ff d0                	callq  *%rax
                  if (cseg->next != NULL) {
  81f3d5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f3d9:	48 8b 00             	mov    (%rax),%rax
  81f3dc:	48 85 c0             	test   %rax,%rax
  81f3df:	0f 84 83 00 00 00    	je     81f468 <tcp_receive+0x1637>
                    next = cseg->next;
  81f3e5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f3e9:	48 8b 00             	mov    (%rax),%rax
  81f3ec:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  81f3f0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f3f4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f3f8:	0f b7 d0             	movzwl %ax,%edx
  81f3fb:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f402:	00 00 00 
  81f405:	8b 00                	mov    (%rax),%eax
  81f407:	01 c2                	add    %eax,%edx
  81f409:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f40d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f411:	8b 40 04             	mov    0x4(%rax),%eax
  81f414:	29 c2                	sub    %eax,%edx
  81f416:	89 d0                	mov    %edx,%eax
  81f418:	85 c0                	test   %eax,%eax
  81f41a:	7e 4c                	jle    81f468 <tcp_receive+0x1637>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  81f41c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f420:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f424:	8b 40 04             	mov    0x4(%rax),%eax
  81f427:	89 c2                	mov    %eax,%edx
  81f429:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f430:	00 00 00 
  81f433:	8b 00                	mov    (%rax),%eax
  81f435:	29 c2                	sub    %eax,%edx
  81f437:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f43b:	66 89 50 18          	mov    %dx,0x18(%rax)
                      pbuf_realloc(cseg->p, cseg->len);
  81f43f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f443:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f447:	0f b7 d0             	movzwl %ax,%edx
  81f44a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f44e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f452:	89 d6                	mov    %edx,%esi
  81f454:	48 89 c7             	mov    %rax,%rdi
  81f457:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  81f45e:	00 00 00 
  81f461:	ff d0                	callq  *%rax
                    }
                  }
                }
                break;
  81f463:	e9 88 03 00 00       	jmpq   81f7f0 <tcp_receive+0x19bf>
  81f468:	e9 83 03 00 00       	jmpq   81f7f0 <tcp_receive+0x19bf>
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
  81f46d:	e9 7e 03 00 00       	jmpq   81f7f0 <tcp_receive+0x19bf>
              }
            } else {
              if (prev == NULL) {
  81f472:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f477:	0f 85 f3 00 00 00    	jne    81f570 <tcp_receive+0x173f>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  81f47d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f484:	00 00 00 
  81f487:	8b 10                	mov    (%rax),%edx
  81f489:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f48d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f491:	8b 40 04             	mov    0x4(%rax),%eax
  81f494:	29 c2                	sub    %eax,%edx
  81f496:	89 d0                	mov    %edx,%eax
  81f498:	85 c0                	test   %eax,%eax
  81f49a:	0f 89 5f 02 00 00    	jns    81f6ff <tcp_receive+0x18ce>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81f4a0:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f4a7:	00 00 00 
  81f4aa:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f4ae:	0f b7 d0             	movzwl %ax,%edx
  81f4b1:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f4b8:	00 00 00 
  81f4bb:	8b 00                	mov    (%rax),%eax
  81f4bd:	01 c2                	add    %eax,%edx
  81f4bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f4c3:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f4c7:	8b 40 04             	mov    0x4(%rax),%eax
  81f4ca:	29 c2                	sub    %eax,%edx
  81f4cc:	89 d0                	mov    %edx,%eax
  81f4ce:	85 c0                	test   %eax,%eax
  81f4d0:	7e 59                	jle    81f52b <tcp_receive+0x16fa>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81f4d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f4d6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f4da:	8b 40 04             	mov    0x4(%rax),%eax
  81f4dd:	89 c2                	mov    %eax,%edx
  81f4df:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f4e6:	00 00 00 
  81f4e9:	8b 00                	mov    (%rax),%eax
  81f4eb:	29 c2                	sub    %eax,%edx
  81f4ed:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f4f4:	00 00 00 
  81f4f7:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(inseg.p, inseg.len);
  81f4fb:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f502:	00 00 00 
  81f505:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f509:	0f b7 d0             	movzwl %ax,%edx
  81f50c:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f513:	00 00 00 
  81f516:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f51a:	89 d6                	mov    %edx,%esi
  81f51c:	48 89 c7             	mov    %rax,%rdi
  81f51f:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  81f526:	00 00 00 
  81f529:	ff d0                	callq  *%rax
                  }
                  cseg = tcp_seg_copy(&inseg);
  81f52b:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f532:	00 00 00 
  81f535:	48 b8 c5 01 81 00 00 	movabs $0x8101c5,%rax
  81f53c:	00 00 00 
  81f53f:	ff d0                	callq  *%rax
  81f541:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                  if (cseg != NULL) {
  81f545:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f54a:	74 1f                	je     81f56b <tcp_receive+0x173a>
                    cseg->next = next;
  81f54c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f550:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f554:	48 89 10             	mov    %rdx,(%rax)
                    pcb->ooseq = cseg;
  81f557:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f55b:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f55f:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  break;
  81f566:	e9 85 02 00 00       	jmpq   81f7f0 <tcp_receive+0x19bf>
  81f56b:	e9 80 02 00 00       	jmpq   81f7f0 <tcp_receive+0x19bf>
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  81f570:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f577:	00 00 00 
  81f57a:	8b 10                	mov    (%rax),%edx
  81f57c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f580:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f584:	8b 40 04             	mov    0x4(%rax),%eax
  81f587:	29 c2                	sub    %eax,%edx
  81f589:	89 d0                	mov    %edx,%eax
  81f58b:	83 e8 01             	sub    $0x1,%eax
  81f58e:	85 c0                	test   %eax,%eax
  81f590:	0f 88 69 01 00 00    	js     81f6ff <tcp_receive+0x18ce>
  81f596:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f59d:	00 00 00 
  81f5a0:	8b 10                	mov    (%rax),%edx
  81f5a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f5a6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f5aa:	8b 40 04             	mov    0x4(%rax),%eax
  81f5ad:	29 c2                	sub    %eax,%edx
  81f5af:	89 d0                	mov    %edx,%eax
  81f5b1:	83 c0 01             	add    $0x1,%eax
  81f5b4:	85 c0                	test   %eax,%eax
  81f5b6:	0f 8f 43 01 00 00    	jg     81f6ff <tcp_receive+0x18ce>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81f5bc:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f5c3:	00 00 00 
  81f5c6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f5ca:	0f b7 d0             	movzwl %ax,%edx
  81f5cd:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f5d4:	00 00 00 
  81f5d7:	8b 00                	mov    (%rax),%eax
  81f5d9:	01 c2                	add    %eax,%edx
  81f5db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f5df:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f5e3:	8b 40 04             	mov    0x4(%rax),%eax
  81f5e6:	29 c2                	sub    %eax,%edx
  81f5e8:	89 d0                	mov    %edx,%eax
  81f5ea:	85 c0                	test   %eax,%eax
  81f5ec:	7e 59                	jle    81f647 <tcp_receive+0x1816>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81f5ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f5f2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f5f6:	8b 40 04             	mov    0x4(%rax),%eax
  81f5f9:	89 c2                	mov    %eax,%edx
  81f5fb:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f602:	00 00 00 
  81f605:	8b 00                	mov    (%rax),%eax
  81f607:	29 c2                	sub    %eax,%edx
  81f609:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f610:	00 00 00 
  81f613:	66 89 50 18          	mov    %dx,0x18(%rax)
                  pbuf_realloc(inseg.p, inseg.len);
  81f617:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f61e:	00 00 00 
  81f621:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f625:	0f b7 d0             	movzwl %ax,%edx
  81f628:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f62f:	00 00 00 
  81f632:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f636:	89 d6                	mov    %edx,%esi
  81f638:	48 89 c7             	mov    %rax,%rdi
  81f63b:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  81f642:	00 00 00 
  81f645:	ff d0                	callq  *%rax
                }

                cseg = tcp_seg_copy(&inseg);
  81f647:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f64e:	00 00 00 
  81f651:	48 b8 c5 01 81 00 00 	movabs $0x8101c5,%rax
  81f658:	00 00 00 
  81f65b:	ff d0                	callq  *%rax
  81f65d:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81f661:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f666:	0f 84 8e 00 00 00    	je     81f6fa <tcp_receive+0x18c9>
                  cseg->next = next;
  81f66c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f670:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f674:	48 89 10             	mov    %rdx,(%rax)
                  prev->next = cseg;
  81f677:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f67b:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f67f:	48 89 10             	mov    %rdx,(%rax)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  81f682:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f686:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f68a:	8b 50 04             	mov    0x4(%rax),%edx
  81f68d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f691:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f695:	0f b7 c0             	movzwl %ax,%eax
  81f698:	01 c2                	add    %eax,%edx
  81f69a:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f6a1:	00 00 00 
  81f6a4:	8b 00                	mov    (%rax),%eax
  81f6a6:	29 c2                	sub    %eax,%edx
  81f6a8:	89 d0                	mov    %edx,%eax
  81f6aa:	85 c0                	test   %eax,%eax
  81f6ac:	7e 4c                	jle    81f6fa <tcp_receive+0x18c9>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  81f6ae:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f6b5:	00 00 00 
  81f6b8:	8b 00                	mov    (%rax),%eax
  81f6ba:	89 c2                	mov    %eax,%edx
  81f6bc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f6c0:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f6c4:	8b 40 04             	mov    0x4(%rax),%eax
  81f6c7:	29 c2                	sub    %eax,%edx
  81f6c9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f6cd:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(prev->p, prev->len);
  81f6d1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f6d5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f6d9:	0f b7 d0             	movzwl %ax,%edx
  81f6dc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f6e0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f6e4:	89 d6                	mov    %edx,%esi
  81f6e6:	48 89 c7             	mov    %rax,%rdi
  81f6e9:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  81f6f0:	00 00 00 
  81f6f3:	ff d0                	callq  *%rax
                  }
                }
                break;
  81f6f5:	e9 f6 00 00 00       	jmpq   81f7f0 <tcp_receive+0x19bf>
  81f6fa:	e9 f1 00 00 00       	jmpq   81f7f0 <tcp_receive+0x19bf>
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81f6ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f703:	48 8b 00             	mov    (%rax),%rax
  81f706:	48 85 c0             	test   %rax,%rax
  81f709:	0f 85 c3 00 00 00    	jne    81f7d2 <tcp_receive+0x19a1>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  81f70f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f716:	00 00 00 
  81f719:	8b 10                	mov    (%rax),%edx
  81f71b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f71f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f723:	8b 40 04             	mov    0x4(%rax),%eax
  81f726:	29 c2                	sub    %eax,%edx
  81f728:	89 d0                	mov    %edx,%eax
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81f72a:	85 c0                	test   %eax,%eax
  81f72c:	0f 8e a0 00 00 00    	jle    81f7d2 <tcp_receive+0x19a1>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  81f732:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f739:	00 00 00 
  81f73c:	48 b8 c5 01 81 00 00 	movabs $0x8101c5,%rax
  81f743:	00 00 00 
  81f746:	ff d0                	callq  *%rax
  81f748:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f74c:	48 89 02             	mov    %rax,(%rdx)
                if (next->next != NULL) {
  81f74f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f753:	48 8b 00             	mov    (%rax),%rax
  81f756:	48 85 c0             	test   %rax,%rax
  81f759:	74 75                	je     81f7d0 <tcp_receive+0x199f>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  81f75b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f75f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f763:	8b 50 04             	mov    0x4(%rax),%edx
  81f766:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f76a:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f76e:	0f b7 c0             	movzwl %ax,%eax
  81f771:	01 c2                	add    %eax,%edx
  81f773:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f77a:	00 00 00 
  81f77d:	8b 00                	mov    (%rax),%eax
  81f77f:	29 c2                	sub    %eax,%edx
  81f781:	89 d0                	mov    %edx,%eax
  81f783:	85 c0                	test   %eax,%eax
  81f785:	7e 49                	jle    81f7d0 <tcp_receive+0x199f>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  81f787:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f78e:	00 00 00 
  81f791:	8b 00                	mov    (%rax),%eax
  81f793:	89 c2                	mov    %eax,%edx
  81f795:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f799:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f79d:	8b 40 04             	mov    0x4(%rax),%eax
  81f7a0:	29 c2                	sub    %eax,%edx
  81f7a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f7a6:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(next->p, next->len);
  81f7aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f7ae:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f7b2:	0f b7 d0             	movzwl %ax,%edx
  81f7b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f7b9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f7bd:	89 d6                	mov    %edx,%esi
  81f7bf:	48 89 c7             	mov    %rax,%rdi
  81f7c2:	48 b8 05 d6 80 00 00 	movabs $0x80d605,%rax
  81f7c9:	00 00 00 
  81f7cc:	ff d0                	callq  *%rax
                  }
                }
                break;
  81f7ce:	eb 20                	jmp    81f7f0 <tcp_receive+0x19bf>
  81f7d0:	eb 1e                	jmp    81f7f0 <tcp_receive+0x19bf>
              }
            }
            prev = next;
  81f7d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f7d6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81f7da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f7de:	48 8b 00             	mov    (%rax),%rax
  81f7e1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81f7e5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81f7ea:	0f 85 3e fb ff ff    	jne    81f32e <tcp_receive+0x14fd>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f7f0:	eb 29                	jmp    81f81b <tcp_receive+0x19ea>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  81f7f2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7f6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f7fa:	83 c8 02             	or     $0x2,%eax
  81f7fd:	89 c2                	mov    %eax,%edx
  81f7ff:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f803:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f806:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f80a:	48 89 c7             	mov    %rax,%rdi
  81f80d:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81f814:	00 00 00 
  81f817:	ff d0                	callq  *%rax
  81f819:	eb 6f                	jmp    81f88a <tcp_receive+0x1a59>
  81f81b:	eb 6d                	jmp    81f88a <tcp_receive+0x1a59>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  81f81d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f824:	00 00 00 
  81f827:	8b 10                	mov    (%rax),%edx
  81f829:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f82d:	8b 40 30             	mov    0x30(%rax),%eax
  81f830:	29 c2                	sub    %eax,%edx
  81f832:	89 d0                	mov    %edx,%eax
  81f834:	85 c0                	test   %eax,%eax
  81f836:	78 2b                	js     81f863 <tcp_receive+0x1a32>
  81f838:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f83f:	00 00 00 
  81f842:	8b 10                	mov    (%rax),%edx
  81f844:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f848:	8b 48 30             	mov    0x30(%rax),%ecx
  81f84b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f84f:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81f853:	0f b7 c0             	movzwl %ax,%eax
  81f856:	01 c8                	add    %ecx,%eax
  81f858:	29 c2                	sub    %eax,%edx
  81f85a:	89 d0                	mov    %edx,%eax
  81f85c:	83 c0 01             	add    $0x1,%eax
  81f85f:	85 c0                	test   %eax,%eax
  81f861:	7e 27                	jle    81f88a <tcp_receive+0x1a59>
      tcp_ack_now(pcb);
  81f863:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f867:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f86b:	83 c8 02             	or     $0x2,%eax
  81f86e:	89 c2                	mov    %eax,%edx
  81f870:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f874:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f877:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f87b:	48 89 c7             	mov    %rax,%rdi
  81f87e:	48 b8 0c 39 81 00 00 	movabs $0x81390c,%rax
  81f885:	00 00 00 
  81f888:	ff d0                	callq  *%rax
    }
  }
  return accepted_inseq;
  81f88a:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
}
  81f88e:	48 83 c4 58          	add    $0x58,%rsp
  81f892:	5b                   	pop    %rbx
  81f893:	41 5c                	pop    %r12
  81f895:	41 5d                	pop    %r13
  81f897:	5d                   	pop    %rbp
  81f898:	c3                   	retq   

000000000081f899 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  81f899:	55                   	push   %rbp
  81f89a:	48 89 e5             	mov    %rsp,%rbp
  81f89d:	53                   	push   %rbx
  81f89e:	48 83 ec 38          	sub    $0x38,%rsp
  81f8a2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  81f8a6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81f8ad:	00 00 00 
  81f8b0:	48 8b 00             	mov    (%rax),%rax
  81f8b3:	48 83 c0 14          	add    $0x14,%rax
  81f8b7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  81f8bb:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81f8c2:	00 00 00 
  81f8c5:	48 8b 00             	mov    (%rax),%rax
  81f8c8:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f8cc:	0f b7 c0             	movzwl %ax,%eax
  81f8cf:	89 c7                	mov    %eax,%edi
  81f8d1:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81f8d8:	00 00 00 
  81f8db:	ff d0                	callq  *%rax
  81f8dd:	66 c1 e8 0c          	shr    $0xc,%ax
  81f8e1:	66 83 f8 05          	cmp    $0x5,%ax
  81f8e5:	0f 86 11 01 00 00    	jbe    81f9fc <tcp_parseopt+0x163>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81f8eb:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  81f8ef:	e9 cd 00 00 00       	jmpq   81f9c1 <tcp_parseopt+0x128>
      opt = opts[c];
  81f8f4:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  81f8f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f8fc:	48 01 d0             	add    %rdx,%rax
  81f8ff:	0f b6 00             	movzbl (%rax),%eax
  81f902:	88 45 df             	mov    %al,-0x21(%rbp)
      if (opt == 0x00) {
  81f905:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  81f909:	75 05                	jne    81f910 <tcp_parseopt+0x77>
        /* End of options. */
        break;
  81f90b:	e9 ec 00 00 00       	jmpq   81f9fc <tcp_parseopt+0x163>
      } else if (opt == 0x01) {
  81f910:	80 7d df 01          	cmpb   $0x1,-0x21(%rbp)
  81f914:	75 09                	jne    81f91f <tcp_parseopt+0x86>
        ++c;
  81f916:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  81f91a:	e9 a2 00 00 00       	jmpq   81f9c1 <tcp_parseopt+0x128>
        /* NOP option. */
      } else if (opt == 0x02 &&
  81f91f:	80 7d df 02          	cmpb   $0x2,-0x21(%rbp)
  81f923:	75 6f                	jne    81f994 <tcp_parseopt+0xfb>
        opts[c + 1] == 0x04) {
  81f925:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f929:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81f92d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f931:	48 01 d0             	add    %rdx,%rax
  81f934:	0f b6 00             	movzbl (%rax),%eax
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
        /* NOP option. */
      } else if (opt == 0x02 &&
  81f937:	3c 04                	cmp    $0x4,%al
  81f939:	75 59                	jne    81f994 <tcp_parseopt+0xfb>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  81f93b:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f93f:	48 8d 50 02          	lea    0x2(%rax),%rdx
  81f943:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f947:	48 01 d0             	add    %rdx,%rax
  81f94a:	0f b6 00             	movzbl (%rax),%eax
  81f94d:	0f b6 c0             	movzbl %al,%eax
  81f950:	c1 e0 08             	shl    $0x8,%eax
  81f953:	89 c2                	mov    %eax,%edx
  81f955:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f959:	48 8d 48 03          	lea    0x3(%rax),%rcx
  81f95d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f961:	48 01 c8             	add    %rcx,%rax
  81f964:	0f b6 00             	movzbl (%rax),%eax
  81f967:	0f b6 c0             	movzbl %al,%eax
  81f96a:	09 d0                	or     %edx,%eax
  81f96c:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  81f970:	66 81 7d dc b4 05    	cmpw   $0x5b4,-0x24(%rbp)
  81f976:	77 0d                	ja     81f985 <tcp_parseopt+0xec>
  81f978:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  81f97d:	74 06                	je     81f985 <tcp_parseopt+0xec>
  81f97f:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81f983:	eb 05                	jmp    81f98a <tcp_parseopt+0xf1>
  81f985:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  81f98a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81f98e:	66 89 42 40          	mov    %ax,0x40(%rdx)

        /* And we are done processing options. */
        break;
  81f992:	eb 68                	jmp    81f9fc <tcp_parseopt+0x163>
      } else {
        if (opts[c + 1] == 0) {
  81f994:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f998:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81f99c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f9a0:	48 01 d0             	add    %rdx,%rax
  81f9a3:	0f b6 00             	movzbl (%rax),%eax
  81f9a6:	84 c0                	test   %al,%al
  81f9a8:	75 02                	jne    81f9ac <tcp_parseopt+0x113>
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
  81f9aa:	eb 50                	jmp    81f9fc <tcp_parseopt+0x163>
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  81f9ac:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f9b0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81f9b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f9b8:	48 01 d0             	add    %rdx,%rax
  81f9bb:	0f b6 00             	movzbl (%rax),%eax
  81f9be:	00 45 ef             	add    %al,-0x11(%rbp)

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81f9c1:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  81f9c5:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81f9cc:	00 00 00 
  81f9cf:	48 8b 00             	mov    (%rax),%rax
  81f9d2:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f9d6:	0f b7 c0             	movzwl %ax,%eax
  81f9d9:	89 c7                	mov    %eax,%edi
  81f9db:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81f9e2:	00 00 00 
  81f9e5:	ff d0                	callq  *%rax
  81f9e7:	66 c1 e8 0c          	shr    $0xc,%ax
  81f9eb:	0f b7 c0             	movzwl %ax,%eax
  81f9ee:	83 e8 05             	sub    $0x5,%eax
  81f9f1:	c1 e0 02             	shl    $0x2,%eax
  81f9f4:	39 c3                	cmp    %eax,%ebx
  81f9f6:	0f 8c f8 fe ff ff    	jl     81f8f4 <tcp_parseopt+0x5b>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  81f9fc:	48 83 c4 38          	add    $0x38,%rsp
  81fa00:	5b                   	pop    %rbx
  81fa01:	5d                   	pop    %rbp
  81fa02:	c3                   	retq   

000000000081fa03 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  81fa03:	55                   	push   %rbp
  81fa04:	48 89 e5             	mov    %rsp,%rbp
  81fa07:	48 83 ec 40          	sub    $0x40,%rsp
  81fa0b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81fa0f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  81fa13:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  81fa17:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81fa1b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fa1f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  proto = IPH_PROTO(iphdr);
  81fa23:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fa27:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81fa2b:	0f b7 c0             	movzwl %ax,%eax
  81fa2e:	89 c7                	mov    %eax,%edi
  81fa30:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81fa37:	00 00 00 
  81fa3a:	ff d0                	callq  *%rax
  81fa3c:	66 25 ff 00          	and    $0xff,%ax
  81fa40:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  prev = NULL;
  81fa44:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81fa4b:	00 
  pcb = raw_pcbs;
  81fa4c:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fa53:	00 00 00 
  81fa56:	48 8b 00             	mov    (%rax),%rax
  81fa59:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81fa5d:	e9 a3 00 00 00       	jmpq   81fb05 <raw_input+0x102>
    if (pcb->protocol == proto) {
  81fa62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fa66:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81fa6a:	0f b6 d0             	movzbl %al,%edx
  81fa6d:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  81fa71:	39 c2                	cmp    %eax,%edx
  81fa73:	75 7c                	jne    81faf1 <raw_input+0xee>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  81fa75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fa79:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fa7d:	48 85 c0             	test   %rax,%rax
  81fa80:	74 6f                	je     81faf1 <raw_input+0xee>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  81fa82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fa86:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fa8a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81fa8e:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  81fa92:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fa96:	48 8b 7a 28          	mov    0x28(%rdx),%rdi
  81fa9a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81fa9e:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81faa2:	ff d0                	callq  *%rax
  81faa4:	84 c0                	test   %al,%al
  81faa6:	74 49                	je     81faf1 <raw_input+0xee>
        {
          /* receive function ate the packet */
          p = NULL;
  81faa8:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  81faaf:	00 
          eaten = 1;
  81fab0:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
          if (prev != NULL) {
  81fab4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fab9:	74 36                	je     81faf1 <raw_input+0xee>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  81fabb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fabf:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81fac3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fac7:	48 89 50 10          	mov    %rdx,0x10(%rax)
            pcb->next = raw_pcbs;
  81facb:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fad2:	00 00 00 
  81fad5:	48 8b 10             	mov    (%rax),%rdx
  81fad8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fadc:	48 89 50 10          	mov    %rdx,0x10(%rax)
            raw_pcbs = pcb;
  81fae0:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fae7:	00 00 00 
  81faea:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81faee:	48 89 10             	mov    %rdx,(%rax)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  81faf1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81faf5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pcb = pcb->next;
  81faf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fafd:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fb01:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81fb05:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81fb09:	75 0b                	jne    81fb16 <raw_input+0x113>
  81fb0b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81fb10:	0f 85 4c ff ff ff    	jne    81fa62 <raw_input+0x5f>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
  81fb16:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  81fb1a:	c9                   	leaveq 
  81fb1b:	c3                   	retq   

000000000081fb1c <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81fb1c:	55                   	push   %rbp
  81fb1d:	48 89 e5             	mov    %rsp,%rbp
  81fb20:	48 83 ec 10          	sub    $0x10,%rsp
  81fb24:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fb28:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->local_ip, ipaddr);
  81fb2c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fb31:	74 08                	je     81fb3b <raw_bind+0x1f>
  81fb33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fb37:	8b 00                	mov    (%rax),%eax
  81fb39:	eb 05                	jmp    81fb40 <raw_bind+0x24>
  81fb3b:	b8 00 00 00 00       	mov    $0x0,%eax
  81fb40:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fb44:	89 02                	mov    %eax,(%rdx)
  return ERR_OK;
  81fb46:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81fb4b:	c9                   	leaveq 
  81fb4c:	c3                   	retq   

000000000081fb4d <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81fb4d:	55                   	push   %rbp
  81fb4e:	48 89 e5             	mov    %rsp,%rbp
  81fb51:	48 83 ec 10          	sub    $0x10,%rsp
  81fb55:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fb59:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
  81fb5d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fb62:	74 08                	je     81fb6c <raw_connect+0x1f>
  81fb64:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fb68:	8b 00                	mov    (%rax),%eax
  81fb6a:	eb 05                	jmp    81fb71 <raw_connect+0x24>
  81fb6c:	b8 00 00 00 00       	mov    $0x0,%eax
  81fb71:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fb75:	89 42 04             	mov    %eax,0x4(%rdx)
  return ERR_OK;
  81fb78:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81fb7d:	c9                   	leaveq 
  81fb7e:	c3                   	retq   

000000000081fb7f <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  81fb7f:	55                   	push   %rbp
  81fb80:	48 89 e5             	mov    %rsp,%rbp
  81fb83:	48 83 ec 18          	sub    $0x18,%rsp
  81fb87:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fb8b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81fb8f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  81fb93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fb97:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81fb9b:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  81fb9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fba3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81fba7:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  81fbab:	c9                   	leaveq 
  81fbac:	c3                   	retq   

000000000081fbad <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  81fbad:	55                   	push   %rbp
  81fbae:	48 89 e5             	mov    %rsp,%rbp
  81fbb1:	48 83 ec 40          	sub    $0x40,%rsp
  81fbb5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81fbb9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81fbbd:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  81fbc1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fbc5:	be 14 00 00 00       	mov    $0x14,%esi
  81fbca:	48 89 c7             	mov    %rax,%rdi
  81fbcd:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  81fbd4:	00 00 00 
  81fbd7:	ff d0                	callq  *%rax
  81fbd9:	84 c0                	test   %al,%al
  81fbdb:	74 4c                	je     81fc29 <raw_sendto+0x7c>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  81fbdd:	ba 00 00 00 00       	mov    $0x0,%edx
  81fbe2:	be 00 00 00 00       	mov    $0x0,%esi
  81fbe7:	bf 01 00 00 00       	mov    $0x1,%edi
  81fbec:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  81fbf3:	00 00 00 
  81fbf6:	ff d0                	callq  *%rax
  81fbf8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  81fbfc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fc01:	75 0a                	jne    81fc0d <raw_sendto+0x60>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  81fc03:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81fc08:	e9 42 01 00 00       	jmpq   81fd4f <raw_sendto+0x1a2>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  81fc0d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81fc11:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fc15:	48 89 d6             	mov    %rdx,%rsi
  81fc18:	48 89 c7             	mov    %rax,%rdi
  81fc1b:	48 b8 39 dd 80 00 00 	movabs $0x80dd39,%rax
  81fc22:	00 00 00 
  81fc25:	ff d0                	callq  *%rax
  81fc27:	eb 4e                	jmp    81fc77 <raw_sendto+0xca>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  81fc29:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fc2d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    if(pbuf_header(q, -IP_HLEN)) {
  81fc31:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fc35:	be ec ff ff ff       	mov    $0xffffffec,%esi
  81fc3a:	48 89 c7             	mov    %rax,%rdi
  81fc3d:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  81fc44:	00 00 00 
  81fc47:	ff d0                	callq  *%rax
  81fc49:	84 c0                	test   %al,%al
  81fc4b:	74 2a                	je     81fc77 <raw_sendto+0xca>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  81fc4d:	48 ba d8 37 82 00 00 	movabs $0x8237d8,%rdx
  81fc54:	00 00 00 
  81fc57:	be e3 00 00 00       	mov    $0xe3,%esi
  81fc5c:	48 bf fe 37 82 00 00 	movabs $0x8237fe,%rdi
  81fc63:	00 00 00 
  81fc66:	b8 00 00 00 00       	mov    $0x0,%eax
  81fc6b:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  81fc72:	00 00 00 
  81fc75:	ff d1                	callq  *%rcx
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  81fc77:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81fc7b:	48 89 c7             	mov    %rax,%rdi
  81fc7e:	48 b8 ad 0a 81 00 00 	movabs $0x810aad,%rax
  81fc85:	00 00 00 
  81fc88:	ff d0                	callq  *%rax
  81fc8a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81fc8e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81fc93:	75 27                	jne    81fcbc <raw_sendto+0x10f>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  81fc95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fc99:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81fc9d:	74 13                	je     81fcb2 <raw_sendto+0x105>
      pbuf_free(q);
  81fc9f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fca3:	48 89 c7             	mov    %rax,%rdi
  81fca6:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81fcad:	00 00 00 
  81fcb0:	ff d0                	callq  *%rax
    }
    return ERR_RTE;
  81fcb2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81fcb7:	e9 93 00 00 00       	jmpq   81fd4f <raw_sendto+0x1a2>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  81fcbc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fcc0:	48 85 c0             	test   %rax,%rax
  81fcc3:	74 0a                	je     81fccf <raw_sendto+0x122>
  81fcc5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fcc9:	8b 00                	mov    (%rax),%eax
  81fccb:	85 c0                	test   %eax,%eax
  81fccd:	75 0e                	jne    81fcdd <raw_sendto+0x130>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  81fccf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fcd3:	48 83 c0 08          	add    $0x8,%rax
  81fcd7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81fcdb:	eb 08                	jmp    81fce5 <raw_sendto+0x138>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  81fcdd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fce1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  81fce5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fce9:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81fced:	44 0f b6 c8          	movzbl %al,%r9d
  81fcf1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fcf5:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  81fcf9:	44 0f b6 c0          	movzbl %al,%r8d
  81fcfd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fd01:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  81fd05:	0f b6 c8             	movzbl %al,%ecx
  81fd08:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81fd0c:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81fd10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fd14:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  81fd18:	48 89 3c 24          	mov    %rdi,(%rsp)
  81fd1c:	48 89 c7             	mov    %rax,%rdi
  81fd1f:	48 b8 e2 0f 81 00 00 	movabs $0x810fe2,%rax
  81fd26:	00 00 00 
  81fd29:	ff d0                	callq  *%rax
  81fd2b:	88 45 e7             	mov    %al,-0x19(%rbp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  81fd2e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fd32:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81fd36:	74 13                	je     81fd4b <raw_sendto+0x19e>
    /* free the header */
    pbuf_free(q);
  81fd38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fd3c:	48 89 c7             	mov    %rax,%rdi
  81fd3f:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81fd46:	00 00 00 
  81fd49:	ff d0                	callq  *%rax
  }
  return err;
  81fd4b:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
}
  81fd4f:	c9                   	leaveq 
  81fd50:	c3                   	retq   

000000000081fd51 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  81fd51:	55                   	push   %rbp
  81fd52:	48 89 e5             	mov    %rsp,%rbp
  81fd55:	48 83 ec 10          	sub    $0x10,%rsp
  81fd59:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fd5d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
  81fd61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fd65:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81fd69:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81fd6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fd71:	48 89 ce             	mov    %rcx,%rsi
  81fd74:	48 89 c7             	mov    %rax,%rdi
  81fd77:	48 b8 ad fb 81 00 00 	movabs $0x81fbad,%rax
  81fd7e:	00 00 00 
  81fd81:	ff d0                	callq  *%rax
}
  81fd83:	c9                   	leaveq 
  81fd84:	c3                   	retq   

000000000081fd85 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  81fd85:	55                   	push   %rbp
  81fd86:	48 89 e5             	mov    %rsp,%rbp
  81fd89:	48 83 ec 20          	sub    $0x20,%rsp
  81fd8d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  81fd91:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fd98:	00 00 00 
  81fd9b:	48 8b 00             	mov    (%rax),%rax
  81fd9e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81fda2:	75 20                	jne    81fdc4 <raw_remove+0x3f>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  81fda4:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fdab:	00 00 00 
  81fdae:	48 8b 00             	mov    (%rax),%rax
  81fdb1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81fdb5:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fdbc:	00 00 00 
  81fdbf:	48 89 10             	mov    %rdx,(%rax)
  81fdc2:	eb 51                	jmp    81fe15 <raw_remove+0x90>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81fdc4:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fdcb:	00 00 00 
  81fdce:	48 8b 00             	mov    (%rax),%rax
  81fdd1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81fdd5:	eb 37                	jmp    81fe0e <raw_remove+0x89>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  81fdd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fddb:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fddf:	48 85 c0             	test   %rax,%rax
  81fde2:	74 1e                	je     81fe02 <raw_remove+0x7d>
  81fde4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fde8:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fdec:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81fdf0:	75 10                	jne    81fe02 <raw_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  81fdf2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fdf6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81fdfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fdfe:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81fe02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe06:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fe0a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81fe0e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81fe13:	75 c2                	jne    81fdd7 <raw_remove+0x52>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  81fe15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fe19:	48 89 c6             	mov    %rax,%rsi
  81fe1c:	bf 00 00 00 00       	mov    $0x0,%edi
  81fe21:	48 b8 ce cb 80 00 00 	movabs $0x80cbce,%rax
  81fe28:	00 00 00 
  81fe2b:	ff d0                	callq  *%rax
}
  81fe2d:	c9                   	leaveq 
  81fe2e:	c3                   	retq   

000000000081fe2f <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  81fe2f:	55                   	push   %rbp
  81fe30:	48 89 e5             	mov    %rsp,%rbp
  81fe33:	48 83 ec 20          	sub    $0x20,%rsp
  81fe37:	89 f8                	mov    %edi,%eax
  81fe39:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  81fe3c:	bf 00 00 00 00       	mov    $0x0,%edi
  81fe41:	48 b8 23 cb 80 00 00 	movabs $0x80cb23,%rax
  81fe48:	00 00 00 
  81fe4b:	ff d0                	callq  *%rax
  81fe4d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  81fe51:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81fe56:	74 56                	je     81feae <raw_new+0x7f>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  81fe58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe5c:	ba 30 00 00 00       	mov    $0x30,%edx
  81fe61:	be 00 00 00 00       	mov    $0x0,%esi
  81fe66:	48 89 c7             	mov    %rax,%rdi
  81fe69:	48 b8 c7 1f 80 00 00 	movabs $0x801fc7,%rax
  81fe70:	00 00 00 
  81fe73:	ff d0                	callq  *%rax
    pcb->protocol = proto;
  81fe75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe79:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  81fe7d:	88 50 18             	mov    %dl,0x18(%rax)
    pcb->ttl = RAW_TTL;
  81fe80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe84:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    pcb->next = raw_pcbs;
  81fe88:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fe8f:	00 00 00 
  81fe92:	48 8b 10             	mov    (%rax),%rdx
  81fe95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe99:	48 89 50 10          	mov    %rdx,0x10(%rax)
    raw_pcbs = pcb;
  81fe9d:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fea4:	00 00 00 
  81fea7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81feab:	48 89 10             	mov    %rdx,(%rax)
  }
  return pcb;
  81feae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81feb2:	c9                   	leaveq 
  81feb3:	c3                   	retq   

000000000081feb4 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  81feb4:	55                   	push   %rbp
  81feb5:	48 89 e5             	mov    %rsp,%rbp
  81feb8:	53                   	push   %rbx
  81feb9:	48 83 ec 58          	sub    $0x58,%rsp
  81febd:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  81fec1:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  81fec5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fec9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fecd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  hlen = IPH_HL(iphdr) * 4;
  81fed1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fed5:	0f b7 00             	movzwl (%rax),%eax
  81fed8:	0f b7 c0             	movzwl %ax,%eax
  81fedb:	89 c7                	mov    %eax,%edi
  81fedd:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81fee4:	00 00 00 
  81fee7:	ff d0                	callq  *%rax
  81fee9:	66 c1 e8 08          	shr    $0x8,%ax
  81feed:	83 e0 0f             	and    $0xf,%eax
  81fef0:	c1 e0 02             	shl    $0x2,%eax
  81fef3:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  81fef7:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  81fefb:	f7 d8                	neg    %eax
  81fefd:	0f bf d0             	movswl %ax,%edx
  81ff00:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ff04:	89 d6                	mov    %edx,%esi
  81ff06:	48 89 c7             	mov    %rax,%rdi
  81ff09:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  81ff10:	00 00 00 
  81ff13:	ff d0                	callq  *%rax
  81ff15:	84 c0                	test   %al,%al
  81ff17:	75 0e                	jne    81ff27 <icmp_input+0x73>
  81ff19:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ff1d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ff21:	66 83 f8 03          	cmp    $0x3,%ax
  81ff25:	77 05                	ja     81ff2c <icmp_input+0x78>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  81ff27:	e9 90 04 00 00       	jmpq   8203bc <icmp_input+0x508>
  }

  type = *((u8_t *)p->payload);
  81ff2c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ff30:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ff34:	0f b6 00             	movzbl (%rax),%eax
  81ff37:	88 45 e5             	mov    %al,-0x1b(%rbp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
  81ff3a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ff3e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ff42:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  81ff46:	88 45 e4             	mov    %al,-0x1c(%rbp)
#endif /* LWIP_DEBUG */
  switch (type) {
  81ff49:	0f b6 45 e5          	movzbl -0x1b(%rbp),%eax
  81ff4d:	83 f8 08             	cmp    $0x8,%eax
  81ff50:	74 05                	je     81ff57 <icmp_input+0xa3>
  81ff52:	e9 50 04 00 00       	jmpq   8203a7 <icmp_input+0x4f3>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  81ff57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ff5b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81ff5f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  81ff63:	48 89 c6             	mov    %rax,%rsi
  81ff66:	48 89 d7             	mov    %rdx,%rdi
  81ff69:	48 b8 10 0a 81 00 00 	movabs $0x810a10,%rax
  81ff70:	00 00 00 
  81ff73:	ff d0                	callq  *%rax
  81ff75:	84 c0                	test   %al,%al
  81ff77:	75 2f                	jne    81ffa8 <icmp_input+0xf4>
  81ff79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ff7d:	8b 58 10             	mov    0x10(%rax),%ebx
  81ff80:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81ff85:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  81ff8c:	00 00 00 
  81ff8f:	ff d0                	callq  *%rax
  81ff91:	21 c3                	and    %eax,%ebx
  81ff93:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81ff98:	48 b8 5b 2d 81 00 00 	movabs $0x812d5b,%rax
  81ff9f:	00 00 00 
  81ffa2:	ff d0                	callq  *%rax
  81ffa4:	39 c3                	cmp    %eax,%ebx
  81ffa6:	75 18                	jne    81ffc0 <icmp_input+0x10c>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  81ffa8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ffac:	48 89 c7             	mov    %rax,%rdi
  81ffaf:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81ffb6:	00 00 00 
  81ffb9:	ff d0                	callq  *%rax
      return;
  81ffbb:	e9 10 04 00 00       	jmpq   8203d0 <icmp_input+0x51c>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  81ffc0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ffc4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ffc8:	66 83 f8 07          	cmp    $0x7,%ax
  81ffcc:	77 05                	ja     81ffd3 <icmp_input+0x11f>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
  81ffce:	e9 e9 03 00 00       	jmpq   8203bc <icmp_input+0x508>
    }
    if (inet_chksum_pbuf(p) != 0) {
  81ffd3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ffd7:	48 89 c7             	mov    %rax,%rdi
  81ffda:	48 b8 ff 27 81 00 00 	movabs $0x8127ff,%rax
  81ffe1:	00 00 00 
  81ffe4:	ff d0                	callq  *%rax
  81ffe6:	66 85 c0             	test   %ax,%ax
  81ffe9:	74 18                	je     820003 <icmp_input+0x14f>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  81ffeb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ffef:	48 89 c7             	mov    %rax,%rdi
  81fff2:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  81fff9:	00 00 00 
  81fffc:	ff d0                	callq  *%rax
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  81fffe:	e9 cd 03 00 00       	jmpq   8203d0 <icmp_input+0x51c>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  820003:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820007:	be 22 00 00 00       	mov    $0x22,%esi
  82000c:	48 89 c7             	mov    %rax,%rdi
  82000f:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  820016:	00 00 00 
  820019:	ff d0                	callq  *%rax
  82001b:	84 c0                	test   %al,%al
  82001d:	0f 84 8f 01 00 00    	je     8201b2 <icmp_input+0x2fe>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  820023:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  820027:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82002b:	89 d6                	mov    %edx,%esi
  82002d:	48 89 c7             	mov    %rax,%rdi
  820030:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  820037:	00 00 00 
  82003a:	ff d0                	callq  *%rax
  82003c:	84 c0                	test   %al,%al
  82003e:	74 2a                	je     82006a <icmp_input+0x1b6>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  820040:	48 ba 18 38 82 00 00 	movabs $0x823818,%rdx
  820047:	00 00 00 
  82004a:	be 7b 00 00 00       	mov    $0x7b,%esi
  82004f:	48 bf 4b 38 82 00 00 	movabs $0x82384b,%rdi
  820056:	00 00 00 
  820059:	b8 00 00 00 00       	mov    $0x0,%eax
  82005e:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  820065:	00 00 00 
  820068:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  82006a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82006e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  820072:	0f b7 c0             	movzwl %ax,%eax
  820075:	ba 00 00 00 00       	mov    $0x0,%edx
  82007a:	89 c6                	mov    %eax,%esi
  82007c:	bf 02 00 00 00       	mov    $0x2,%edi
  820081:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  820088:	00 00 00 
  82008b:	ff d0                	callq  *%rax
  82008d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      if (r == NULL) {
  820091:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  820096:	75 1a                	jne    8200b2 <icmp_input+0x1fe>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
  820098:	90                   	nop
  pbuf_free(p);
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
memerr:
  pbuf_free(p);
  820099:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82009d:	48 89 c7             	mov    %rax,%rdi
  8200a0:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8200a7:	00 00 00 
  8200aa:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  8200ac:	90                   	nop
  8200ad:	e9 1e 03 00 00       	jmpq   8203d0 <icmp_input+0x51c>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  8200b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8200b6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8200ba:	0f b7 c0             	movzwl %ax,%eax
  8200bd:	48 0f bf 55 e6       	movswq -0x1a(%rbp),%rdx
  8200c2:	48 83 c2 08          	add    $0x8,%rdx
  8200c6:	48 39 d0             	cmp    %rdx,%rax
  8200c9:	73 2a                	jae    8200f5 <icmp_input+0x241>
  8200cb:	48 ba 68 38 82 00 00 	movabs $0x823868,%rdx
  8200d2:	00 00 00 
  8200d5:	be 85 00 00 00       	mov    $0x85,%esi
  8200da:	48 bf 4b 38 82 00 00 	movabs $0x82384b,%rdi
  8200e1:	00 00 00 
  8200e4:	b8 00 00 00 00       	mov    $0x0,%eax
  8200e9:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8200f0:	00 00 00 
  8200f3:	ff d1                	callq  *%rcx
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  8200f5:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8200f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8200fd:	48 89 d6             	mov    %rdx,%rsi
  820100:	48 89 c7             	mov    %rax,%rdi
  820103:	48 b8 8e de 80 00 00 	movabs $0x80de8e,%rax
  82010a:	00 00 00 
  82010d:	ff d0                	callq  *%rax
  82010f:	84 c0                	test   %al,%al
  820111:	74 2a                	je     82013d <icmp_input+0x289>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  820113:	48 ba a0 38 82 00 00 	movabs $0x8238a0,%rdx
  82011a:	00 00 00 
  82011d:	be 88 00 00 00       	mov    $0x88,%esi
  820122:	48 bf 4b 38 82 00 00 	movabs $0x82384b,%rdi
  820129:	00 00 00 
  82012c:	b8 00 00 00 00       	mov    $0x0,%eax
  820131:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  820138:	00 00 00 
  82013b:	ff d1                	callq  *%rcx
        goto memerr;
      }
      iphdr = r->payload;
  82013d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820141:	48 8b 40 08          	mov    0x8(%rax),%rax
  820145:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  820149:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  82014d:	f7 d8                	neg    %eax
  82014f:	0f bf d0             	movswl %ax,%edx
  820152:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820156:	89 d6                	mov    %edx,%esi
  820158:	48 89 c7             	mov    %rax,%rdi
  82015b:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  820162:	00 00 00 
  820165:	ff d0                	callq  *%rax
  820167:	84 c0                	test   %al,%al
  820169:	74 2a                	je     820195 <icmp_input+0x2e1>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  82016b:	48 ba c8 38 82 00 00 	movabs $0x8238c8,%rdx
  820172:	00 00 00 
  820175:	be 8e 00 00 00       	mov    $0x8e,%esi
  82017a:	48 bf 4b 38 82 00 00 	movabs $0x82384b,%rdi
  820181:	00 00 00 
  820184:	b8 00 00 00 00       	mov    $0x0,%eax
  820189:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  820190:	00 00 00 
  820193:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  820195:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820199:	48 89 c7             	mov    %rax,%rdi
  82019c:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8201a3:	00 00 00 
  8201a6:	ff d0                	callq  *%rax
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  8201a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8201ac:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8201b0:	eb 46                	jmp    8201f8 <icmp_input+0x344>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  8201b2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8201b6:	be de ff ff ff       	mov    $0xffffffde,%esi
  8201bb:	48 89 c7             	mov    %rax,%rdi
  8201be:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  8201c5:	00 00 00 
  8201c8:	ff d0                	callq  *%rax
  8201ca:	84 c0                	test   %al,%al
  8201cc:	74 2a                	je     8201f8 <icmp_input+0x344>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  8201ce:	48 ba c8 38 82 00 00 	movabs $0x8238c8,%rdx
  8201d5:	00 00 00 
  8201d8:	be 98 00 00 00       	mov    $0x98,%esi
  8201dd:	48 bf 4b 38 82 00 00 	movabs $0x82384b,%rdi
  8201e4:	00 00 00 
  8201e7:	b8 00 00 00 00       	mov    $0x0,%eax
  8201ec:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8201f3:	00 00 00 
  8201f6:	ff d1                	callq  *%rcx
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  8201f8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8201fc:	48 8b 40 08          	mov    0x8(%rax),%rax
  820200:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    tmpaddr.addr = iphdr->src.addr;
  820204:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820208:	8b 40 0c             	mov    0xc(%rax),%eax
  82020b:	89 45 c0             	mov    %eax,-0x40(%rbp)
    iphdr->src.addr = iphdr->dest.addr;
  82020e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820212:	8b 50 10             	mov    0x10(%rax),%edx
  820215:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820219:	89 50 0c             	mov    %edx,0xc(%rax)
    iphdr->dest.addr = tmpaddr.addr;
  82021c:	8b 55 c0             	mov    -0x40(%rbp),%edx
  82021f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820223:	89 50 10             	mov    %edx,0x10(%rax)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  820226:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82022a:	0f b7 00             	movzwl (%rax),%eax
  82022d:	0f b7 c0             	movzwl %ax,%eax
  820230:	89 c7                	mov    %eax,%edi
  820232:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  820239:	00 00 00 
  82023c:	ff d0                	callq  *%rax
  82023e:	0f b7 c0             	movzwl %ax,%eax
  820241:	0f b6 c0             	movzbl %al,%eax
  820244:	89 c7                	mov    %eax,%edi
  820246:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  82024d:	00 00 00 
  820250:	ff d0                	callq  *%rax
  820252:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  820256:	66 89 02             	mov    %ax,(%rdx)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  820259:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82025d:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  820261:	bf ff f7 00 00       	mov    $0xf7ff,%edi
  820266:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  82026d:	00 00 00 
  820270:	ff d0                	callq  *%rax
  820272:	66 39 c3             	cmp    %ax,%bx
  820275:	72 28                	jb     82029f <icmp_input+0x3eb>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  820277:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82027b:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  82027f:	bf 00 08 00 00       	mov    $0x800,%edi
  820284:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  82028b:	00 00 00 
  82028e:	ff d0                	callq  *%rax
  820290:	01 d8                	add    %ebx,%eax
  820292:	8d 50 01             	lea    0x1(%rax),%edx
  820295:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820299:	66 89 50 02          	mov    %dx,0x2(%rax)
  82029d:	eb 24                	jmp    8202c3 <icmp_input+0x40f>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  82029f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8202a3:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  8202a7:	bf 00 08 00 00       	mov    $0x800,%edi
  8202ac:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8202b3:	00 00 00 
  8202b6:	ff d0                	callq  *%rax
  8202b8:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  8202bb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8202bf:	66 89 50 02          	mov    %dx,0x2(%rax)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  8202c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8202c7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8202cb:	0f b7 c0             	movzwl %ax,%eax
  8202ce:	89 c7                	mov    %eax,%edi
  8202d0:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8202d7:	00 00 00 
  8202da:	ff d0                	callq  *%rax
  8202dc:	66 0d 00 ff          	or     $0xff00,%ax
  8202e0:	0f b7 c0             	movzwl %ax,%eax
  8202e3:	89 c7                	mov    %eax,%edi
  8202e5:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8202ec:	00 00 00 
  8202ef:	ff d0                	callq  *%rax
  8202f1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8202f5:	66 89 42 08          	mov    %ax,0x8(%rdx)
    IPH_CHKSUM_SET(iphdr, 0);
  8202f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8202fd:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  820303:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820307:	be 14 00 00 00       	mov    $0x14,%esi
  82030c:	48 89 c7             	mov    %rax,%rdi
  82030f:	48 b8 d0 27 81 00 00 	movabs $0x8127d0,%rax
  820316:	00 00 00 
  820319:	ff d0                	callq  *%rax
  82031b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  82031f:	66 89 42 0a          	mov    %ax,0xa(%rdx)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  820323:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  820327:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82032b:	89 d6                	mov    %edx,%esi
  82032d:	48 89 c7             	mov    %rax,%rdi
  820330:	48 b8 4e d8 80 00 00 	movabs $0x80d84e,%rax
  820337:	00 00 00 
  82033a:	ff d0                	callq  *%rax
  82033c:	84 c0                	test   %al,%al
  82033e:	74 2a                	je     82036a <icmp_input+0x4b6>
      LWIP_ASSERT("Can't move over header in packet", 0);
  820340:	48 ba 00 39 82 00 00 	movabs $0x823900,%rdx
  820347:	00 00 00 
  82034a:	be b9 00 00 00       	mov    $0xb9,%esi
  82034f:	48 bf 4b 38 82 00 00 	movabs $0x82384b,%rdi
  820356:	00 00 00 
  820359:	b8 00 00 00 00       	mov    $0x0,%eax
  82035e:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  820365:	00 00 00 
  820368:	ff d1                	callq  *%rcx
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  82036a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82036e:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  820372:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820376:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  82037a:	48 89 14 24          	mov    %rdx,(%rsp)
  82037e:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  820384:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  82038a:	b9 ff 00 00 00       	mov    $0xff,%ecx
  82038f:	ba 00 00 00 00       	mov    $0x0,%edx
  820394:	48 89 c7             	mov    %rax,%rdi
  820397:	48 b8 e2 0f 81 00 00 	movabs $0x810fe2,%rax
  82039e:	00 00 00 
  8203a1:	ff d0                	callq  *%rax
  8203a3:	88 45 cf             	mov    %al,-0x31(%rbp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
  8203a6:	90                   	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  8203a7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8203ab:	48 89 c7             	mov    %rax,%rdi
  8203ae:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8203b5:	00 00 00 
  8203b8:	ff d0                	callq  *%rax
  return;
  8203ba:	eb 14                	jmp    8203d0 <icmp_input+0x51c>
lenerr:
  pbuf_free(p);
  8203bc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8203c0:	48 89 c7             	mov    %rax,%rdi
  8203c3:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  8203ca:	00 00 00 
  8203cd:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  8203cf:	90                   	nop
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  8203d0:	48 83 c4 58          	add    $0x58,%rsp
  8203d4:	5b                   	pop    %rbx
  8203d5:	5d                   	pop    %rbp
  8203d6:	c3                   	retq   

00000000008203d7 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  8203d7:	55                   	push   %rbp
  8203d8:	48 89 e5             	mov    %rsp,%rbp
  8203db:	48 83 ec 30          	sub    $0x30,%rsp
  8203df:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8203e3:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  8203e6:	ba 00 00 00 00       	mov    $0x0,%edx
  8203eb:	be 24 00 00 00       	mov    $0x24,%esi
  8203f0:	bf 01 00 00 00       	mov    $0x1,%edi
  8203f5:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  8203fc:	00 00 00 
  8203ff:	ff d0                	callq  *%rax
  820401:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  820405:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  82040a:	75 05                	jne    820411 <icmp_dest_unreach+0x3a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  82040c:	e9 60 01 00 00       	jmpq   820571 <icmp_dest_unreach+0x19a>
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  820411:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820415:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820419:	66 83 f8 23          	cmp    $0x23,%ax
  82041d:	77 2a                	ja     820449 <icmp_dest_unreach+0x72>
  82041f:	48 ba 28 39 82 00 00 	movabs $0x823928,%rdx
  820426:	00 00 00 
  820429:	be ef 00 00 00       	mov    $0xef,%esi
  82042e:	48 bf 4b 38 82 00 00 	movabs $0x82384b,%rdi
  820435:	00 00 00 
  820438:	b8 00 00 00 00       	mov    $0x0,%eax
  82043d:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  820444:	00 00 00 
  820447:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  820449:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82044d:	48 8b 40 08          	mov    0x8(%rax),%rax
  820451:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  idur = q->payload;
  820455:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820459:	48 8b 40 08          	mov    0x8(%rax),%rax
  82045d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  820461:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820465:	0f b7 00             	movzwl (%rax),%eax
  820468:	0f b7 c0             	movzwl %ax,%eax
  82046b:	89 c7                	mov    %eax,%edi
  82046d:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  820474:	00 00 00 
  820477:	ff d0                	callq  *%rax
  820479:	0f b6 c0             	movzbl %al,%eax
  82047c:	80 cc 03             	or     $0x3,%ah
  82047f:	0f b7 c0             	movzwl %ax,%eax
  820482:	89 c7                	mov    %eax,%edi
  820484:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  82048b:	00 00 00 
  82048e:	ff d0                	callq  *%rax
  820490:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820494:	66 89 02             	mov    %ax,(%rdx)
  ICMPH_CODE_SET(idur, t);
  820497:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82049b:	0f b7 00             	movzwl (%rax),%eax
  82049e:	0f b7 c0             	movzwl %ax,%eax
  8204a1:	89 c7                	mov    %eax,%edi
  8204a3:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8204aa:	00 00 00 
  8204ad:	ff d0                	callq  *%rax
  8204af:	b0 00                	mov    $0x0,%al
  8204b1:	89 c2                	mov    %eax,%edx
  8204b3:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8204b6:	09 d0                	or     %edx,%eax
  8204b8:	0f b7 c0             	movzwl %ax,%eax
  8204bb:	89 c7                	mov    %eax,%edi
  8204bd:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  8204c4:	00 00 00 
  8204c7:	ff d0                	callq  *%rax
  8204c9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8204cd:	66 89 02             	mov    %ax,(%rdx)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  8204d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8204d4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8204d8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8204dc:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8204e0:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8204e4:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8204e9:	48 89 c6             	mov    %rax,%rsi
  8204ec:	48 89 cf             	mov    %rcx,%rdi
  8204ef:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  8204f6:	00 00 00 
  8204f9:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  8204fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8204ff:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  idur->chksum = inet_chksum(idur, q->len);
  820505:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820509:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  82050d:	0f b7 d0             	movzwl %ax,%edx
  820510:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820514:	89 d6                	mov    %edx,%esi
  820516:	48 89 c7             	mov    %rax,%rdi
  820519:	48 b8 d0 27 81 00 00 	movabs $0x8127d0,%rax
  820520:	00 00 00 
  820523:	ff d0                	callq  *%rax
  820525:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820529:	66 89 42 02          	mov    %ax,0x2(%rdx)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  82052d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820531:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  820535:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820539:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  82053f:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  820545:	b9 ff 00 00 00       	mov    $0xff,%ecx
  82054a:	be 00 00 00 00       	mov    $0x0,%esi
  82054f:	48 89 c7             	mov    %rax,%rdi
  820552:	48 b8 98 12 81 00 00 	movabs $0x811298,%rax
  820559:	00 00 00 
  82055c:	ff d0                	callq  *%rax
  pbuf_free(q);
  82055e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820562:	48 89 c7             	mov    %rax,%rdi
  820565:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  82056c:	00 00 00 
  82056f:	ff d0                	callq  *%rax
}
  820571:	c9                   	leaveq 
  820572:	c3                   	retq   

0000000000820573 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  820573:	55                   	push   %rbp
  820574:	48 89 e5             	mov    %rsp,%rbp
  820577:	48 83 ec 30          	sub    $0x30,%rsp
  82057b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  82057f:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  820582:	ba 00 00 00 00       	mov    $0x0,%edx
  820587:	be 24 00 00 00       	mov    $0x24,%esi
  82058c:	bf 01 00 00 00       	mov    $0x1,%edi
  820591:	48 b8 30 d1 80 00 00 	movabs $0x80d130,%rax
  820598:	00 00 00 
  82059b:	ff d0                	callq  *%rax
  82059d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  8205a1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8205a6:	75 05                	jne    8205ad <icmp_time_exceeded+0x3a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  8205a8:	e9 60 01 00 00       	jmpq   82070d <icmp_time_exceeded+0x19a>
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  8205ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8205b1:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8205b5:	66 83 f8 23          	cmp    $0x23,%ax
  8205b9:	77 2a                	ja     8205e5 <icmp_time_exceeded+0x72>
  8205bb:	48 ba 28 39 82 00 00 	movabs $0x823928,%rdx
  8205c2:	00 00 00 
  8205c5:	be 1e 01 00 00       	mov    $0x11e,%esi
  8205ca:	48 bf 4b 38 82 00 00 	movabs $0x82384b,%rdi
  8205d1:	00 00 00 
  8205d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8205d9:	48 b9 40 0f 80 00 00 	movabs $0x800f40,%rcx
  8205e0:	00 00 00 
  8205e3:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  8205e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8205e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8205ed:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  8205f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8205f5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8205f9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  8205fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820601:	0f b7 00             	movzwl (%rax),%eax
  820604:	0f b7 c0             	movzwl %ax,%eax
  820607:	89 c7                	mov    %eax,%edi
  820609:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  820610:	00 00 00 
  820613:	ff d0                	callq  *%rax
  820615:	0f b6 c0             	movzbl %al,%eax
  820618:	80 cc 0b             	or     $0xb,%ah
  82061b:	0f b7 c0             	movzwl %ax,%eax
  82061e:	89 c7                	mov    %eax,%edi
  820620:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  820627:	00 00 00 
  82062a:	ff d0                	callq  *%rax
  82062c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820630:	66 89 02             	mov    %ax,(%rdx)
  ICMPH_CODE_SET(tehdr, t);
  820633:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820637:	0f b7 00             	movzwl (%rax),%eax
  82063a:	0f b7 c0             	movzwl %ax,%eax
  82063d:	89 c7                	mov    %eax,%edi
  82063f:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  820646:	00 00 00 
  820649:	ff d0                	callq  *%rax
  82064b:	b0 00                	mov    $0x0,%al
  82064d:	89 c2                	mov    %eax,%edx
  82064f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  820652:	09 d0                	or     %edx,%eax
  820654:	0f b7 c0             	movzwl %ax,%eax
  820657:	89 c7                	mov    %eax,%edi
  820659:	48 b8 de 2c 81 00 00 	movabs $0x812cde,%rax
  820660:	00 00 00 
  820663:	ff d0                	callq  *%rax
  820665:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820669:	66 89 02             	mov    %ax,(%rdx)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  82066c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820670:	48 8b 40 08          	mov    0x8(%rax),%rax
  820674:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  820678:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  82067c:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  820680:	ba 1c 00 00 00       	mov    $0x1c,%edx
  820685:	48 89 c6             	mov    %rax,%rsi
  820688:	48 89 cf             	mov    %rcx,%rdi
  82068b:	48 b8 69 21 80 00 00 	movabs $0x802169,%rax
  820692:	00 00 00 
  820695:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  820697:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82069b:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  8206a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8206a5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8206a9:	0f b7 d0             	movzwl %ax,%edx
  8206ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8206b0:	89 d6                	mov    %edx,%esi
  8206b2:	48 89 c7             	mov    %rax,%rdi
  8206b5:	48 b8 d0 27 81 00 00 	movabs $0x8127d0,%rax
  8206bc:	00 00 00 
  8206bf:	ff d0                	callq  *%rax
  8206c1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8206c5:	66 89 42 02          	mov    %ax,0x2(%rdx)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  8206c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8206cd:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8206d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8206d5:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  8206db:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8206e1:	b9 ff 00 00 00       	mov    $0xff,%ecx
  8206e6:	be 00 00 00 00       	mov    $0x0,%esi
  8206eb:	48 89 c7             	mov    %rax,%rdi
  8206ee:	48 b8 98 12 81 00 00 	movabs $0x811298,%rax
  8206f5:	00 00 00 
  8206f8:	ff d0                	callq  *%rax
  pbuf_free(q);
  8206fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8206fe:	48 89 c7             	mov    %rax,%rdi
  820701:	48 b8 0f da 80 00 00 	movabs $0x80da0f,%rax
  820708:	00 00 00 
  82070b:	ff d0                	callq  *%rax
}
  82070d:	c9                   	leaveq 
  82070e:	c3                   	retq   
